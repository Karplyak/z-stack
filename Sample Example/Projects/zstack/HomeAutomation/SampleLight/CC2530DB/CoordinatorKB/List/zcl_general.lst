###############################################################################
#                                                                             #
# IAR C/C++ Compiler V7.51A/W32 for 8051                29/Nov/2010  16:01:16 #
# Copyright 2004-2009 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Documents and Settings\Darren\桌面\ZIGBEE       #
#                          教學模組_出貨光碟\ZIGBEE                           #
#                          Example\CC2530_ZStack\教學模組_Z-Stack_Ex\ZStack-C #
#                          C2530-2.3.0-1.4.0\Components\stack\zcl\zcl_general #
#                          .c                                                 #
#    Command line       =  -f "C:\Documents and Settings\Darren\桌面\ZIGBEE   #
#                          教學模組_出貨光碟\ZIGBEE                           #
#                          Example\CC2530_ZStack\教學模組_Z-Stack_Ex\ZStack-C #
#                          C2530-2.3.0-1.4.0\Projects\zstack\HomeAutomation\S #
#                          ampleLight\CC2530DB\..\..\..\Tools\CC2530DB\f8wCoo #
#                          rd.cfg" (-DCPU32MHZ -DROOT=__near_func             #
#                          -DMAC_CFG_APP_PENDING_QUEUE=TRUE                   #
#                          -DZDO_COORDINATOR -DRTR_NWK -DBLINK_LEDS) -f       #
#                          "C:\Documents and Settings\Darren\桌面\ZIGBEE      #
#                          教學模組_出貨光碟\ZIGBEE                           #
#                          Example\CC2530_ZStack\教學模組_Z-Stack_Ex\ZStack-C #
#                          C2530-2.3.0-1.4.0\Projects\zstack\HomeAutomation\S #
#                          ampleLight\CC2530DB\..\..\..\Tools\CC2530DB\f8wCon #
#                          fig.cfg" (-DSECURE=0 -DZG_SECURE_DYNAMIC=0         #
#                          -DREFLECTOR -DDEFAULT_CHANLIST=0x00000800          #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116 "-DCONST=const __code"    #
#                          -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=TRUE      #
#                          -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100            #
#                          -DRESPONSE_POLL_RATE=100 -DREJOIN_POLL_RATE=440)   #
#                          -f "C:\Documents and Settings\Darren\桌面\ZIGBEE   #
#                          教學模組_出貨光碟\ZIGBEE                           #
#                          Example\CC2530_ZStack\教學模組_Z-Stack_Ex\ZStack-C #
#                          C2530-2.3.0-1.4.0\Projects\zstack\HomeAutomation\S #
#                          ampleLight\CC2530DB\..\..\..\Tools\CC2530DB\f8wZCL #
#                          .cfg" (-DZCL_READ -DZCL_WRITE -DZCL_BASIC          #
#                          -DZCL_IDENTIFY -DZCL_ON_OFF -DZCL_KEY_ESTABLISH    #
#                          -DZCL_LOAD_CONTROL -DZCL_SIMPLE_METERING           #
#                          -DZCL_PRICING) -DZCL_MESSAGE "C:\Documents and     #
#                          Settings\Darren\桌面\ZIGBEE                        #
#                          教學模組_出貨光碟\ZIGBEE                           #
#                          Example\CC2530_ZStack\教學模組_Z-Stack_Ex\ZStack-C #
#                          C2530-2.3.0-1.4.0\Components\stack\zcl\zcl_general #
#                          .c" -D ZTOOL_P1 -D MT_TASK -D MT_APP_FUNC -D       #
#                          MT_SYS_FUNC -D MT_ZDO_FUNC -D LCD_SUPPORTED=DEBUG  #
#                          -lC "C:\Documents and Settings\Darren\桌面\ZIGBEE  #
#                          教學模組_出貨光碟\ZIGBEE                           #
#                          Example\CC2530_ZStack\教學模組_Z-Stack_Ex\ZStack-C #
#                          C2530-2.3.0-1.4.0\Projects\zstack\HomeAutomation\S #
#                          ampleLight\CC2530DB\CoordinatorKB\List\" -lA       #
#                          "C:\Documents and Settings\Darren\桌面\ZIGBEE      #
#                          教學模組_出貨光碟\ZIGBEE                           #
#                          Example\CC2530_ZStack\教學模組_Z-Stack_Ex\ZStack-C #
#                          C2530-2.3.0-1.4.0\Projects\zstack\HomeAutomation\S #
#                          ampleLight\CC2530DB\CoordinatorKB\List\"           #
#                          --diag_suppress Pe001,Pa010 -o "C:\Documents and   #
#                          Settings\Darren\桌面\ZIGBEE                        #
#                          教學模組_出貨光碟\ZIGBEE                           #
#                          Example\CC2530_ZStack\教學模組_Z-Stack_Ex\ZStack-C #
#                          C2530-2.3.0-1.4.0\Projects\zstack\HomeAutomation\S #
#                          ampleLight\CC2530DB\CoordinatorKB\Obj\" -e         #
#                          --require_prototypes --debug --core=plain          #
#                          --dptr=16,1 --data_model=large                     #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data_rom                  #
#                          --nr_virtual_regs 16 -I "C:\Documents and          #
#                          Settings\Darren\桌面\ZIGBEE                        #
#                          教學模組_出貨光碟\ZIGBEE                           #
#                          Example\CC2530_ZStack\教學模組_Z-Stack_Ex\ZStack-C #
#                          C2530-2.3.0-1.4.0\Projects\zstack\HomeAutomation\S #
#                          ampleLight\CC2530DB\" -I "C:\Documents and         #
#                          Settings\Darren\桌面\ZIGBEE                        #
#                          教學模組_出貨光碟\ZIGBEE                           #
#                          Example\CC2530_ZStack\教學模組_Z-Stack_Ex\ZStack-C #
#                          C2530-2.3.0-1.4.0\Projects\zstack\HomeAutomation\S #
#                          ampleLight\CC2530DB\..\SOURCE\" -I "C:\Documents   #
#                          and Settings\Darren\桌面\ZIGBEE                    #
#                          教學模組_出貨光碟\ZIGBEE                           #
#                          Example\CC2530_ZStack\教學模組_Z-Stack_Ex\ZStack-C #
#                          C2530-2.3.0-1.4.0\Projects\zstack\HomeAutomation\S #
#                          ampleLight\CC2530DB\..\..\SOURCE\" -I              #
#                          "C:\Documents and Settings\Darren\桌面\ZIGBEE      #
#                          教學模組_出貨光碟\ZIGBEE                           #
#                          Example\CC2530_ZStack\教學模組_Z-Stack_Ex\ZStack-C #
#                          C2530-2.3.0-1.4.0\Projects\zstack\HomeAutomation\S #
#                          ampleLight\CC2530DB\..\..\..\ZMAIN\TI2530DB\" -I   #
#                          "C:\Documents and Settings\Darren\桌面\ZIGBEE      #
#                          教學模組_出貨光碟\ZIGBEE                           #
#                          Example\CC2530_ZStack\教學模組_Z-Stack_Ex\ZStack-C #
#                          C2530-2.3.0-1.4.0\Projects\zstack\HomeAutomation\S #
#                          ampleLight\CC2530DB\..\..\..\..\..\COMPONENTS\MT\" #
#                           -I "C:\Documents and Settings\Darren\桌面\ZIGBEE  #
#                          教學模組_出貨光碟\ZIGBEE                           #
#                          Example\CC2530_ZStack\教學模組_Z-Stack_Ex\ZStack-C #
#                          C2530-2.3.0-1.4.0\Projects\zstack\HomeAutomation\S #
#                          ampleLight\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\ #
#                          INCLUDE\" -I "C:\Documents and                     #
#                          Settings\Darren\桌面\ZIGBEE                        #
#                          教學模組_出貨光碟\ZIGBEE                           #
#                          Example\CC2530_ZStack\教學模組_Z-Stack_Ex\ZStack-C #
#                          C2530-2.3.0-1.4.0\Projects\zstack\HomeAutomation\S #
#                          ampleLight\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\ #
#                          TARGET\CC2530EB\" -I "C:\Documents and             #
#                          Settings\Darren\桌面\ZIGBEE                        #
#                          教學模組_出貨光碟\ZIGBEE                           #
#                          Example\CC2530_ZStack\教學模組_Z-Stack_Ex\ZStack-C #
#                          C2530-2.3.0-1.4.0\Projects\zstack\HomeAutomation\S #
#                          ampleLight\CC2530DB\..\..\..\..\..\COMPONENTS\OSAL #
#                          \MCU\CCSOC\" -I "C:\Documents and                  #
#                          Settings\Darren\桌面\ZIGBEE                        #
#                          教學模組_出貨光碟\ZIGBEE                           #
#                          Example\CC2530_ZStack\教學模組_Z-Stack_Ex\ZStack-C #
#                          C2530-2.3.0-1.4.0\Projects\zstack\HomeAutomation\S #
#                          ampleLight\CC2530DB\..\..\..\..\..\COMPONENTS\OSAL #
#                          \INCLUDE\" -I "C:\Documents and                    #
#                          Settings\Darren\桌面\ZIGBEE                        #
#                          教學模組_出貨光碟\ZIGBEE                           #
#                          Example\CC2530_ZStack\教學模組_Z-Stack_Ex\ZStack-C #
#                          C2530-2.3.0-1.4.0\Projects\zstack\HomeAutomation\S #
#                          ampleLight\CC2530DB\..\..\..\..\..\COMPONENTS\STAC #
#                          K\AF\" -I "C:\Documents and                        #
#                          Settings\Darren\桌面\ZIGBEE                        #
#                          教學模組_出貨光碟\ZIGBEE                           #
#                          Example\CC2530_ZStack\教學模組_Z-Stack_Ex\ZStack-C #
#                          C2530-2.3.0-1.4.0\Projects\zstack\HomeAutomation\S #
#                          ampleLight\CC2530DB\..\..\..\..\..\COMPONENTS\STAC #
#                          K\NWK\" -I "C:\Documents and                       #
#                          Settings\Darren\桌面\ZIGBEE                        #
#                          教學模組_出貨光碟\ZIGBEE                           #
#                          Example\CC2530_ZStack\教學模組_Z-Stack_Ex\ZStack-C #
#                          C2530-2.3.0-1.4.0\Projects\zstack\HomeAutomation\S #
#                          ampleLight\CC2530DB\..\..\..\..\..\COMPONENTS\STAC #
#                          K\SEC\" -I "C:\Documents and                       #
#                          Settings\Darren\桌面\ZIGBEE                        #
#                          教學模組_出貨光碟\ZIGBEE                           #
#                          Example\CC2530_ZStack\教學模組_Z-Stack_Ex\ZStack-C #
#                          C2530-2.3.0-1.4.0\Projects\zstack\HomeAutomation\S #
#                          ampleLight\CC2530DB\..\..\..\..\..\COMPONENTS\STAC #
#                          K\SAPI\" -I "C:\Documents and                      #
#                          Settings\Darren\桌面\ZIGBEE                        #
#                          教學模組_出貨光碟\ZIGBEE                           #
#                          Example\CC2530_ZStack\教學模組_Z-Stack_Ex\ZStack-C #
#                          C2530-2.3.0-1.4.0\Projects\zstack\HomeAutomation\S #
#                          ampleLight\CC2530DB\..\..\..\..\..\COMPONENTS\STAC #
#                          K\SYS\" -I "C:\Documents and                       #
#                          Settings\Darren\桌面\ZIGBEE                        #
#                          教學模組_出貨光碟\ZIGBEE                           #
#                          Example\CC2530_ZStack\教學模組_Z-Stack_Ex\ZStack-C #
#                          C2530-2.3.0-1.4.0\Projects\zstack\HomeAutomation\S #
#                          ampleLight\CC2530DB\..\..\..\..\..\COMPONENTS\STAC #
#                          K\ZCL\" -I "C:\Documents and                       #
#                          Settings\Darren\桌面\ZIGBEE                        #
#                          教學模組_出貨光碟\ZIGBEE                           #
#                          Example\CC2530_ZStack\教學模組_Z-Stack_Ex\ZStack-C #
#                          C2530-2.3.0-1.4.0\Projects\zstack\HomeAutomation\S #
#                          ampleLight\CC2530DB\..\..\..\..\..\COMPONENTS\STAC #
#                          K\ZDO\" -I "C:\Documents and                       #
#                          Settings\Darren\桌面\ZIGBEE                        #
#                          教學模組_出貨光碟\ZIGBEE                           #
#                          Example\CC2530_ZStack\教學模組_Z-Stack_Ex\ZStack-C #
#                          C2530-2.3.0-1.4.0\Projects\zstack\HomeAutomation\S #
#                          ampleLight\CC2530DB\..\..\..\..\..\COMPONENTS\ZMAC #
#                          \F8W\" -I "C:\Documents and                        #
#                          Settings\Darren\桌面\ZIGBEE                        #
#                          教學模組_出貨光碟\ZIGBEE                           #
#                          Example\CC2530_ZStack\教學模組_Z-Stack_Ex\ZStack-C #
#                          C2530-2.3.0-1.4.0\Projects\zstack\HomeAutomation\S #
#                          ampleLight\CC2530DB\..\..\..\..\..\COMPONENTS\ZMAC #
#                          \" -I "C:\Documents and Settings\Darren\桌面\ZIGBE #
#                          E 教學模組_出貨光碟\ZIGBEE                         #
#                          Example\CC2530_ZStack\教學模組_Z-Stack_Ex\ZStack-C #
#                          C2530-2.3.0-1.4.0\Projects\zstack\HomeAutomation\S #
#                          ampleLight\CC2530DB\..\..\..\..\..\COMPONENTS\SERV #
#                          ICES\SADDR\" -I "C:\Documents and                  #
#                          Settings\Darren\桌面\ZIGBEE                        #
#                          教學模組_出貨光碟\ZIGBEE                           #
#                          Example\CC2530_ZStack\教學模組_Z-Stack_Ex\ZStack-C #
#                          C2530-2.3.0-1.4.0\Projects\zstack\HomeAutomation\S #
#                          ampleLight\CC2530DB\..\..\..\..\..\COMPONENTS\SERV #
#                          ICES\SDATA\" -I "C:\Documents and                  #
#                          Settings\Darren\桌面\ZIGBEE                        #
#                          教學模組_出貨光碟\ZIGBEE                           #
#                          Example\CC2530_ZStack\教學模組_Z-Stack_Ex\ZStack-C #
#                          C2530-2.3.0-1.4.0\Projects\zstack\HomeAutomation\S #
#                          ampleLight\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\ #
#                          INCLUDE\" -I "C:\Documents and                     #
#                          Settings\Darren\桌面\ZIGBEE                        #
#                          教學模組_出貨光碟\ZIGBEE                           #
#                          Example\CC2530_ZStack\教學模組_Z-Stack_Ex\ZStack-C #
#                          C2530-2.3.0-1.4.0\Projects\zstack\HomeAutomation\S #
#                          ampleLight\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\ #
#                          HIGH_LEVEL\" -I "C:\Documents and                  #
#                          Settings\Darren\桌面\ZIGBEE                        #
#                          教學模組_出貨光碟\ZIGBEE                           #
#                          Example\CC2530_ZStack\教學模組_Z-Stack_Ex\ZStack-C #
#                          C2530-2.3.0-1.4.0\Projects\zstack\HomeAutomation\S #
#                          ampleLight\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\ #
#                          LOW_LEVEL\srf04\" -I "C:\Documents and             #
#                          Settings\Darren\桌面\ZIGBEE                        #
#                          教學模組_出貨光碟\ZIGBEE                           #
#                          Example\CC2530_ZStack\教學模組_Z-Stack_Ex\ZStack-C #
#                          C2530-2.3.0-1.4.0\Projects\zstack\HomeAutomation\S #
#                          ampleLight\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\ #
#                          LOW_LEVEL\srf04\SINGLE_CHIP\" -I "C:\IAR           #
#                          Systems\Embedded Workbench for MCS-51              #
#                          V7.51\8051\INC\" -I "C:\IAR Systems\Embedded       #
#                          Workbench for MCS-51 V7.51\8051\INC\CLIB\" -Ohz    #
#    List file          =  C:\Documents and Settings\Darren\桌面\ZIGBEE       #
#                          教學模組_出貨光碟\ZIGBEE                           #
#                          Example\CC2530_ZStack\教學模組_Z-Stack_Ex\ZStack-C #
#                          C2530-2.3.0-1.4.0\Projects\zstack\HomeAutomation\S #
#                          ampleLight\CC2530DB\CoordinatorKB\List\zcl_general #
#                          .lst                                               #
#    Object file        =  C:\Documents and Settings\Darren\桌面\ZIGBEE       #
#                          教學模組_出貨光碟\ZIGBEE                           #
#                          Example\CC2530_ZStack\教學模組_Z-Stack_Ex\ZStack-C #
#                          C2530-2.3.0-1.4.0\Projects\zstack\HomeAutomation\S #
#                          ampleLight\CC2530DB\CoordinatorKB\Obj\zcl_general. #
#                          r51                                                #
#                                                                             #
#                                                                             #
###############################################################################

C:\Documents and Settings\Darren\桌面\ZIGBEE 教學模組_出貨光碟\ZIGBEE Example\CC2530_ZStack\教學模組_Z-Stack_Ex\ZStack-CC2530-2.3.0-1.4.0\Components\stack\zcl\zcl_general.c
      1          /**************************************************************************************************
      2            Filename:       zcl_general.c
      3            Revised:        $Date: 2009-10-26 15:51:02 -0700 (Mon, 26 Oct 2009) $
      4            Revision:       $Revision: 20979 $
      5          
      6            Description:    Zigbee Cluster Library - General.  This application receives all
      7                            ZCL messages and initially parses them before passing to application.
      8          
      9          
     10            Copyright 2006-2008 Texas Instruments Incorporated. All rights reserved.
     11          
     12            Should you have any questions regarding your right to use this Software,
     13            contact Texas Instruments Incorporated at www.TI.com.
     14          **************************************************************************************************/
     15          
     16          /*********************************************************************
     17           * INCLUDES
     18           */
     19          #include "ZComDef.h"
     20          #include "OSAL.h"
     21          #include "OSAL_Nv.h"
     22          #include "zcl.h"
     23          #include "zcl_general.h"
     24          #include "ZDApp.h"
     25          
     26          #if defined ( INTER_PAN )
     27            #include "stub_aps.h"
     28          #endif
     29          
     30          /*********************************************************************
     31           * MACROS
     32           */
     33          #define locationTypeAbsolute( a )          ( (a) & LOCATION_TYPE_ABSOLUTE )
     34          #define locationType2D( a )                ( (a) & LOCATION_TYPE_2_D )
     35          #define locationTypeCoordinateSystem( a )  ( (a) & LOCATION_TYPE_COORDINATE_SYSTEM )
     36          
     37          #ifdef ZCL_SCENES
     38          #define zclGeneral_ScenesRemaingCapacity() ( ZCL_GEN_MAX_SCENES - zclGeneral_CountAllScenes() )
     39          #endif // ZCL_SCENES
     40          
     41          /*********************************************************************
     42           * CONSTANTS
     43           */
     44          
     45          /*********************************************************************
     46           * TYPEDEFS
     47           */
     48          typedef struct zclGenCBRec
     49          {
     50            struct zclGenCBRec        *next;
     51            uint8                     endpoint; // Used to link it into the endpoint descriptor
     52            zclGeneral_AppCallbacks_t *CBs;     // Pointer to Callback function
     53          } zclGenCBRec_t;
     54          
     55          typedef struct zclGenSceneItem
     56          {
     57            struct zclGenSceneItem    *next;
     58            uint8                     endpoint; // Used to link it into the endpoint descriptor
     59            zclGeneral_Scene_t        scene;    // Scene info
     60          } zclGenSceneItem_t;
     61          
     62          typedef struct zclGenAlarmItem
     63          {
     64            struct zclGenAlarmItem    *next;
     65            uint8                     endpoint; // Used to link it into the endpoint descriptor
     66            zclGeneral_Alarm_t        alarm;    // Alarm info
     67          } zclGenAlarmItem_t;
     68          
     69          // Scene NV types
     70          typedef struct
     71          {
     72            uint16                    numRecs;
     73          } nvGenScenesHdr_t;
     74          
     75          typedef struct zclGenSceneNVItem
     76          {
     77            uint8                     endpoint;
     78            zclGeneral_Scene_t        scene;
     79          } zclGenSceneNVItem_t;
     80          
     81          /*********************************************************************
     82           * GLOBAL VARIABLES
     83           */
     84          
     85          /*********************************************************************
     86           * GLOBAL FUNCTIONS
     87           */
     88          
     89          /*********************************************************************
     90           * LOCAL VARIABLES
     91           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     92          static zclGenCBRec_t *zclGenCBs = (zclGenCBRec_t *)NULL;
   \                     zclGenCBs:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     93          static uint8 zclGenPluginRegisted = FALSE;
   \                     zclGenPluginRegisted:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
     94          #ifdef ZCL_SCENES
     95          static zclGenSceneItem_t *zclGenSceneTable = (zclGenSceneItem_t *)NULL;
     96          #endif // ZCL_SCENES
     97          #ifdef ZCL_ALARMS
     98          static zclGenAlarmItem_t *zclGenAlarmTable = (zclGenAlarmItem_t *)NULL;
     99          #endif // ZCL_ALARMS
    100          
    101          /*********************************************************************
    102           * LOCAL FUNCTIONS
    103           */
    104          static ZStatus_t zclGeneral_HdlIncoming( zclIncoming_t *pInMsg );
    105          static ZStatus_t zclGeneral_HdlInSpecificCommands( zclIncoming_t *pInMsg );
    106          static zclGeneral_AppCallbacks_t *zclGeneral_FindCallbacks( uint8 endpoint );
    107          
    108          // Device Configuration and Installation clusters
    109          #ifdef ZCL_BASIC
    110          static ZStatus_t zclGeneral_ProcessInBasic( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    111          #endif // ZCL_BASIC
    112          
    113          #ifdef ZCL_IDENTIFY
    114          static ZStatus_t zclGeneral_ProcessInIdentity( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    115          #endif // ZCL_IDENTIFY
    116          
    117          // Groups and Scenes clusters
    118          #ifdef ZCL_GROUPS
    119          static ZStatus_t zclGeneral_ProcessInGroupsServer( zclIncoming_t *pInMsg );
    120          static ZStatus_t zclGeneral_ProcessInGroupsClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    121          static ZStatus_t zclGeneral_AddGroup( uint8 endPoint, aps_Group_t *group, uint8 *pData );
    122          #endif // ZCL_GROUPS
    123          
    124          #ifdef ZCL_SCENES
    125          static ZStatus_t zclGeneral_ProcessInScenesServer( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    126          static ZStatus_t zclGeneral_ProcessInScenesClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    127          #endif // ZCL_SCENES
    128          
    129          // On/Off and Level Control Configuration clusters
    130          #ifdef ZCL_ON_OFF
    131          static ZStatus_t zclGeneral_ProcessInOnOff( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    132          #endif // ZCL_ONOFF
    133          
    134          #ifdef ZCL_LEVEL_CTRL
    135          static ZStatus_t zclGeneral_ProcessInLevelControl( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    136          #endif // ZCL_LEVEL_CTRL
    137          
    138          // Alarms cluster
    139          #ifdef ZCL_ALARMS
    140          static ZStatus_t zclGeneral_ProcessInAlarmsServer( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    141          static ZStatus_t zclGeneral_ProcessInAlarmsClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    142          #endif // ZCL_ALARMS
    143          
    144          // Location cluster
    145          #ifdef ZCL_LOCATION
    146          static ZStatus_t zclGeneral_ProcessInLocationServer( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    147          static ZStatus_t zclGeneral_ProcessInLocationClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    148          #endif // ZCL_LOCATION
    149          
    150          #ifdef ZCL_SCENES
    151          static uint8 zclGeneral_ScenesInitNV( void );
    152          static void zclGeneral_ScenesSetDefaultNV( void );
    153          static void zclGeneral_ScenesWriteNV( void );
    154          static uint16 zclGeneral_ScenesRestoreFromNV( void );
    155          #endif // ZCL_SCENES
    156          
    157          /*********************************************************************
    158           * @fn      zclGeneral_RegisterCmdCallbacks
    159           *
    160           * @brief   Register an applications command callbacks
    161           *
    162           * @param   endpoint - application's endpoint
    163           * @param   callbacks - pointer to the callback record.
    164           *
    165           * @return  ZMemError if not able to allocate
    166           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    167          ZStatus_t zclGeneral_RegisterCmdCallbacks( uint8 endpoint, zclGeneral_AppCallbacks_t *callbacks )
   \                     zclGeneral_RegisterCmdCallbacks:
    168          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 0,R1
   \   000007   EA           MOV     A,R2
   \   000008   FE           MOV     R6,A
   \   000009   EB           MOV     A,R3
   \   00000A   FF           MOV     R7,A
    169            zclGenCBRec_t *pNewItem;
    170            zclGenCBRec_t *pLoop;
    171          
    172            // Register as a ZCL Plugin
    173            if ( zclGenPluginRegisted == FALSE )
   \   00000B   90....       MOV     DPTR,#zclGenPluginRegisted
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   7021         JNZ     ??zclGeneral_RegisterCmdCallbacks_0
    174            {
    175              zcl_registerPlugin( ZCL_CLUSTER_ID_GEN_BASIC,
    176                                  ZCL_CLUSTER_ID_GEN_LOCATION,
    177                                  zclGeneral_HdlIncoming );
   \   000011                ; Setup parameters for call to function zcl_registerPlugin
   \   000011   75....       MOV     ?V0 + 2,#(??zclGeneral_HdlIncoming?relay & 0xff)
   \   000014   75....       MOV     ?V0 + 3,#((??zclGeneral_HdlIncoming?relay >> 8) & 0xff)
   \   000017   78..         MOV     R0,#?V0 + 2
   \   000019   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00001C   7C0B         MOV     R4,#0xb
   \   00001E   7D00         MOV     R5,#0x0
   \   000020   7A00         MOV     R2,#0x0
   \   000022   7B00         MOV     R3,#0x0
   \   000024   12....       LCALL   ??zcl_registerPlugin?relay
   \   000027   7402         MOV     A,#0x2
   \   000029   12....       LCALL   ?DEALLOC_XSTACK8
    178          
    179          #ifdef ZCL_SCENES
    180              // Initialize NV items
    181              zclGeneral_ScenesInitNV();
    182          
    183              // Restore the Scene table
    184              zclGeneral_ScenesRestoreFromNV();
    185          #endif // ZCL_SCENES
    186          
    187              zclGenPluginRegisted = TRUE;
   \   00002C   7401         MOV     A,#0x1
   \   00002E   90....       MOV     DPTR,#zclGenPluginRegisted
   \   000031   F0           MOVX    @DPTR,A
    188            }
    189          
    190            // Fill in the new profile list
    191            pNewItem = osal_mem_alloc( sizeof( zclGenCBRec_t ) );
   \                     ??zclGeneral_RegisterCmdCallbacks_0:
   \   000032                ; Setup parameters for call to function osal_mem_alloc
   \   000032   7A05         MOV     R2,#0x5
   \   000034   7B00         MOV     R3,#0x0
   \   000036   12....       LCALL   ??osal_mem_alloc?relay
   \   000039   8A..         MOV     ?V0 + 2,R2
   \   00003B   8B..         MOV     ?V0 + 3,R3
   \   00003D   A8..         MOV     R0,?V0 + 2
   \   00003F   A9..         MOV     R1,?V0 + 3
    192            if ( pNewItem == NULL )
   \   000041   E8           MOV     A,R0
   \   000042   7001         JNZ     ??zclGeneral_RegisterCmdCallbacks_1
   \   000044   E9           MOV     A,R1
   \                     ??zclGeneral_RegisterCmdCallbacks_1:
   \   000045   7004         JNZ     ??zclGeneral_RegisterCmdCallbacks_2
    193              return (ZMemError);
   \   000047   7910         MOV     R1,#0x10
   \   000049   804E         SJMP    ??zclGeneral_RegisterCmdCallbacks_3
    194          
    195            pNewItem->next = (zclGenCBRec_t *)NULL;
   \                     ??zclGeneral_RegisterCmdCallbacks_2:
   \   00004B   8882         MOV     DPL,R0
   \   00004D   8983         MOV     DPH,R1
   \   00004F   E4           CLR     A
   \   000050   F0           MOVX    @DPTR,A
   \   000051   A3           INC     DPTR
   \   000052   F0           MOVX    @DPTR,A
    196            pNewItem->endpoint = endpoint;
   \   000053   8882         MOV     DPL,R0
   \   000055   8983         MOV     DPH,R1
   \   000057   A3           INC     DPTR
   \   000058   A3           INC     DPTR
   \   000059   E5..         MOV     A,?V0 + 0
   \   00005B   F0           MOVX    @DPTR,A
    197            pNewItem->CBs = callbacks;
   \   00005C   8882         MOV     DPL,R0
   \   00005E   8983         MOV     DPH,R1
   \   000060   A3           INC     DPTR
   \   000061   A3           INC     DPTR
   \   000062   A3           INC     DPTR
   \   000063   EE           MOV     A,R6
   \   000064   F0           MOVX    @DPTR,A
   \   000065   A3           INC     DPTR
   \   000066   EF           MOV     A,R7
   \   000067   F0           MOVX    @DPTR,A
    198          
    199            // Find spot in list
    200            if (  zclGenCBs == NULL )
   \   000068   90....       MOV     DPTR,#zclGenCBs
   \   00006B   E0           MOVX    A,@DPTR
   \   00006C   7002         JNZ     ??zclGeneral_RegisterCmdCallbacks_4
   \   00006E   A3           INC     DPTR
   \   00006F   E0           MOVX    A,@DPTR
   \                     ??zclGeneral_RegisterCmdCallbacks_4:
   \   000070   90....       MOV     DPTR,#zclGenCBs
   \   000073   601D         JZ      ??zclGeneral_RegisterCmdCallbacks_5
    201            {
    202              zclGenCBs = pNewItem;
    203            }
    204            else
    205            {
    206              // Look for end of list
    207              pLoop = zclGenCBs;
   \   000075   E0           MOVX    A,@DPTR
   \   000076   FC           MOV     R4,A
   \   000077   A3           INC     DPTR
   \   000078   E0           MOVX    A,@DPTR
   \   000079   8003         SJMP    ??zclGeneral_RegisterCmdCallbacks_6
    208              while ( pLoop->next != NULL )
    209                pLoop = pLoop->next;
   \                     ??zclGeneral_RegisterCmdCallbacks_7:
   \   00007B   EA           MOV     A,R2
   \   00007C   FC           MOV     R4,A
   \   00007D   EB           MOV     A,R3
   \                     ??zclGeneral_RegisterCmdCallbacks_6:
   \   00007E   FD           MOV     R5,A
   \   00007F   8C82         MOV     DPL,R4
   \   000081   8D83         MOV     DPH,R5
   \   000083   E0           MOVX    A,@DPTR
   \   000084   FA           MOV     R2,A
   \   000085   A3           INC     DPTR
   \   000086   E0           MOVX    A,@DPTR
   \   000087   FB           MOV     R3,A
   \   000088   EA           MOV     A,R2
   \   000089   7001         JNZ     ??zclGeneral_RegisterCmdCallbacks_8
   \   00008B   EB           MOV     A,R3
   \                     ??zclGeneral_RegisterCmdCallbacks_8:
   \   00008C   70ED         JNZ     ??zclGeneral_RegisterCmdCallbacks_7
    210          
    211              // Put new item at end of list
    212              pLoop->next = pNewItem;
   \   00008E   8C82         MOV     DPL,R4
   \   000090   8D83         MOV     DPH,R5
   \                     ??zclGeneral_RegisterCmdCallbacks_5:
   \   000092   E8           MOV     A,R0
   \   000093   F0           MOVX    @DPTR,A
   \   000094   A3           INC     DPTR
   \   000095   E9           MOV     A,R1
   \   000096   F0           MOVX    @DPTR,A
    213            }
    214          
    215            return ( ZSuccess );
   \   000097   7900         MOV     R1,#0x0
   \                     ??zclGeneral_RegisterCmdCallbacks_3:
   \   000099                REQUIRE ?Subroutine9
   \   000099                ; // Fall through to label ?Subroutine9
    216          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   7F04         MOV     R7,#0x4
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    217          
    218          #ifdef ZCL_IDENTIFY
    219          /*********************************************************************
    220           * @fn      zclGeneral_SendIdentify
    221           *
    222           * @brief   Call to send out an Identify Command
    223           *
    224           * @param   srcEP - Sending application's endpoint
    225           * @param   dstAddr - where you want the message to go
    226           * @param   identifyTime - how long the device will continue to identify itself (in seconds)
    227           * @param   seqNum - identification number for the transaction
    228           *
    229           * @return  ZStatus_t
    230           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    231          ZStatus_t zclGeneral_SendIdentify( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zclGeneral_SendIdentify:
    232                                uint16 identifyTime, uint8 disableDefaultRsp, uint8 seqNum )
    233          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   740C         MOV     A,#0xc
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   FE           MOV     R6,A
   \   000011   740D         MOV     A,#0xd
   \   000013   12....       LCALL   ?XSTACK_DISP0_8
   \   000016   12....       LCALL   ?Subroutine1 & 0xFFFF
    234            uint8 buf[2];
    235          
    236            buf[0] = LO_UINT16( identifyTime );
    237            buf[1] = HI_UINT16( identifyTime );
   \                     ??CrossCallReturnLabel_2:
   \   000019   12....       LCALL   ?XSTACK_DISP0_8
   \   00001C   12....       LCALL   ?Subroutine0 & 0xFFFF
    238          
    239            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_IDENTIFY,
    240                                    COMMAND_IDENTIFY, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    241                                    disableDefaultRsp, 0, seqNum, 2, buf );
   \                     ??CrossCallReturnLabel_0:
   \   00001F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000022   75..02       MOV     ?V0 + 0,#0x2
   \   000025   75..00       MOV     ?V0 + 1,#0x0
   \   000028   78..         MOV     R0,#?V0 + 0
   \   00002A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00002D   EF           MOV     A,R7
   \   00002E   F5..         MOV     ?V0 + 0,A
   \   000030   78..         MOV     R0,#?V0 + 0
   \   000032   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000035   75..00       MOV     ?V0 + 0,#0x0
   \   000038   78..         MOV     R0,#?V0 + 0
   \   00003A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003D   EE           MOV     A,R6
   \   00003E   F5..         MOV     ?V0 + 0,A
   \   000040   78..         MOV     R0,#?V0 + 0
   \   000042   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000045   75..00       MOV     ?V0 + 0,#0x0
   \   000048   78..         MOV     R0,#?V0 + 0
   \   00004A   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00004D   75..01       MOV     ?V0 + 0,#0x1
   \   000050                REQUIRE ?Subroutine10
   \   000050                ; // Fall through to label ?Subroutine10

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   78..         MOV     R0,#?V0 + 0
   \   000002   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000005   75..00       MOV     ?V0 + 0,#0x0
   \   000008   78..         MOV     R0,#?V0 + 0
   \   00000A   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00000D   7C03         MOV     R4,#0x3
   \   00000F   7D00         MOV     R5,#0x0
   \   000011   12....       LCALL   ??zcl_SendCommand?relay
   \   000014   740B         MOV     A,#0xb
   \   000016   12....       LCALL   ?DEALLOC_XSTACK8
   \   000019   7402         MOV     A,#0x2
   \   00001B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00001E                REQUIRE ??Subroutine11_0
   \   00001E                ; // Fall through to label ??Subroutine11_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine11_0:
   \   000000   7F02         MOV     R7,#0x2
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FF           MOV     R7,A
   \   000002   EC           MOV     A,R4
   \   000003   85..82       MOV     DPL,?XSP + 0
   \   000006   85..83       MOV     DPH,?XSP + 1
   \   000009   F0           MOVX    @DPTR,A
   \   00000A   7401         MOV     A,#0x1
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   ED           MOV     A,R5
   \   000001   F0           MOVX    @DPTR,A
   \   000002                ; Setup parameters for call to function zcl_SendCommand
   \   000002                ; Setup parameters for call to function zcl_SendCommand
   \   000002   85..82       MOV     DPL,?XSP + 0
   \   000005   85..83       MOV     DPH,?XSP + 1
   \   000008   8582..       MOV     ?V0 + 0,DPL
   \   00000B   8583..       MOV     ?V0 + 1,DPH
   \   00000E   78..         MOV     R0,#?V0 + 0
   \   000010   22           RET
    242          }
    243          
    244          /*********************************************************************
    245           * @fn      zclGeneral_SendIdentifyQueryResponse
    246           *
    247           * @brief   Call to send out an Identify Query Response Command
    248           *
    249           * @param   srcEP - Sending application's endpoint
    250           * @param   dstAddr - where you want the message to go
    251           * @param   timeout - how long the device will continue to identify itself (in seconds)
    252           * @param   seqNum - identification number for the transaction
    253           *
    254           * @return  ZStatus_t
    255           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    256          ZStatus_t zclGeneral_SendIdentifyQueryResponse( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zclGeneral_SendIdentifyQueryResponse:
    257                                      uint16 timeout, uint8 disableDefaultRsp, uint8 seqNum )
    258          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   740C         MOV     A,#0xc
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   FE           MOV     R6,A
   \   000011   740D         MOV     A,#0xd
   \   000013   12....       LCALL   ?XSTACK_DISP0_8
   \   000016   12....       LCALL   ?Subroutine1 & 0xFFFF
    259            uint8 buf[2];
    260          
    261            buf[0] = LO_UINT16( timeout );
    262            buf[1] = HI_UINT16( timeout );
   \                     ??CrossCallReturnLabel_3:
   \   000019   12....       LCALL   ?XSTACK_DISP0_8
   \   00001C   12....       LCALL   ?Subroutine0 & 0xFFFF
    263          
    264            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_IDENTIFY,
    265                                    COMMAND_IDENTIFY_QUERY_RSP, TRUE,
    266                                    ZCL_FRAME_SERVER_CLIENT_DIR, disableDefaultRsp, 0, seqNum, 2, buf );
   \                     ??CrossCallReturnLabel_1:
   \   00001F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000022   75..02       MOV     ?V0 + 0,#0x2
   \   000025   75..00       MOV     ?V0 + 1,#0x0
   \   000028   78..         MOV     R0,#?V0 + 0
   \   00002A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00002D   EF           MOV     A,R7
   \   00002E   F5..         MOV     ?V0 + 0,A
   \   000030   78..         MOV     R0,#?V0 + 0
   \   000032   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000035   75..00       MOV     ?V0 + 0,#0x0
   \   000038   78..         MOV     R0,#?V0 + 0
   \   00003A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003D   EE           MOV     A,R6
   \   00003E   F5..         MOV     ?V0 + 0,A
   \   000040   78..         MOV     R0,#?V0 + 0
   \   000042   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000045   75..01       MOV     ?V0 + 0,#0x1
   \   000048   78..         MOV     R0,#?V0 + 0
   \   00004A   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00004D   80..         SJMP    ?Subroutine10
    267          }
    268          #endif // ZCL_IDENTIFY
    269          
    270          #ifdef ZCL_GROUPS
    271          /*********************************************************************
    272           * @fn      zclGeneral_SendGroupRequest
    273           *
    274           * @brief   Send a Group Request to a device.  You can also use the
    275           *          appropriate macro.
    276           *
    277           * @param   srcEP - Sending Apps endpoint
    278           * @param   dstAddr - where to send the request
    279           * @param   cmd - one of the following:
    280           *              COMMAND_GROUP_VIEW
    281           *              COMMAND_GROUP_REMOVE
    282           * @param   groupID -
    283           *
    284           * @return  ZStatus_t
    285           */
    286          ZStatus_t zclGeneral_SendGroupRequest( uint8 srcEP, afAddrType_t *dstAddr,
    287                               uint8 cmd, uint16 groupID, uint8 disableDefaultRsp, uint8 seqNum )
    288          {
    289            uint8 buf[2];
    290          
    291            buf[0] = LO_UINT16( groupID );
    292            buf[1] = HI_UINT16( groupID );
    293          
    294            return ( zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
    295                                      cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    296                                      disableDefaultRsp, 0, seqNum, 2, buf ) );
    297          }
    298          
    299          /*********************************************************************
    300           * @fn      zclGeneral_SendAddGroupRequest
    301           *
    302           * @brief   Send the Add Group Request to a device
    303           *
    304           * @param   srcEP - Sending Apps endpoint
    305           * @param   dstAddr - where to send the request
    306           * @param   cmd - one of the following:
    307           *                COMMAND_GROUP_ADD
    308           *                COMMAND_GROUP_ADD_IF_IDENTIFYING
    309           * @param   groupID - pointer to the group structure
    310           * @param   groupName - pointer to Group Name.  This is a Zigbee
    311           *          string data type, so the first byte is the length of the
    312           *          name (in bytes), then the name.
    313           *
    314           * @return  ZStatus_t
    315           */
    316          ZStatus_t zclGeneral_SendAddGroupRequest( uint8 srcEP, afAddrType_t *dstAddr,
    317                                                    uint8 cmd, uint16 groupID, uint8 *groupName,
    318                                                    uint8 disableDefaultRsp, uint8 seqNum )
    319          {
    320            uint8 *buf;
    321            uint8 *pBuf;
    322            uint8 len;
    323            ZStatus_t status;
    324          
    325            len = 2;    // Group ID
    326            len += groupName[0] + 1;  // String + 1 for length
    327          
    328            buf = osal_mem_alloc( len );
    329            if ( buf )
    330            {
    331              pBuf = buf;
    332              *pBuf++ = LO_UINT16( groupID );
    333              *pBuf++ = HI_UINT16( groupID );
    334              *pBuf++ = groupName[0]; // string length
    335              osal_memcpy( pBuf, &(groupName[1]), groupName[0] );
    336          
    337              status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
    338                                        cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    339                                        disableDefaultRsp, 0, seqNum, len, buf );
    340              osal_mem_free( buf );
    341            }
    342            else
    343              status = ZMemError;
    344          
    345            return ( status );
    346          }
    347          
    348          /*********************************************************************
    349           * @fn      zclGeneral_SendGroupGetMembershipRequest
    350           *
    351           * @brief   Send a Get Group Membership (Resposne) Command to a device
    352           *
    353           * @param   srcEP - Sending Apps endpoint
    354           * @param   dstAddr - where to send the request
    355           * @param   cmd - one of the following:
    356           *                COMMAND_GROUP_GET_MEMBERSHIP
    357           *                COMMAND_GROUP_GET_MEMBERSHIP_RSP
    358           * @param   groupID - pointer to the group structure
    359           * @param   groupName - pointer to Group Name.  This is a Zigbee
    360           *          string data type, so the first byte is the length of the
    361           *          name (in bytes), then the name.
    362           *
    363           * @return  ZStatus_t
    364           */
    365          ZStatus_t zclGeneral_SendGroupGetMembershipRequest( uint8 srcEP, afAddrType_t *dstAddr,
    366                                        uint8 cmd, uint8 rspCmd, uint8 direction, uint8 capacity,
    367                                        uint8 grpCnt, uint16 *grpList, uint8 disableDefaultRsp, uint8 seqNum )
    368          {
    369            uint8 *buf;
    370            uint8 *pBuf;
    371            uint8 len = 0;
    372            uint8 i;
    373            ZStatus_t status;
    374          
    375            if ( rspCmd )
    376              len++;  // Capacity
    377          
    378            len++;  // Group Count
    379            len += sizeof ( uint16 ) * grpCnt;  // Group List
    380          
    381            buf = osal_mem_alloc( len );
    382            if ( buf )
    383            {
    384              pBuf = buf;
    385              if ( rspCmd )
    386                *pBuf++ = capacity;
    387          
    388              *pBuf++ = grpCnt;
    389              for ( i = 0; i < grpCnt; i++ )
    390              {
    391                *pBuf++ = LO_UINT16( grpList[i] );
    392                *pBuf++ = HI_UINT16( grpList[i] );
    393              }
    394          
    395              status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
    396                                        cmd, TRUE, direction,
    397                                        disableDefaultRsp, 0, seqNum, len, buf );
    398              osal_mem_free( buf );
    399            }
    400            else
    401              status = ZMemError;
    402          
    403            return ( status );
    404          }
    405          
    406          /*********************************************************************
    407           * @fn      zclGeneral_SendGroupResponse
    408           *
    409           * @brief   Send Group Response (not Group View Response)
    410           *
    411           * @param   srcEP - Sending application's endpoint
    412           * @param   dstAddr - where you want the message to go
    413           * @param   cmd - either COMMAND_GROUP_ADD_RSP or COMMAND_GROUP_REMOVE_RSP
    414           * @param   status - group command status
    415           * @param   groupID - what group
    416           *
    417           * @return  ZStatus_t
    418           */
    419          ZStatus_t zclGeneral_SendGroupResponse( uint8 srcEP, afAddrType_t *dstAddr,
    420                                                  uint8 cmd, uint8 status, uint16 groupID,
    421                                                  uint8 disableDefaultRsp, uint8 seqNum )
    422          {
    423            uint8 buf[3];
    424          
    425            buf[0] = status;
    426            buf[1] = LO_UINT16( groupID );
    427            buf[2] = HI_UINT16( groupID );
    428          
    429            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
    430                                    cmd, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
    431                                    disableDefaultRsp, 0, seqNum, 3, buf );
    432          }
    433          
    434          /*********************************************************************
    435           * @fn      zclGeneral_SendGroupViewResponse
    436           *
    437           * @brief   Call to send Group Response Command
    438           *
    439           * @param   srcEP - Sending application's endpoint
    440           * @param   dstAddr - where you want the message to go
    441           * @param   cmd - either COMMAND_GROUP_ADD_RSP or COMMAND_GROUP_REMOVE_RSP
    442           * @param   status - group command status
    443           * @param   grp - group info
    444           *
    445           * @return  ZStatus_t
    446           */
    447          ZStatus_t zclGeneral_SendGroupViewResponse( uint8 srcEP, afAddrType_t *dstAddr,
    448                           uint8 status, aps_Group_t *grp, uint8 disableDefaultRsp, uint8 seqNum )
    449          {
    450            uint8 *buf;
    451            uint8 len;
    452            ZStatus_t stat;
    453          
    454            len = 1 + 2; // Status + Group ID
    455          
    456            if ( status == ZCL_STATUS_SUCCESS )
    457              len += grp->name[0] + 1;  // String + 1 for length
    458          
    459            buf = osal_mem_alloc( len );
    460            if ( buf )
    461            {
    462              buf[0] = status;
    463              buf[1] = LO_UINT16( grp->ID );
    464              buf[2] = HI_UINT16( grp->ID );
    465          
    466              if ( status == ZCL_STATUS_SUCCESS )
    467              {
    468                buf[3] = grp->name[0]; // string length
    469                osal_memcpy( &buf[4], (&grp->name[1]), grp->name[0] );
    470              }
    471          
    472              stat = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
    473                                      COMMAND_GROUP_VIEW_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
    474                                      disableDefaultRsp, 0, seqNum, len, buf );
    475              osal_mem_free( buf );
    476            }
    477            else
    478              stat = ZMemError;
    479          
    480            return ( stat );
    481          }
    482          #endif // ZCL_GROUPS
    483          
    484          #ifdef ZCL_SCENES
    485          /*********************************************************************
    486           * @fn      zclGeneral_SendAddScene
    487           *
    488           * @brief   Send the Add Scene Request to a device
    489           *
    490           * @param   srcEP - Sending Apps endpoint
    491           * @param   dstAddr - where to send the request
    492           * @param   scene - pointer to the scene structure
    493           *
    494           * @return  ZStatus_t
    495           */
    496          ZStatus_t zclGeneral_SendAddScene( uint8 srcEP, afAddrType_t *dstAddr,
    497                                zclGeneral_Scene_t *scene, uint8 disableDefaultRsp, uint8 seqNum )
    498          {
    499            uint8 *buf;
    500            uint8 *pBuf;
    501            uint8 len;
    502            ZStatus_t status;
    503          
    504            len = 2 + 1 + 2;    // Group ID + Scene ID + transition time
    505            len += scene->name[0] + 1; // String + 1 for length
    506          
    507            // Add something for the extension field length
    508            len += scene->extLen;
    509          
    510            buf = osal_mem_alloc( len );
    511            if ( buf )
    512            {
    513              pBuf = buf;
    514              *pBuf++ = LO_UINT16( scene->groupID );
    515              *pBuf++ = HI_UINT16( scene->groupID );
    516              *pBuf++ = scene->ID;
    517              *pBuf++ = LO_UINT16( scene->transTime );
    518              *pBuf++ = HI_UINT16( scene->transTime );
    519              *pBuf++ = scene->name[0]; // string length
    520              osal_memcpy( pBuf, &(scene->name[1]), scene->name[0] );
    521              pBuf += scene->name[0]; // move pass name
    522          
    523              // Add the extension fields
    524              if ( scene->extLen > 0 )
    525                osal_memcpy( pBuf, scene->extField, scene->extLen );
    526          
    527              status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    528                                        COMMAND_SCENE_ADD, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    529                                        disableDefaultRsp, 0, seqNum, len, buf );
    530              osal_mem_free( buf );
    531            }
    532            else
    533              status = ZMemError;
    534          
    535            return ( status );
    536          }
    537          
    538          /*********************************************************************
    539           * @fn      zclGeneral_SendSceneRequest
    540           *
    541           * @brief   Send a Scene Request to a device.  You can also use the
    542           *          appropriate macro.
    543           *
    544           * @param   srcEP - Sending Apps endpoint
    545           * @param   dstAddr - where to send the request
    546           * @param   cmd - one of the following:
    547           *              COMMAND_SCENE_VIEW
    548           *              COMMAND_SCENE_REMOVE
    549           *              COMMAND_SCENE_REMOVE_ALL
    550           *              COMMAND_SCENE_STORE
    551           *              COMMAND_SCENE_RECALL
    552           *              COMMAND_SCENE_GET_MEMBERSHIP
    553           * @param   groupID - group ID
    554           * @param   sceneID - scene ID (not applicable to COMMAND_SCENE_REMOVE_ALL and
    555           *                    COMMAND_SCENE_GET_MEMBERSHIP)
    556           * @return  ZStatus_t
    557           */
    558          ZStatus_t zclGeneral_SendSceneRequest( uint8 srcEP, afAddrType_t *dstAddr,
    559                                                 uint8 cmd, uint16 groupID, uint8 sceneID,
    560                                                 uint8 disableDefaultRsp, uint8 seqNum )
    561          {
    562            uint8 buf[3];
    563            uint8 len = 2;
    564          
    565            buf[0] = LO_UINT16( groupID );
    566            buf[1] = HI_UINT16( groupID );
    567          
    568            if ( cmd != COMMAND_SCENE_REMOVE_ALL && cmd != COMMAND_SCENE_GET_MEMBERSHIP )
    569            {
    570              buf[2] = sceneID;
    571              len++;
    572            }
    573          
    574            return ( zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    575                                      cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    576                                      disableDefaultRsp, 0, seqNum, len, buf ) );
    577          }
    578          
    579          /*********************************************************************
    580           * @fn      zclGeneral_SendSceneResponse
    581           *
    582           * @brief   Send Group Response (not Group View Response)
    583           *
    584           * @param   srcEP - Sending application's endpoint
    585           * @param   dstAddr - where you want the message to go
    586           * @param   cmd - either COMMAND_SCENE_ADD_RSP, COMMAND_SCENE_REMOVE_RSP
    587           *                COMMAND_SCENE_STORE_RSP, or COMMAND_SCENE_REMOVE_ALL_RSP
    588           * @param   status - scene command status
    589           * @param   groupID - what group
    590           * @param   sceneID - what scene (not applicable to COMMAND_SCENE_REMOVE_ALL_RSP)
    591           *
    592           * @return  ZStatus_t
    593           */
    594          ZStatus_t zclGeneral_SendSceneResponse( uint8 srcEP, afAddrType_t *dstAddr,
    595                                            uint8 cmd, uint8 status, uint16 groupID,
    596                                            uint8 sceneID, uint8 disableDefaultRsp, uint8 seqNum )
    597          {
    598            uint8 buf[4];
    599            uint8 len = 1 + 2; // Status + Group ID
    600          
    601            buf[0] = status;
    602            buf[1] = LO_UINT16( groupID );
    603            buf[2] = HI_UINT16( groupID );
    604          
    605            if ( cmd != COMMAND_SCENE_REMOVE_ALL_RSP )
    606            {
    607              buf[3] = sceneID;
    608              len++;
    609            }
    610          
    611            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    612                                    cmd, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
    613                                    disableDefaultRsp, 0, seqNum, len, buf );
    614          }
    615          
    616          /*********************************************************************
    617           * @fn      zclGeneral_SendSceneViewResponse
    618           *
    619           * @brief   Call to send Scene Response Command
    620           *
    621           * @param   srcEP - Sending application's endpoint
    622           * @param   dstAddr - where you want the message to go
    623           * @param   status - scene command status
    624           * @param   scene - scene info
    625           *
    626           * @return  ZStatus_t
    627           */
    628          ZStatus_t zclGeneral_SendSceneViewResponse( uint8 srcEP, afAddrType_t *dstAddr,
    629                                                 uint8 status, zclGeneral_Scene_t *scene,
    630                                                 uint8 disableDefaultRsp, uint8 seqNum )
    631          {
    632            uint8 *buf;
    633            uint8 *pBuf;
    634            uint8 len = 1 + 2 + 1; // Status + Group ID + Scene ID
    635            ZStatus_t stat;
    636          
    637            if ( status == ZCL_STATUS_SUCCESS )
    638            {
    639              len += 2; // Transition Time
    640              len += scene->name[0] + 1; // string + 1 for length
    641          
    642              // Add something for the extension field length
    643              len += scene->extLen;
    644            }
    645          
    646            buf = osal_mem_alloc( len );
    647            if ( buf )
    648            {
    649              pBuf = buf;
    650              *pBuf++ = status;
    651              *pBuf++ = LO_UINT16( scene->groupID );
    652              *pBuf++ = HI_UINT16( scene->groupID );
    653              *pBuf++ = scene->ID;
    654              if ( status == ZCL_STATUS_SUCCESS )
    655              {
    656                *pBuf++ = LO_UINT16( scene->transTime );
    657                *pBuf++ = HI_UINT16( scene->transTime );
    658                *pBuf++ = scene->name[0]; // string length
    659                if ( scene->name[0] != 0 )
    660                {
    661                  osal_memcpy( pBuf, &(scene->name[1]), scene->name[0] );
    662                  pBuf += scene->name[0]; // move pass name
    663                }
    664          
    665                // Add the extension fields
    666                if ( scene->extLen > 0 )
    667                  osal_memcpy( pBuf, scene->extField, scene->extLen );
    668              }
    669          
    670              stat = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    671                                      COMMAND_SCENE_VIEW_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
    672                                      disableDefaultRsp, 0, seqNum, len, buf );
    673              osal_mem_free( buf );
    674            }
    675            else
    676              stat = ZMemError;
    677          
    678            return ( stat );
    679          }
    680          
    681          /*********************************************************************
    682           * @fn      zclGeneral_SendSceneGetMembershipResponse
    683           *
    684           * @brief   Call to send Scene Get Membership Response Command
    685           *
    686           * @param   srcEP - Sending application's endpoint
    687           * @param   dstAddr - where you want the message to go
    688           * @param   status - scene command status
    689           * @param   capacity - remaining capacity of the scene table
    690           * @param   sceneCnt - number of scenes in the scene list
    691           * @param   sceneList - list of scene IDs
    692           * @param   groupID - group ID that scene belongs to
    693           * @param   seqNum - sequence number
    694           *
    695           * @return  ZStatus_t
    696           */
    697          ZStatus_t zclGeneral_SendSceneGetMembershipResponse( uint8 srcEP, afAddrType_t *dstAddr,
    698                                 uint8 status, uint8 capacity, uint8 sceneCnt, uint8 *sceneList,
    699                                 uint16 groupID, uint8 disableDefaultRsp, uint8 seqNum )
    700          {
    701            uint8 *buf;
    702            uint8 *pBuf;
    703            uint8 len = 1 + 1 + 2; // Status + Capacity + Group ID;
    704            uint8 i;
    705            ZStatus_t stat;
    706          
    707            if ( status == ZCL_STATUS_SUCCESS )
    708            {
    709              len++; // Scene Count
    710              len += sceneCnt; // Scene List (Scene ID is a single octet)
    711            }
    712          
    713            buf = osal_mem_alloc( len );
    714            if ( buf )
    715            {
    716              pBuf = buf;
    717              *pBuf++ = status;
    718              *pBuf++ = capacity;
    719              *pBuf++ = LO_UINT16( groupID );
    720              *pBuf++ = HI_UINT16( groupID );
    721              if ( status == ZCL_STATUS_SUCCESS )
    722              {
    723                *pBuf++ = sceneCnt;
    724                for ( i = 0; i < sceneCnt; i++ )
    725                  *pBuf++ = sceneList[i];
    726              }
    727          
    728              stat = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    729                                      COMMAND_SCENE_GET_MEMBERSHIP_RSP, TRUE,
    730                                      ZCL_FRAME_SERVER_CLIENT_DIR, disableDefaultRsp, 0, seqNum, len, buf );
    731              osal_mem_free( buf );
    732            }
    733            else
    734              stat = ZMemError;
    735          
    736            return ( stat );
    737          }
    738          #endif // ZCL_SCENES
    739          
    740          #ifdef ZCL_LEVEL_CTRL
    741          /*********************************************************************
    742           * @fn      zclGeneral_SendLevelControlMoveToLevelRequest
    743           *
    744           * @brief   Call to send out a Level Control Request. You can also use
    745           *          the appropriate macro.
    746           *
    747           * @param   srcEP - Sending application's endpoint
    748           * @param   dstAddr - where you want the message to go
    749           * @param   cmd - one of the following:
    750           *              COMMAND_LEVEL_MOVE_TO_LEVEL or
    751           *              COMMAND_LEVEL_MOVE_TO_LEVEL_WITH_ON_OFF
    752           * @param   level - what level to move to
    753           * @param   transitionTime - how long to take to get to the level (in seconds)
    754           *
    755           * @return  ZStatus_t
    756           */
    757          ZStatus_t zclGeneral_SendLevelControlMoveToLevelRequest( uint8 srcEP, afAddrType_t *dstAddr,
    758                                                                   uint8 cmd, uint8 level, uint16 transTime,
    759                                                                   uint8 disableDefaultRsp, uint8 seqNum )
    760          {
    761            uint8 buf[3];
    762          
    763            buf[0] = level;
    764            buf[1] = LO_UINT16( transTime );
    765            buf[2] = HI_UINT16( transTime );
    766          
    767            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL,
    768                                    cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    769                                    disableDefaultRsp, 0, seqNum, 3, buf );
    770          }
    771          
    772          /*********************************************************************
    773           * @fn      zclGeneral_SendLevelControlMoveRequest
    774           *
    775           * @brief   Call to send out a Level Control Request. You can also use
    776           *          the appropriate macro.
    777           *
    778           * @param   srcEP - Sending application's endpoint
    779           * @param   dstAddr - where you want the message to go
    780           * @param   cmd - one of the following:
    781           *              COMMAND_LEVEL_MOVE or
    782           *              COMMAND_LEVEL_MOVE_WITH_ON_OFF
    783           * @param   moveMode - LEVEL_MOVE_UP or
    784           *                     LEVEL_MOVE_DOWN
    785           * @param   rate - number of steps to take per second
    786           *
    787           * @return  ZStatus_t
    788           */
    789          ZStatus_t zclGeneral_SendLevelControlMoveRequest( uint8 srcEP, afAddrType_t *dstAddr,
    790                                                            uint8 cmd, uint8 moveMode, uint8 rate,
    791                                                            uint8 disableDefaultRsp, uint8 seqNum )
    792          {
    793            uint8 buf[2];
    794          
    795            buf[0] = moveMode;
    796            buf[1] = rate;
    797          
    798            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL,
    799                                    cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    800                                    disableDefaultRsp, 0, seqNum, 2, buf );
    801          }
    802          
    803          /*********************************************************************
    804           * @fn      zclGeneral_SendLevelControlStepRequest
    805           *
    806           * @brief   Call to send out a Level Control Request. You can also use
    807           *          the appropriate macro.
    808           *
    809           * @param   srcEP - Sending application's endpoint
    810           * @param   dstAddr - where you want the message to go
    811           * @param   cmd - one of the following:
    812           *              COMMAND_LEVEL_STEP
    813           *              COMMAND_LEVEL_STEP_WITH_ON_OFF
    814           * @param   stepMode - LEVEL_STEP_UP or
    815           *                     LEVEL_STEP_DOWN
    816           * @param   amount - number of levels to step
    817           * @param   transitionTime - time, in 1/10ths of a second, to take to perform the step
    818           *
    819           * @return  ZStatus_t
    820           */
    821          ZStatus_t zclGeneral_SendLevelControlStepRequest( uint8 srcEP, afAddrType_t *dstAddr,
    822                                   uint8 cmd, uint8 stepMode, uint8 stepSize, uint16 transTime,
    823                                   uint8 disableDefaultRsp, uint8 seqNum )
    824          {
    825            uint8 buf[4];
    826          
    827            buf[0] = stepMode;
    828            buf[1] = stepSize;
    829            buf[2] = LO_UINT16( transTime );
    830            buf[3] = HI_UINT16( transTime );
    831          
    832            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL,
    833                                    cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    834                                    disableDefaultRsp, 0, seqNum, 4, buf );
    835          }
    836          #endif // ZCL_LEVEL_CTRL
    837          
    838          #ifdef ZCL_ALARMS
    839          /*********************************************************************
    840           * @fn      zclGeneral_SendAlarmRequest
    841           *
    842           * @brief   Call to send out an Alarm Request Command
    843           *
    844           * @param   srcEP - Sending application's endpoint
    845           * @param   dstAddr - where you want the message to go
    846           * @param   cmd - either COMMAND_ALARMS_RESET or COMMAND_ALARMS_ALARM
    847           * @param   alarmCode - code for the cause of the alarm
    848           * @param   clusterID - cluster whose attribute generate the alarm
    849           *
    850           * @return  ZStatus_t
    851           */
    852          ZStatus_t zclGeneral_SendAlarmRequest( uint8 srcEP, afAddrType_t *dstAddr,
    853                                                 uint8 cmd, uint8 alarmCode, uint16 clusterID,
    854                                                 uint8 disableDefaultRsp, uint8 seqNum )
    855          {
    856            uint8 buf[3];
    857          
    858            buf[0] = alarmCode;
    859            buf[1] = LO_UINT16( clusterID );
    860            buf[2] = HI_UINT16( clusterID );
    861          
    862            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ALARMS,
    863                                    cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    864                                    disableDefaultRsp, 0, seqNum, 3, buf );
    865          }
    866          
    867          /*********************************************************************
    868           * @fn      zclGeneral_SendAlarmGetRespnose
    869           *
    870           * @brief   Call to send out an Alarm Get Response Command
    871           *
    872           * @param   srcEP - Sending application's endpoint
    873           * @param   dstAddr - where you want the message to go
    874           * @param   status - SUCCESS or NOT_FOUND
    875           * @param   alarmCode - code for the cause of the alarm
    876           * @param   clusterID - cluster whose attribute generate the alarm
    877           * @param   timeStamp - time at which the alarm occured
    878           *
    879           * @return  ZStatus_t
    880           */
    881          ZStatus_t zclGeneral_SendAlarmGetRespnose( uint8 srcEP, afAddrType_t *dstAddr,
    882                                        uint8 status, uint8 alarmCode, uint16 clusterID,
    883                                        uint32 timeStamp, uint8 disableDefaultRsp, uint8 seqNum )
    884          {
    885            uint8 buf[8];
    886            uint8 len = 1; // Status
    887          
    888            buf[0] = status;
    889            if ( status == ZCL_STATUS_SUCCESS )
    890            {
    891              len += 1 + 2 + 4; // Alarm code + Cluster ID + Time stamp
    892              buf[1] = alarmCode;
    893              buf[2] = LO_UINT16( clusterID );
    894              buf[3] = HI_UINT16( clusterID );
    895              osal_buffer_uint32( &buf[4], timeStamp );
    896            }
    897          
    898            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ALARMS,
    899                                    COMMAND_ALARMS_GET_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
    900                                    disableDefaultRsp, 0, seqNum, len, buf );
    901          }
    902          #endif // ZCL_ALARMS
    903          
    904          #ifdef ZCL_LOCATION
    905          /*********************************************************************
    906           * @fn      zclGeneral_SendLocationSetAbsolute
    907           *
    908           * @brief   Call to send out a Set Absolute Location Command
    909           *
    910           * @param   srcEP - Sending application's endpoint
    911           * @param   dstAddr - where you want the message to go
    912           * @param   absLoc - absolute location info
    913           *
    914           * @return  ZStatus_t
    915           */
    916          ZStatus_t zclGeneral_SendLocationSetAbsolute( uint8 srcEP, afAddrType_t *dstAddr,
    917                                                        zclLocationAbsolute_t *absLoc,
    918                                                        uint8 disableDefaultRsp, uint8 seqNum )
    919          {
    920             uint8 buf[10]; // 5 fields (2 octects each)
    921          
    922             buf[0] = LO_UINT16( absLoc->coordinate1 );
    923             buf[1] = HI_UINT16( absLoc->coordinate1 );
    924             buf[2] = LO_UINT16( absLoc->coordinate2 );
    925             buf[3] = HI_UINT16( absLoc->coordinate2 );
    926             buf[4] = LO_UINT16( absLoc->coordinate3 );
    927             buf[5] = HI_UINT16( absLoc->coordinate3 );
    928             buf[6] = LO_UINT16( absLoc->power );
    929             buf[7] = HI_UINT16( absLoc->power );
    930             buf[8] = LO_UINT16( absLoc->pathLossExponent );
    931             buf[9] = HI_UINT16( absLoc->pathLossExponent );
    932          
    933             return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
    934                                     COMMAND_LOCATION_SET_ABSOLUTE, TRUE,
    935                                     ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, 10, buf );
    936          }
    937          
    938          /*********************************************************************
    939           * @fn      zclGeneral_SendLocationSetDevCfg
    940           *
    941           * @brief   Call to send out a Set Device Configuration Command
    942           *
    943           * @param   srcEP - Sending application's endpoint
    944           * @param   dstAddr - where you want the message to go
    945           * @param   devCfg - device configuration info
    946           *
    947           * @return  ZStatus_t
    948           */
    949          ZStatus_t zclGeneral_SendLocationSetDevCfg( uint8 srcEP, afAddrType_t *dstAddr,
    950                                                      zclLocationDevCfg_t *devCfg,
    951                                                      uint8 disableDefaultRsp, uint8 seqNum )
    952          {
    953             uint8 buf[9];  // 4 fields (2 octects each) + 1 field with 1 octect
    954          
    955             buf[0] = LO_UINT16( devCfg->power );
    956             buf[1] = HI_UINT16( devCfg->power );
    957             buf[2] = LO_UINT16( devCfg->pathLossExponent );
    958             buf[3] = HI_UINT16( devCfg->pathLossExponent );
    959             buf[4] = LO_UINT16( devCfg->calcPeriod );
    960             buf[5] = HI_UINT16( devCfg->calcPeriod );
    961             buf[6] = devCfg->numMeasurements;
    962             buf[7] = LO_UINT16( devCfg->reportPeriod );
    963             buf[8] = HI_UINT16( devCfg->reportPeriod );
    964          
    965             return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
    966                                     COMMAND_LOCATION_SET_DEV_CFG, TRUE,
    967                                     ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, 9, buf );
    968          }
    969          
    970          /*********************************************************************
    971           * @fn      zclGeneral_SendLocationGetDevCfg
    972           *
    973           * @brief   Call to send out a Get Device Configuration Command
    974           *
    975           * @param   srcEP - Sending application's endpoint
    976           * @param   dstAddr - where you want the message to go
    977           * @param   targetAddr - device for which location parameters are being requested
    978           *
    979           * @return  ZStatus_t
    980           */
    981          ZStatus_t zclGeneral_SendLocationGetDevCfg( uint8 srcEP, afAddrType_t *dstAddr,
    982                                 uint8 *targetAddr, uint8 disableDefaultRsp, uint8 seqNum )
    983          {
    984            uint8 buf[8];
    985          
    986            osal_cpyExtAddr( buf, targetAddr );
    987          
    988            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
    989                                    COMMAND_LOCATION_GET_DEV_CFG, TRUE,
    990                                    ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, 8, buf );
    991          }
    992          
    993          /*********************************************************************
    994           * @fn      zclGeneral_SendLocationGetData
    995           *
    996           * @brief   Call to send out a Get Location Data Command
    997           *
    998           * @param   srcEP - Sending application's endpoint
    999           * @param   dstAddr - where you want the message to go
   1000           * @param   locaData - location information and channel parameters that are requested.
   1001           *
   1002           * @return  ZStatus_t
   1003           */
   1004          ZStatus_t zclGeneral_SendLocationGetData( uint8 srcEP, afAddrType_t *dstAddr,
   1005                                                    zclLocationGetData_t *locData,
   1006                                                    uint8 disableDefaultRsp, uint8 seqNum )
   1007          {
   1008            uint8 buf[10]; // bitmap (1) + number responses (1) + IEEE Address (8)
   1009            uint8 *pBuf = buf;
   1010            uint8 len = 2; // bitmap + number responses
   1011          
   1012            *pBuf  = locData->absoluteOnly;
   1013            *pBuf |= locData->recalculate << 1;
   1014            *pBuf |= locData->brdcastIndicator << 2;
   1015            *pBuf |= locData->brdcastResponse << 3;
   1016            *pBuf |= locData->compactResponse << 4;
   1017            pBuf++;  // move past the bitmap field
   1018          
   1019            *pBuf++ = locData->numResponses;
   1020          
   1021            if ( locData->brdcastIndicator == 0 )
   1022            {
   1023              osal_cpyExtAddr( pBuf, locData->targetAddr );
   1024              len += 8; // ieee addr
   1025            }
   1026          
   1027            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
   1028                                    COMMAND_LOCATION_GET_DATA, TRUE,
   1029                                    ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, len, buf );
   1030          }
   1031          
   1032          /*********************************************************************
   1033           * @fn      zclGeneral_SendLocationDevCfgResponse
   1034           *
   1035           * @brief   Call to send out a Device Configuration Response Command
   1036           *
   1037           * @param   srcEP - Sending application's endpoint
   1038           * @param   dstAddr - where you want the message to go
   1039           * @param   devCfg - device's location parameters that are requested
   1040           *
   1041           * @return  ZStatus_t
   1042           */
   1043          ZStatus_t zclGeneral_SendLocationDevCfgResponse( uint8 srcEP, afAddrType_t *dstAddr,
   1044                                                           zclLocationDevCfgRsp_t *devCfg,
   1045                                                           uint8 disableDefaultRsp, uint8 seqNum )
   1046          {
   1047            uint8 buf[10]; // 4 fields (2 octects each) + 2 fields (1 octect each)
   1048            uint8 len = 1; // Status
   1049          
   1050            buf[0] = devCfg->status;
   1051            if ( devCfg->status == ZCL_STATUS_SUCCESS )
   1052            {
   1053              buf[1] = LO_UINT16( devCfg->data.power );
   1054              buf[2] = HI_UINT16( devCfg->data.power );
   1055              buf[3] = LO_UINT16( devCfg->data.pathLossExponent );
   1056              buf[4] = HI_UINT16( devCfg->data.pathLossExponent );
   1057              buf[5] = LO_UINT16( devCfg->data.calcPeriod );
   1058              buf[6] = HI_UINT16( devCfg->data.calcPeriod );
   1059              buf[7] = devCfg->data.numMeasurements;
   1060              buf[8] = LO_UINT16( devCfg->data.reportPeriod );
   1061              buf[9] = HI_UINT16( devCfg->data.reportPeriod );
   1062              len += 9;
   1063            }
   1064          
   1065            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
   1066                                    COMMAND_LOCATION_DEV_CFG_RSP, TRUE,
   1067                                    ZCL_FRAME_SERVER_CLIENT_DIR, disableDefaultRsp, 0, seqNum, len, buf );
   1068          }
   1069          
   1070          /*********************************************************************
   1071           * @fn      zclGeneral_SendLocationData
   1072           *
   1073           * @brief   Call to send out location data
   1074           *
   1075           * @param   srcEP - Sending application's endpoint
   1076           * @param   dstAddr - where you want the message to go
   1077           * @param   status - indicates whether response to request was successful or not
   1078           * @param   locData - location information and channel parameters being sent
   1079           *
   1080           * @return  ZStatus_t
   1081           */
   1082          ZStatus_t zclGeneral_SendLocationData( uint8 srcEP, afAddrType_t *dstAddr, uint8 cmd,
   1083                                                 uint8 status, zclLocationData_t *locData,
   1084                                                 uint8 disableDefaultRsp, uint8 seqNum )
   1085          {
   1086            uint8 buf[16];
   1087            uint8 *pBuf = buf;
   1088            uint8 len = 0;
   1089          
   1090            if ( cmd == COMMAND_LOCATION_DATA_RSP )
   1091            {
   1092              // Only response command includes a status field
   1093              *pBuf++ = status;
   1094              len++;
   1095            }
   1096          
   1097            if ( cmd != COMMAND_LOCATION_DATA_RSP || status == ZCL_STATUS_SUCCESS )
   1098            {
   1099              // Notification or Response with successful status
   1100              *pBuf++ = locData->type;
   1101              *pBuf++ = LO_UINT16( locData->absLoc.coordinate1 );
   1102              *pBuf++ = HI_UINT16( locData->absLoc.coordinate1 );
   1103              *pBuf++ = LO_UINT16( locData->absLoc.coordinate2 );
   1104              *pBuf++ = HI_UINT16( locData->absLoc.coordinate2 );
   1105              len += 5;
   1106          
   1107              if ( locationType2D(locData->type) == 0 )
   1108              {
   1109                // 2D location doesn't have coordinate 3
   1110                *pBuf++ = LO_UINT16( locData->absLoc.coordinate3 );
   1111                *pBuf++ = HI_UINT16( locData->absLoc.coordinate3 );
   1112                len += 2;
   1113              }
   1114          
   1115              if ( cmd != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
   1116              {
   1117                // Compact notification doesn't include these fields
   1118                *pBuf++ = LO_UINT16( locData->absLoc.power );
   1119                *pBuf++ = HI_UINT16( locData->absLoc.power );
   1120                *pBuf++ = LO_UINT16( locData->absLoc.pathLossExponent );
   1121                *pBuf++ = HI_UINT16( locData->absLoc.pathLossExponent );
   1122                len += 4;
   1123              }
   1124          
   1125              if ( locationTypeAbsolute(locData->type) == 0 )
   1126              {
   1127                // Absolute location doesn't include these fields
   1128                if ( cmd != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
   1129                {
   1130                  // Compact notification doesn't include this field
   1131                  *pBuf++ = locData->calcLoc.locationMethod;
   1132                  len++;
   1133                }
   1134          
   1135                *pBuf++ = locData->calcLoc.qualityMeasure;
   1136                *pBuf++ = LO_UINT16( locData->calcLoc.locationAge );
   1137                *pBuf++ = HI_UINT16( locData->calcLoc.locationAge );
   1138                len += 3;
   1139              }
   1140            }
   1141          
   1142            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
   1143                                    cmd, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
   1144                                    disableDefaultRsp, 0, seqNum, len, buf );
   1145          }
   1146          #endif // ZCL_LOCATION
   1147          
   1148          /*********************************************************************
   1149           * @fn      zclGeneral_FindCallbacks
   1150           *
   1151           * @brief   Find the callbacks for an endpoint
   1152           *
   1153           * @param   endpoint - endpoint to find the application callbacks for
   1154           *
   1155           * @return  pointer to the callbacks
   1156           */
   1157          static zclGeneral_AppCallbacks_t *zclGeneral_FindCallbacks( uint8 endpoint )
   1158          {
   1159            zclGenCBRec_t *pCBs;
   1160          
   1161            pCBs = zclGenCBs;
   1162            while ( pCBs )
   1163            {
   1164              if ( pCBs->endpoint == endpoint )
   1165                return ( pCBs->CBs );
   1166              pCBs = pCBs->next;
   1167            }
   1168            return ( (zclGeneral_AppCallbacks_t *)NULL );
   1169          }
   1170          
   1171          /*********************************************************************
   1172           * @fn      zclGeneral_HdlIncoming
   1173           *
   1174           * @brief   Callback from ZCL to process incoming Commands specific
   1175           *          to this cluster library or Profile commands for attributes
   1176           *          that aren't in the attribute list
   1177           *
   1178           *
   1179           * @param   pInMsg - pointer to the incoming message
   1180           *
   1181           * @return  ZStatus_t
   1182           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1183          static ZStatus_t zclGeneral_HdlIncoming( zclIncoming_t *pInMsg )
   \                     zclGeneral_HdlIncoming:
   1184          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1185            ZStatus_t stat = ZSuccess;
   1186          
   1187          #if defined ( INTER_PAN )
   1188            if ( StubAPS_InterPan( pInMsg->msg->srcAddr.panId, pInMsg->msg->srcAddr.endPoint ) )
   1189              return ( stat ); // Cluster not supported thru Inter-PAN
   1190          #endif
   1191            if ( zcl_ClusterCmd( pInMsg->hdr.fc.type ) )
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   F8           MOV     R0,A
   \   00000C   5403         ANL     A,#0x3
   \   00000E   6401         XRL     A,#0x1
   \   000010   700A         JNZ     ??zclGeneral_HdlIncoming_0
   1192            {
   1193              // Is this a manufacturer specific command?
   1194              if ( pInMsg->hdr.fc.manuSpecific == 0 )
   \   000012   E8           MOV     A,R0
   \   000013   5404         ANL     A,#0x4
   \   000015   7005         JNZ     ??zclGeneral_HdlIncoming_0
   1195              {
   1196                stat = zclGeneral_HdlInSpecificCommands( pInMsg );
   \   000017                ; Setup parameters for call to function zclGeneral_HdlInSpecificCommands
   \   000017   12....       LCALL   ??zclGeneral_HdlInSpecificCommands?relay
   \   00001A   8002         SJMP    ??zclGeneral_HdlIncoming_1
   1197              }
   1198              else
   1199              {
   1200                // We don't support any manufacturer specific command.
   1201                stat = ZFailure;
   \                     ??zclGeneral_HdlIncoming_0:
   \   00001C   7901         MOV     R1,#0x1
   1202              }
   1203            }
   1204            else
   1205            {
   1206              // Handle all the normal (Read, Write...) commands -- should never get here
   1207              stat = ZFailure;
   1208            }
   1209            return ( stat );
   \                     ??zclGeneral_HdlIncoming_1:
   \   00001E   D083         POP     DPH
   \   000020   D082         POP     DPL
   \   000022   02....       LJMP    ?BRET
   1210          }
   1211          
   1212          /*********************************************************************
   1213           * @fn      zclGeneral_HdlInSpecificCommands
   1214           *
   1215           * @brief   Callback from ZCL to process incoming Commands specific
   1216           *          to this cluster library
   1217          
   1218           * @param   pInMsg - pointer to the incoming message
   1219           *
   1220           * @return  ZStatus_t
   1221           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1222          static ZStatus_t zclGeneral_HdlInSpecificCommands( zclIncoming_t *pInMsg )
   \                     zclGeneral_HdlInSpecificCommands:
   1223          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   1224            ZStatus_t stat;
   1225            zclGeneral_AppCallbacks_t *pCBs;
   1226          
   1227            // make sure endpoint exists
   1228            pCBs = zclGeneral_FindCallbacks( pInMsg->msg->endPoint );
   \   000005   8A82         MOV     DPL,R2
   \   000007   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_10:
   \   00000A   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_12:
   \   00000D   FC           MOV     R4,A
   \   00000E   90....       MOV     DPTR,#zclGenCBs
   \                     ??zclGeneral_HdlInSpecificCommands_0:
   \   000011   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_14:
   \   000014   7001         JNZ     ??zclGeneral_HdlInSpecificCommands_1
   \   000016   E9           MOV     A,R1
   \                     ??zclGeneral_HdlInSpecificCommands_1:
   \   000017   6065         JZ      ??zclGeneral_HdlInSpecificCommands_2
   \   000019   8882         MOV     DPL,R0
   \   00001B   8983         MOV     DPH,R1
   \   00001D   A3           INC     DPTR
   \   00001E   A3           INC     DPTR
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   6C           XRL     A,R4
   \   000021   8882         MOV     DPL,R0
   \   000023   8983         MOV     DPH,R1
   \   000025   70EA         JNZ     ??zclGeneral_HdlInSpecificCommands_0
   \   000027   A3           INC     DPTR
   \   000028   A3           INC     DPTR
   \   000029   A3           INC     DPTR
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   FC           MOV     R4,A
   \   00002C   A3           INC     DPTR
   \   00002D   E0           MOVX    A,@DPTR
   \   00002E   FD           MOV     R5,A
   1229            if ( pCBs == NULL )
   \   00002F   EC           MOV     A,R4
   \   000030   7001         JNZ     ??zclGeneral_HdlInSpecificCommands_3
   \   000032   ED           MOV     A,R5
   \                     ??zclGeneral_HdlInSpecificCommands_3:
   \   000033   6049         JZ      ??zclGeneral_HdlInSpecificCommands_2
   1230              return ( ZFailure );
   1231          
   1232            switch ( pInMsg->msg->clusterId )
   \   000035   8E82         MOV     DPL,R6
   \   000037   8F83         MOV     DPH,R7
   \   000039   A3           INC     DPTR
   \   00003A   A3           INC     DPTR
   \   00003B   A3           INC     DPTR
   \   00003C   A3           INC     DPTR
   \   00003D   E0           MOVX    A,@DPTR
   \   00003E   F5..         MOV     ?V0 + 0,A
   \   000040   A3           INC     DPTR
   \   000041   E0           MOVX    A,@DPTR
   \   000042   707A         JNZ     ??zclGeneral_HdlInSpecificCommands_4
   \   000044   E5..         MOV     A,?V0 + 0
   \   000046   12....       LCALL   ?UC_SWITCH_SPARSE
   \                     `?<Jumptable for zclGeneral_HdlInSpecificComman_0`:
   \   000049   00           DB        0
   \   00004A   03           DB        3
   \   00004B   00           DB        0
   \   00004C   ....         DW        ??zclGeneral_HdlInSpecificCommands_5
   \   00004E   03           DB        3
   \   00004F   ....         DW        ??zclGeneral_HdlInSpecificCommands_6
   \   000051   06           DB        6
   \   000052   ....         DW        ??zclGeneral_HdlInSpecificCommands_7
   \   000054   ....         DW        ??zclGeneral_HdlInSpecificCommands_4
   1233            {
   1234          #ifdef ZCL_BASIC
   1235              case ZCL_CLUSTER_ID_GEN_BASIC:
   1236                stat = zclGeneral_ProcessInBasic( pInMsg, pCBs );
   \                     ??zclGeneral_HdlInSpecificCommands_5:
   \   000056   8A82         MOV     DPL,R2
   \   000058   8B83         MOV     DPH,R3
   \   00005A   A3           INC     DPTR
   \   00005B   A3           INC     DPTR
   \   00005C   E0           MOVX    A,@DPTR
   \   00005D   5408         ANL     A,#0x8
   \   00005F   7059         JNZ     ??zclGeneral_HdlInSpecificCommands_8
   \   000061   8A82         MOV     DPL,R2
   \   000063   8B83         MOV     DPH,R3
   \   000065   A3           INC     DPTR
   \   000066   A3           INC     DPTR
   \   000067   A3           INC     DPTR
   \   000068   A3           INC     DPTR
   \   000069   A3           INC     DPTR
   \   00006A   A3           INC     DPTR
   \   00006B   A3           INC     DPTR
   \   00006C   E0           MOVX    A,@DPTR
   \   00006D   704F         JNZ     ??zclGeneral_HdlInSpecificCommands_4
   \   00006F   8C82         MOV     DPL,R4
   \   000071   8D83         MOV     DPH,R5
   \   000073   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   000076   7002         JNZ     ??zclGeneral_HdlInSpecificCommands_9
   \   000078   E583         MOV     A,DPH
   \                     ??zclGeneral_HdlInSpecificCommands_9:
   \   00007A   603E         JZ      ??zclGeneral_HdlInSpecificCommands_8
   \   00007C                ; Setup parameters for indirect call
   \   00007C   8039         SJMP    ??zclGeneral_HdlInSpecificCommands_10
   \                     ??zclGeneral_HdlInSpecificCommands_2:
   \   00007E   803E         SJMP    ??zclGeneral_HdlInSpecificCommands_4
   1237                break;
   1238          #endif // ZCL_BASIC
   1239          
   1240          #ifdef ZCL_IDENTIFY
   1241              case ZCL_CLUSTER_ID_GEN_IDENTIFY:
   1242                stat = zclGeneral_ProcessInIdentity( pInMsg, pCBs );
   \                     ??zclGeneral_HdlInSpecificCommands_6:
   \   000080                ; Setup parameters for call to function zclGeneral_ProcessInIdentity
   \   000080   12....       LCALL   ??zclGeneral_ProcessInIdentity?relay
   \   000083   803B         SJMP    ??zclGeneral_HdlInSpecificCommands_11
   1243                break;
   1244          #endif // ZCL_IDENTIFY
   1245          
   1246          #ifdef ZCL_GROUPS
   1247              case ZCL_CLUSTER_ID_GEN_GROUPS:
   1248                if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   1249                  stat = zclGeneral_ProcessInGroupsServer( pInMsg );
   1250                else
   1251                  stat = zclGeneral_ProcessInGroupsClient( pInMsg, pCBs );
   1252                break;
   1253          #endif // ZCL_GROUPS
   1254          
   1255          #ifdef ZCL_SCENES
   1256              case ZCL_CLUSTER_ID_GEN_SCENES:
   1257                if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   1258                  stat = zclGeneral_ProcessInScenesServer( pInMsg, pCBs );
   1259                else
   1260                  stat = zclGeneral_ProcessInScenesClient( pInMsg, pCBs );
   1261                break;
   1262          #endif // ZCL_SCENES
   1263          
   1264          #ifdef ZCL_ON_OFF
   1265              case ZCL_CLUSTER_ID_GEN_ON_OFF:
   1266                stat = zclGeneral_ProcessInOnOff( pInMsg, pCBs );
   \                     ??zclGeneral_HdlInSpecificCommands_7:
   \   000085   8A82         MOV     DPL,R2
   \   000087   8B83         MOV     DPH,R3
   \   000089   A3           INC     DPTR
   \   00008A   A3           INC     DPTR
   \   00008B   E0           MOVX    A,@DPTR
   \   00008C   5408         ANL     A,#0x8
   \   00008E   702A         JNZ     ??zclGeneral_HdlInSpecificCommands_8
   \   000090   8A82         MOV     DPL,R2
   \   000092   8B83         MOV     DPH,R3
   \   000094   A3           INC     DPTR
   \   000095   A3           INC     DPTR
   \   000096   A3           INC     DPTR
   \   000097   A3           INC     DPTR
   \   000098   A3           INC     DPTR
   \   000099   A3           INC     DPTR
   \   00009A   A3           INC     DPTR
   \   00009B   E0           MOVX    A,@DPTR
   \   00009C   FA           MOV     R2,A
   \   00009D   C3           CLR     C
   \   00009E   9403         SUBB    A,#0x3
   \   0000A0   501C         JNC     ??zclGeneral_HdlInSpecificCommands_4
   \   0000A2   8C82         MOV     DPL,R4
   \   0000A4   8D83         MOV     DPH,R5
   \   0000A6   A3           INC     DPTR
   \   0000A7   A3           INC     DPTR
   \   0000A8   A3           INC     DPTR
   \   0000A9   A3           INC     DPTR
   \   0000AA   A3           INC     DPTR
   \   0000AB   A3           INC     DPTR
   \   0000AC   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   0000AF   7002         JNZ     ??zclGeneral_HdlInSpecificCommands_12
   \   0000B1   E583         MOV     A,DPH
   \                     ??zclGeneral_HdlInSpecificCommands_12:
   \   0000B3   6005         JZ      ??zclGeneral_HdlInSpecificCommands_8
   \   0000B5                ; Setup parameters for indirect call
   \   0000B5   EA           MOV     A,R2
   \   0000B6   F9           MOV     R1,A
   \                     ??zclGeneral_HdlInSpecificCommands_10:
   \   0000B7   12....       LCALL   ?CALL_IND
   \                     ??zclGeneral_HdlInSpecificCommands_8:
   \   0000BA   7900         MOV     R1,#0x0
   \   0000BC   8002         SJMP    ??zclGeneral_HdlInSpecificCommands_11
   1267                break;
   1268          #endif // ZCL_ON_OFF
   1269          
   1270          #ifdef ZCL_LEVEL_CTRL
   1271              case ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL:
   1272                stat = zclGeneral_ProcessInLevelControl( pInMsg, pCBs );
   1273                break;
   1274          #endif // ZCL_LEVEL_CTRL
   1275          
   1276          #ifdef ZCL_ALARMS
   1277              case ZCL_CLUSTER_ID_GEN_ALARMS:
   1278                if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   1279                  stat = zclGeneral_ProcessInAlarmsServer( pInMsg, pCBs );
   1280                else
   1281                  stat = zclGeneral_ProcessInAlarmsClient( pInMsg, pCBs );
   1282                break;
   1283          #endif // ZCL_ALARMS
   1284          
   1285          #ifdef ZCL_LOCATION
   1286              case ZCL_CLUSTER_ID_GEN_LOCATION:
   1287                if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   1288                  stat = zclGeneral_ProcessInLocationServer( pInMsg, pCBs );
   1289                else
   1290                  stat = zclGeneral_ProcessInLocationClient( pInMsg, pCBs );
   1291                break;
   1292          #endif // ZCL_LOCATION
   1293          
   1294              case ZCL_CLUSTER_ID_GEN_POWER_CFG:
   1295              case ZCL_CLUSTER_ID_GEN_DEVICE_TEMP_CONFIG:
   1296              case ZCL_CLUSTER_ID_GEN_ON_OFF_SWITCH_CONFIG:
   1297              case ZCL_CLUSTER_ID_GEN_TIME:
   1298              default:
   1299                stat = ZFailure;
   \                     ??zclGeneral_HdlInSpecificCommands_4:
   \   0000BE   7901         MOV     R1,#0x1
   1300                break;
   1301            }
   1302          
   1303            return ( stat );
   \                     ??zclGeneral_HdlInSpecificCommands_11:
   \   0000C0   02....       LJMP    ??Subroutine11_0 & 0xFFFF
   1304          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_18:
   \   000003   E582         MOV     A,DPL
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   8882         MOV     DPL,R0
   \   000007   8983         MOV     DPH,R1
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   8B83         MOV     DPH,R3
   \   000002   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_16:
   \   000005   FE           MOV     R6,A
   \   000006   E9           MOV     A,R1
   \   000007   FF           MOV     R7,A
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   E8           MOV     A,R0
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   EE           MOV     A,R6
   \   000001   2414         ADD     A,#0x14
   \   000003   F582         MOV     DPL,A
   \   000005   EF           MOV     A,R7
   \   000006   3400         ADDC    A,#0x0
   \   000008   F583         MOV     DPH,A
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   22           RET
   1305          
   1306          #ifdef ZCL_BASIC
   1307          /*********************************************************************
   1308           * @fn      zclGeneral_ProcessInBasic
   1309           *
   1310           * @brief   Process in the received Basic Command.
   1311           *
   1312           * @param   pInMsg - pointer to the incoming message
   1313           *
   1314           * @return  ZStatus_t
   1315           */
   1316          static ZStatus_t zclGeneral_ProcessInBasic( zclIncoming_t *pInMsg,
   1317                                                      zclGeneral_AppCallbacks_t *pCBs )
   1318          {
   1319            if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   1320            {
   1321              if ( pInMsg->hdr.commandID > COMMAND_BASIC_RESET_FACT_DEFAULT )
   1322                return ( ZFailure );   // Error ignore the command
   1323          
   1324              if ( pCBs->pfnBasicReset )
   1325                pCBs->pfnBasicReset();
   1326            }
   1327            // no Client command
   1328          
   1329            return ( ZSuccess );
   1330          }
   1331          #endif // ZCL_BASIC
   1332          
   1333          #ifdef ZCL_IDENTIFY
   1334          /*********************************************************************
   1335           * @fn      zclGeneral_ProcessInIdentity
   1336           *
   1337           * @brief   Process in the received Identity Command.
   1338           *
   1339           * @param   pInMsg - pointer to the incoming message
   1340           *
   1341           * @return  ZStatus_t
   1342           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1343          static ZStatus_t zclGeneral_ProcessInIdentity( zclIncoming_t *pInMsg,
   \                     zclGeneral_ProcessInIdentity:
   1344                                                         zclGeneral_AppCallbacks_t *pCBs )
   1345          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 14
   \   000005   74F2         MOV     A,#-0xe
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 0,R2
   \   00000C   8B..         MOV     ?V0 + 1,R3
   1346            if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   \   00000E   8A82         MOV     DPL,R2
   \   000010   8B83         MOV     DPH,R3
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   A3           INC     DPTR
   \   000015   A3           INC     DPTR
   \   000016   A3           INC     DPTR
   \   000017   A3           INC     DPTR
   \   000018   A3           INC     DPTR
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   FA           MOV     R2,A
   \   00001B   85..82       MOV     DPL,?V0 + 0
   \   00001E   8B83         MOV     DPH,R3
   \   000020   A3           INC     DPTR
   \   000021   A3           INC     DPTR
   \   000022   E0           MOVX    A,@DPTR
   \   000023   5408         ANL     A,#0x8
   \   000025   6003         JZ      $+5
   \   000027   02....       LJMP    ??zclGeneral_ProcessInIdentity_0 & 0xFFFF
   1347            {
   1348              if ( pInMsg->hdr.commandID > COMMAND_IDENTIFY_QUERY )
   \   00002A   EA           MOV     A,R2
   \   00002B   C3           CLR     C
   \   00002C   9402         SUBB    A,#0x2
   \   00002E   4005         JC      ??zclGeneral_ProcessInIdentity_1
   1349                return ( ZFailure );   // Error ignore the command
   \                     ??zclGeneral_ProcessInIdentity_2:
   \   000030   7901         MOV     R1,#0x1
   \   000032   02....       LJMP    ??zclGeneral_ProcessInIdentity_3 & 0xFFFF
   1350          
   1351              if ( pInMsg->hdr.commandID == COMMAND_IDENTIFY )
   \                     ??zclGeneral_ProcessInIdentity_1:
   \   000035   EA           MOV     A,R2
   \   000036   700D         JNZ     ??zclGeneral_ProcessInIdentity_4
   1352              {
   1353                if ( pCBs->pfnIdentify )
   \   000038   8C82         MOV     DPL,R4
   \   00003A   8D83         MOV     DPH,R5
   \   00003C   12....       LCALL   ?Subroutine4 & 0xFFFF
   1354                {
   1355                  zclIdentify_t cmd;
   1356          
   1357                  cmd.srcAddr = &(pInMsg->msg->srcAddr);
   1358                  cmd.identifyTime = BUILD_UINT16( pInMsg->pData[0], pInMsg->pData[1] );
   1359          
   1360                  pCBs->pfnIdentify( &cmd );
   1361                }
   1362              }
   \                     ??CrossCallReturnLabel_8:
   \   00003F   7001         JNZ     ??zclGeneral_ProcessInIdentity_5
   \   000041   ED           MOV     A,R5
   \                     ??zclGeneral_ProcessInIdentity_5:
   \   000042   02....       LJMP    ??zclGeneral_ProcessInIdentity_6 & 0xFFFF
   1363              else
   1364              {
   1365                zclAttrRec_t attrRec;
   1366                uint16 identifyTime = 0;
   \                     ??zclGeneral_ProcessInIdentity_4:
   \   000045   7404         MOV     A,#0x4
   \   000047   12....       LCALL   ?XSTACK_DISP0_8
   \   00004A   E4           CLR     A
   \   00004B   F0           MOVX    @DPTR,A
   \   00004C   A3           INC     DPTR
   \   00004D   F0           MOVX    @DPTR,A
   1367          
   1368                // Retrieve Identify Time
   1369                if ( zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, ATTRID_IDENTIFY_TIME, &attrRec ) )
   \   00004E   85..82       MOV     DPL,?V0 + 0
   \   000051   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_11:
   \   000054                ; Setup parameters for call to function zclFindAttrRec
   \   000054   7406         MOV     A,#0x6
   \   000056   12....       LCALL   ?XSTACK_DISP0_8
   \   000059   8582..       MOV     ?V0 + 2,DPL
   \   00005C   8583..       MOV     ?V0 + 3,DPH
   \   00005F   78..         MOV     R0,#?V0 + 2
   \   000061   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000064   7C00         MOV     R4,#0x0
   \   000066   7D00         MOV     R5,#0x0
   \   000068   8E82         MOV     DPL,R6
   \   00006A   8F83         MOV     DPH,R7
   \   00006C   A3           INC     DPTR
   \   00006D   A3           INC     DPTR
   \   00006E   A3           INC     DPTR
   \   00006F   A3           INC     DPTR
   \   000070   E0           MOVX    A,@DPTR
   \   000071   FA           MOV     R2,A
   \   000072   A3           INC     DPTR
   \   000073   E0           MOVX    A,@DPTR
   \   000074   12....       LCALL   ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_6:
   \   000077   12....       LCALL   ??zclFindAttrRec?relay
   \   00007A   7402         MOV     A,#0x2
   \   00007C   12....       LCALL   ?DEALLOC_XSTACK8
   \   00007F   E9           MOV     A,R1
   \   000080   6015         JZ      ??zclGeneral_ProcessInIdentity_7
   1370                  zclReadAttrData( (uint8 *)&identifyTime, &attrRec );
   \   000082                ; Setup parameters for call to function zclReadAttrData
   \   000082   7406         MOV     A,#0x6
   \   000084   12....       LCALL   ?XSTACK_DISP0_8
   \   000087   AC82         MOV     R4,DPL
   \   000089   AD83         MOV     R5,DPH
   \   00008B   7404         MOV     A,#0x4
   \   00008D   12....       LCALL   ?XSTACK_DISP0_8
   \   000090   AA82         MOV     R2,DPL
   \   000092   AB83         MOV     R3,DPH
   \   000094   12....       LCALL   ??zclReadAttrData?relay
   1371          
   1372                // Is device identifying itself?
   1373                if ( identifyTime > 0 )
   \                     ??zclGeneral_ProcessInIdentity_7:
   \   000097   7404         MOV     A,#0x4
   \   000099   12....       LCALL   ?XSTACK_DISP0_8
   \   00009C   E0           MOVX    A,@DPTR
   \   00009D   7002         JNZ     ??zclGeneral_ProcessInIdentity_8
   \   00009F   A3           INC     DPTR
   \   0000A0   E0           MOVX    A,@DPTR
   \                     ??zclGeneral_ProcessInIdentity_8:
   \   0000A1   6043         JZ      ??zclGeneral_ProcessInIdentity_9
   1374                {
   1375                  zclGeneral_SendIdentifyQueryResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   1376                                                        identifyTime, true, pInMsg->hdr.transSeqNum );
   \   0000A3   85..82       MOV     DPL,?V0 + 0
   \   0000A6   85..83       MOV     DPH,?V0 + 1
   \   0000A9   E0           MOVX    A,@DPTR
   \   0000AA   FE           MOV     R6,A
   \   0000AB   A3           INC     DPTR
   \   0000AC   E0           MOVX    A,@DPTR
   \   0000AD   FF           MOV     R7,A
   \   0000AE                ; Setup parameters for call to function zclGeneral_SendIdentifyQueryResponse
   \   0000AE   85..82       MOV     DPL,?V0 + 0
   \   0000B1   85..83       MOV     DPH,?V0 + 1
   \   0000B4   A3           INC     DPTR
   \   0000B5   A3           INC     DPTR
   \   0000B6   A3           INC     DPTR
   \   0000B7   A3           INC     DPTR
   \   0000B8   A3           INC     DPTR
   \   0000B9   A3           INC     DPTR
   \   0000BA   E0           MOVX    A,@DPTR
   \   0000BB   F5..         MOV     ?V0 + 0,A
   \   0000BD   78..         MOV     R0,#?V0 + 0
   \   0000BF   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000C2   75..01       MOV     ?V0 + 0,#0x1
   \   0000C5   78..         MOV     R0,#?V0 + 0
   \   0000C7   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000CA   7406         MOV     A,#0x6
   \   0000CC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CF   E0           MOVX    A,@DPTR
   \   0000D0   FC           MOV     R4,A
   \   0000D1   A3           INC     DPTR
   \   0000D2   E0           MOVX    A,@DPTR
   \   0000D3   FD           MOV     R5,A
   \   0000D4   EE           MOV     A,R6
   \   0000D5   2406         ADD     A,#0x6
   \   0000D7   FA           MOV     R2,A
   \   0000D8   EF           MOV     A,R7
   \   0000D9   3400         ADDC    A,#0x0
   \   0000DB   12....       LCALL   ?Subroutine3 & 0xFFFF
   1377                }
   \                     ??CrossCallReturnLabel_7:
   \   0000DE   12....       LCALL   ??zclGeneral_SendIdentifyQueryResponse?relay
   \   0000E1   7402         MOV     A,#0x2
   \   0000E3   12....       LCALL   ?DEALLOC_XSTACK8
   1378          
   1379                return ( ZCL_STATUS_CMD_HAS_RSP );
   \                     ??zclGeneral_ProcessInIdentity_9:
   \   0000E6   79FF         MOV     R1,#-0x1
   \   0000E8   8061         SJMP    ??zclGeneral_ProcessInIdentity_3
   1380              }
   1381            }
   1382            else // Client Command
   1383            {
   1384              if ( pInMsg->hdr.commandID > COMMAND_IDENTIFY_QUERY_RSP )
   \                     ??zclGeneral_ProcessInIdentity_0:
   \   0000EA   EA           MOV     A,R2
   \   0000EB   6003         JZ      $+5
   \   0000ED   02....       LJMP    ??zclGeneral_ProcessInIdentity_2 & 0xFFFF
   1385                return ( ZFailure );   // Error ignore the command
   1386          
   1387              if ( pCBs->pfnIdentifyQueryRsp )
   \   0000F0   8C82         MOV     DPL,R4
   \   0000F2   8D83         MOV     DPH,R5
   \   0000F4   A3           INC     DPTR
   \   0000F5   A3           INC     DPTR
   \   0000F6   12....       LCALL   ?Subroutine4 & 0xFFFF
   \                     ??CrossCallReturnLabel_9:
   \   0000F9   7001         JNZ     ??zclGeneral_ProcessInIdentity_6
   \   0000FB   ED           MOV     A,R5
   \                     ??zclGeneral_ProcessInIdentity_6:
   \   0000FC   604B         JZ      ??zclGeneral_ProcessInIdentity_10
   1388              {
   1389                zclIdentifyQueryRsp_t rsp;
   1390          
   1391                rsp.srcAddr = &(pInMsg->msg->srcAddr);
   \   0000FE   85..82       MOV     DPL,?V0 + 0
   \   000101   8B83         MOV     DPH,R3
   \   000103   E0           MOVX    A,@DPTR
   \   000104   2406         ADD     A,#0x6
   \   000106   F8           MOV     R0,A
   \   000107   A3           INC     DPTR
   \   000108   E0           MOVX    A,@DPTR
   \   000109   3400         ADDC    A,#0x0
   \   00010B   F9           MOV     R1,A
   \   00010C   85..82       MOV     DPL,?XSP + 0
   \   00010F   85..83       MOV     DPH,?XSP + 1
   \   000112   E8           MOV     A,R0
   \   000113   F0           MOVX    @DPTR,A
   \   000114   A3           INC     DPTR
   \   000115   E9           MOV     A,R1
   \   000116   F0           MOVX    @DPTR,A
   1392                rsp.timeout = BUILD_UINT16( pInMsg->pData[0], pInMsg->pData[1] );
   \   000117   85..82       MOV     DPL,?V0 + 0
   \   00011A   8B83         MOV     DPH,R3
   \   00011C   A3           INC     DPTR
   \   00011D   A3           INC     DPTR
   \   00011E   A3           INC     DPTR
   \   00011F   A3           INC     DPTR
   \   000120   A3           INC     DPTR
   \   000121   A3           INC     DPTR
   \   000122   A3           INC     DPTR
   \   000123   A3           INC     DPTR
   \   000124   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_17:
   \   000127   E0           MOVX    A,@DPTR
   \   000128   FA           MOV     R2,A
   \   000129   A3           INC     DPTR
   \   00012A   E0           MOVX    A,@DPTR
   \   00012B   F9           MOV     R1,A
   \   00012C   EA           MOV     A,R2
   \   00012D   F8           MOV     R0,A
   \   00012E   7402         MOV     A,#0x2
   \   000130   12....       LCALL   ?XSTACK_DISP0_8
   \   000133   E8           MOV     A,R0
   \   000134   F0           MOVX    @DPTR,A
   \   000135   A3           INC     DPTR
   \   000136   E9           MOV     A,R1
   \   000137   F0           MOVX    @DPTR,A
   1393          
   1394                pCBs->pfnIdentifyQueryRsp( &rsp );
   \   000138                ; Setup parameters for indirect call
   \   000138   85..82       MOV     DPL,?XSP + 0
   \   00013B   85..83       MOV     DPH,?XSP + 1
   \   00013E   AA82         MOV     R2,DPL
   \   000140   AB83         MOV     R3,DPH
   \   000142   8C82         MOV     DPL,R4
   \   000144   8D83         MOV     DPH,R5
   \   000146   12....       LCALL   ?CALL_IND
   1395              }
   1396            }
   1397          
   1398            return ( ZSuccess );
   \                     ??zclGeneral_ProcessInIdentity_10:
   \   000149   7900         MOV     R1,#0x0
   \                     ??zclGeneral_ProcessInIdentity_3:
   \   00014B   740E         MOV     A,#0xe
   \   00014D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000150   02....       LJMP    ?Subroutine9 & 0xFFFF
   1399          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_15:
   \   000005   FC           MOV     R4,A
   \   000006   E9           MOV     A,R1
   \   000007   FD           MOV     R5,A
   \   000008   EC           MOV     A,R4
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   FB           MOV     R3,A
   \   000001   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_13:
   \   000004   F9           MOV     R1,A
   \   000005   22           RET

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclGeneral_RegisterCmdCallbacks?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGeneral_RegisterCmdCallbacks

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclGeneral_SendIdentify?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGeneral_SendIdentify

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclGeneral_SendIdentifyQueryResponse?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGeneral_SendIdentifyQueryResponse

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclGeneral_HdlIncoming?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGeneral_HdlIncoming

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclGeneral_HdlInSpecificCommands?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGeneral_HdlInSpecificCommands

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclGeneral_ProcessInIdentity?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGeneral_ProcessInIdentity
   1400          #endif // ZCL_IDENTIFY
   1401          
   1402          #ifdef ZCL_GROUPS
   1403          
   1404          /*********************************************************************
   1405           * @fn      zclGeneral_AddGroup
   1406           *
   1407           * @brief   Add a Group.
   1408           *
   1409           * @param   endPoint - application endpoint
   1410           * @param   group - group to be added
   1411           * @param   pData - pointer to the group info
   1412           *
   1413           * @return  ZStatus_t
   1414           */
   1415          static ZStatus_t zclGeneral_AddGroup( uint8 endPoint, aps_Group_t *group, uint8 *pData )
   1416          {
   1417            zclAttrRec_t attrRec;
   1418            uint8 nameLen;
   1419            uint8 nameSupport = FALSE;
   1420          
   1421            pData += 2;   // Move past group ID
   1422            nameLen = *pData++;
   1423          
   1424            // Retrieve Name Support attribute
   1425            if ( zclFindAttrRec( endPoint, ZCL_CLUSTER_ID_GEN_GROUPS, ATTRID_GROUP_NAME_SUPPORT, &attrRec ) )
   1426               zclReadAttrData( &nameSupport, &attrRec );
   1427          
   1428            if ( nameSupport )
   1429            {
   1430              if ( nameLen > (APS_GROUP_NAME_LEN-1) )
   1431                 nameLen = (APS_GROUP_NAME_LEN-1);
   1432              group->name[0] = nameLen;
   1433              osal_memcpy( &(group->name[1]), pData, nameLen );
   1434            }
   1435          
   1436            return ( aps_AddGroup( endPoint, group ) );
   1437          }
   1438          
   1439          /*********************************************************************
   1440           * @fn      zclGeneral_ProcessInGroupsServer
   1441           *
   1442           * @brief   Process in the received Groups Command.
   1443           *
   1444           * @param   pInMsg - pointer to the incoming message
   1445           *
   1446           * @return  ZStatus_t
   1447           */
   1448          static ZStatus_t zclGeneral_ProcessInGroupsServer( zclIncoming_t *pInMsg )
   1449          {
   1450            zclAttrRec_t attrRec;
   1451            aps_Group_t group;
   1452            aps_Group_t *pGroup;
   1453            uint8 *pData;
   1454            uint8 status;
   1455            uint8 grpCnt;
   1456            uint8 grpRspCnt = 0;
   1457            uint16 *grpList;
   1458            uint16 identifyTime = 0;
   1459            uint8 i;
   1460            ZStatus_t stat = ZSuccess;
   1461          
   1462            osal_memset( (uint8*)&group, 0, sizeof( aps_Group_t ) );
   1463          
   1464            pData = pInMsg->pData;
   1465            group.ID = BUILD_UINT16( pData[0], pData[1] );
   1466            switch ( pInMsg->hdr.commandID )
   1467            {
   1468              case COMMAND_GROUP_ADD:
   1469                status = zclGeneral_AddGroup( pInMsg->msg->endPoint, &group, pData );
   1470                if ( status != ZSuccess )
   1471                {
   1472                  if ( status == ZApsDuplicateEntry )
   1473                    status = ZCL_STATUS_DUPLICATE_EXISTS;
   1474                  else
   1475                    status = ZCL_STATUS_INSUFFICIENT_SPACE;
   1476                }
   1477          
   1478                zclGeneral_SendGroupAddResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   1479                                                 status, group.ID, true, pInMsg->hdr.transSeqNum );
   1480                stat = ZCL_STATUS_CMD_HAS_RSP;
   1481                break;
   1482          
   1483              case COMMAND_GROUP_VIEW:
   1484                pGroup = aps_FindGroup( pInMsg->msg->endPoint, group.ID );
   1485                if ( pGroup )
   1486                {
   1487                  status = ZCL_STATUS_SUCCESS;
   1488                }
   1489                else
   1490                {
   1491                  // Group not found
   1492                  status = ZCL_STATUS_NOT_FOUND;
   1493                  pGroup = &group;
   1494                }
   1495                zclGeneral_SendGroupViewResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   1496                                                  status, pGroup, true, pInMsg->hdr.transSeqNum );
   1497                stat = ZCL_STATUS_CMD_HAS_RSP;
   1498                break;
   1499          
   1500              case COMMAND_GROUP_GET_MEMBERSHIP:
   1501                grpCnt = *pData++;
   1502                  
   1503                // Allocate space for the group list
   1504                grpList = osal_mem_alloc( sizeof( uint16 ) * APS_MAX_GROUPS );
   1505                if ( grpList != NULL )
   1506                {
   1507                  if ( grpCnt == 0 )
   1508                  {
   1509                    // Find out all the groups of which the endpoint is a member.
   1510                    grpRspCnt = aps_FindAllGroupsForEndpoint( pInMsg->msg->endPoint, grpList );
   1511                  }
   1512                  else
   1513                  {
   1514                    // Find out the groups (in the list) of which the endpoint is a member.
   1515                    for ( i = 0; i < grpCnt; i++ )
   1516                    {
   1517                      group.ID = BUILD_UINT16( pData[0], pData[1] );
   1518                      pData += 2;
   1519          
   1520                      if ( aps_FindGroup( pInMsg->msg->endPoint, group.ID ) )
   1521                        grpList[grpRspCnt++] = group.ID;
   1522                    }
   1523                  }
   1524                
   1525                  if ( grpCnt == 0 ||  grpRspCnt != 0 )
   1526                  {
   1527                    zclGeneral_SendGroupGetMembershipResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr, 
   1528                                                               aps_GroupsRemaingCapacity(), grpRspCnt, 
   1529                                                               grpList, true, pInMsg->hdr.transSeqNum );
   1530                  }
   1531          
   1532                  osal_mem_free( grpList );
   1533                }
   1534                else
   1535                {
   1536                  // Couldn't allocate space for the group list -- send a Default Response command back.
   1537                  zclDefaultRspCmd_t defaultRspCmd;
   1538                  
   1539                  defaultRspCmd.commandID = pInMsg->hdr.commandID;
   1540                  defaultRspCmd.statusCode = ZCL_STATUS_INSUFFICIENT_SPACE;
   1541                  zcl_SendDefaultRspCmd( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   1542                                         pInMsg->msg->clusterId, &defaultRspCmd,
   1543                                         ZCL_FRAME_SERVER_CLIENT_DIR, true, 0, pInMsg->hdr.transSeqNum );
   1544                }
   1545          
   1546                stat = ZCL_STATUS_CMD_HAS_RSP;
   1547                break;
   1548          
   1549              case COMMAND_GROUP_REMOVE:
   1550                if ( aps_RemoveGroup( pInMsg->msg->endPoint, group.ID ) )
   1551                  status = ZCL_STATUS_SUCCESS;
   1552                else
   1553                  status = ZCL_STATUS_NOT_FOUND;
   1554                zclGeneral_SendGroupRemoveResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   1555                                                    status, group.ID, true, pInMsg->hdr.transSeqNum );
   1556                stat = ZCL_STATUS_CMD_HAS_RSP;
   1557                break;
   1558          
   1559              case COMMAND_GROUP_REMOVE_ALL:
   1560                aps_RemoveAllGroup( pInMsg->msg->endPoint );
   1561                break;
   1562          
   1563              case COMMAND_GROUP_ADD_IF_IDENTIFYING:
   1564                // Retrieve Identify Time
   1565                if ( zclFindAttrRec( pInMsg->msg->endPoint, ZCL_CLUSTER_ID_GEN_IDENTIFY, ATTRID_IDENTIFY_TIME, &attrRec ) )
   1566                  zclReadAttrData( (uint8 *)&identifyTime, &attrRec );
   1567          
   1568                // Is device identifying itself?
   1569                if ( identifyTime > 0 )
   1570                  zclGeneral_AddGroup( pInMsg->msg->endPoint, &group, pData );
   1571                break;
   1572          
   1573              default:
   1574                stat = ZFailure;
   1575                break;
   1576            }
   1577          
   1578            return ( stat );
   1579          }
   1580          
   1581          /*********************************************************************
   1582           * @fn      zclGeneral_ProcessInGroupsClient
   1583           *
   1584           * @brief   Process in the received Groups Command.
   1585           *
   1586           * @param   pInMsg - pointer to the incoming message
   1587           *
   1588           * @return  ZStatus_t
   1589           */
   1590          static ZStatus_t zclGeneral_ProcessInGroupsClient( zclIncoming_t *pInMsg,
   1591                                                             zclGeneral_AppCallbacks_t *pCBs )
   1592          {
   1593            aps_Group_t group;
   1594            uint8 *pData = pInMsg->pData;
   1595            uint16 *grpList;
   1596            uint8 grpCnt;
   1597            uint8 nameLen;
   1598            zclGroupRsp_t rsp;
   1599            uint8 i;
   1600            ZStatus_t stat = ZSuccess;
   1601          
   1602            osal_memset( (uint8*)&group, 0, sizeof( aps_Group_t ) );
   1603            osal_memset( (uint8*)&rsp, 0, sizeof( zclGroupRsp_t ) );
   1604          
   1605            switch ( pInMsg->hdr.commandID )
   1606            {
   1607              case COMMAND_GROUP_ADD_RSP:
   1608              case COMMAND_GROUP_VIEW_RSP:
   1609              case COMMAND_GROUP_REMOVE_RSP:
   1610                rsp.status = *pData++;
   1611                group.ID = BUILD_UINT16( pData[0], pData[1] );
   1612          
   1613                if ( rsp.status == ZCL_STATUS_SUCCESS && pInMsg->hdr.commandID == COMMAND_GROUP_VIEW_RSP )
   1614                {
   1615                  pData += 2;   // Move past ID
   1616                  nameLen = *pData++;
   1617                  if ( nameLen > (APS_GROUP_NAME_LEN-1) )
   1618                    nameLen = (APS_GROUP_NAME_LEN-1);
   1619                  group.name[0] = nameLen;
   1620                  osal_memcpy( &(group.name[1]), pData, nameLen );
   1621                  rsp.grpName = group.name;
   1622                }
   1623          
   1624                if ( pCBs->pfnGroupRsp )
   1625                {
   1626                  rsp.srcAddr = &(pInMsg->msg->srcAddr);
   1627                  rsp.cmdID = pInMsg->hdr.commandID;
   1628                  rsp.grpCnt = 1;
   1629                  rsp.grpList = &group.ID;
   1630                  rsp.capacity = 0;
   1631          
   1632                  pCBs->pfnGroupRsp( &rsp );
   1633                }
   1634                break;
   1635          
   1636              case COMMAND_GROUP_GET_MEMBERSHIP_RSP:
   1637                rsp.capacity = *pData++;
   1638                grpCnt = *pData++;
   1639          
   1640                if ( grpCnt > 0 )
   1641                {
   1642                  // Allocate space for the group list
   1643                  grpList = osal_mem_alloc( sizeof( uint16 ) * grpCnt );
   1644                  if ( grpList != NULL )
   1645                  {
   1646                    rsp.grpCnt = grpCnt;
   1647                    for ( i = 0; i < grpCnt; i++ )
   1648                    {
   1649                      grpList[i] = BUILD_UINT16( pData[0], pData[1] );
   1650                      pData += 2;
   1651                    }
   1652                  }
   1653                }
   1654          
   1655                if ( pCBs->pfnGroupRsp )
   1656                {
   1657                  rsp.srcAddr = &(pInMsg->msg->srcAddr);
   1658                  rsp.cmdID = pInMsg->hdr.commandID;
   1659                  rsp.grpList = grpList;
   1660          
   1661                  pCBs->pfnGroupRsp( &rsp );
   1662                }
   1663                
   1664                if ( grpList != NULL )
   1665                  osal_mem_free( grpList );
   1666                break;
   1667          
   1668              default:
   1669                stat = ZFailure;
   1670                break;
   1671            }
   1672          
   1673            return ( stat );
   1674          }
   1675          #endif // ZCL_GROUPS
   1676          
   1677          #ifdef ZCL_SCENES
   1678          /*********************************************************************
   1679           * @fn      zclGeneral_AddScene
   1680           *
   1681           * @brief   Add a scene for an endpoint
   1682           *
   1683           * @param   endpoint -
   1684           * @param   scene - new scene item
   1685           *
   1686           * @return  ZStatus_t
   1687           */
   1688          ZStatus_t zclGeneral_AddScene( uint8 endpoint, zclGeneral_Scene_t *scene )
   1689          {
   1690            zclGenSceneItem_t *pNewItem;
   1691            zclGenSceneItem_t *pLoop;
   1692          
   1693            // Fill in the new profile list
   1694            pNewItem = osal_mem_alloc( sizeof( zclGenSceneItem_t ) );
   1695            if ( pNewItem == NULL )
   1696              return ( ZMemError );
   1697          
   1698            // Fill in the plugin record.
   1699            pNewItem->next = (zclGenSceneItem_t *)NULL;
   1700            pNewItem->endpoint = endpoint;
   1701            osal_memcpy( (uint8*)&(pNewItem->scene), (uint8*)scene, sizeof ( zclGeneral_Scene_t ));
   1702          
   1703            // Find spot in list
   1704            if (  zclGenSceneTable == NULL )
   1705            {
   1706              zclGenSceneTable = pNewItem;
   1707            }
   1708            else
   1709            {
   1710              // Look for end of list
   1711              pLoop = zclGenSceneTable;
   1712              while ( pLoop->next != NULL )
   1713                pLoop = pLoop->next;
   1714          
   1715              // Put new item at end of list
   1716              pLoop->next = pNewItem;
   1717            }
   1718          
   1719            // Update NV
   1720            zclGeneral_ScenesWriteNV();
   1721          
   1722            return ( ZSuccess );
   1723          }
   1724          
   1725          /*********************************************************************
   1726           * @fn      zclGeneral_FindScene
   1727           *
   1728           * @brief   Find a scene with endpoint and sceneID
   1729           *
   1730           * @param   endpoint -
   1731           * @param   groupID - what group the scene belongs to
   1732           * @param   sceneID - ID to look for scene
   1733           *
   1734           * @return  a pointer to the scene information, NULL if not found
   1735           */
   1736          zclGeneral_Scene_t *zclGeneral_FindScene( uint8 endpoint, uint16 groupID, uint8 sceneID )
   1737          {
   1738            zclGenSceneItem_t *pLoop;
   1739          
   1740            // Look for end of list
   1741            pLoop = zclGenSceneTable;
   1742            while ( pLoop )
   1743            {
   1744              if ( (pLoop->endpoint == endpoint || endpoint == 0xFF)
   1745                  && pLoop->scene.groupID == groupID && pLoop->scene.ID == sceneID )
   1746              {
   1747                return ( &(pLoop->scene) );
   1748              }
   1749              pLoop = pLoop->next;
   1750            }
   1751          
   1752            return ( (zclGeneral_Scene_t *)NULL );
   1753          }
   1754          
   1755          /*********************************************************************
   1756           * @fn      aps_FindAllScensForGroup
   1757           *
   1758           * @brief   Find all the scenes with groupID
   1759           *
   1760           * @param   endpoint - endpoint to look for
   1761           * @param   sceneList - List to hold scene IDs (should hold APS_MAX_SCENES entries)
   1762           *
   1763           * @return  number of scenes copied to sceneList
   1764           */
   1765          uint8 zclGeneral_FindAllScenesForGroup( uint8 endpoint, uint16 groupID, uint8 *sceneList )
   1766          {
   1767            zclGenSceneItem_t *pLoop;
   1768            uint8 cnt = 0;
   1769          
   1770            // Look for end of list
   1771            pLoop = zclGenSceneTable;
   1772            while ( pLoop )
   1773            {
   1774              if ( pLoop->endpoint == endpoint && pLoop->scene.groupID == groupID )
   1775                sceneList[cnt++] = pLoop->scene.ID;
   1776              pLoop = pLoop->next;
   1777            }
   1778            return ( cnt );
   1779          }
   1780          
   1781          /*********************************************************************
   1782           * @fn      zclGeneral_RemoveScene
   1783           *
   1784           * @brief   Remove a scene with endpoint and sceneID
   1785           *
   1786           * @param   endpoint -
   1787           * @param   groupID - what group the scene belongs to
   1788           * @param   sceneID - ID to look for scene
   1789           *
   1790           * @return  TRUE if removed, FALSE if not found
   1791           */
   1792          uint8 zclGeneral_RemoveScene( uint8 endpoint, uint16 groupID, uint8 sceneID )
   1793          {
   1794            zclGenSceneItem_t *pLoop;
   1795            zclGenSceneItem_t *pPrev;
   1796          
   1797            // Look for end of list
   1798            pLoop = zclGenSceneTable;
   1799            pPrev = NULL;
   1800            while ( pLoop )
   1801            {
   1802              if ( pLoop->endpoint == endpoint
   1803                  && pLoop->scene.groupID == groupID && pLoop->scene.ID == sceneID )
   1804              {
   1805                if ( pPrev == NULL )
   1806                  zclGenSceneTable = pLoop->next;
   1807                else
   1808                  pPrev->next = pLoop->next;
   1809          
   1810                // Free the memory
   1811                osal_mem_free( pLoop );
   1812          
   1813                // Update NV
   1814                zclGeneral_ScenesWriteNV();
   1815          
   1816                return ( TRUE );
   1817              }
   1818              pPrev = pLoop;
   1819              pLoop = pLoop->next;
   1820            }
   1821          
   1822            return ( FALSE );
   1823          }
   1824          
   1825          /*********************************************************************
   1826           * @fn      zclGeneral_RemoveAllScenes
   1827           *
   1828           * @brief   Remove all scenes with endpoint and group Id
   1829           *
   1830           * @param   endpoint -
   1831           * @param   groupID - ID to look for group
   1832           *
   1833           * @return  none
   1834           */
   1835          void zclGeneral_RemoveAllScenes( uint8 endpoint, uint16 groupID )
   1836          {
   1837            zclGenSceneItem_t *pLoop;
   1838            zclGenSceneItem_t *pPrev;
   1839            zclGenSceneItem_t *pNext;
   1840          
   1841            // Look for end of list
   1842            pLoop = zclGenSceneTable;
   1843            pPrev = NULL;
   1844            while ( pLoop )
   1845            {
   1846              if ( pLoop->endpoint == endpoint && pLoop->scene.groupID == groupID )
   1847              {
   1848                if ( pPrev == NULL )
   1849                  zclGenSceneTable = pLoop->next;
   1850                else
   1851                  pPrev->next = pLoop->next;
   1852                pNext = pLoop->next;
   1853          
   1854                // Free the memory
   1855                osal_mem_free( pLoop );
   1856                pLoop = pNext;
   1857              }
   1858              else
   1859              {
   1860                pPrev = pLoop;
   1861                pLoop = pLoop->next;
   1862              }
   1863            }
   1864          
   1865            // Update NV
   1866            zclGeneral_ScenesWriteNV();
   1867          }
   1868          
   1869          /*********************************************************************
   1870           * @fn      zclGeneral_CountScenes
   1871           *
   1872           * @brief   Count the number of scenes for an endpoint
   1873           *
   1874           * @param   endpoint -
   1875           *
   1876           * @return  number of scenes assigned to an endpoint
   1877           */
   1878          uint8 zclGeneral_CountScenes( uint8 endpoint )
   1879          {
   1880            zclGenSceneItem_t *pLoop;
   1881            uint8 cnt = 0;
   1882          
   1883            // Look for end of list
   1884            pLoop = zclGenSceneTable;
   1885            while ( pLoop )
   1886            {
   1887              if ( pLoop->endpoint == endpoint  )
   1888                cnt++;
   1889              pLoop = pLoop->next;
   1890            }
   1891            return ( cnt );
   1892          }
   1893          
   1894          /*********************************************************************
   1895           * @fn      zclGeneral_CountAllScenes
   1896           *
   1897           * @brief   Count the total number of scenes
   1898           *
   1899           * @param   none
   1900           *
   1901           * @return  number of scenes
   1902           */
   1903          uint8 zclGeneral_CountAllScenes( void )
   1904          {
   1905            zclGenSceneItem_t *pLoop;
   1906            uint8 cnt = 0;
   1907          
   1908            // Look for end of list
   1909            pLoop = zclGenSceneTable;
   1910            while ( pLoop )
   1911            {
   1912              cnt++;
   1913              pLoop = pLoop->next;
   1914            }
   1915            return ( cnt );
   1916          }
   1917          
   1918          /*********************************************************************
   1919           * @fn      zclGeneral_ProcessInScenesServer
   1920           *
   1921           * @brief   Process in the received Scenes Command.
   1922           *
   1923           * @param   pInMsg - pointer to the incoming message
   1924           *
   1925           * @return  ZStatus_t
   1926           */
   1927          static ZStatus_t zclGeneral_ProcessInScenesServer( zclIncoming_t *pInMsg,
   1928                                                             zclGeneral_AppCallbacks_t *pCBs )
   1929          {
   1930            zclAttrRec_t attrRec;
   1931            zclGeneral_Scene_t scene;
   1932            zclGeneral_Scene_t *pScene;
   1933            uint8 *pData = pInMsg->pData;
   1934            uint8 nameLen;
   1935            uint8 status;
   1936            uint8 sceneCnt = 0;
   1937            uint8 *sceneList = NULL;
   1938            uint8 sendRsp = FALSE;
   1939            uint8 nameSupport = FALSE;
   1940            ZStatus_t stat = ZSuccess;
   1941          
   1942            osal_memset( (uint8*)&scene, 0, sizeof( zclGeneral_Scene_t ) );
   1943          
   1944            scene.groupID = BUILD_UINT16( pData[0], pData[1] );
   1945            pData += 2;   // Move past group ID
   1946            scene.ID = *pData++;
   1947          
   1948            switch ( pInMsg->hdr.commandID )
   1949            {
   1950              case COMMAND_SCENE_ADD:
   1951                // Parse the rest of the incoming message
   1952                scene.transTime = BUILD_UINT16( pData[0], pData[1] );
   1953                pData += 2;
   1954                nameLen= *pData++; // Name length
   1955          
   1956                // Retrieve Name Support attribute
   1957                if ( zclFindAttrRec( pInMsg->msg->endPoint, ZCL_CLUSTER_ID_GEN_SCENES, ATTRID_SCENES_NAME_SUPPORT, &attrRec ) )
   1958                  zclReadAttrData( &nameSupport, &attrRec );
   1959          
   1960                if ( nameSupport )
   1961                {
   1962                  if ( nameLen > (ZCL_GEN_SCENE_NAME_LEN-1) )
   1963                    nameLen = (ZCL_GEN_SCENE_NAME_LEN-1);
   1964                  scene.name[0] = nameLen;
   1965                  osal_memcpy( &(scene.name[1]), pData, nameLen );
   1966                }
   1967          
   1968                pData += nameLen; // move pass name
   1969          
   1970                scene.extLen = pInMsg->pDataLen - ( (uint16)( pData - pInMsg->pData ) );
   1971                if ( scene.extLen > 0 )
   1972                {
   1973                  // Copy the extention field(s)
   1974                  if ( scene.extLen > ZCL_GEN_SCENE_EXT_LEN )
   1975                    scene.extLen = ZCL_GEN_SCENE_EXT_LEN;
   1976                  osal_memcpy( scene.extField, pData, scene.extLen );
   1977                }
   1978          
   1979                if ( scene.groupID == 0x0000 ||
   1980                     aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
   1981                {
   1982                  // Either the Scene doesn't belong to a Group (Group ID = 0x0000) or it
   1983                  // does and the corresponding Group exits
   1984                  pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
   1985                  if ( pScene || ( zclGeneral_CountAllScenes() < ZCL_GEN_MAX_SCENES ) )
   1986                  {
   1987                    status = ZCL_STATUS_SUCCESS;
   1988                    if ( pScene != NULL )
   1989                    {
   1990                      // The Scene already exists so update it
   1991                      pScene->transTime = scene.transTime;
   1992                      osal_memcpy( pScene->name, scene.name, ZCL_GEN_SCENE_NAME_LEN );
   1993          
   1994                      // Use the new extention field(s)
   1995                      osal_memcpy( pScene->extField, scene.extField, scene.extLen );
   1996                      pScene->extLen = scene.extLen;
   1997          
   1998                      // Update NV
   1999                      zclGeneral_ScenesWriteNV();
   2000                    }
   2001                    else
   2002                    {
   2003                      // The Scene doesn't exist so add it
   2004                      zclGeneral_AddScene( pInMsg->msg->endPoint, &scene );
   2005                    }
   2006                  }
   2007                  else
   2008                    status = ZCL_STATUS_INSUFFICIENT_SPACE; // The Scene Table is full
   2009                }
   2010                else
   2011                  status = ZCL_STATUS_INVALID_FIELD; // The Group is not in the Group Table
   2012          
   2013                zclGeneral_SendSceneAddResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2014                                                 status, scene.groupID, scene.ID,
   2015                                                 true, pInMsg->hdr.transSeqNum );
   2016                stat = ZCL_STATUS_CMD_HAS_RSP;
   2017                break;
   2018          
   2019              case COMMAND_SCENE_VIEW:
   2020                pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
   2021                if ( pScene != NULL )
   2022                {
   2023                  status = ZCL_STATUS_SUCCESS;
   2024                }
   2025                else
   2026                {
   2027                  // Scene not found
   2028                  if ( scene.groupID != 0x0000 &&
   2029                       aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) == NULL )
   2030                  {
   2031                    status = ZCL_STATUS_INVALID_FIELD; // The Group is not in the Group Table
   2032                  }
   2033                  else
   2034                    status = ZCL_STATUS_NOT_FOUND;
   2035                  pScene = &scene;
   2036                }
   2037                zclGeneral_SendSceneViewResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2038                                                  status, pScene, true, pInMsg->hdr.transSeqNum );
   2039                stat = ZCL_STATUS_CMD_HAS_RSP;
   2040                break;
   2041          
   2042              case COMMAND_SCENE_REMOVE:
   2043                if ( zclGeneral_RemoveScene( pInMsg->msg->endPoint, scene.groupID, scene.ID ) )
   2044                {
   2045                  status = ZCL_STATUS_SUCCESS;
   2046                }
   2047                else
   2048                {
   2049                  // Scene not found
   2050                  if ( aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) == NULL )
   2051                  {
   2052                    // The Group is not in the Group Table
   2053                    status = ZCL_STATUS_INVALID_FIELD;
   2054                  }
   2055                  else
   2056                    status = ZCL_STATUS_NOT_FOUND;
   2057                }
   2058          
   2059                if ( UNICAST_MSG( pInMsg->msg ) )
   2060                {
   2061                  // Addressed to this device (not to a group) - send a response back
   2062                  zclGeneral_SendSceneRemoveResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2063                                                      status, scene.groupID,
   2064                                                      scene.ID, true, pInMsg->hdr.transSeqNum );
   2065                }
   2066                stat = ZCL_STATUS_CMD_HAS_RSP;
   2067                break;
   2068          
   2069              case COMMAND_SCENE_REMOVE_ALL:
   2070                if ( scene.groupID == 0x0000 ||
   2071                     aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
   2072                {
   2073                  zclGeneral_RemoveAllScenes( pInMsg->msg->endPoint, scene.groupID );
   2074                  status = ZCL_STATUS_SUCCESS;
   2075                }
   2076                else
   2077                  status = ZCL_STATUS_INVALID_FIELD;
   2078          
   2079                if ( UNICAST_MSG( pInMsg->msg ) )
   2080                {
   2081                  // Addressed to this device (not to a group) - send a response back
   2082                  zclGeneral_SendSceneRemoveAllResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2083                                                         status, scene.groupID, true, pInMsg->hdr.transSeqNum );
   2084                }
   2085                stat = ZCL_STATUS_CMD_HAS_RSP;
   2086                break;
   2087          
   2088              case COMMAND_SCENE_STORE:
   2089                if ( scene.groupID == 0x0000 ||
   2090                     aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
   2091                {
   2092                  // Either the Scene doesn't belong to a Group (Group ID = 0x0000) or it
   2093                  // does and the corresponding Group exits
   2094                  pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
   2095                  if ( pScene || ( zclGeneral_CountAllScenes() < ZCL_GEN_MAX_SCENES ) )
   2096                  {
   2097                    uint8 sceneChanged = FALSE;
   2098          
   2099                    status = ZCL_STATUS_SUCCESS;
   2100                    if ( pScene == NULL )
   2101                    {
   2102                      // Haven't been added yet
   2103                      pScene = &scene;
   2104                    }
   2105          
   2106                    if ( pCBs->pfnSceneStoreReq )
   2107                    {
   2108                      zclSceneReq_t req;
   2109          
   2110                      req.srcAddr = &(pInMsg->msg->srcAddr);
   2111                      req.scene = pScene;
   2112          
   2113                      // Get the latest Scene info
   2114                      if ( pCBs->pfnSceneStoreReq( &req ) )
   2115                        sceneChanged = TRUE;
   2116                    }
   2117          
   2118                    if ( pScene == &scene )
   2119                    {
   2120                      // The Scene doesn't exist so add it
   2121                      zclGeneral_AddScene( pInMsg->msg->endPoint, &scene );
   2122                    }
   2123                    else if ( sceneChanged )
   2124                    {
   2125                      // The Scene already exists so update only NV
   2126                      zclGeneral_ScenesWriteNV();
   2127                    }
   2128                  }
   2129                  else
   2130                    status = ZCL_STATUS_INSUFFICIENT_SPACE; // The Scene Table is full
   2131                }
   2132                else
   2133                  status = ZCL_STATUS_INVALID_FIELD; // The Group is not in the Group Table
   2134          
   2135                if ( UNICAST_MSG( pInMsg->msg ) )
   2136                {
   2137                  // Addressed to this device (not to a group) - send a response back
   2138                  zclGeneral_SendSceneStoreResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2139                                                     status, scene.groupID, scene.ID,
   2140                                                     true, pInMsg->hdr.transSeqNum );
   2141                }
   2142                stat = ZCL_STATUS_CMD_HAS_RSP;
   2143                break;
   2144          
   2145              case COMMAND_SCENE_RECALL:
   2146                pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
   2147                if ( pScene && pCBs->pfnSceneRecallReq )
   2148                {
   2149                  zclSceneReq_t req;
   2150          
   2151                  req.srcAddr = &(pInMsg->msg->srcAddr);
   2152                  req.scene = pScene;
   2153          
   2154                  pCBs->pfnSceneRecallReq( &req );
   2155                }
   2156                // No response
   2157                break;
   2158          
   2159              case COMMAND_SCENE_GET_MEMBERSHIP:
   2160                // Find all the Scenes corresponding to the Group ID
   2161                if ( scene.groupID == 0x0000 ||
   2162                     aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
   2163                {
   2164                  // Allocate space for the scene list
   2165                  sceneList = osal_mem_alloc( ZCL_GEN_MAX_SCENES );
   2166                  if ( sceneList != NULL )
   2167                  {
   2168                    sceneCnt = zclGeneral_FindAllScenesForGroup( pInMsg->msg->endPoint, 
   2169                                                                 scene.groupID, sceneList ); 
   2170                    status = ZCL_STATUS_SUCCESS;
   2171                    if ( UNICAST_MSG( pInMsg->msg ) )
   2172                    {
   2173                      // Addressed only to this device - send a response back
   2174                      sendRsp = TRUE;
   2175                    }
   2176                    else
   2177                    {
   2178                      // Addressed to the Group - ONLY send a response if an entry within the 
   2179                      // Scene Table corresponds to the Group ID
   2180                      if ( sceneCnt != 0 )
   2181                        sendRsp = TRUE;
   2182                    }
   2183                  }
   2184                  else
   2185                  {
   2186                    // Couldn't allocate space for the scene list!
   2187                    status = ZCL_STATUS_INSUFFICIENT_SPACE;
   2188                    sendRsp = TRUE;
   2189                  }
   2190                }
   2191                else
   2192                {
   2193                  // The Group is not in the Group Table - send a response back
   2194                  status = ZCL_STATUS_INVALID_FIELD;
   2195                  sendRsp = TRUE;
   2196                }
   2197          
   2198                if ( sendRsp )
   2199                {
   2200                  zclGeneral_SendSceneGetMembershipResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2201                                              status, zclGeneral_ScenesRemaingCapacity(), sceneCnt, sceneList,
   2202                                              scene.groupID, true, pInMsg->hdr.transSeqNum );
   2203                }
   2204                
   2205                if ( sceneList != NULL )
   2206                  osal_mem_free( sceneList );
   2207                
   2208                stat = ZCL_STATUS_CMD_HAS_RSP;
   2209                break;
   2210          
   2211              default:
   2212                stat = ZFailure;
   2213              break;
   2214            }
   2215          
   2216            return ( stat );
   2217          }
   2218          
   2219          /*********************************************************************
   2220           * @fn      zclGeneral_ProcessInScenesClient
   2221           *
   2222           * @brief   Process in the received Scenes Command.
   2223           *
   2224           * @param   pInMsg - pointer to the incoming message
   2225           *
   2226           * @return  ZStatus_t
   2227           */
   2228          static ZStatus_t zclGeneral_ProcessInScenesClient( zclIncoming_t *pInMsg,
   2229                                                             zclGeneral_AppCallbacks_t *pCBs )
   2230          {
   2231            zclGeneral_Scene_t scene;
   2232            uint8 *pData = pInMsg->pData;
   2233            uint8 nameLen;
   2234            uint8 *sceneList = NULL;
   2235            zclSceneRsp_t rsp;
   2236            uint8 i;
   2237            ZStatus_t stat = ZSuccess;
   2238          
   2239            osal_memset( (uint8*)&scene, 0, sizeof( zclGeneral_Scene_t ) );
   2240            osal_memset( (uint8*)&rsp, 0, sizeof( zclSceneRsp_t ) );
   2241          
   2242            // Get the status field first
   2243            rsp.status = *pData++;
   2244          
   2245            if ( pInMsg->hdr.commandID == COMMAND_SCENE_GET_MEMBERSHIP_RSP )
   2246              rsp.capacity = *pData++;
   2247          
   2248            scene.groupID = BUILD_UINT16( pData[0], pData[1] );
   2249            pData += 2;   // Move past group ID
   2250          
   2251            switch ( pInMsg->hdr.commandID )
   2252            {
   2253              case COMMAND_SCENE_VIEW_RSP:
   2254                // Parse the rest of the incoming message
   2255                scene.ID = *pData++; // Not applicable to Remove All Response command
   2256                scene.transTime = BUILD_UINT16( pData[0], pData[1] );
   2257                pData += 2;
   2258                nameLen = *pData++; // Name length
   2259                if ( nameLen > (ZCL_GEN_SCENE_NAME_LEN-1) )
   2260                  nameLen = (ZCL_GEN_SCENE_NAME_LEN-1);
   2261                scene.name[0] = nameLen;
   2262                osal_memcpy( &(scene.name[1]), pData, nameLen );
   2263                pData += nameLen; // move pass name
   2264          
   2265                //*** Do something with the extension field(s)
   2266          
   2267                // Fall through to callback - break is left off intentionally
   2268          
   2269              case COMMAND_SCENE_ADD_RSP:
   2270              case COMMAND_SCENE_REMOVE_RSP:
   2271              case COMMAND_SCENE_REMOVE_ALL_RSP:
   2272              case COMMAND_SCENE_STORE_RSP:
   2273                if ( pCBs->pfnSceneRsp )
   2274                {
   2275                  rsp.srcAddr = &(pInMsg->msg->srcAddr);
   2276                  rsp.cmdID = pInMsg->hdr.commandID;
   2277                  rsp.scene = &scene;
   2278          
   2279                  pCBs->pfnSceneRsp( &rsp );
   2280                }
   2281                break;
   2282          
   2283              case COMMAND_SCENE_GET_MEMBERSHIP_RSP:
   2284                if ( rsp.status == ZCL_STATUS_SUCCESS )
   2285                {
   2286                  uint8 sceneCnt = *pData++;
   2287                  
   2288                  if ( sceneCnt > 0 )
   2289                  {
   2290                    // Allocate space for the scene list
   2291                    sceneList = osal_mem_alloc( sceneCnt );
   2292                    if ( sceneList != NULL )
   2293                    {
   2294                      rsp.sceneCnt = sceneCnt;
   2295                      for ( i = 0; i < sceneCnt; i++ )
   2296                        sceneList[i] = *pData++;
   2297                    }
   2298                  }
   2299                }
   2300          
   2301                if ( pCBs->pfnSceneRsp )
   2302                {
   2303                  rsp.srcAddr = &(pInMsg->msg->srcAddr);
   2304                  rsp.cmdID = pInMsg->hdr.commandID;
   2305                  rsp.sceneList = sceneList;
   2306                  rsp.scene = &scene;
   2307          
   2308                  pCBs->pfnSceneRsp( &rsp);
   2309                }
   2310                
   2311                if ( sceneList != NULL )
   2312                  osal_mem_free( sceneList );
   2313                break;
   2314          
   2315              default:
   2316                stat = ZFailure;
   2317                break;
   2318            }
   2319          
   2320            return ( stat );
   2321          }
   2322          #endif // ZCL_SCENES
   2323          
   2324          #ifdef ZCL_ON_OFF
   2325          /*********************************************************************
   2326           * @fn      zclGeneral_ProcessInCmdOnOff
   2327           *
   2328           * @brief   Process in the received On/Off Command.
   2329           *
   2330           * @param   pInMsg - pointer to the incoming message
   2331           *
   2332           * @return  ZStatus_t
   2333           */
   2334          static ZStatus_t zclGeneral_ProcessInOnOff( zclIncoming_t *pInMsg,
   2335                                                      zclGeneral_AppCallbacks_t *pCBs )
   2336          {
   2337            if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   2338            {
   2339              if ( pInMsg->hdr.commandID > COMMAND_TOGGLE )
   2340                return ( ZFailure );   // Error ignore the command
   2341          
   2342              if ( pCBs->pfnOnOff )
   2343                pCBs->pfnOnOff( pInMsg->hdr.commandID );
   2344            }
   2345            // no Client command
   2346          
   2347            return ( ZSuccess );
   2348          }
   2349          #endif // ZCL_ON_OFF
   2350          
   2351          #ifdef ZCL_LEVEL_CTRL
   2352          /*********************************************************************
   2353           * @fn      zclGeneral_ProcessInLevelControl
   2354           *
   2355           * @brief   Process in the received Level Control Command.
   2356           *
   2357           * @param   pInMsg - pointer to the incoming message
   2358           *
   2359           * @return  ZStatus_t
   2360           */
   2361          static ZStatus_t zclGeneral_ProcessInLevelControl( zclIncoming_t *pInMsg,
   2362                                                             zclGeneral_AppCallbacks_t *pCBs )
   2363          {
   2364            uint8 withOnOff = FALSE;
   2365            ZStatus_t stat = ZSuccess;
   2366          
   2367            if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   2368            {
   2369              switch ( pInMsg->hdr.commandID )
   2370              {
   2371                case COMMAND_LEVEL_MOVE_TO_LEVEL_WITH_ON_OFF:
   2372                  withOnOff = TRUE;
   2373                  // fall through
   2374                case COMMAND_LEVEL_MOVE_TO_LEVEL:
   2375                  if ( pCBs->pfnLevelControlMoveToLevel )
   2376                  {
   2377                    zclLCMoveToLevel_t cmd;
   2378          
   2379                    cmd.level = pInMsg->pData[0];
   2380                    cmd.transitionTime = BUILD_UINT16( pInMsg->pData[1], pInMsg->pData[2] );
   2381                    cmd.withOnOff = withOnOff;
   2382          
   2383                    pCBs->pfnLevelControlMoveToLevel( &cmd );
   2384                  }
   2385                  break;
   2386          
   2387                case COMMAND_LEVEL_MOVE_WITH_ON_OFF:
   2388                  withOnOff = TRUE;
   2389                  // fall through
   2390                case COMMAND_LEVEL_MOVE:
   2391                  if ( pCBs->pfnLevelControlMove )
   2392                  {
   2393                    zclLCMove_t cmd;
   2394          
   2395                    cmd.moveMode = pInMsg->pData[0];
   2396                    cmd.rate = pInMsg->pData[1];
   2397                    cmd.withOnOff = withOnOff;
   2398          
   2399                    pCBs->pfnLevelControlMove( &cmd );
   2400                  }
   2401                  break;
   2402          
   2403                case COMMAND_LEVEL_STEP_WITH_ON_OFF:
   2404                  withOnOff = TRUE;
   2405                  // fall through
   2406                case COMMAND_LEVEL_STEP:
   2407                  if ( pCBs->pfnLevelControlStep )
   2408                  {
   2409                    zclLCStep_t cmd;
   2410          
   2411                    cmd.stepMode = pInMsg->pData[0];
   2412                    cmd.amount =  pInMsg->pData[1];
   2413                    cmd.transitionTime = BUILD_UINT16( pInMsg->pData[2], pInMsg->pData[3] );
   2414                    cmd.withOnOff = withOnOff;
   2415          
   2416                    pCBs->pfnLevelControlStep( &cmd );
   2417                  }
   2418                  break;
   2419          
   2420                case COMMAND_LEVEL_STOP:
   2421                case COMMAND_LEVEL_STOP_WITH_ON_OFF:
   2422                  // Both Stop commands are identical
   2423                  if ( pCBs->pfnLevelControlStop )
   2424                  {
   2425                    pCBs->pfnLevelControlStop();
   2426                  }
   2427                  break;
   2428          
   2429                default:
   2430                  stat = ZFailure;
   2431                  break;
   2432              }
   2433            }
   2434            // no Client command
   2435          
   2436            return ( stat );
   2437          }
   2438          #endif // ZCL_LEVEL_CTRL
   2439          
   2440          #ifdef ZCL_ALARMS
   2441          /*********************************************************************
   2442           * @fn      zclGeneral_AddAlarm
   2443           *
   2444           * @brief   Add an alarm for a cluster
   2445           *
   2446           * @param   endpoint -
   2447           * @param   alarm - new alarm item
   2448           *
   2449           * @return  ZStatus_t
   2450           */
   2451          ZStatus_t zclGeneral_AddAlarm( uint8 endpoint, zclGeneral_Alarm_t *alarm )
   2452          {
   2453            zclGenAlarmItem_t *pNewItem;
   2454            zclGenAlarmItem_t *pLoop;
   2455          
   2456            // Fill in the new profile list
   2457            pNewItem = osal_mem_alloc( sizeof( zclGenAlarmItem_t ) );
   2458            if ( pNewItem == NULL )
   2459              return ( ZMemError );
   2460          
   2461            // Fill in the plugin record.
   2462            pNewItem->next = (zclGenAlarmItem_t *)NULL;
   2463            pNewItem->endpoint =  endpoint;
   2464            osal_memcpy( (uint8*)(&pNewItem->alarm), (uint8*)alarm, sizeof ( zclGeneral_Alarm_t ) );
   2465          
   2466            // Find spot in list
   2467            if (  zclGenAlarmTable == NULL )
   2468            {
   2469              zclGenAlarmTable = pNewItem;
   2470            }
   2471            else
   2472            {
   2473              // Look for end of list
   2474              pLoop = zclGenAlarmTable;
   2475              while ( pLoop->next != NULL )
   2476                pLoop = pLoop->next;
   2477          
   2478              // Put new item at end of list
   2479              pLoop->next = pNewItem;
   2480            }
   2481          
   2482            return ( ZSuccess );
   2483          }
   2484          
   2485          /*********************************************************************
   2486           * @fn      zclGeneral_FindAlarm
   2487           *
   2488           * @brief   Find an alarm with alarmCode and clusterID
   2489           *
   2490           * @param   endpoint -
   2491           * @param   groupID - what group the scene belongs to
   2492           * @param   sceneID - ID to look for scene
   2493           *
   2494           * @return  a pointer to the alarm information, NULL if not found
   2495           */
   2496          zclGeneral_Alarm_t *zclGeneral_FindAlarm( uint8 endpoint, uint8 alarmCode, uint16 clusterID )
   2497          {
   2498            zclGenAlarmItem_t *pLoop;
   2499          
   2500            // Look for the alarm
   2501            pLoop = zclGenAlarmTable;
   2502            while ( pLoop )
   2503            {
   2504              if ( pLoop->endpoint == endpoint &&
   2505                   pLoop->alarm.code == alarmCode && pLoop->alarm.clusterID == clusterID )
   2506              {
   2507                return ( &(pLoop->alarm) );
   2508              }
   2509              pLoop = pLoop->next;
   2510            }
   2511          
   2512            return ( (zclGeneral_Alarm_t *)NULL );
   2513          }
   2514          
   2515          /*********************************************************************
   2516           * @fn      zclGeneral_FindEarliestAlarm
   2517           *
   2518           * @brief   Find an alarm with the earliest timestamp
   2519           *
   2520           * @param   endpoint -
   2521           *
   2522           * @return  a pointer to the alarm information, NULL if not found
   2523           */
   2524          zclGeneral_Alarm_t *zclGeneral_FindEarliestAlarm( uint8 endpoint )
   2525          {
   2526            zclGenAlarmItem_t *pLoop;
   2527            zclGenAlarmItem_t earliestAlarm;
   2528            zclGenAlarmItem_t *pEarliestAlarm = &earliestAlarm;
   2529          
   2530            pEarliestAlarm->alarm.timeStamp = 0xFFFFFFFF;
   2531          
   2532            // Look for alarm with earliest time
   2533            pLoop = zclGenAlarmTable;
   2534            while ( pLoop )
   2535            {
   2536              if ( pLoop->endpoint == endpoint &&
   2537                   pLoop->alarm.timeStamp < pEarliestAlarm->alarm.timeStamp )
   2538              {
   2539                pEarliestAlarm = pLoop;
   2540              }
   2541              pLoop = pLoop->next;
   2542            }
   2543          
   2544            if ( pEarliestAlarm->alarm.timeStamp != 0xFFFFFFFF )
   2545              return ( &(pEarliestAlarm->alarm) );
   2546          
   2547            // No alarm
   2548            return ( (zclGeneral_Alarm_t *)NULL );
   2549          }
   2550          
   2551          /*********************************************************************
   2552           * @fn      zclGeneral_ResetAlarm
   2553           *
   2554           * @brief   Remove a scene with endpoint and sceneID
   2555           *
   2556           * @param   endpoint -
   2557           * @param   alarmCode -
   2558           * @param   clusterID -
   2559           *
   2560           * @return  TRUE if removed, FALSE if not found
   2561           */
   2562          void zclGeneral_ResetAlarm( uint8 endpoint, uint8 alarmCode, uint16 clusterID )
   2563          {
   2564            zclGenAlarmItem_t *pLoop;
   2565            zclGenAlarmItem_t *pPrev;
   2566          
   2567            // Look for end of list
   2568            pLoop = zclGenAlarmTable;
   2569            pPrev = NULL;
   2570            while ( pLoop )
   2571            {
   2572              if ( pLoop->endpoint == endpoint &&
   2573                   pLoop->alarm.code == alarmCode && pLoop->alarm.clusterID == clusterID )
   2574              {
   2575                if ( pPrev == NULL )
   2576                  zclGenAlarmTable = pLoop->next;
   2577                else
   2578                  pPrev->next = pLoop->next;
   2579          
   2580                // Free the memory
   2581                osal_mem_free( pLoop );
   2582          
   2583                // Notify the Application so that if the alarm condition still active then
   2584                // a new notification will be generated, and a new alarm record will be
   2585                // added to the alarm log
   2586                // zclGeneral_NotifyReset( alarmCode, clusterID ); // callback function?
   2587                return;
   2588              }
   2589              pPrev = pLoop;
   2590              pLoop = pLoop->next;
   2591            }
   2592          }
   2593          
   2594          /*********************************************************************
   2595           * @fn      zclGeneral_ResetAllAlarms
   2596           *
   2597           * @brief   Remove all alarms with endpoint
   2598           *
   2599           * @param   endpoint -
   2600           * @param   notifyApp -
   2601           *
   2602           * @return  none
   2603           */
   2604          void zclGeneral_ResetAllAlarms( uint8 endpoint, uint8 notifyApp )
   2605          {
   2606            zclGenAlarmItem_t *pLoop;
   2607            zclGenAlarmItem_t *pPrev;
   2608            zclGenAlarmItem_t *pNext;
   2609          
   2610            // Look for end of list
   2611            pLoop = zclGenAlarmTable;
   2612            pPrev = NULL;
   2613            while ( pLoop )
   2614            {
   2615              if (  pLoop->endpoint == endpoint )
   2616              {
   2617                if ( pPrev == NULL )
   2618                  zclGenAlarmTable = pLoop->next;
   2619                else
   2620                  pPrev->next = pLoop->next;
   2621          
   2622                pNext = pLoop->next;
   2623          
   2624                // Free the memory
   2625                osal_mem_free( pLoop );
   2626          
   2627                pLoop = pNext;
   2628              }
   2629              else
   2630              {
   2631                pPrev = pLoop;
   2632                pLoop = pLoop->next;
   2633              }
   2634            }
   2635          
   2636            if ( notifyApp )
   2637            {
   2638              // Notify the Application so that if any alarm conditions still active then
   2639              // a new notification will be generated, and a new alarm record will be
   2640              // added to the alarm log
   2641              // zclGeneral_NotifyResetAll(); // callback function?
   2642            }
   2643          }
   2644          
   2645          /*********************************************************************
   2646           * @fn      zclGeneral_ProcessInAlarmsServer
   2647           *
   2648           * @brief   Process in the received Alarms Command.
   2649           *
   2650           * @param   pInMsg - pointer to the incoming message
   2651           *
   2652           * @return  ZStatus_t
   2653           */
   2654          static ZStatus_t zclGeneral_ProcessInAlarmsServer( zclIncoming_t *pInMsg,
   2655                                                             zclGeneral_AppCallbacks_t *pCBs )
   2656          {
   2657            zclGeneral_Alarm_t *pAlarm;
   2658            uint8 *pData = pInMsg->pData;
   2659            ZStatus_t stat = ZSuccess;
   2660          
   2661            switch ( pInMsg->hdr.commandID )
   2662            {
   2663              case COMMAND_ALARMS_RESET:
   2664                zclGeneral_ResetAlarm( pInMsg->msg->endPoint, pData[0],
   2665                                       BUILD_UINT16( pData[1], pData[2] ) );
   2666                break;
   2667          
   2668              case COMMAND_ALARMS_RESET_ALL:
   2669                zclGeneral_ResetAllAlarms( pInMsg->msg->endPoint, TRUE );
   2670                break;
   2671          
   2672              case COMMAND_ALARMS_GET:
   2673                pAlarm = zclGeneral_FindEarliestAlarm( pInMsg->msg->endPoint );
   2674                if ( pAlarm )
   2675                {
   2676                  // Send a response back
   2677                  zclGeneral_SendAlarmGetRespnose( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2678                                                   ZCL_STATUS_SUCCESS, pAlarm->code,
   2679                                                   pAlarm->clusterID, pAlarm->timeStamp,
   2680                                                   true, pInMsg->hdr.transSeqNum );
   2681                  // Remove the entry from the Alarm table
   2682                  zclGeneral_ResetAlarm( pInMsg->msg->endPoint, pAlarm->code, pAlarm->clusterID );
   2683                }
   2684                else
   2685                {
   2686                  // Send a response back
   2687                  zclGeneral_SendAlarmGetRespnose( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2688                                                   ZCL_STATUS_NOT_FOUND, 0, 0, 0,
   2689                                                   true, pInMsg->hdr.transSeqNum );
   2690                }
   2691                stat = ZCL_STATUS_CMD_HAS_RSP;
   2692                break;
   2693          
   2694              case COMMAND_ALARMS_RESET_LOG:
   2695                zclGeneral_ResetAllAlarms( pInMsg->msg->endPoint, FALSE );
   2696                break;
   2697          
   2698              default:
   2699                stat = ZFailure;
   2700                break;
   2701            }
   2702          
   2703            return ( stat );
   2704          }
   2705          
   2706          /*********************************************************************
   2707           * @fn      zclGeneral_ProcessInAlarmsClient
   2708           *
   2709           * @brief   Process in the received Alarms Command.
   2710           *
   2711           * @param   pInMsg - pointer to the incoming message
   2712           *
   2713           * @return  ZStatus_t
   2714           */
   2715          static ZStatus_t zclGeneral_ProcessInAlarmsClient( zclIncoming_t *pInMsg,
   2716                                                             zclGeneral_AppCallbacks_t *pCBs )
   2717          {
   2718            uint8 *pData = pInMsg->pData;
   2719            zclAlarm_t alarm;
   2720            ZStatus_t stat = ZSuccess;
   2721          
   2722            osal_memset( (uint8*)&alarm, 0, sizeof( zclAlarm_t ) );
   2723          
   2724            switch ( pInMsg->hdr.commandID )
   2725            {
   2726              case COMMAND_ALARMS_ALARM:
   2727                if ( pCBs->pfnAlarm )
   2728                {
   2729                  alarm.srcAddr = &(pInMsg->msg->srcAddr);
   2730                  alarm.cmdID = pInMsg->hdr.commandID;
   2731                  alarm.status = *pData++;
   2732                  alarm.alarmCode = *pData++;
   2733                  alarm.clusterID = BUILD_UINT16( pData[0], pData[1] );
   2734                  pData += 2;
   2735                  alarm.timeStamp = osal_build_uint32( pData, 4 );
   2736          
   2737                  pCBs->pfnAlarm( &alarm );
   2738                }
   2739                break;
   2740          
   2741              case COMMAND_ALARMS_GET_RSP:
   2742                if ( pCBs->pfnAlarm )
   2743                {
   2744                  alarm.srcAddr = &(pInMsg->msg->srcAddr);
   2745                  alarm.cmdID = pInMsg->hdr.commandID;
   2746                  alarm.alarmCode = *pData++;
   2747                  alarm.clusterID = BUILD_UINT16( pData[0], pData[1] );
   2748          
   2749                  pCBs->pfnAlarm( &alarm );
   2750                }
   2751                break;
   2752          
   2753              default:
   2754                stat = ZFailure;
   2755                break;
   2756            }
   2757          
   2758            return ( stat );
   2759          }
   2760          #endif // ZCL_ALARMS
   2761          
   2762          #ifdef ZCL_LOCATION
   2763          /*********************************************************************
   2764           * @fn      zclGeneral_ProcessInLocationServer
   2765           *
   2766           * @brief   Process in the received Location Command.
   2767           *
   2768           * @param   pInMsg - pointer to the incoming message
   2769           *
   2770           * @return  ZStatus_t
   2771           */
   2772          static ZStatus_t zclGeneral_ProcessInLocationServer( zclIncoming_t *pInMsg,
   2773                                                               zclGeneral_AppCallbacks_t *pCBs )
   2774          {
   2775            uint8 *pData = pInMsg->pData;
   2776            zclLocation_t cmd;
   2777            ZStatus_t stat = ZSuccess;
   2778          
   2779            osal_memset( (uint8*)&cmd, 0, sizeof( zclLocation_t ) );
   2780          
   2781            switch ( pInMsg->hdr.commandID )
   2782            {
   2783              case COMMAND_LOCATION_SET_ABSOLUTE:
   2784                cmd.un.absLoc.coordinate1 = BUILD_UINT16( pData[0], pData[1] );
   2785                pData += 2;
   2786                cmd.un.absLoc.coordinate2 = BUILD_UINT16( pData[0], pData[1] );
   2787                pData += 2;
   2788                cmd.un.absLoc.coordinate3 = BUILD_UINT16( pData[0], pData[1] );
   2789                pData += 2;
   2790                cmd.un.absLoc.power = BUILD_UINT16( pData[0], pData[1] );
   2791                pData += 2;
   2792                cmd.un.absLoc.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
   2793          
   2794                if ( pCBs->pfnLocation )
   2795                {
   2796                  cmd.srcAddr = &(pInMsg->msg->srcAddr);
   2797                  cmd.cmdID = pInMsg->hdr.commandID;
   2798          
   2799                  // Update the absolute location info
   2800                  pCBs->pfnLocation( &cmd );
   2801                }
   2802                break;
   2803          
   2804              case COMMAND_LOCATION_SET_DEV_CFG:
   2805                cmd.un.devCfg.power = BUILD_UINT16( pData[0], pData[1] );
   2806                pData += 2;
   2807                cmd.un.devCfg.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
   2808                pData += 2;
   2809                cmd.un.devCfg.calcPeriod = BUILD_UINT16( pData[0], pData[1] );
   2810                pData += 2;
   2811                cmd.un.devCfg.numMeasurements = *pData++;
   2812                cmd.un.devCfg.reportPeriod = BUILD_UINT16( pData[0], pData[1] );
   2813          
   2814                if ( pCBs->pfnLocation )
   2815                {
   2816                  cmd.srcAddr = &(pInMsg->msg->srcAddr);
   2817                  cmd.cmdID = pInMsg->hdr.commandID;
   2818          
   2819                  // Update the device configuration info
   2820                  pCBs->pfnLocation( &cmd );
   2821                }
   2822                break;
   2823          
   2824              case COMMAND_LOCATION_GET_DEV_CFG:
   2825                cmd.un.ieeeAddr = pData;
   2826          
   2827                if ( pCBs->pfnLocation )
   2828                {
   2829                  cmd.srcAddr = &(pInMsg->msg->srcAddr);
   2830                  cmd.cmdID = pInMsg->hdr.commandID;
   2831                  cmd.seqNum = pInMsg->hdr.transSeqNum;
   2832          
   2833                  // Retreive the Device Configuration
   2834                  pCBs->pfnLocation( &cmd );
   2835                }
   2836                stat = ZCL_STATUS_CMD_HAS_RSP;
   2837                break;
   2838          
   2839              case COMMAND_LOCATION_GET_DATA:
   2840                cmd.un.loc.bitmap.locByte = *pData++;
   2841                cmd.un.loc.numResponses = *pData++;
   2842          
   2843                if ( cmd.un.loc.brdcastResponse == 0 ) // command is sent as a unicast
   2844                  osal_cpyExtAddr( cmd.un.loc.targetAddr, pData );
   2845          
   2846                if ( pCBs->pfnLocation )
   2847                {
   2848                  cmd.srcAddr = &(pInMsg->msg->srcAddr);
   2849                  cmd.cmdID = pInMsg->hdr.commandID;
   2850                  cmd.seqNum = pInMsg->hdr.transSeqNum;
   2851          
   2852                  // Retreive the Location Data
   2853                  pCBs->pfnLocation( &cmd );
   2854                }
   2855                stat = ZCL_STATUS_CMD_HAS_RSP;
   2856                break;
   2857          
   2858              default:
   2859                stat = ZFailure;
   2860                break;
   2861            }
   2862          
   2863            return ( stat );
   2864          }
   2865          
   2866          /*********************************************************************
   2867           * @fn      zclGeneral_ProcessInLocationDataRsp
   2868           *
   2869           * @brief   Process in the received Location Command.
   2870           *
   2871           * @param   pInMsg - pointer to the incoming message
   2872           *
   2873           * @return  ZStatus_t
   2874           */
   2875          static void zclGeneral_ProcessInLocationDataRsp( zclIncoming_t *pInMsg,
   2876                                                           zclGeneral_AppCallbacks_t *pCBs )
   2877          {
   2878            uint8 *pData = pInMsg->pData;
   2879            zclLocationRsp_t rsp;
   2880          
   2881            osal_memset( (uint8*)&rsp, 0, sizeof( zclLocationRsp_t ) );
   2882          
   2883            if ( pCBs->pfnLocationRsp )
   2884            {
   2885              if ( pInMsg->hdr.commandID == COMMAND_LOCATION_DATA_RSP )
   2886                rsp.un.loc.status = *pData++;
   2887          
   2888              if ( pInMsg->hdr.commandID != COMMAND_LOCATION_DATA_RSP ||
   2889                   rsp.un.loc.status == ZCL_STATUS_SUCCESS )
   2890              {
   2891                rsp.un.loc.data.type = *pData++;
   2892                rsp.un.loc.data.absLoc.coordinate1 = BUILD_UINT16( pData[0], pData[1] );
   2893                pData += 2;
   2894                rsp.un.loc.data.absLoc.coordinate2 = BUILD_UINT16( pData[0], pData[1] );
   2895                pData += 2;
   2896          
   2897                if ( locationType2D( rsp.un.loc.data.type ) == 0 )
   2898                {
   2899                  rsp.un.loc.data.absLoc.coordinate3 = BUILD_UINT16( pData[0], pData[1] );
   2900                  pData += 2;
   2901                }
   2902          
   2903                if ( pInMsg->hdr.commandID != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
   2904                {
   2905                  rsp.un.loc.data.absLoc.power = BUILD_UINT16( pData[0], pData[1] );
   2906                  pData += 2;
   2907                  rsp.un.loc.data.absLoc.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
   2908                  pData += 2;
   2909                }
   2910          
   2911                if ( locationTypeAbsolute( rsp.un.loc.data.type ) == 0 )
   2912                {
   2913                  if ( pInMsg->hdr.commandID != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
   2914                    rsp.un.loc.data.calcLoc.locationMethod = *pData++;
   2915          
   2916                  rsp.un.loc.data.calcLoc.qualityMeasure = *pData++;
   2917                  rsp.un.loc.data.calcLoc.locationAge = BUILD_UINT16( pData[0], pData[1] );
   2918                }
   2919              }
   2920          
   2921              rsp.srcAddr = &(pInMsg->msg->srcAddr);
   2922              rsp.cmdID = pInMsg->hdr.commandID;
   2923          
   2924              // Notify the Application
   2925              pCBs->pfnLocationRsp( &rsp );
   2926            }
   2927          }
   2928          
   2929          /*********************************************************************
   2930           * @fn      zclGeneral_ProcessInLocationClient
   2931           *
   2932           * @brief   Process in the received Location Command.
   2933           *
   2934           * @param   pInMsg - pointer to the incoming message
   2935           *
   2936           * @return  ZStatus_t
   2937           */
   2938          static ZStatus_t zclGeneral_ProcessInLocationClient( zclIncoming_t *pInMsg,
   2939                                                               zclGeneral_AppCallbacks_t *pCBs )
   2940          {
   2941            uint8 *pData = pInMsg->pData;
   2942            zclLocationRsp_t rsp;
   2943            ZStatus_t stat = ZSuccess;
   2944          
   2945            osal_memset( (uint8*)&rsp, 0, sizeof( zclLocationRsp_t ) );
   2946          
   2947            switch ( pInMsg->hdr.commandID )
   2948            {
   2949              case COMMAND_LOCATION_DEV_CFG_RSP:
   2950                if ( pCBs->pfnLocationRsp )
   2951                {
   2952                  rsp.un.devCfg.status = *pData++;
   2953                  if ( rsp.un.devCfg.status == ZCL_STATUS_SUCCESS )
   2954                  {
   2955                    rsp.un.devCfg.data.power = BUILD_UINT16( pData[0], pData[1] );
   2956                    pData += 2;
   2957                    rsp.un.devCfg.data.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
   2958                    pData += 2;
   2959                    rsp.un.devCfg.data.calcPeriod = BUILD_UINT16( pData[0], pData[1] );
   2960                    pData += 2;
   2961                    rsp.un.devCfg.data.numMeasurements = *pData++;
   2962                    rsp.un.devCfg.data.reportPeriod = BUILD_UINT16( pData[0], pData[1] );
   2963          
   2964                    rsp.srcAddr = &(pInMsg->msg->srcAddr);
   2965                    rsp.cmdID = pInMsg->hdr.commandID;
   2966          
   2967                    // Notify the Application
   2968                    pCBs->pfnLocationRsp( &rsp );
   2969                  }
   2970                }
   2971                break;
   2972          
   2973              case COMMAND_LOCATION_DATA_RSP:
   2974              case COMMAND_LOCATION_DATA_NOTIF:
   2975              case COMMAND_LOCATION_COMPACT_DATA_NOTIF:
   2976                zclGeneral_ProcessInLocationDataRsp( pInMsg, pCBs );
   2977                break;
   2978          
   2979              case COMMAND_LOCATION_RSSI_PING:
   2980                if ( pCBs->pfnLocationRsp )
   2981                {
   2982                  rsp.un.locationType = *pData;
   2983          
   2984                  rsp.srcAddr = &(pInMsg->msg->srcAddr);
   2985                  rsp.cmdID = pInMsg->hdr.commandID;
   2986          
   2987                  // Notify the Application
   2988                  pCBs->pfnLocationRsp( &rsp );
   2989                }
   2990                break;
   2991          
   2992              default:
   2993                stat = ZFailure;
   2994                break;
   2995            }
   2996          
   2997            return ( stat );
   2998          }
   2999          #endif // ZCL_LOCATION
   3000          
   3001          #ifdef ZCL_SCENES
   3002          /*********************************************************************
   3003           * @fn      zclGeneral_ScenesInitNV
   3004           *
   3005           * @brief   Initialize the NV Scene Table Items
   3006           *
   3007           * @param   none
   3008           *
   3009           * @return  number of scenes
   3010           */
   3011          static uint8 zclGeneral_ScenesInitNV( void )
   3012          {
   3013            uint8  status;
   3014            uint16 size;
   3015          
   3016            size = (uint16)((sizeof ( nvGenScenesHdr_t ))
   3017                            + ( sizeof( zclGenSceneNVItem_t ) * ZCL_GEN_MAX_SCENES ));
   3018          
   3019            status = osal_nv_item_init( ZCD_NV_SCENE_TABLE, size, NULL );
   3020          
   3021            if ( status != ZSUCCESS )
   3022            {
   3023              zclGeneral_ScenesSetDefaultNV();
   3024            }
   3025          
   3026            return status;
   3027          }
   3028          
   3029          /*********************************************************************
   3030           * @fn          zclGeneral_ScenesSetDefaultNV
   3031           *
   3032           * @brief       Write the defaults to NV
   3033           *
   3034           * @param       none
   3035           *
   3036           * @return      none
   3037           */
   3038          static void zclGeneral_ScenesSetDefaultNV( void )
   3039          {
   3040            nvGenScenesHdr_t hdr;
   3041          
   3042            // Initialize the header
   3043            hdr.numRecs = 0;
   3044          
   3045            // Save off the header
   3046            osal_nv_write( ZCD_NV_SCENE_TABLE, 0, sizeof( nvGenScenesHdr_t ), &hdr );
   3047          }
   3048          
   3049          /*********************************************************************
   3050           * @fn          zclGeneral_ScenesWriteNV
   3051           *
   3052           * @brief       Save the Scene Table in NV
   3053           *
   3054           * @param       none
   3055           *
   3056           * @return      none
   3057           */
   3058          static void zclGeneral_ScenesWriteNV( void )
   3059          {
   3060            nvGenScenesHdr_t hdr;
   3061            zclGenSceneItem_t *pLoop;
   3062            zclGenSceneNVItem_t item;
   3063          
   3064            hdr.numRecs = 0;
   3065          
   3066            // Look for end of list
   3067            pLoop = zclGenSceneTable;
   3068            while ( pLoop )
   3069            {
   3070              // Build the record
   3071              item.endpoint = pLoop->endpoint;
   3072              osal_memcpy( &(item.scene), &(pLoop->scene), sizeof ( zclGeneral_Scene_t ) );
   3073          
   3074              // Save the record to NV
   3075              osal_nv_write( ZCD_NV_SCENE_TABLE,
   3076                      (uint16)((sizeof( nvGenScenesHdr_t )) + (hdr.numRecs * sizeof ( zclGenSceneNVItem_t ))),
   3077                              sizeof ( zclGenSceneNVItem_t ), &item );
   3078          
   3079              hdr.numRecs++;
   3080          
   3081              pLoop = pLoop->next;
   3082            }
   3083          
   3084            // Save off the header
   3085            osal_nv_write( ZCD_NV_SCENE_TABLE, 0, sizeof( nvGenScenesHdr_t ), &hdr );
   3086          }
   3087          
   3088          /*********************************************************************
   3089           * @fn          zclGeneral_ScenesRestoreFromNV
   3090           *
   3091           * @brief       Restore the Scene table from NV
   3092           *
   3093           * @param       none
   3094           *
   3095           * @return      Number of entries restored
   3096           */
   3097          static uint16 zclGeneral_ScenesRestoreFromNV( void )
   3098          {
   3099            uint16 x;
   3100            nvGenScenesHdr_t hdr;
   3101          
   3102            zclGenSceneNVItem_t item;
   3103            uint16 numAdded = 0;
   3104          
   3105            if ( osal_nv_read( ZCD_NV_SCENE_TABLE, 0, sizeof(nvGenScenesHdr_t), &hdr ) == ZSuccess )
   3106            {
   3107              // Read in the device list
   3108              for ( x = 0; x < hdr.numRecs; x++ )
   3109              {
   3110                if ( osal_nv_read( ZCD_NV_SCENE_TABLE,
   3111                          (uint16)(sizeof(nvGenScenesHdr_t) + (x * sizeof ( zclGenSceneNVItem_t ))),
   3112                                            sizeof ( zclGenSceneNVItem_t ), &item ) == ZSUCCESS )
   3113                {
   3114                  // Add the scene
   3115                  if ( zclGeneral_AddScene( item.endpoint, &(item.scene) ) == ZSuccess )
   3116                  {
   3117                    numAdded++;
   3118                  }
   3119                }
   3120              }
   3121            }
   3122          
   3123            return ( numAdded );
   3124          }
   3125          #endif // ZCL_SCENES
   3126          
   3127          /***************************************************************************
   3128          ****************************************************************************/

   Maximum stack usage in bytes:

     Function                       ISTACK PSTACK XSTACK
     --------                       ------ ------ ------
     zclGeneral_HdlInSpecificCommands
                                        0      0     10
       -> zclGeneral_ProcessInIdentity
                                        0      0     20
     zclGeneral_HdlIncoming             2      0      0
       -> zclGeneral_HdlInSpecificCommands
                                        4      0      0
     zclGeneral_ProcessInIdentity       0      0     38
       -> zclFindAttrRec                0      0     56
       -> zclReadAttrData               0      0     52
       -> zclGeneral_SendIdentifyQueryResponse
                                        0      0     56
     zclGeneral_RegisterCmdCallbacks
                                        1      0     14
       -> zcl_registerPlugin            0      0     28
       -> osal_mem_alloc                0      0     24
     zclGeneral_SendIdentify            1      0     25
       -> zcl_SendCommand               0      0     46
     zclGeneral_SendIdentifyQueryResponse
                                        1      0     51
       -> zcl_SendCommand               0      0     46


   Segment part sizes:

     Function/Label                               Bytes
     --------------                               -----
     zclGenCBs                                       2
     zclGenPluginRegisted                            1
     zclGeneral_RegisterCmdCallbacks
                                                   153
     ?Subroutine9                                    5
     zclGeneral_SendIdentify                        80
     ?Subroutine10                                  30
     ??Subroutine11_0                                5
     ?Subroutine1                                   13
     ?Subroutine0                                   17
     zclGeneral_SendIdentifyQueryResponse
                                                    79
     zclGeneral_HdlIncoming                         37
     zclGeneral_HdlInSpecificCommands
                                                   195
     ?Subroutine2                                    6
     ?Subroutine8                                   10
     ?Subroutine5                                    9
     ?Subroutine7                                    7
     ?Subroutine6                                   12
     zclGeneral_ProcessInIdentity                  339
     ?Subroutine4                                   10
     ?Subroutine3                                    6
     ??zclGeneral_RegisterCmdCallbacks?relay         6
     ??zclGeneral_SendIdentify?relay                 6
     ??zclGeneral_SendIdentifyQueryResponse?relay    6
     ??zclGeneral_HdlIncoming?relay                  6
     ??zclGeneral_HdlInSpecificCommands?relay        6
     ??zclGeneral_ProcessInIdentity?relay            6

 
 1 013 bytes in segment BANKED_CODE
    36 bytes in segment BANK_RELAYS
     3 bytes in segment XDATA_Z
 
 1 049 bytes of CODE  memory
     3 bytes of XDATA memory

Errors: none
Warnings: none
