###############################################################################
#                                                                             #
# IAR C/C++ Compiler V7.51A/W32 for 8051                21/Aug/2013  17:04:47 #
# Copyright 2004-2009 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  D:\GitHub\z-stack\Sensor Network                   #
#                          Example\Components\stack\zcl\zcl.c                 #
#    Command line       =  -f "D:\GitHub\z-stack\Sensor Network               #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\..\..\..\Tools\CC2530DB\f8wCoord.c #
#                          fg" (-DCPU32MHZ -DROOT=__near_func                 #
#                          -DMAC_CFG_APP_PENDING_QUEUE=TRUE                   #
#                          -DZDO_COORDINATOR -DRTR_NWK -DBLINK_LEDS) -f       #
#                          "D:\GitHub\z-stack\Sensor Network                  #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig. #
#                          cfg" (-DSECURE=0 -DZG_SECURE_DYNAMIC=0             #
#                          -DREFLECTOR -DDEFAULT_CHANLIST=0x00000800          #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116 "-DCONST=const __code"    #
#                          -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=TRUE      #
#                          -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100            #
#                          -DRESPONSE_POLL_RATE=100 -DREJOIN_POLL_RATE=440)   #
#                          -f "D:\GitHub\z-stack\Sensor Network               #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\..\..\..\Tools\CC2530DB\f8wZCL.cfg #
#                          " (-DZCL_READ -DZCL_WRITE -DZCL_BASIC              #
#                          -DZCL_IDENTIFY -DZCL_ON_OFF -DZCL_KEY_ESTABLISH    #
#                          -DZCL_LOAD_CONTROL -DZCL_SIMPLE_METERING           #
#                          -DZCL_PRICING) -DZCL_MESSAGE                       #
#                          "D:\GitHub\z-stack\Sensor Network                  #
#                          Example\Components\stack\zcl\zcl.c" -D CC2530 -D   #
#                          ZTOOL_P1 -D MT_TASK -D MT_APP_FUNC -D MT_SYS_FUNC  #
#                          -D MT_ZDO_FUNC -D LCD_SUPPORTED=DEBUG -D           #
#                          Coor_receiver -D xHAL_KEYPAD -D xPA2591 -lC        #
#                          "D:\GitHub\z-stack\Sensor Network                  #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\Coordinator_KB_PA\List\" -lA       #
#                          "D:\GitHub\z-stack\Sensor Network                  #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\Coordinator_KB_PA\List\"           #
#                          --diag_suppress Pe001,Pa010 -o                     #
#                          "D:\GitHub\z-stack\Sensor Network                  #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\Coordinator_KB_PA\Obj\" -e         #
#                          --require_prototypes --debug --core=plain          #
#                          --dptr=16,1 --data_model=large                     #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data_rom                  #
#                          --nr_virtual_regs 16 -I "D:\GitHub\z-stack\Sensor  #
#                          Network Example\Projects\zstack\Sensor Network     #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\" -I "D:\GitHub\z-stack\Sensor     #
#                          Network Example\Projects\zstack\Sensor Network     #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\..\SOURCE\" -I                     #
#                          "D:\GitHub\z-stack\Sensor Network                  #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\..\..\SOURCE\" -I                  #
#                          "D:\GitHub\z-stack\Sensor Network                  #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\..\..\..\ZMAIN\TI2530DB\" -I       #
#                          "D:\GitHub\z-stack\Sensor Network                  #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\..\..\..\..\..\COMPONENTS\MT\" -I  #
#                          "D:\GitHub\z-stack\Sensor Network                  #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\INCL #
#                          UDE\" -I "D:\GitHub\z-stack\Sensor Network         #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\TARG #
#                          ET\CC2530KB\" -I "D:\GitHub\z-stack\Sensor         #
#                          Network Example\Projects\zstack\Sensor Network     #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\..\..\..\..\..\COMPONENTS\OSAL\MCU #
#                          \CCSOC\" -I "D:\GitHub\z-stack\Sensor Network      #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\..\..\..\..\..\COMPONENTS\OSAL\INC #
#                          LUDE\" -I "D:\GitHub\z-stack\Sensor Network        #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\AF #
#                          \" -I "D:\GitHub\z-stack\Sensor Network            #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\NW #
#                          K\" -I "D:\GitHub\z-stack\Sensor Network           #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SE #
#                          C\" -I "D:\GitHub\z-stack\Sensor Network           #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SA #
#                          PI\" -I "D:\GitHub\z-stack\Sensor Network          #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SY #
#                          S\" -I "D:\GitHub\z-stack\Sensor Network           #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\ZC #
#                          L\" -I "D:\GitHub\z-stack\Sensor Network           #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\ZD #
#                          O\" -I "D:\GitHub\z-stack\Sensor Network           #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\..\..\..\..\..\COMPONENTS\ZMAC\F8W #
#                          \" -I "D:\GitHub\z-stack\Sensor Network            #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\..\..\..\..\..\COMPONENTS\ZMAC\"   #
#                          -I "D:\GitHub\z-stack\Sensor Network               #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\..\..\..\..\..\COMPONENTS\SERVICES #
#                          \SADDR\" -I "D:\GitHub\z-stack\Sensor Network      #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\..\..\..\..\..\COMPONENTS\SERVICES #
#                          \SDATA\" -I "D:\GitHub\z-stack\Sensor Network      #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\INCL #
#                          UDE\" -I "D:\GitHub\z-stack\Sensor Network         #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\HIGH #
#                          _LEVEL\" -I "D:\GitHub\z-stack\Sensor Network      #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\LOW_ #
#                          LEVEL\srf04\" -I "D:\GitHub\z-stack\Sensor         #
#                          Network Example\Projects\zstack\Sensor Network     #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\LOW_ #
#                          LEVEL\srf04\SINGLE_CHIP\" -I "C:\Program Files     #
#                          (x86)\IAR Systems\Embedded Workbench               #
#                          5.3\8051\INC\" -I "C:\Program Files (x86)\IAR      #
#                          Systems\Embedded Workbench 5.3\8051\INC\CLIB\"     #
#                          -Ohz                                               #
#    List file          =  D:\GitHub\z-stack\Sensor Network                   #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\Coordinator_KB_PA\List\zcl.lst     #
#    Object file        =  D:\GitHub\z-stack\Sensor Network                   #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\Coordinator_KB_PA\Obj\zcl.r51      #
#                                                                             #
#                                                                             #
###############################################################################

D:\GitHub\z-stack\Sensor Network Example\Components\stack\zcl\zcl.c
      1          #include "ZComDef.h"
      2          #include "OSAL.h"
      3          #include "OSAL_Tasks.h"
      4          #include "AF.h"
      5          #include "ZDConfig.h"
      6          #include "zcl.h"
      7          #include "zcl_general.h"
      8          #include <string.h>
      9          #include <stdio.h>
     10          
     11          #if defined ( INTER_PAN )
     12            #include "stub_aps.h"
     13          #endif
     14          
     15          /* HAL */
     16          #include "hal_uart.h"
     17          #include "hal_timer.h"
     18          #include "hal_led.h"
     19          #if defined (LCD_SUPPORTED)
     20            #include "hal_lcd.h"
     21          #endif
     22          
     23          /* MT */
     24          #include "MT_UART.h"
     25          #include "MT.h"
     26          
     27          /*********************************************************************
     28           * MACROS
     29           */
     30          /*** Frame Control ***/
     31          #define zcl_FCType( a )               ( (a) & ZCL_FRAME_CONTROL_TYPE )
     32          #define zcl_FCManuSpecific( a )       ( (a) & ZCL_FRAME_CONTROL_MANU_SPECIFIC )
     33          #define zcl_FCDirection( a )          ( (a) & ZCL_FRAME_CONTROL_DIRECTION )
     34          #define zcl_FCDisableDefaultRsp( a )  ( (a) & ZCL_FRAME_CONTROL_DISABLE_DEFAULT_RSP )
     35          
     36          /*** Attribute Access Control ***/
     37          #define zcl_AccessCtrlRead( a )       ( (a) & ACCESS_CONTROL_READ )
     38          #define zcl_AccessCtrlWrite( a )      ( (a) & ACCESS_CONTROL_WRITE )
     39          #define zcl_AccessCtrlCmd( a )        ( (a) & ACCESS_CONTROL_CMD )
     40          
     41          #define zclParseCmd( a, b )           zclCmdTable[(a)].pfnParseInProfile( (b) )
     42          #define zclProcessCmd( a, b )         zclCmdTable[(a)].pfnProcessInProfile( (b) )
     43          
     44          #define zcl_DefaultRspCmd( zclHdr )   ( zcl_ProfileCmd( (zclHdr).fc.type )     && \
     45                                                  (zclHdr).fc.manuSpecific == 0          && \
     46                                                  (zclHdr).commandID == ZCL_CMD_DEFAULT_RSP )
     47          
     48          // Commands that have corresponding responses
     49          #define CMD_HAS_RSP( cmd )            ( (cmd) == ZCL_CMD_READ            || \
     50                                                  (cmd) == ZCL_CMD_WRITE           || \
     51                                                  (cmd) == ZCL_CMD_WRITE_UNDIVIDED || \
     52                                                  (cmd) == ZCL_CMD_CONFIG_REPORT   || \
     53                                                  (cmd) == ZCL_CMD_READ_REPORT_CFG || \
     54                                                  (cmd) == ZCL_CMD_DISCOVER        || \
     55                                                  (cmd) == ZCL_CMD_DEFAULT_RSP ) // exception
     56          
     57          /*********************************************************************
     58           * CONSTANTS
     59           */
     60          
     61          /*********************************************************************
     62           * TYPEDEFS
     63           */
     64          typedef struct zclLibPlugin
     65          {
     66            struct zclLibPlugin *next;
     67            uint16              startClusterID;    // starting cluster ID
     68            uint16              endClusterID;      // ending cluster ID
     69            zclInHdlr_t         pfnIncomingHdlr;    // function to handle incoming message
     70          } zclLibPlugin_t;
     71          
     72          // Attribute record list item
     73          typedef struct zclAttrRecsList
     74          {
     75            struct zclAttrRecsList *next;
     76            uint8                  endpoint;      // Used to link it into the endpoint descriptor
     77            uint8                  numAttributes; // Number of the following records
     78            CONST zclAttrRec_t     *attrs;        // attribute records
     79          } zclAttrRecsList;
     80          
     81          // Cluster option list item
     82          typedef struct zclClusterOptionList
     83          {
     84            struct zclClusterOptionList *next;
     85            uint8                       endpoint;   // Used to link it into the endpoint descriptor
     86            uint8                       numOptions; // Number of the following records
     87            zclOptionRec_t              *options;   // option records
     88          } zclClusterOptionList;
     89          
     90          typedef void *(*zclParseInProfileCmd_t)( zclParseCmd_t *pCmd );
     91          typedef uint8 (*zclProcessInProfileCmd_t)( zclIncoming_t *pInMsg );
     92          
     93          typedef struct
     94          {
     95            zclParseInProfileCmd_t   pfnParseInProfile;
     96            zclProcessInProfileCmd_t pfnProcessInProfile;
     97          } zclCmdItems_t;
     98          
     99          
    100          /*********************************************************************
    101           * GLOBAL VARIABLES
    102           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    103          uint8 zcl_TaskID;
   \                     zcl_TaskID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    104          
    105          // The task Id of the Application where the unprocessed Foundation
    106          // Command/Response messages will be sent to.

   \                                 In  segment XDATA_I, align 1, keep-with-next
    107          uint8 zcl_RegisteredMsgTaskID = TASK_NO_TASK;
   \                     zcl_RegisteredMsgTaskID:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for zcl_RegisteredMsgTaskID>`
   \   000001                REQUIRE __INIT_XDATA_I
    108          
    109          // The Application should register its attribute data validation function

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    110          zclValidateAttrData_t zcl_ValidateAttrDataCB = NULL;
   \                     zcl_ValidateAttrDataCB:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    111          
    112          // ZCL Sequence number

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    113          uint8 zcl_SeqNum = 0x00;
   \                     zcl_SeqNum:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    114             
    115          /*********************************************************************
    116           * EXTERNAL VARIABLES
    117           */
    118          
    119          /*********************************************************************
    120           * EXTERNAL FUNCTIONS
    121           */
    122          
    123          /*********************************************************************
    124           * LOCAL VARIABLES
    125           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    126          static zclLibPlugin_t *plugins;
   \                     plugins:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    127          static zclAttrRecsList *attrList;
   \                     attrList:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    128          static zclClusterOptionList *clusterOptionList;
   \                     clusterOptionList:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    129          static uint8 zcl_TransID = 0;  // This is the unique message ID (counter)
   \                     zcl_TransID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    130          
    131          /*********************************************************************
    132           * LOCAL FUNCTIONS
    133           */
    134          void zclProcessMessageMSG( afIncomingMSGPacket_t *pkt );  // Not static for ZNP build.
    135          
    136          void zclZigbeeReceiverMSG(afIncomingMSGPacket_t *msg);
    137          
    138          static uint8 *zclBuildHdr( zclFrameHdr_t *hdr, uint8 *pData );
    139          static uint8 zclCalcHdrSize( zclFrameHdr_t *hdr );
    140          static zclLibPlugin_t *zclFindPlugin( uint16 clusterID, uint16 profileID );
    141          static zclOptionRec_t *zclFindClusterOption( uint8 endpoint, uint16 clusterID );
    142          static uint8 zclGetClusterOption( uint8 endpoint, uint16 clusterID );
    143          static void zclSetSecurityOption( uint8 endpoint, uint16 clusterID, uint8 enable );
    144          
    145          static uint8 zcl_DeviceOperational( uint8 srcEP, uint16 clusterID, uint8 frameType, uint8 cmd, uint16 profileID );
    146          
    147          #if defined(ZCL_READ) || defined(ZCL_WRITE) || defined(ZCL_REPORT)
    148            static void zclSerializeData( uint8 dataType, void *attrData, uint8 *buf );
    149          #endif // ZCL_READ || ZCL_WRITE || ZCL_REPORT
    150          
    151          #ifdef ZCL_READ
    152            static void *zclParseInReadRspCmd( zclParseCmd_t *pCmd );
    153            static uint8 zclProcessInReadCmd( zclIncoming_t *pInMsg );
    154          #endif // ZCL_READ
    155          
    156          #ifdef ZCL_WRITE
    157            static uint8 zclWriteAttrData( zclAttrRec_t *pAttr, zclWriteRec_t *pWriteRec );
    158            static void *zclParseInWriteRspCmd( zclParseCmd_t *pCmd );
    159            static uint8 zclProcessInWriteCmd( zclIncoming_t *pInMsg );
    160            static uint8 zclProcessInWriteUndividedCmd( zclIncoming_t *pInMsg );
    161          #endif // ZCL_WRITE
    162          
    163          #ifdef ZCL_REPORT
    164            static void *zclParseInConfigReportRspCmd( zclParseCmd_t *pCmd );
    165            static void *zclParseInReadReportCfgRspCmd( zclParseCmd_t *pCmd );
    166          #endif // ZCL_REPORT
    167          
    168          static void *zclParseInDefaultRspCmd( zclParseCmd_t *pCmd );
    169          
    170          #ifdef ZCL_DISCOVER
    171            static uint8 zclFindNextAttrRec( uint8 endpoint, uint16 clusterID, uint16 *attrId, zclAttrRec_t *pAttr );
    172            static void *zclParseInDiscRspCmd( zclParseCmd_t *pCmd );
    173            static uint8 zclProcessInDiscCmd( zclIncoming_t *pInMsg );
    174          #endif // ZCL_DISCOVER
    175          
    176          static uint8 zclSendMsg( zclIncoming_t *pInMsg );
    177          
    178          /*********************************************************************
    179           * Parse Profile Command Function Table
    180           */

   \                                 In  segment CODE_C, align 1
    181          static CONST zclCmdItems_t zclCmdTable[] =
   \                     zclCmdTable:
   \   000000   ........     DW ??zclParseInReadCmd?relay, ??zclProcessInReadCmd?relay
   \   000004   ........     DW ??zclParseInReadRspCmd?relay, ??zclSendMsg?relay
   \   000008   ........     DW ??zclParseInWriteCmd?relay, ??zclProcessInWriteCmd?relay
   \   00000C   ........     DW ??zclParseInWriteCmd?relay, ??zclProcessInWriteUndividedCmd?relay
   \   000010   ........     DW ??zclParseInWriteRspCmd?relay, ??zclSendMsg?relay
   \   000014   ........     DW ??zclParseInWriteCmd?relay, ??zclProcessInWriteCmd?relay, 0H, 0H, 0H
   \            00000000
   \            0000    
   \   00001E   00000000     DW 0H, 0H, 0H, 0H, 0H, 0H, 0H, ??zclParseInDefaultRspCmd?relay
   \            00000000
   \            00000000
   \            0000....
   \   00002E   ....0000     DW ??zclSendMsg?relay, 0H, 0H, 0H, 0H
   \            00000000
   \            0000    
    182          {
    183          #ifdef ZCL_READ
    184            /* ZCL_CMD_READ */                { zclParseInReadCmd,             zclProcessInReadCmd             },
    185            /* ZCL_CMD_READ_RSP */            { zclParseInReadRspCmd,          zclSendMsg                      },
    186          #else
    187            /* ZCL_CMD_READ */                { NULL,                          NULL                            },
    188            /* ZCL_CMD_READ_RSP */            { NULL,                          NULL                            },
    189          #endif // ZCL_READ
    190          
    191          #ifdef ZCL_WRITE
    192            /* ZCL_CMD_WRITE */               { zclParseInWriteCmd,            zclProcessInWriteCmd            },
    193            /* ZCL_CMD_WRITE_UNDIVIDED */     { zclParseInWriteCmd,            zclProcessInWriteUndividedCmd   },
    194            /* ZCL_CMD_WRITE_RSP */           { zclParseInWriteRspCmd,         zclSendMsg                      },
    195            /* ZCL_CMD_WRITE_NO_RSP */        { zclParseInWriteCmd,            zclProcessInWriteCmd            },
    196          #else
    197            /* ZCL_CMD_WRITE */               { NULL,                          NULL                            },
    198            /* ZCL_CMD_WRITE_UNDIVIDED */     { NULL,                          NULL                            },
    199            /* ZCL_CMD_WRITE_RSP */           { NULL,                          NULL                            },
    200            /* ZCL_CMD_WRITE_NO_RSP */        { NULL,                          NULL                            },
    201          #endif // ZCL_WRITE
    202          
    203          #ifdef ZCL_REPORT
    204            /* ZCL_CMD_CONFIG_REPORT */       { zclParseInConfigReportCmd,     zclSendMsg                      },
    205            /* ZCL_CMD_CONFIG_REPORT_RSP */   { zclParseInConfigReportRspCmd,  zclSendMsg                      },
    206            /* ZCL_CMD_READ_REPORT_CFG */     { zclParseInReadReportCfgCmd,    zclSendMsg                      },
    207            /* ZCL_CMD_READ_REPORT_CFG_RSP */ { zclParseInReadReportCfgRspCmd, zclSendMsg                      },
    208            /* ZCL_CMD_REPORT */              { zclParseInReportCmd,           zclSendMsg                      },
    209          #else
    210            /* ZCL_CMD_CONFIG_REPORT */       { NULL,                          NULL                            },
    211            /* ZCL_CMD_CONFIG_REPORT_RSP */   { NULL,                          NULL                            },
    212            /* ZCL_CMD_READ_REPORT_CFG */     { NULL,                          NULL                            },
    213            /* ZCL_CMD_READ_REPORT_CFG_RSP */ { NULL,                          NULL                            },
    214            /* ZCL_CMD_REPORT */              { NULL,                          NULL                            },
    215          #endif // ZCL_REPORT
    216          
    217            /* ZCL_CMD_DEFAULT_RSP */         { zclParseInDefaultRspCmd,       zclSendMsg                      },
    218            
    219          #ifdef ZCL_DISCOVER  
    220            /* ZCL_CMD_DISCOVER */            { zclParseInDiscCmd,             zclProcessInDiscCmd             },
    221            /* ZCL_CMD_DISCOVER_RSP */        { zclParseInDiscRspCmd,          zclSendMsg                      }
    222          #else
    223            /* ZCL_CMD_DISCOVER */            { NULL,                          NULL                            },
    224            /* ZCL_CMD_DISCOVER_RSP */        { NULL,                          NULL                            }
    225          #endif // ZCL_DISCOVER
    226          };
    227          
    228          /*********************************************************************
    229           * PUBLIC FUNCTIONS
    230           *********************************************************************/
    231          
    232          /*********************************************************************
    233           * @fn          zcl_Init
    234           * @brief       Initialization function for the zcl layer.
    235           * @param       task_id - ZCL task id
    236           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    237          void zcl_Init( uint8 task_id )
   \                     zcl_Init:
    238          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    239            zcl_TaskID = task_id;
   \   000004   E9           MOV     A,R1
   \   000005   90....       MOV     DPTR,#zcl_TaskID
   \   000008   F0           MOVX    @DPTR,A
    240          
    241            plugins = (zclLibPlugin_t  *)NULL;
   \   000009   90....       MOV     DPTR,#plugins
   \   00000C   E4           CLR     A
   \   00000D   F0           MOVX    @DPTR,A
   \   00000E   A3           INC     DPTR
   \   00000F   F0           MOVX    @DPTR,A
    242            attrList = (zclAttrRecsList *)NULL;
   \   000010   90....       MOV     DPTR,#attrList
   \   000013   F0           MOVX    @DPTR,A
   \   000014   A3           INC     DPTR
   \   000015   F0           MOVX    @DPTR,A
    243            clusterOptionList = (zclClusterOptionList *)NULL;
   \   000016   90....       MOV     DPTR,#clusterOptionList
   \   000019   F0           MOVX    @DPTR,A
   \   00001A   A3           INC     DPTR
   \   00001B   F0           MOVX    @DPTR,A
    244          }
   \   00001C   02....       LJMP    ?Subroutine109 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine109:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET
    245          
    246          /*********************************************************************
    247           * @fn          zcl_event_loop
    248           * @brief       Event Loop Processor for zcl.
    249           * @param       task_id - task id
    250           *              events - event bitmap
    251           * @return      unprocessed events
    252           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    253          uint16 zcl_event_loop( uint8 task_id, uint16 events )
   \                     zcl_event_loop:
    254          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
    255            uint8 *msgPtr;
    256            (void)task_id;  // Intentionally unreferenced parameter
    257            
    258            if ( events & SYS_EVENT_MSG )
   \   000009   7480         MOV     A,#-0x80
   \   00000B   55..         ANL     A,?V0 + 1
   \   00000D   F9           MOV     R1,A
   \   00000E   E4           CLR     A
   \   00000F   7001         JNZ     ??zcl_event_loop_0
   \   000011   E9           MOV     A,R1
   \                     ??zcl_event_loop_0:
   \   000012   604B         JZ      ??zcl_event_loop_1
    259            {
    260              msgPtr = osal_msg_receive( zcl_TaskID );
   \   000014                ; Setup parameters for call to function osal_msg_receive
   \   000014   800E         SJMP    ??zcl_event_loop_2
    261              while ( msgPtr != NULL )
    262              {
    263                uint8 dealloc = TRUE;
    264                
    265                if ( *msgPtr == AF_INCOMING_MSG_CMD )
    266                {
    267                  zclProcessMessageMSG( (afIncomingMSGPacket_t *)msgPtr );
   \                     ??zcl_event_loop_3:
   \   000016                ; Setup parameters for call to function zclProcessMessageMSG
   \   000016   EE           MOV     A,R6
   \   000017   FA           MOV     R2,A
   \   000018   EF           MOV     A,R7
   \   000019   FB           MOV     R3,A
   \   00001A   12....       LCALL   ??zclProcessMessageMSG?relay
    268                }
    269                else if ( zcl_RegisteredMsgTaskID != TASK_NO_TASK )
    270                {
    271                  osal_msg_send( zcl_RegisteredMsgTaskID, msgPtr ); // send it to another task to process.
    272                  dealloc = FALSE;
    273                }
    274                if ( dealloc ) // Release the memory
    275                {
    276                  osal_msg_deallocate( msgPtr );
   \                     ??zcl_event_loop_4:
   \   00001D                ; Setup parameters for call to function osal_msg_deallocate
   \   00001D   EE           MOV     A,R6
   \   00001E   FA           MOV     R2,A
   \   00001F   EF           MOV     A,R7
   \   000020   FB           MOV     R3,A
   \   000021   12....       LCALL   ??osal_msg_deallocate?relay
    277                }
    278                msgPtr = osal_msg_receive( zcl_TaskID ); // Next
   \                     ??zcl_event_loop_2:
   \   000024                ; Setup parameters for call to function osal_msg_receive
   \   000024   90....       MOV     DPTR,#zcl_TaskID
   \   000027   E0           MOVX    A,@DPTR
   \   000028   F9           MOV     R1,A
   \   000029   12....       LCALL   ??osal_msg_receive?relay
   \   00002C   8A..         MOV     ?V0 + 2,R2
   \   00002E   8B..         MOV     ?V0 + 3,R3
   \   000030   AE..         MOV     R6,?V0 + 2
   \   000032   AF..         MOV     R7,?V0 + 3
   \   000034   EE           MOV     A,R6
   \   000035   7001         JNZ     ??zcl_event_loop_5
   \   000037   EF           MOV     A,R7
   \                     ??zcl_event_loop_5:
   \   000038   601C         JZ      ??zcl_event_loop_6
   \   00003A   8E82         MOV     DPL,R6
   \   00003C   8F83         MOV     DPH,R7
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   641A         XRL     A,#0x1a
   \   000041   60D3         JZ      ??zcl_event_loop_3
   \   000043   90....       MOV     DPTR,#zcl_RegisteredMsgTaskID
   \   000046   E0           MOVX    A,@DPTR
   \   000047   64FF         XRL     A,#0xff
   \   000049   60D2         JZ      ??zcl_event_loop_4
   \   00004B                ; Setup parameters for call to function osal_msg_send
   \   00004B   EE           MOV     A,R6
   \   00004C   FA           MOV     R2,A
   \   00004D   EF           MOV     A,R7
   \   00004E   FB           MOV     R3,A
   \   00004F   E0           MOVX    A,@DPTR
   \   000050   F9           MOV     R1,A
   \   000051   12....       LCALL   ??osal_msg_send?relay
   \   000054   80CE         SJMP    ??zcl_event_loop_2
    279              } 
    280              return (events ^ SYS_EVENT_MSG);// return unprocessed events
   \                     ??zcl_event_loop_6:
   \   000056   AA..         MOV     R2,?V0 + 0
   \   000058   7480         MOV     A,#-0x80
   \   00005A   65..         XRL     A,?V0 + 1
   \   00005C   FB           MOV     R3,A
   \   00005D   8004         SJMP    ??zcl_event_loop_7
    281            }
    282            return 0; // Discard unknown events
   \                     ??zcl_event_loop_1:
   \   00005F   7A00         MOV     R2,#0x0
   \   000061   7B00         MOV     R3,#0x0
   \                     ??zcl_event_loop_7:
   \   000063   02....       LJMP    ?Subroutine110 & 0xFFFF
    283          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine110:
   \   000000   7F04         MOV     R7,#0x4
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    284          
    285          /*********************************************************************
    286           * @fn          zcl_registerPlugin
    287           * @brief       Add a Cluster Library handler
    288           * @param       startClusterID - starting cluster ID
    289           *              endClusterID - ending cluster ID
    290           *              pfnHdlr - function pointer to incoming message handler
    291           * @return      ZSuccess if OK
    292           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    293          ZStatus_t zcl_registerPlugin( uint16 startClusterID,
   \                     zcl_registerPlugin:
    294                    uint16 endClusterID, zclInHdlr_t pfnIncomingHdlr )
    295          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
   \   000009   8C..         MOV     ?V0 + 2,R4
   \   00000B   8D..         MOV     ?V0 + 3,R5
   \   00000D   740E         MOV     A,#0xe
   \   00000F   12....       LCALL   ?XSTACK_DISP0_8
   \   000012   12....       LCALL   ?Subroutine39 & 0xFFFF
    296            zclLibPlugin_t *pNewItem;
    297            zclLibPlugin_t *pLoop;
    298          
    299            // Fill in the new profile list
    300            pNewItem = osal_mem_alloc( sizeof( zclLibPlugin_t ) );
   \                     ??CrossCallReturnLabel_46:
   \   000015                ; Setup parameters for call to function osal_mem_alloc
   \   000015   7A08         MOV     R2,#0x8
   \   000017   7B00         MOV     R3,#0x0
   \   000019   12....       LCALL   ??osal_mem_alloc?relay
   \   00001C   8A..         MOV     ?V0 + 4,R2
   \   00001E   8B..         MOV     ?V0 + 5,R3
   \   000020   A8..         MOV     R0,?V0 + 4
   \   000022   A9..         MOV     R1,?V0 + 5
    301            if ( pNewItem == NULL )
   \   000024   E8           MOV     A,R0
   \   000025   7001         JNZ     ??zcl_registerPlugin_0
   \   000027   E9           MOV     A,R1
   \                     ??zcl_registerPlugin_0:
   \   000028   7004         JNZ     ??zcl_registerPlugin_1
    302              return (ZMemError);
   \   00002A   7910         MOV     R1,#0x10
   \   00002C   8051         SJMP    ??CrossCallReturnLabel_14
    303          
    304            // Fill in the plugin record.
    305            pNewItem->next = (zclLibPlugin_t *)NULL;
   \                     ??zcl_registerPlugin_1:
   \   00002E   8882         MOV     DPL,R0
   \   000030   8983         MOV     DPH,R1
   \   000032   E4           CLR     A
   \   000033   F0           MOVX    @DPTR,A
   \   000034   A3           INC     DPTR
   \   000035   12....       LCALL   ?Subroutine14 & 0xFFFF
    306            pNewItem->startClusterID = startClusterID;
   \                     ??CrossCallReturnLabel_19:
   \   000038   A3           INC     DPTR
   \   000039   E5..         MOV     A,?V0 + 0
   \   00003B   F0           MOVX    @DPTR,A
   \   00003C   A3           INC     DPTR
   \   00003D   E5..         MOV     A,?V0 + 1
   \   00003F   12....       LCALL   ?Subroutine14 & 0xFFFF
    307            pNewItem->endClusterID = endClusterID;
   \                     ??CrossCallReturnLabel_20:
   \   000042   A3           INC     DPTR
   \   000043   A3           INC     DPTR
   \   000044   A3           INC     DPTR
   \   000045   E5..         MOV     A,?V0 + 2
   \   000047   F0           MOVX    @DPTR,A
   \   000048   A3           INC     DPTR
   \   000049   E5..         MOV     A,?V0 + 3
   \   00004B   F0           MOVX    @DPTR,A
    308            pNewItem->pfnIncomingHdlr = pfnIncomingHdlr;
   \   00004C   EE           MOV     A,R6
   \   00004D   FA           MOV     R2,A
   \   00004E   EF           MOV     A,R7
   \   00004F   FB           MOV     R3,A
   \   000050   8882         MOV     DPL,R0
   \   000052   8983         MOV     DPH,R1
   \   000054   A3           INC     DPTR
   \   000055   A3           INC     DPTR
   \   000056   A3           INC     DPTR
   \   000057   A3           INC     DPTR
   \   000058   12....       LCALL   ?Subroutine17 & 0xFFFF
    309          
    310            if (  plugins == NULL ) // Find spot in list
   \                     ??CrossCallReturnLabel_310:
   \   00005B   90....       MOV     DPTR,#plugins
   \   00005E   E0           MOVX    A,@DPTR
   \   00005F   7002         JNZ     ??zcl_registerPlugin_2
   \   000061   A3           INC     DPTR
   \   000062   E0           MOVX    A,@DPTR
   \                     ??zcl_registerPlugin_2:
   \   000063   90....       MOV     DPTR,#plugins
   \   000066   6014         JZ      ??zcl_registerPlugin_3
    311            {
    312              plugins = pNewItem;
    313            }
    314            else
    315            {
    316              // Look for end of list
    317              pLoop = plugins;
   \   000068   12....       LCALL   ?Subroutine90 & 0xFFFF
   \                     ??CrossCallReturnLabel_274:
   \   00006B   8003         SJMP    ??zcl_registerPlugin_4
    318              while ( pLoop->next != NULL )
    319                pLoop = pLoop->next;
   \                     ??zcl_registerPlugin_5:
   \   00006D   EA           MOV     A,R2
   \   00006E   FC           MOV     R4,A
   \   00006F   EB           MOV     A,R3
   \                     ??zcl_registerPlugin_4:
   \   000070   12....       LCALL   ?Subroutine33 & 0xFFFF
   \                     ??CrossCallReturnLabel_176:
   \   000073   7001         JNZ     ??zcl_registerPlugin_6
   \   000075   EB           MOV     A,R3
   \                     ??zcl_registerPlugin_6:
   \   000076   70F5         JNZ     ??zcl_registerPlugin_5
    320          
    321              pLoop->next = pNewItem; // Put new item at end of list
   \   000078   8C82         MOV     DPL,R4
   \   00007A   8D83         MOV     DPH,R5
    322            }
   \                     ??zcl_registerPlugin_3:
   \   00007C   12....       LCALL   ?Subroutine11 & 0xFFFF
    323            return ( ZSuccess );
   \                     ??CrossCallReturnLabel_14:
   \   00007F                REQUIRE ?Subroutine111
   \   00007F                ; // Fall through to label ?Subroutine111
    324          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine111:
   \   000000   7F06         MOV     R7,#0x6
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine33:
   \   000000   FD           MOV     R5,A
   \   000001   8C82         MOV     DPL,R4
   \   000003   8D83         MOV     DPH,R5
   \   000005                REQUIRE ??Subroutine126_0
   \   000005                ; // Fall through to label ??Subroutine126_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine126_0:
   \   000000   12....       LCALL   ??Subroutine138_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_284:
   \   000003   EA           MOV     A,R2
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004   F0           MOVX    @DPTR,A
   \   000005   7900         MOV     R1,#0x0
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   12....       LCALL   ?Subroutine100 & 0xFFFF
   \                     ??CrossCallReturnLabel_142:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine100:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8882         MOV     DPL,R0
   \   000003   8983         MOV     DPH,R1
   \   000005   A3           INC     DPTR
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine90:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FC           MOV     R4,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine138_0:
   \   000000   12....       LCALL   ?Subroutine103 & 0xFFFF
   \                     ??CrossCallReturnLabel_293:
   \   000003   FB           MOV     R3,A
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine103:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine39:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FE           MOV     R6,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FF           MOV     R7,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine152_0
   \   000002                ; // Fall through to label ??Subroutine152_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine152_0:
   \   000000   EA           MOV     A,R2
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   EB           MOV     A,R3
   \   000004   F0           MOVX    @DPTR,A
   \   000005   22           RET
    325          
    326          /*********************************************************************
    327           * @fn          zcl_registerAttrList
    328           * @brief       Register an Attribute List with ZCL Foundation
    329           * @param       endpoint - endpoint the attribute list belongs to
    330           *              numAttr - number of attributes in list
    331           *              newAttrList - array of Attribute records.
    332           *
    333           *              NOTE: THE ATTRIBUTE IDs (FOR A CLUSTER) MUST BE IN ASCENDING ORDER.
    334           *                    OTHERWISE, THE DISCOVERY RESPONSE COMMAND WILL NOT HAVE THE RIGHT ATTRIBUTE INFO
    335           * @return      ZSuccess if OK
    336           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    337          ZStatus_t zcl_registerAttrList( uint8 endpoint, uint8 numAttr, CONST zclAttrRec_t newAttrList[] )
   \                     zcl_registerAttrList:
    338          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   12....       LCALL   ?Subroutine63 & 0xFFFF
    339            zclAttrRecsList *pNewItem;
    340            zclAttrRecsList *pLoop;
    341          
    342            pNewItem = osal_mem_alloc( sizeof( zclAttrRecsList ) ); // Fill in the new profile list
    343            if ( pNewItem == NULL )
   \                     ??CrossCallReturnLabel_85:
   \   000008   7001         JNZ     ??zcl_registerAttrList_0
   \   00000A   E9           MOV     A,R1
   \                     ??zcl_registerAttrList_0:
   \   00000B   7004         JNZ     ??zcl_registerAttrList_1
    344              return (ZMemError);
   \   00000D   7910         MOV     R1,#0x10
   \   00000F   8027         SJMP    ??CrossCallReturnLabel_15
    345          
    346            pNewItem->next = (zclAttrRecsList *)NULL;
   \                     ??zcl_registerAttrList_1:
   \   000011   12....       LCALL   ?Subroutine0 & 0xFFFF
    347            pNewItem->endpoint = endpoint;
    348            pNewItem->numAttributes = numAttr;
    349            pNewItem->attrs = newAttrList;
    350          
    351            if ( attrList == NULL ) // Find spot in list
   \                     ??CrossCallReturnLabel_0:
   \   000014   90....       MOV     DPTR,#attrList
   \   000017   E0           MOVX    A,@DPTR
   \   000018   7002         JNZ     ??zcl_registerAttrList_2
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \                     ??zcl_registerAttrList_2:
   \   00001C   90....       MOV     DPTR,#attrList
   \   00001F   6014         JZ      ??zcl_registerAttrList_3
    352            {
    353              attrList = pNewItem;
    354            }
    355            else
    356            {
    357              pLoop = attrList; // Look for end of list
   \   000021   12....       LCALL   ?Subroutine90 & 0xFFFF
   \                     ??CrossCallReturnLabel_275:
   \   000024   8003         SJMP    ??zcl_registerAttrList_4
    358              while ( pLoop->next != NULL )
    359                pLoop = pLoop->next;
   \                     ??zcl_registerAttrList_5:
   \   000026   EA           MOV     A,R2
   \   000027   FC           MOV     R4,A
   \   000028   EB           MOV     A,R3
   \                     ??zcl_registerAttrList_4:
   \   000029   12....       LCALL   ?Subroutine33 & 0xFFFF
   \                     ??CrossCallReturnLabel_177:
   \   00002C   7001         JNZ     ??zcl_registerAttrList_6
   \   00002E   EB           MOV     A,R3
   \                     ??zcl_registerAttrList_6:
   \   00002F   70F5         JNZ     ??zcl_registerAttrList_5
    360          
    361              pLoop->next = pNewItem; // Put new item at end of list
   \   000031   8C82         MOV     DPL,R4
   \   000033   8D83         MOV     DPH,R5
    362            }
   \                     ??zcl_registerAttrList_3:
   \   000035   12....       LCALL   ?Subroutine11 & 0xFFFF
    363            return ( ZSuccess );
   \                     ??CrossCallReturnLabel_15:
   \   000038   02....       LJMP    ?Subroutine110 & 0xFFFF
    364          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine63:
   \   000000   89..         MOV     ?V0 + 0,R1
   \   000002   8A..         MOV     ?V0 + 1,R2
   \   000004   EC           MOV     A,R4
   \   000005   FE           MOV     R6,A
   \   000006   ED           MOV     A,R5
   \   000007   FF           MOV     R7,A
   \   000008                ; Setup parameters for call to function osal_mem_alloc
   \   000008                ; Setup parameters for call to function osal_mem_alloc
   \   000008   7A06         MOV     R2,#0x6
   \   00000A   7B00         MOV     R3,#0x0
   \   00000C   12....       LCALL   ??osal_mem_alloc?relay
   \   00000F   8A..         MOV     ?V0 + 2,R2
   \   000011   8B..         MOV     ?V0 + 3,R3
   \   000013   A8..         MOV     R0,?V0 + 2
   \   000015   A9..         MOV     R1,?V0 + 3
   \   000017   E8           MOV     A,R0
   \   000018   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   8882         MOV     DPL,R0
   \   000002   8983         MOV     DPH,R1
   \   000004   E4           CLR     A
   \   000005   F0           MOVX    @DPTR,A
   \   000006   A3           INC     DPTR
   \   000007   12....       LCALL   ?Subroutine100 & 0xFFFF
   \                     ??CrossCallReturnLabel_140:
   \   00000A   A3           INC     DPTR
   \   00000B   E5..         MOV     A,?V0 + 0
   \   00000D   12....       LCALL   ?Subroutine81 & 0xFFFF
   \                     ??CrossCallReturnLabel_114:
   \   000010   E5..         MOV     A,?V0 + 1
   \   000012   12....       LCALL   ?Subroutine81 & 0xFFFF
   \                     ??CrossCallReturnLabel_115:
   \   000015   A3           INC     DPTR
   \   000016   EE           MOV     A,R6
   \   000017   F0           MOVX    @DPTR,A
   \   000018   A3           INC     DPTR
   \   000019   EF           MOV     A,R7
   \   00001A   F0           MOVX    @DPTR,A
   \   00001B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine81:
   \   000000   12....       LCALL   ?Subroutine100 & 0xFFFF
   \                     ??CrossCallReturnLabel_141:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   22           RET
    365          
    366          /*********************************************************************
    367           * @fn          zcl_registerClusterOptionList
    368           * @brief       Register a Cluster Option List with ZCL Foundation
    369           * @param       endpoint - endpoint the option list belongs to
    370           *              numOption - number of options in list
    371           *              optionList - array of cluster option records.
    372           *                           
    373           *              NOTE: This API should be called to enable 'Application Link Key' security and/or
    374           *                    'APS ACK' for a specific Cluster. The 'Application Link Key' is discarded 
    375           *                    if security isn't enabled on the device. The default behavior is 'Network Key'
    376           *                    when security is enabled and no 'APS ACK' for the ZCL messages.
    377           * @return      ZSuccess if OK
    378           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    379          ZStatus_t zcl_registerClusterOptionList( uint8 endpoint, uint8 numOption, zclOptionRec_t optionList[] )
   \                     zcl_registerClusterOptionList:
    380          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   12....       LCALL   ?Subroutine63 & 0xFFFF
    381            zclClusterOptionList *pNewItem;
    382            zclClusterOptionList *pLoop;
    383          
    384            // Fill in the new profile list
    385            pNewItem = osal_mem_alloc( sizeof( zclClusterOptionList ) );
    386            if ( pNewItem == NULL )
   \                     ??CrossCallReturnLabel_86:
   \   000008   7001         JNZ     ??zcl_registerClusterOptionList_0
   \   00000A   E9           MOV     A,R1
   \                     ??zcl_registerClusterOptionList_0:
   \   00000B   7004         JNZ     ??zcl_registerClusterOptionList_1
    387              return (ZMemError);
   \   00000D   7910         MOV     R1,#0x10
   \   00000F   8027         SJMP    ??CrossCallReturnLabel_16
    388          
    389            pNewItem->next = (zclClusterOptionList *)NULL;
   \                     ??zcl_registerClusterOptionList_1:
   \   000011   12....       LCALL   ?Subroutine0 & 0xFFFF
    390            pNewItem->endpoint = endpoint;
    391            pNewItem->numOptions = numOption;
    392            pNewItem->options = optionList;
    393          
    394            // Find spot in list
    395            if ( clusterOptionList == NULL )
   \                     ??CrossCallReturnLabel_1:
   \   000014   90....       MOV     DPTR,#clusterOptionList
   \   000017   E0           MOVX    A,@DPTR
   \   000018   7002         JNZ     ??zcl_registerClusterOptionList_2
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \                     ??zcl_registerClusterOptionList_2:
   \   00001C   90....       MOV     DPTR,#clusterOptionList
   \   00001F   6014         JZ      ??zcl_registerClusterOptionList_3
    396            {
    397              clusterOptionList = pNewItem;
    398            }
    399            else
    400            {
    401              // Look for end of list
    402              pLoop = clusterOptionList;
   \   000021   12....       LCALL   ?Subroutine90 & 0xFFFF
   \                     ??CrossCallReturnLabel_276:
   \   000024   8003         SJMP    ??zcl_registerClusterOptionList_4
    403              while ( pLoop->next != NULL )
    404                pLoop = pLoop->next;
   \                     ??zcl_registerClusterOptionList_5:
   \   000026   EA           MOV     A,R2
   \   000027   FC           MOV     R4,A
   \   000028   EB           MOV     A,R3
   \                     ??zcl_registerClusterOptionList_4:
   \   000029   12....       LCALL   ?Subroutine33 & 0xFFFF
   \                     ??CrossCallReturnLabel_178:
   \   00002C   7001         JNZ     ??zcl_registerClusterOptionList_6
   \   00002E   EB           MOV     A,R3
   \                     ??zcl_registerClusterOptionList_6:
   \   00002F   70F5         JNZ     ??zcl_registerClusterOptionList_5
    405          
    406              // Put new item at end of list
    407              pLoop->next = pNewItem;
   \   000031   8C82         MOV     DPL,R4
   \   000033   8D83         MOV     DPH,R5
    408            }
   \                     ??zcl_registerClusterOptionList_3:
   \   000035   12....       LCALL   ?Subroutine11 & 0xFFFF
    409          
    410            return ( ZSuccess );
   \                     ??CrossCallReturnLabel_16:
   \   000038   02....       LJMP    ?Subroutine110 & 0xFFFF
    411          }
    412          
    413          /*********************************************************************
    414           * @fn          zcl_registerValidateAttrData
    415           * @brief       Add a validation function for attribute data
    416           * @param       pfnValidateAttrData - function pointer to validate routine
    417           * @return      ZSuccess if OK
    418           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    419          ZStatus_t zcl_registerValidateAttrData( zclValidateAttrData_t pfnValidateAttrData )
   \                     zcl_registerValidateAttrData:
    420          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    421            zcl_ValidateAttrDataCB = pfnValidateAttrData;
   \   000004   90....       MOV     DPTR,#zcl_ValidateAttrDataCB
   \   000007   12....       LCALL   ??Subroutine152_0 & 0xFFFF
    422            
    423            return ( ZSuccess );
   \                     ??CrossCallReturnLabel_306:
   \   00000A   7900         MOV     R1,#0x0
   \   00000C   80..         SJMP    ?Subroutine109
    424          }
    425          
    426          /*********************************************************************
    427           * @fn      zcl_registerForMsg
    428           * @brief   The ZCL is setup to send all incoming Foundation Command/Response
    429           *          messages that aren't processed to one task (if a task is
    430           *          registered).
    431           * @param   taskId - task Id of the Application where commands will be sent to
    432           * @return  TRUE if task registeration successful, FALSE otherwise
    433           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    434          uint8 zcl_registerForMsg( uint8 taskId )
   \                     zcl_registerForMsg:
    435          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    436            // Allow only the first task
    437            if ( zcl_RegisteredMsgTaskID == TASK_NO_TASK )
   \   000004   90....       MOV     DPTR,#zcl_RegisteredMsgTaskID
   \   000007   E0           MOVX    A,@DPTR
   \   000008   64FF         XRL     A,#0xff
   \   00000A   7006         JNZ     ??zcl_registerForMsg_0
    438            {
    439              zcl_RegisteredMsgTaskID = taskId;  
   \   00000C   E9           MOV     A,R1
   \   00000D   F0           MOVX    @DPTR,A
    440              return ( true );
   \   00000E   7901         MOV     R1,#0x1
   \   000010   8002         SJMP    ??zcl_registerForMsg_1
    441            }
    442            return ( false );
   \                     ??zcl_registerForMsg_0:
   \   000012   7900         MOV     R1,#0x0
   \                     ??zcl_registerForMsg_1:
   \   000014                REQUIRE ?Subroutine109
   \   000014                ; // Fall through to label ?Subroutine109
    443          }
    444          
    445          /*********************************************************************
    446           * @fn      zcl_DeviceOperational
    447           * @brief   Used to see whether or not the device can send or respond 
    448           *          to application level commands.
    449           * @param   srcEP - source endpoint
    450           *          clusterID - cluster ID
    451           *          frameType - command type
    452           *          cmd - command ID
    453           * @return  TRUE if device is operational, FALSE otherwise
    454           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    455          static uint8 zcl_DeviceOperational( uint8 srcEP, uint16 clusterID, 
   \                     zcl_DeviceOperational:
    456                                              uint8 frameType, uint8 cmd, uint16 profileID )
    457          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 9
   \   000005   74F7         MOV     A,#-0x9
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    458            zclAttrRec_t attrRec;
    459            uint8 deviceEnabled = DEVICE_ENABLED; // default value
   \   00000A   7401         MOV     A,#0x1
   \   00000C   85..82       MOV     DPL,?XSP + 0
   \   00000F   85..83       MOV     DPH,?XSP + 1
   \   000012   F0           MOVX    @DPTR,A
    460            
    461            (void)profileID;  // Intentionally unreferenced parameter
    462            
    463            // If the device is Disabled (DeviceEnabled attribute is set to Disabled), it 
    464            // cannot send or respond to application level commands, other than commands
    465            // to read or write attributes. Note that the Identify cluster cannot be 
    466            // disabled, and remains functional regardless of this setting.
    467            if ( zcl_ProfileCmd( frameType ) && cmd <= ZCL_CMD_WRITE_NO_RSP )
   \   000013   EC           MOV     A,R4
   \   000014   700A         JNZ     ??zcl_DeviceOperational_0
   \   000016   ED           MOV     A,R5
   \   000017   C3           CLR     C
   \   000018   9406         SUBB    A,#0x6
   \   00001A   5004         JNC     ??zcl_DeviceOperational_0
    468              return ( TRUE );
   \                     ??zcl_DeviceOperational_1:
   \   00001C   7901         MOV     R1,#0x1
   \   00001E   804E         SJMP    ??zcl_DeviceOperational_2
    469            
    470            if ( clusterID == ZCL_CLUSTER_ID_GEN_IDENTIFY )
   \                     ??zcl_DeviceOperational_0:
   \   000020   7403         MOV     A,#0x3
   \   000022   6A           XRL     A,R2
   \   000023   7001         JNZ     ??zcl_DeviceOperational_3
   \   000025   EB           MOV     A,R3
   \                     ??zcl_DeviceOperational_3:
   \   000026   60F4         JZ      ??zcl_DeviceOperational_1
    471              return ( TRUE );
    472            
    473            // Is device enabled?
    474            if ( zclFindAttrRec( srcEP, ZCL_CLUSTER_ID_GEN_BASIC, ATTRID_BASIC_DEVICE_ENABLED, &attrRec ) )
   \   000028                ; Setup parameters for call to function zclFindAttrRec
   \   000028   7401         MOV     A,#0x1
   \   00002A   12....       LCALL   ?XSTACK_DISP0_8
   \   00002D   8582..       MOV     ?V0 + 0,DPL
   \   000030   8583..       MOV     ?V0 + 1,DPH
   \   000033   78..         MOV     R0,#?V0 + 0
   \   000035   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000038   7C12         MOV     R4,#0x12
   \   00003A   7D00         MOV     R5,#0x0
   \   00003C   7A00         MOV     R2,#0x0
   \   00003E   7B00         MOV     R3,#0x0
   \   000040   12....       LCALL   ??zclFindAttrRec?relay
   \   000043   7402         MOV     A,#0x2
   \   000045   12....       LCALL   ?DEALLOC_XSTACK8
   \   000048   E9           MOV     A,R1
   \   000049   6016         JZ      ??zcl_DeviceOperational_4
    475              zclReadAttrData( &deviceEnabled, &attrRec );
   \   00004B                ; Setup parameters for call to function zclReadAttrData
   \   00004B   7401         MOV     A,#0x1
   \   00004D   12....       LCALL   ?XSTACK_DISP0_8
   \   000050   AC82         MOV     R4,DPL
   \   000052   AD83         MOV     R5,DPH
   \   000054   85..82       MOV     DPL,?XSP + 0
   \   000057   85..83       MOV     DPH,?XSP + 1
   \   00005A   AA82         MOV     R2,DPL
   \   00005C   AB83         MOV     R3,DPH
   \   00005E   12....       LCALL   ??zclReadAttrData?relay
    476            
    477            return ( deviceEnabled == DEVICE_ENABLED ? TRUE : FALSE );
   \                     ??zcl_DeviceOperational_4:
   \   000061   85..82       MOV     DPL,?XSP + 0
   \   000064   85..83       MOV     DPH,?XSP + 1
   \   000067   E0           MOVX    A,@DPTR
   \   000068   6401         XRL     A,#0x1
   \   00006A   60B0         JZ      ??zcl_DeviceOperational_1
   \   00006C   7900         MOV     R1,#0x0
   \                     ??zcl_DeviceOperational_2:
   \   00006E   7409         MOV     A,#0x9
   \   000070   12....       LCALL   ?DEALLOC_XSTACK8
   \   000073   02....       LJMP    ?Subroutine119 & 0xFFFF
    478          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine119:
   \   000000   7F02         MOV     R7,#0x2
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    479          
    480          /*********************************************************************
    481           * @fn      zcl_SendCommand
    482           * @brief   Used to send Profile and Cluster Specific Command messages.
    483           *          NOTE: The calling application is responsible for incrementing the Sequence Number.                
    484           * @param   srcEp - source endpoint
    485           *          destAddr - destination address 
    486           *          clusterID - cluster ID
    487           *          cmd - command ID
    488           *          specific - whether the command is Cluster Specific
    489           *          direction - client/server direction of the command
    490           *          disableDefaultRsp - disable Default Response command
    491           *          manuCode - manufacturer code for proprietary extensions to a profile
    492           *          seqNumber - identification number for the transaction
    493           *          cmdFormatLen - length of the command to be sent
    494           *          cmdFormat - command to be sent
    495           * @return  ZSuccess if OK
    496           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    497          ZStatus_t zcl_SendCommand( uint8 srcEP, afAddrType_t *destAddr,
   \                     zcl_SendCommand:
    498                                     uint16 clusterID, uint8 cmd, uint8 specific, uint8 direction,
    499                                     uint8 disableDefaultRsp, uint16 manuCode, uint8 seqNum,
    500                                     uint16 cmdFormatLen, uint8 *cmdFormat )
    501          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 18
   \   000005   74EE         MOV     A,#-0x12
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FF           MOV     R7,A
   \   00000C   8C..         MOV     ?V0 + 0,R4
   \   00000E   8D..         MOV     ?V0 + 1,R5
   \   000010   742A         MOV     A,#0x2a
   \   000012   12....       LCALL   ?XSTACK_DISP0_8
   \   000015   E0           MOVX    A,@DPTR
   \   000016   FE           MOV     R6,A
   \   000017   742B         MOV     A,#0x2b
   \   000019   12....       LCALL   ?XSTACK_DISP0_8
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   F5..         MOV     ?V0 + 3,A
   \   00001F   742C         MOV     A,#0x2c
   \   000021   12....       LCALL   ?XSTACK_DISP0_8
   \   000024   E0           MOVX    A,@DPTR
   \   000025   F5..         MOV     ?V0 + 9,A
   \   000027   742D         MOV     A,#0x2d
   \   000029   12....       LCALL   ?XSTACK_DISP0_8
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   F5..         MOV     ?V0 + 8,A
   \   00002F   742E         MOV     A,#0x2e
   \   000031   12....       LCALL   ?XSTACK_DISP0_8
   \   000034   E0           MOVX    A,@DPTR
   \   000035   F5..         MOV     ?V0 + 12,A
   \   000037   A3           INC     DPTR
   \   000038   E0           MOVX    A,@DPTR
   \   000039   F5..         MOV     ?V0 + 13,A
   \   00003B   7430         MOV     A,#0x30
   \   00003D   12....       LCALL   ?XSTACK_DISP0_8
   \   000040   E0           MOVX    A,@DPTR
   \   000041   F5..         MOV     ?V0 + 7,A
   \   000043   7431         MOV     A,#0x31
   \   000045   12....       LCALL   ?XSTACK_DISP0_8
   \   000048   E0           MOVX    A,@DPTR
   \   000049   F5..         MOV     ?V0 + 14,A
   \   00004B   A3           INC     DPTR
   \   00004C   E0           MOVX    A,@DPTR
   \   00004D   F5..         MOV     ?V0 + 15,A
    502            endPointDesc_t *epDesc;
    503            zclFrameHdr_t hdr;
    504            uint8 *msgBuf;
    505            uint16 msgLen;
    506            uint8 *pBuf;
    507            afAddrType_t dstAddr;
    508            uint8 options;
    509            ZStatus_t status;
    510          
    511            osal_memcpy( &dstAddr, destAddr, sizeof ( afAddrType_t ) );
   \   00004F                ; Setup parameters for call to function osal_memcpy
   \   00004F   8A..         MOV     ?V0 + 4,R2
   \   000051   8B..         MOV     ?V0 + 5,R3
   \   000053   75..00       MOV     ?V0 + 6,#0x0
   \   000056   78..         MOV     R0,#?V0 + 4
   \   000058   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00005B   7C0C         MOV     R4,#0xc
   \   00005D   7D00         MOV     R5,#0x0
   \   00005F   7409         MOV     A,#0x9
   \   000061   12....       LCALL   ?XSTACK_DISP0_8
   \   000064   AA82         MOV     R2,DPL
   \   000066   AB83         MOV     R3,DPH
   \   000068   12....       LCALL   ?Subroutine113 & 0xFFFF
   \                     ??CrossCallReturnLabel_159:
   \   00006B   12....       LCALL   ?DEALLOC_XSTACK8
    512          
    513            epDesc = afFindEndPointDesc( srcEP );
   \   00006E                ; Setup parameters for call to function afFindEndPointDesc
   \   00006E   EF           MOV     A,R7
   \   00006F   F9           MOV     R1,A
   \   000070   12....       LCALL   ??afFindEndPointDesc?relay
   \   000073   8A..         MOV     ?V0 + 10,R2
   \   000075   8B..         MOV     ?V0 + 11,R3
    514            if ( epDesc == NULL )
   \   000077   EA           MOV     A,R2
   \   000078   7001         JNZ     ??zcl_SendCommand_0
   \   00007A   EB           MOV     A,R3
   \                     ??zcl_SendCommand_0:
   \   00007B   7005         JNZ     ??zcl_SendCommand_1
    515              return ( ZInvalidParameter ); // EMBEDDED RETURN
   \                     ??zcl_SendCommand_2:
   \   00007D   7902         MOV     R1,#0x2
   \   00007F   02....       LJMP    ??zcl_SendCommand_3 & 0xFFFF
    516          
    517            if ( clusterID == ZCL_INVALID_CLUSTER_ID )
   \                     ??zcl_SendCommand_1:
   \   000082   74FF         MOV     A,#-0x1
   \   000084   65..         XRL     A,?V0 + 0
   \   000086   7004         JNZ     ??zcl_SendCommand_4
   \   000088   74FF         MOV     A,#-0x1
   \   00008A   65..         XRL     A,?V0 + 1
   \                     ??zcl_SendCommand_4:
   \   00008C   60EF         JZ      ??zcl_SendCommand_2
    518              return ( ZInvalidParameter ); // EMBEDDED RETURN
    519          
    520          #if defined ( INTER_PAN )
    521            if ( StubAPS_InterPan( destAddr->panId, destAddr->endPoint ) )
    522              options = AF_TX_OPTIONS_NONE;
    523            else
    524          #endif
    525              options = zclGetClusterOption( srcEP, clusterID );
   \   00008E                ; Setup parameters for call to function zclGetClusterOption
   \   00008E   AA..         MOV     R2,?V0 + 0
   \   000090   AB..         MOV     R3,?V0 + 1
   \   000092   EF           MOV     A,R7
   \   000093   F9           MOV     R1,A
   \   000094   12....       LCALL   ??zclGetClusterOption?relay
   \   000097   E9           MOV     A,R1
   \   000098   F5..         MOV     ?V0 + 2,A
    526            
    527            osal_memset( &hdr, 0, sizeof( zclFrameHdr_t ) );
   \   00009A                ; Setup parameters for call to function osal_memset
   \   00009A   7C06         MOV     R4,#0x6
   \   00009C   7D00         MOV     R5,#0x0
   \   00009E   7900         MOV     R1,#0x0
   \   0000A0   85..82       MOV     DPL,?XSP + 0
   \   0000A3   85..83       MOV     DPH,?XSP + 1
   \   0000A6   AA82         MOV     R2,DPL
   \   0000A8   AB83         MOV     R3,DPH
   \   0000AA   12....       LCALL   ??osal_memset?relay
    528          
    529            // Not Profile wide command (like READ, WRITE)
    530            if ( specific )
   \   0000AD   E5..         MOV     A,?V0 + 3
   \   0000AF   85..82       MOV     DPL,?XSP + 0
   \   0000B2   85..83       MOV     DPH,?XSP + 1
   \   0000B5   6015         JZ      ??zcl_SendCommand_5
    531              hdr.fc.type = ZCL_FRAME_TYPE_SPECIFIC_CMD;
   \   0000B7   E0           MOVX    A,@DPTR
   \   0000B8   54FC         ANL     A,#0xfc
   \   0000BA   F8           MOV     R0,A
   \   0000BB   A3           INC     DPTR
   \   0000BC   E0           MOVX    A,@DPTR
   \   0000BD   F9           MOV     R1,A
   \   0000BE   7401         MOV     A,#0x1
   \   0000C0   48           ORL     A,R0
   \   0000C1   85..82       MOV     DPL,?XSP + 0
   \   0000C4   85..83       MOV     DPH,?XSP + 1
   \   0000C7   F0           MOVX    @DPTR,A
   \   0000C8   A3           INC     DPTR
   \   0000C9   E9           MOV     A,R1
   \   0000CA   8006         SJMP    ??zcl_SendCommand_6
    532            else
    533              hdr.fc.type = ZCL_FRAME_TYPE_PROFILE_CMD;
   \                     ??zcl_SendCommand_5:
   \   0000CC   E0           MOVX    A,@DPTR
   \   0000CD   54FC         ANL     A,#0xfc
   \   0000CF   F0           MOVX    @DPTR,A
   \   0000D0   A3           INC     DPTR
   \   0000D1   E0           MOVX    A,@DPTR
   \                     ??zcl_SendCommand_6:
   \   0000D2   F0           MOVX    @DPTR,A
    534          
    535            if ((epDesc->simpleDesc == NULL) ||
    536                (zcl_DeviceOperational(srcEP, clusterID, hdr.fc.type, cmd, epDesc->simpleDesc->AppProfId) == FALSE))
   \   0000D3   85..82       MOV     DPL,?V0 + 10
   \   0000D6   85..83       MOV     DPH,?V0 + 11
   \   0000D9   A3           INC     DPTR
   \   0000DA   A3           INC     DPTR
   \   0000DB   A3           INC     DPTR
   \   0000DC   12....       LCALL   ?Subroutine40 & 0xFFFF
   \                     ??CrossCallReturnLabel_51:
   \   0000DF   7002         JNZ     ??zcl_SendCommand_7
   \   0000E1   E583         MOV     A,DPH
   \                     ??zcl_SendCommand_7:
   \   0000E3   6020         JZ      ??zcl_SendCommand_8
   \   0000E5                ; Setup parameters for call to function zcl_DeviceOperational
   \   0000E5   A3           INC     DPTR
   \   0000E6   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0000E9   EE           MOV     A,R6
   \   0000EA   FD           MOV     R5,A
   \   0000EB   7402         MOV     A,#0x2
   \   0000ED   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F0   E0           MOVX    A,@DPTR
   \   0000F1   5403         ANL     A,#0x3
   \   0000F3   FC           MOV     R4,A
   \   0000F4   AA..         MOV     R2,?V0 + 0
   \   0000F6   AB..         MOV     R3,?V0 + 1
   \   0000F8   EF           MOV     A,R7
   \   0000F9   F9           MOV     R1,A
   \   0000FA   12....       LCALL   ??zcl_DeviceOperational?relay
   \   0000FD   7402         MOV     A,#0x2
   \   0000FF   12....       LCALL   ?DEALLOC_XSTACK8
   \   000102   E9           MOV     A,R1
   \   000103   7005         JNZ     ??zcl_SendCommand_9
    537              return ( ZFailure ); // EMBEDDED RETURN
   \                     ??zcl_SendCommand_8:
   \   000105   7901         MOV     R1,#0x1
   \   000107   02....       LJMP    ??zcl_SendCommand_3 & 0xFFFF
    538            
    539            if ( manuCode != 0 ) // Fill in the Maufacturer Code
   \                     ??zcl_SendCommand_9:
   \   00010A   E5..         MOV     A,?V0 + 12
   \   00010C   7002         JNZ     ??zcl_SendCommand_10
   \   00010E   E5..         MOV     A,?V0 + 13
   \                     ??zcl_SendCommand_10:
   \   000110   6019         JZ      ??zcl_SendCommand_11
    540            {
    541              hdr.fc.manuSpecific = 1;
   \   000112   85..82       MOV     DPL,?XSP + 0
   \   000115   85..83       MOV     DPH,?XSP + 1
   \   000118   E0           MOVX    A,@DPTR
   \   000119   4404         ORL     A,#0x4
   \   00011B   F0           MOVX    @DPTR,A
   \   00011C   A3           INC     DPTR
   \   00011D   E0           MOVX    A,@DPTR
   \   00011E   F0           MOVX    @DPTR,A
    542              hdr.manuCode = manuCode;
   \   00011F   7402         MOV     A,#0x2
   \   000121   12....       LCALL   ?XSTACK_DISP0_8
   \   000124   E5..         MOV     A,?V0 + 12
   \   000126   F0           MOVX    @DPTR,A
   \   000127   A3           INC     DPTR
   \   000128   E5..         MOV     A,?V0 + 13
   \   00012A   F0           MOVX    @DPTR,A
    543            }
    544            
    545            if ( direction ) // Set the Command Direction
   \                     ??zcl_SendCommand_11:
   \   00012B   E5..         MOV     A,?V0 + 9
   \   00012D   85..82       MOV     DPL,?XSP + 0
   \   000130   85..83       MOV     DPH,?XSP + 1
   \   000133   6005         JZ      ??zcl_SendCommand_12
    546              hdr.fc.direction = ZCL_FRAME_SERVER_CLIENT_DIR;
   \   000135   E0           MOVX    A,@DPTR
   \   000136   4408         ORL     A,#0x8
   \   000138   8003         SJMP    ??zcl_SendCommand_13
    547            else
    548              hdr.fc.direction = ZCL_FRAME_CLIENT_SERVER_DIR;
   \                     ??zcl_SendCommand_12:
   \   00013A   E0           MOVX    A,@DPTR
   \   00013B   54F7         ANL     A,#0xf7
   \                     ??zcl_SendCommand_13:
   \   00013D   F0           MOVX    @DPTR,A
   \   00013E   A3           INC     DPTR
   \   00013F   E0           MOVX    A,@DPTR
   \   000140   F0           MOVX    @DPTR,A
    549          
    550            if ( disableDefaultRsp ) // Set the Disable Default Response field
   \   000141   E5..         MOV     A,?V0 + 8
   \   000143   85..82       MOV     DPL,?XSP + 0
   \   000146   85..83       MOV     DPH,?XSP + 1
   \   000149   6005         JZ      ??zcl_SendCommand_14
    551              hdr.fc.disableDefaultRsp = 1;
   \   00014B   E0           MOVX    A,@DPTR
   \   00014C   4410         ORL     A,#0x10
   \   00014E   8003         SJMP    ??zcl_SendCommand_15
    552            else
    553              hdr.fc.disableDefaultRsp = 0;
   \                     ??zcl_SendCommand_14:
   \   000150   E0           MOVX    A,@DPTR
   \   000151   54EF         ANL     A,#0xef
   \                     ??zcl_SendCommand_15:
   \   000153   F0           MOVX    @DPTR,A
   \   000154   A3           INC     DPTR
   \   000155   E0           MOVX    A,@DPTR
   \   000156   F0           MOVX    @DPTR,A
    554                               
    555            hdr.transSeqNum = seqNum; // Fill in the Transaction Sequence Number
   \   000157   7404         MOV     A,#0x4
   \   000159   12....       LCALL   ?XSTACK_DISP0_8
   \   00015C   E5..         MOV     A,?V0 + 7
   \   00015E   F0           MOVX    @DPTR,A
    556            
    557            hdr.commandID = cmd; // Fill in the command
   \   00015F   7405         MOV     A,#0x5
   \   000161   12....       LCALL   ?XSTACK_DISP0_8
   \   000164   EE           MOV     A,R6
   \   000165   F0           MOVX    @DPTR,A
    558            
    559            msgLen = zclCalcHdrSize( &hdr ); // calculate the needed buffer size
   \   000166   75..03       MOV     ?V0 + 4,#0x3
   \   000169   85..82       MOV     DPL,?XSP + 0
   \   00016C   85..83       MOV     DPH,?XSP + 1
   \   00016F   E0           MOVX    A,@DPTR
   \   000170   5404         ANL     A,#0x4
   \   000172   6003         JZ      ??zcl_SendCommand_16
   \   000174   75..05       MOV     ?V0 + 4,#0x5
    560            msgLen += cmdFormatLen;
   \                     ??zcl_SendCommand_16:
   \   000177   E5..         MOV     A,?V0 + 14
   \   000179   25..         ADD     A,?V0 + 4
   \   00017B   F5..         MOV     ?V0 + 12,A
   \   00017D   E5..         MOV     A,?V0 + 15
   \   00017F   3400         ADDC    A,#0x0
   \   000181   F5..         MOV     ?V0 + 13,A
    561          
    562            msgBuf = osal_mem_alloc( msgLen ); // Allocate the buffer needed
   \   000183                ; Setup parameters for call to function osal_mem_alloc
   \   000183   AA..         MOV     R2,?V0 + 12
   \   000185   FB           MOV     R3,A
   \   000186   12....       LCALL   ??osal_mem_alloc?relay
   \   000189   8A..         MOV     ?V0 + 8,R2
   \   00018B   8B..         MOV     ?V0 + 9,R3
    563            if ( msgBuf != NULL )
   \   00018D   EA           MOV     A,R2
   \   00018E   7001         JNZ     ??zcl_SendCommand_17
   \   000190   EB           MOV     A,R3
   \                     ??zcl_SendCommand_17:
   \   000191   606B         JZ      ??zcl_SendCommand_18
    564            {
    565              pBuf = zclBuildHdr( &hdr, msgBuf ); // Fill in the ZCL Header
    566          
    567              osal_memcpy( pBuf, cmdFormat, cmdFormatLen ); // Fill in the command frame
   \   000193                ; Setup parameters for call to function osal_memcpy
   \   000193   7433         MOV     A,#0x33
   \   000195   12....       LCALL   ?XSTACK_DISP0_8
   \   000198   12....       LCALL   ?Subroutine82 & 0xFFFF
   \                     ??CrossCallReturnLabel_116:
   \   00019B   78..         MOV     R0,#?V0 + 4
   \   00019D   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0001A0                ; Setup parameters for call to function zclBuildHdr
   \   0001A0   AC..         MOV     R4,?V0 + 8
   \   0001A2   AD..         MOV     R5,?V0 + 9
   \   0001A4   7403         MOV     A,#0x3
   \   0001A6   12....       LCALL   ?XSTACK_DISP0_8
   \   0001A9   AA82         MOV     R2,DPL
   \   0001AB   AB83         MOV     R3,DPH
   \   0001AD   12....       LCALL   ??zclBuildHdr?relay
   \   0001B0   AC..         MOV     R4,?V0 + 14
   \   0001B2   AD..         MOV     R5,?V0 + 15
   \   0001B4   12....       LCALL   ?Subroutine113 & 0xFFFF
   \                     ??CrossCallReturnLabel_160:
   \   0001B7   12....       LCALL   ?DEALLOC_XSTACK8
    568          
    569              status = AF_DataRequest( &dstAddr, epDesc, clusterID, msgLen, msgBuf, 
    570                                       &zcl_TransID, options, AF_DEFAULT_RADIUS );  
   \   0001BA                ; Setup parameters for call to function AF_DataRequest
   \   0001BA   75..1E       MOV     ?V0 + 3,#0x1e
   \   0001BD   78..         MOV     R0,#?V0 + 3
   \   0001BF   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001C2   75....       MOV     ?V0 + 4,#(zcl_TransID & 0xff)
   \   0001C5   75....       MOV     ?V0 + 5,#((zcl_TransID >> 8) & 0xff)
   \   0001C8   78..         MOV     R0,#?V0 + 4
   \   0001CA   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001CD   78..         MOV     R0,#?V0 + 8
   \   0001CF   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001D2   78..         MOV     R0,#?V0 + 12
   \   0001D4   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001D7   78..         MOV     R0,#?V0 + 0
   \   0001D9   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001DC   A9..         MOV     R1,?V0 + 2
   \   0001DE   AC..         MOV     R4,?V0 + 10
   \   0001E0   AD..         MOV     R5,?V0 + 11
   \   0001E2   740F         MOV     A,#0xf
   \   0001E4   12....       LCALL   ?XSTACK_DISP0_8
   \   0001E7   AA82         MOV     R2,DPL
   \   0001E9   AB83         MOV     R3,DPH
   \   0001EB   12....       LCALL   ??AF_DataRequest?relay
   \   0001EE   7409         MOV     A,#0x9
   \   0001F0   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001F3   E9           MOV     A,R1
   \   0001F4   FE           MOV     R6,A
    571              osal_mem_free ( msgBuf );
   \   0001F5                ; Setup parameters for call to function osal_mem_free
   \   0001F5   AA..         MOV     R2,?V0 + 8
   \   0001F7   AB..         MOV     R3,?V0 + 9
   \   0001F9   12....       LCALL   ??osal_mem_free?relay
   \   0001FC   8002         SJMP    ??zcl_SendCommand_19
    572            }
    573            else
    574              status = ZMemError;
   \                     ??zcl_SendCommand_18:
   \   0001FE   7E10         MOV     R6,#0x10
    575          
    576            return ( status );
   \                     ??zcl_SendCommand_19:
   \   000200   EE           MOV     A,R6
   \   000201   F9           MOV     R1,A
   \                     ??zcl_SendCommand_3:
   \   000202                REQUIRE ?Subroutine125
   \   000202                ; // Fall through to label ?Subroutine125
    577          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine125:
   \   000000   7412         MOV     A,#0x12
   \   000002   80..         SJMP    ??Subroutine127_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine127_0:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003   7F10         MOV     R7,#0x10
   \   000005   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine40:
   \   000000   12....       LCALL   ?Subroutine91 & 0xFFFF
   \                     ??CrossCallReturnLabel_223:
   \   000003   8882         MOV     DPL,R0
   \   000005   8983         MOV     DPH,R1
   \   000007   E582         MOV     A,DPL
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine113:
   \   000000   12....       LCALL   ??osal_memcpy?relay
   \   000003   7403         MOV     A,#0x3
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine91:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine82:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0 + 4,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V0 + 5,A
   \   000007   22           RET
    578          
    579          #ifdef ZCL_READ
    580          /*********************************************************************
    581           * @fn      zcl_SendRead
    582           * @brief   Send a Read command
    583           * @param   srcEP - Application's endpoint
    584           *          dstAddr - destination address
    585           *          clusterID - cluster ID
    586           *          readCmd - read command to be sent
    587           *          direction - direction of the command
    588           *          seqNum - transaction sequence number
    589           * @return  ZSuccess if OK
    590           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    591          ZStatus_t zcl_SendRead( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendRead:
    592                                  uint16 clusterID, zclReadCmd_t *readCmd,
    593                                  uint8 direction, uint8 disableDefaultRsp, uint8 seqNum)
    594          {
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 8,R1
   \   000007   EA           MOV     A,R2
   \   000008   FE           MOV     R6,A
   \   000009   EB           MOV     A,R3
   \   00000A   FF           MOV     R7,A
   \   00000B   8C..         MOV     ?V0 + 0,R4
   \   00000D   8D..         MOV     ?V0 + 1,R5
   \   00000F   7416         MOV     A,#0x16
   \   000011   12....       LCALL   ?XSTACK_DISP0_8
   \   000014   12....       LCALL   ?Subroutine57 & 0xFFFF
   \                     ??CrossCallReturnLabel_79:
   \   000017   12....       LCALL   ?XSTACK_DISP0_8
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   F5..         MOV     ?V0 + 9,A
   \   00001D   7419         MOV     A,#0x19
   \   00001F   12....       LCALL   ?XSTACK_DISP0_8
   \   000022   E0           MOVX    A,@DPTR
   \   000023   F5..         MOV     ?V0 + 12,A
   \   000025   741A         MOV     A,#0x1a
   \   000027   12....       LCALL   ?XSTACK_DISP0_8
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   F5..         MOV     ?V0 + 13,A
    595            uint8 dataLen;
    596            uint8 *buf;
    597            uint8 *pBuf;
    598            ZStatus_t status;
    599          
    600            dataLen = readCmd->numAttr * 2; // Attribute ID
   \   00002D   85..82       MOV     DPL,?V0 + 4
   \   000030   85..83       MOV     DPH,?V0 + 5
   \   000033   E0           MOVX    A,@DPTR
   \   000034   C3           CLR     C
   \   000035   33           RLC     A
   \   000036   FA           MOV     R2,A
    601          
    602            buf = osal_mem_alloc( dataLen );
   \   000037   8A82         MOV     DPL,R2
   \   000039   8582..       MOV     ?V0 + 6,DPL
   \   00003C   75..00       MOV     ?V0 + 7,#0x0
   \   00003F                ; Setup parameters for call to function osal_mem_alloc
   \   00003F   12....       LCALL   ?Subroutine64 & 0xFFFF
    603            if ( buf != NULL )
   \                     ??CrossCallReturnLabel_87:
   \   000042   7001         JNZ     ??zcl_SendRead_0
   \   000044   EB           MOV     A,R3
   \                     ??zcl_SendRead_0:
   \   000045   7003         JNZ     $+5
   \   000047   02....       LJMP    ??zcl_SendRead_1 & 0xFFFF
    604            {
    605              uint8 i;
    606          
    607              pBuf = buf; // Load the buffer - serially
   \   00004A   A8..         MOV     R0,?V0 + 2
   \   00004C   A9..         MOV     R1,?V0 + 3
    608              for (i = 0; i < readCmd->numAttr; i++)
   \   00004E   75..00       MOV     ?V0 + 10,#0x0
   \   000051   801F         SJMP    ??zcl_SendRead_2
    609              {
    610                *pBuf++ = LO_UINT16( readCmd->attrID[i] );
   \                     ??zcl_SendRead_3:
   \   000053   E5..         MOV     A,?V0 + 10
   \   000055   C3           CLR     C
   \   000056   33           RLC     A
   \   000057   FA           MOV     R2,A
   \   000058   E4           CLR     A
   \   000059   33           RLC     A
   \   00005A   FB           MOV     R3,A
   \   00005B   E5..         MOV     A,?V0 + 4
   \   00005D   2A           ADD     A,R2
   \   00005E   F582         MOV     DPL,A
   \   000060   E5..         MOV     A,?V0 + 5
   \   000062   3B           ADDC    A,R3
   \   000063   F583         MOV     DPH,A
   \   000065   A3           INC     DPTR
   \   000066   AA82         MOV     R2,DPL
   \   000068   AB83         MOV     R3,DPH
   \   00006A   12....       LCALL   ?Subroutine41 & 0xFFFF
    611                *pBuf++ = HI_UINT16( readCmd->attrID[i] );
   \                     ??CrossCallReturnLabel_172:
   \   00006D   12....       LCALL   ?Subroutine28 & 0xFFFF
    612              }
   \                     ??CrossCallReturnLabel_181:
   \   000070   05..         INC     ?V0 + 10
   \                     ??zcl_SendRead_2:
   \   000072   85..82       MOV     DPL,?V0 + 4
   \   000075   85..83       MOV     DPH,?V0 + 5
   \   000078   E0           MOVX    A,@DPTR
   \   000079   FA           MOV     R2,A
   \   00007A   E5..         MOV     A,?V0 + 10
   \   00007C   C3           CLR     C
   \   00007D   9A           SUBB    A,R2
   \   00007E   40D3         JC      ??zcl_SendRead_3
    613              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ, FALSE,
    614                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );  
   \   000080                ; Setup parameters for call to function zcl_SendCommand
   \   000080   78..         MOV     R0,#?V0 + 2
   \   000082   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000085   78..         MOV     R0,#?V0 + 6
   \   000087   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00008A   E5..         MOV     A,?V0 + 13
   \   00008C   F5..         MOV     ?V0 + 4,A
   \   00008E   78..         MOV     R0,#?V0 + 4
   \   000090   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000093   75..00       MOV     ?V0 + 4,#0x0
   \   000096   75..00       MOV     ?V0 + 5,#0x0
   \   000099   78..         MOV     R0,#?V0 + 4
   \   00009B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00009E   E5..         MOV     A,?V0 + 12
   \   0000A0   F5..         MOV     ?V0 + 4,A
   \   0000A2   78..         MOV     R0,#?V0 + 4
   \   0000A4   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000A7   E5..         MOV     A,?V0 + 9
   \   0000A9   F5..         MOV     ?V0 + 4,A
   \   0000AB   78..         MOV     R0,#?V0 + 4
   \   0000AD   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000B0   75..00       MOV     ?V0 + 4,#0x0
   \   0000B3   78..         MOV     R0,#?V0 + 4
   \   0000B5   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000B8   78..         MOV     R0,#?V0 + 4
   \   0000BA   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000BD   AC..         MOV     R4,?V0 + 0
   \   0000BF   AD..         MOV     R5,?V0 + 1
   \   0000C1   EE           MOV     A,R6
   \   0000C2   FA           MOV     R2,A
   \   0000C3   EF           MOV     A,R7
   \   0000C4   FB           MOV     R3,A
   \   0000C5   A9..         MOV     R1,?V0 + 8
   \   0000C7   12....       LCALL   ?Subroutine96 & 0xFFFF
   \                     ??CrossCallReturnLabel_132:
   \   0000CA   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000CD   E9           MOV     A,R1
   \   0000CE   FE           MOV     R6,A
    615              osal_mem_free( buf );
   \   0000CF                ; Setup parameters for call to function osal_mem_free
   \   0000CF   AA..         MOV     R2,?V0 + 2
   \   0000D1   AB..         MOV     R3,?V0 + 3
   \   0000D3   12....       LCALL   ??osal_mem_free?relay
   \   0000D6   8002         SJMP    ??zcl_SendRead_4
    616            }
    617            else
    618              status = ZMemError;
   \                     ??zcl_SendRead_1:
   \   0000D8   7E10         MOV     R6,#0x10
    619          
    620            return ( status );
   \                     ??zcl_SendRead_4:
   \   0000DA                REQUIRE ?Subroutine121
   \   0000DA                ; // Fall through to label ?Subroutine121
    621          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine121:
   \   000000   EE           MOV     A,R6
   \   000001   F9           MOV     R1,A
   \   000002                REQUIRE ??Subroutine128_0
   \   000002                ; // Fall through to label ??Subroutine128_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine128_0:
   \   000000   7F0E         MOV     R7,#0xe
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine28:
   \   000000   8A82         MOV     DPL,R2
   \   000002   8B83         MOV     DPH,R3
   \   000004   A3           INC     DPTR
   \   000005                REQUIRE ??Subroutine129_0
   \   000005                ; // Fall through to label ??Subroutine129_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine129_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8882         MOV     DPL,R0
   \   000003   8983         MOV     DPH,R1
   \   000005   F0           MOVX    @DPTR,A
   \   000006   A3           INC     DPTR
   \   000007   08           INC     R0
   \   000008   A983         MOV     R1,DPH
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine116:
   \   000000   A882         MOV     R0,DPL
   \   000002   A983         MOV     R1,DPH
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine96:
   \   000000   12....       LCALL   ??zcl_SendCommand?relay
   \   000003   740B         MOV     A,#0xb
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine64:
   \   000000   7B00         MOV     R3,#0x0
   \   000002   12....       LCALL   ??osal_mem_alloc?relay
   \   000005   8A..         MOV     ?V0 + 2,R2
   \   000007   8B..         MOV     ?V0 + 3,R3
   \   000009   EA           MOV     A,R2
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine57:
   \   000000   12....       LCALL   ?Subroutine82 & 0xFFFF
   \                     ??CrossCallReturnLabel_119:
   \   000003   7418         MOV     A,#0x18
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine41:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8882         MOV     DPL,R0
   \   000003   8983         MOV     DPH,R1
   \   000005   F0           MOVX    @DPTR,A
   \   000006   A3           INC     DPTR
   \   000007   02....       LJMP    ?Subroutine116 & 0xFFFF
    622          
    623          /*********************************************************************
    624           * @fn      zcl_SendReadRsp
    625           * @brief   Send a Read Response command.
    626           * @param   srcEP - Application's endpoint
    627           *          dstAddr - destination address
    628           *          clusterID - cluster ID
    629           *          readRspCmd - read response command to be sent
    630           *          direction - direction of the command
    631           *          seqNum - transaction sequence number
    632           * @return  ZSuccess if OK
    633           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine120:
   \   000000   EE           MOV     A,R6
   \   000001   F9           MOV     R1,A
   \   000002   7404         MOV     A,#0x4
   \   000004                REQUIRE ??Subroutine127_0
   \   000004                ; // Fall through to label ??Subroutine127_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    634          ZStatus_t zcl_SendReadRsp( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendReadRsp:
    635                                     uint16 clusterID, zclReadRspCmd_t *readRspCmd,
    636                                     uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
    637          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   7402         MOV     A,#0x2
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   000012   12....       LCALL   ?XSTACK_DISP0_8
   \   000015   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_81:
   \   000018   12....       LCALL   ?XSTACK_DISP0_8
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F5..         MOV     ?V0 + 10,A
   \   00001E   741F         MOV     A,#0x1f
   \   000020   12....       LCALL   ?XSTACK_DISP0_8
   \   000023   E0           MOVX    A,@DPTR
   \   000024   F5..         MOV     ?V0 + 9,A
   \   000026   7420         MOV     A,#0x20
   \   000028   12....       LCALL   ?XSTACK_DISP0_8
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   F5..         MOV     ?V0 + 8,A
    638            uint8 *buf;
    639            uint8 *pBuf;
    640            zclReadRspStatus_t *statusRec;
    641            uint8 len = 0;
   \   00002E   7E00         MOV     R6,#0x0
    642            uint8 i;
    643            ZStatus_t status;
    644            
    645            // calculate the size of the command
    646            for ( i = 0; i < readRspCmd->numAttr; i++ )
   \   000030   8E..         MOV     ?V0 + 5,R6
   \   000032   8021         SJMP    ??zcl_SendReadRsp_0
    647            {
    648              statusRec = &(readRspCmd->attrList[i]);
   \                     ??zcl_SendReadRsp_1:
   \   000034   E5..         MOV     A,?V0 + 5
   \   000036   75F006       MOV     B,#0x6
   \   000039   12....       LCALL   ?Subroutine74 & 0xFFFF
    649              
    650              len += 2 + 1; // Attribute ID + Status
   \                     ??CrossCallReturnLabel_101:
   \   00003C   0E           INC     R6
   \   00003D   0E           INC     R6
   \   00003E   0E           INC     R6
    651          
    652              if ( statusRec->status == ZCL_STATUS_SUCCESS )
   \   00003F   A3           INC     DPTR
   \   000040   A3           INC     DPTR
   \   000041   E0           MOVX    A,@DPTR
   \   000042   700F         JNZ     ??zcl_SendReadRsp_2
    653              {
    654                len++; // Attribute Data Type
    655                len += zclGetAttrDataLength( statusRec->dataType, statusRec->data); // Attribute Data
   \   000044                ; Setup parameters for call to function zclGetAttrDataLength
   \   000044   8882         MOV     DPL,R0
   \   000046   8983         MOV     DPH,R1
   \   000048   A3           INC     DPTR
   \   000049   12....       LCALL   ?Subroutine42 & 0xFFFF
    656              }
    657            }
   \                     ??CrossCallReturnLabel_53:
   \   00004C   A3           INC     DPTR
   \   00004D   12....       LCALL   ?Subroutine89 & 0xFFFF
   \                     ??CrossCallReturnLabel_204:
   \   000050   04           INC     A
   \   000051   2E           ADD     A,R6
   \   000052   FE           MOV     R6,A
   \                     ??zcl_SendReadRsp_2:
   \   000053   05..         INC     ?V0 + 5
   \                     ??zcl_SendReadRsp_0:
   \   000055   12....       LCALL   ?Subroutine37 & 0xFFFF
   \                     ??CrossCallReturnLabel_40:
   \   000058   40DA         JC      ??zcl_SendReadRsp_1
    658          
    659            buf = osal_mem_alloc( len );
   \   00005A   12....       LCALL   ?Subroutine65 & 0xFFFF
    660            if ( buf != NULL )
   \                     ??CrossCallReturnLabel_89:
   \   00005D   7001         JNZ     ??zcl_SendReadRsp_3
   \   00005F   EB           MOV     A,R3
   \                     ??zcl_SendReadRsp_3:
   \   000060   7003         JNZ     $+5
   \   000062   02....       LJMP    ??zcl_SendReadRsp_4 & 0xFFFF
    661            {
    662              // Load the buffer - serially
    663              pBuf = buf;
   \   000065   AE..         MOV     R6,?V0 + 6
   \   000067   AF..         MOV     R7,?V0 + 7
    664              for ( i = 0; i < readRspCmd->numAttr; i++ )
   \   000069   75..00       MOV     ?V0 + 5,#0x0
   \   00006C   8028         SJMP    ??zcl_SendReadRsp_5
    665              {
    666                statusRec = &(readRspCmd->attrList[i]);
   \                     ??zcl_SendReadRsp_6:
   \   00006E   E5..         MOV     A,?V0 + 5
   \   000070   75F006       MOV     B,#0x6
   \   000073   12....       LCALL   ?Subroutine1 & 0xFFFF
    667                
    668                *pBuf++ = LO_UINT16( statusRec->attrID );
    669                *pBuf++ = HI_UINT16( statusRec->attrID );
    670                *pBuf++ = statusRec->status;
   \                     ??CrossCallReturnLabel_2:
   \   000076   FA           MOV     R2,A
   \   000077   E9           MOV     A,R1
   \   000078   3400         ADDC    A,#0x0
   \   00007A   FB           MOV     R3,A
   \   00007B   8A82         MOV     DPL,R2
   \   00007D   8B83         MOV     DPH,R3
   \   00007F   12....       LCALL   ?Subroutine102 & 0xFFFF
    671          
    672                if ( statusRec->status == ZCL_STATUS_SUCCESS )
   \                     ??CrossCallReturnLabel_143:
   \   000082   8A82         MOV     DPL,R2
   \   000084   8B83         MOV     DPH,R3
   \   000086   E0           MOVX    A,@DPTR
   \   000087   700B         JNZ     ??CrossCallReturnLabel_168
    673                {
    674                  *pBuf++ = statusRec->dataType;
   \   000089   E8           MOV     A,R0
   \   00008A   2403         ADD     A,#0x3
   \   00008C   12....       LCALL   ?Subroutine44 & 0xFFFF
    675                  zclSerializeData( statusRec->dataType, statusRec->data, pBuf );
    676                  
    677                  // move pass attribute data
    678                  pBuf += zclGetAttrDataLength( statusRec->dataType, statusRec->data );
    679                }
    680              } // for loop
   \                     ??CrossCallReturnLabel_57:
   \   00008F   2404         ADD     A,#0x4
   \   000091   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_168:
   \   000094   05..         INC     ?V0 + 5
   \                     ??zcl_SendReadRsp_5:
   \   000096   12....       LCALL   ?Subroutine37 & 0xFFFF
   \                     ??CrossCallReturnLabel_41:
   \   000099   40D3         JC      ??zcl_SendReadRsp_6
    681          
    682              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ_RSP, FALSE, 
    683                                        direction, disableDefaultRsp, 0, seqNum, len, buf );
   \   00009B                ; Setup parameters for call to function zcl_SendCommand
   \   00009B   78..         MOV     R0,#?V0 + 6
   \   00009D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000A0   78..         MOV     R0,#?V0 + 0
   \   0000A2   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000A5   E5..         MOV     A,?V0 + 8
   \   0000A7   F5..         MOV     ?V0 + 0,A
   \   0000A9   78..         MOV     R0,#?V0 + 0
   \   0000AB   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000AE   75..00       MOV     ?V0 + 0,#0x0
   \   0000B1   78..         MOV     R0,#?V0 + 0
   \   0000B3   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000B6   E5..         MOV     A,?V0 + 9
   \   0000B8   F5..         MOV     ?V0 + 0,A
   \   0000BA   78..         MOV     R0,#?V0 + 0
   \   0000BC   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000BF   E5..         MOV     A,?V0 + 10
   \   0000C1   F5..         MOV     ?V0 + 0,A
   \   0000C3   78..         MOV     R0,#?V0 + 0
   \   0000C5   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000C8   75..00       MOV     ?V0 + 0,#0x0
   \   0000CB   78..         MOV     R0,#?V0 + 0
   \   0000CD   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000D0   75..01       MOV     ?V0 + 0,#0x1
   \   0000D3   78..         MOV     R0,#?V0 + 0
   \   0000D5   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000D8   740B         MOV     A,#0xb
   \   0000DA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DD   12....       LCALL   ??Subroutine133_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_186:
   \   0000E0   740D         MOV     A,#0xd
   \   0000E2   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E5   12....       LCALL   ?Subroutine36 & 0xFFFF
   \                     ??CrossCallReturnLabel_38:
   \   0000E8   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000EB   E9           MOV     A,R1
   \   0000EC   FE           MOV     R6,A
    684              osal_mem_free( buf );
   \   0000ED                ; Setup parameters for call to function osal_mem_free
   \   0000ED   AA..         MOV     R2,?V0 + 6
   \   0000EF   AB..         MOV     R3,?V0 + 7
   \   0000F1   12....       LCALL   ??osal_mem_free?relay
   \   0000F4   8002         SJMP    ??zcl_SendReadRsp_7
    685            }
    686            else
    687              status = ZMemError;
   \                     ??zcl_SendReadRsp_4:
   \   0000F6   7E10         MOV     R6,#0x10
    688          
    689            return ( status );
   \                     ??zcl_SendReadRsp_7:
   \   0000F8   02....       LJMP    ?Subroutine120 & 0xFFFF
    690          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine89:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F9           MOV     R1,A
   \   000002   12....       LCALL   ??zclGetAttrDataLength?relay
   \   000005   E9           MOV     A,R1
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine74:
   \   000000   12....       LCALL   ?Subroutine97 & 0xFFFF
   \                     ??CrossCallReturnLabel_175:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine97:
   \   000000   A4           MUL     AB
   \   000001   F8           MOV     R0,A
   \   000002   A9F0         MOV     R1,B
   \   000004   12....       LCALL   ?Subroutine107 & 0xFFFF
   \                     ??CrossCallReturnLabel_151:
   \   000007                REQUIRE ?Subroutine116
   \   000007                ; // Fall through to label ?Subroutine116

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine65:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8582..       MOV     ?V0 + 0,DPL
   \   000005   75..00       MOV     ?V0 + 1,#0x0
   \   000008                ; Setup parameters for call to function osal_mem_alloc
   \   000008                ; Setup parameters for call to function osal_mem_alloc
   \   000008   AA..         MOV     R2,?V0 + 0
   \   00000A   7B00         MOV     R3,#0x0
   \   00000C   12....       LCALL   ??osal_mem_alloc?relay
   \   00000F   8A..         MOV     ?V0 + 6,R2
   \   000011   8B..         MOV     ?V0 + 7,R3
   \   000013   EA           MOV     A,R2
   \   000014   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine58:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0 + 2,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V0 + 3,A
   \   000007   741E         MOV     A,#0x1e
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine44:
   \   000000   F5..         MOV     ?V0 + 12,A
   \   000002   E9           MOV     A,R1
   \   000003   3400         ADDC    A,#0x0
   \   000005   F5..         MOV     ?V0 + 13,A
   \   000007   85..82       MOV     DPL,?V0 + 12
   \   00000A   F583         MOV     DPH,A
   \   00000C   12....       LCALL   ?Subroutine87 & 0xFFFF
   \                     ??CrossCallReturnLabel_124:
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine87:
   \   000000   12....       LCALL   ?Subroutine102 & 0xFFFF
   \                     ??CrossCallReturnLabel_144:
   \   000003   E8           MOV     A,R0
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine102:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005   F0           MOVX    @DPTR,A
   \   000006   A3           INC     DPTR
   \   000007   0E           INC     R6
   \   000008   AF83         MOV     R7,DPH
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine42:
   \   000000   12....       LCALL   ?Subroutine85 & 0xFFFF
   \                     ??CrossCallReturnLabel_286:
   \   000003   8882         MOV     DPL,R0
   \   000005   8983         MOV     DPH,R1
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine37:
   \   000000   85..82       MOV     DPL,?V0 + 2
   \   000003   85..83       MOV     DPH,?V0 + 3
   \   000006   E0           MOVX    A,@DPTR
   \   000007   FA           MOV     R2,A
   \   000008   E5..         MOV     A,?V0 + 5
   \   00000A   C3           CLR     C
   \   00000B   9A           SUBB    A,R2
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine36:
   \   000000   12....       LCALL   ??Subroutine138_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_281:
   \   000003   A9..         MOV     R1,?V0 + 4
   \   000005   12....       LCALL   ?Subroutine96 & 0xFFFF
   \                     ??CrossCallReturnLabel_133:
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   F5..         MOV     ?V0 + 14,A
   \   000002   E9           MOV     A,R1
   \   000003   3400         ADDC    A,#0x0
   \   000005   F5..         MOV     ?V0 + 15,A
   \   000007                ; Setup parameters for call to function zclSerializeData
   \   000007                ; Setup parameters for call to function zclSerializeData
   \   000007   EE           MOV     A,R6
   \   000008   FC           MOV     R4,A
   \   000009   EF           MOV     A,R7
   \   00000A   FD           MOV     R5,A
   \   00000B   12....       LCALL   ?Subroutine83 & 0xFFFF
   \                     ??CrossCallReturnLabel_120:
   \   00000E   12....       LCALL   ??zclSerializeData?relay
   \   000011                ; Setup parameters for call to function zclGetAttrDataLength
   \   000011                ; Setup parameters for call to function zclGetAttrDataLength
   \   000011   12....       LCALL   ?Subroutine83 & 0xFFFF
   \                     ??CrossCallReturnLabel_121:
   \   000014   12....       LCALL   ??zclGetAttrDataLength?relay
   \   000017   E9           MOV     A,R1
   \   000018   F8           MOV     R0,A
   \   000019   EE           MOV     A,R6
   \   00001A   28           ADD     A,R0
   \   00001B   FE           MOV     R6,A
   \   00001C                REQUIRE ?Subroutine115
   \   00001C                ; // Fall through to label ?Subroutine115

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine115:
   \   000000   EF           MOV     A,R7
   \   000001   3400         ADDC    A,#0x0
   \   000003   FF           MOV     R7,A
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine83:
   \   000000   85..82       MOV     DPL,?V0 + 14
   \   000003   85..83       MOV     DPH,?V0 + 15
   \   000006   12....       LCALL   ?Subroutine103 & 0xFFFF
   \                     ??CrossCallReturnLabel_291:
   \   000009   FB           MOV     R3,A
   \   00000A   85..82       MOV     DPL,?V0 + 12
   \   00000D   85..83       MOV     DPH,?V0 + 13
   \   000010   E0           MOVX    A,@DPTR
   \   000011   F9           MOV     R1,A
   \   000012   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   EA           MOV     A,R2
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   EB           MOV     A,R3
   \   000004   F0           MOVX    @DPTR,A
   \   000005   85..82       MOV     DPL,?XSP + 0
   \   000008   85..83       MOV     DPH,?XSP + 1
   \   00000B   EC           MOV     A,R4
   \   00000C   F0           MOVX    @DPTR,A
   \   00000D   A3           INC     DPTR
   \   00000E   ED           MOV     A,R5
   \   00000F   F0           MOVX    @DPTR,A
   \   000010   89..         MOV     ?V0 + 4,R1
   \   000012   741C         MOV     A,#0x1c
   \   000014   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   12....       LCALL   ?Subroutine97 & 0xFFFF
   \                     ??CrossCallReturnLabel_174:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   8E82         MOV     DPL,R6
   \   000006   8F83         MOV     DPH,R7
   \   000008   F0           MOVX    @DPTR,A
   \   000009   A3           INC     DPTR
   \   00000A   AE82         MOV     R6,DPL
   \   00000C   AF83         MOV     R7,DPH
   \   00000E   8882         MOV     DPL,R0
   \   000010   8983         MOV     DPH,R1
   \   000012   A3           INC     DPTR
   \   000013   12....       LCALL   ?Subroutine87 & 0xFFFF
   \                     ??CrossCallReturnLabel_125:
   \   000016   2402         ADD     A,#0x2
   \   000018   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine133_0:
   \   000000   12....       LCALL   ?Subroutine90 & 0xFFFF
   \                     ??CrossCallReturnLabel_279:
   \   000003   FD           MOV     R5,A
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine85:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003                REQUIRE ??Subroutine138_0
   \   000003                ; // Fall through to label ??Subroutine138_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine107:
   \   000000   E5..         MOV     A,?V0 + 2
   \   000002   28           ADD     A,R0
   \   000003   F582         MOV     DPL,A
   \   000005   E5..         MOV     A,?V0 + 3
   \   000007   39           ADDC    A,R1
   \   000008   F583         MOV     DPH,A
   \   00000A   A3           INC     DPTR
   \   00000B   22           RET
    691          #endif // ZCL_READ
    692          
    693          #ifdef ZCL_WRITE
    694          /*********************************************************************
    695           * @fn      sendWriteRequest
    696           * @brief   Send a Write command
    697           * @param   dstAddr - destination address
    698           *          clusterID - cluster ID
    699           *          writeCmd - write command to be sent
    700           *          cmd - ZCL_CMD_WRITE, ZCL_CMD_WRITE_UNDIVIDED or ZCL_CMD_WRITE_NO_RSP
    701           *          direction - direction of the command
    702           *          seqNum - transaction sequence number
    703           * @return  ZSuccess if OK
    704           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    705          ZStatus_t zcl_SendWriteRequest( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID, 
   \                     zcl_SendWriteRequest:
    706                                          zclWriteCmd_t *writeCmd, uint8 cmd, uint8 direction, 
    707                                          uint8 disableDefaultRsp, uint8 seqNum )
    708          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   7402         MOV     A,#0x2
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   000012   12....       LCALL   ?XSTACK_DISP0_8
   \   000015   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_82:
   \   000018   12....       LCALL   ?XSTACK_DISP0_8
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F5..         MOV     ?V0 + 11,A
   \   00001E   741F         MOV     A,#0x1f
   \   000020   12....       LCALL   ?XSTACK_DISP0_8
   \   000023   E0           MOVX    A,@DPTR
   \   000024   F5..         MOV     ?V0 + 10,A
   \   000026   7420         MOV     A,#0x20
   \   000028   12....       LCALL   ?XSTACK_DISP0_8
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   F5..         MOV     ?V0 + 9,A
   \   00002E   7421         MOV     A,#0x21
   \   000030   12....       LCALL   ?XSTACK_DISP0_8
   \   000033   E0           MOVX    A,@DPTR
   \   000034   F5..         MOV     ?V0 + 8,A
    709            uint8 *buf;
    710            uint8 *pBuf;
    711            zclWriteRec_t *statusRec;
    712            uint8 attrDataLen;
    713            uint8 dataLen = 0;
   \   000036   7E00         MOV     R6,#0x0
    714            uint8 i;
    715            ZStatus_t status;
    716            
    717            for ( i = 0; i < writeCmd->numAttr; i++ )
   \   000038   8E..         MOV     ?V0 + 5,R6
   \   00003A   8014         SJMP    ??zcl_SendWriteRequest_0
    718            {
    719              statusRec = &(writeCmd->attrList[i]);
   \                     ??zcl_SendWriteRequest_1:
   \   00003C   E5..         MOV     A,?V0 + 5
   \   00003E   75F005       MOV     B,#0x5
   \   000041   12....       LCALL   ?Subroutine74 & 0xFFFF
    720              
    721              attrDataLen = zclGetAttrDataLength( statusRec->dataType, statusRec->attrData );
    722              dataLen += 2 + 1 + attrDataLen; // Attribute ID + Attribute Type + Attribute Data
   \                     ??CrossCallReturnLabel_102:
   \   000044                ; Setup parameters for call to function zclGetAttrDataLength
   \   000044   12....       LCALL   ?Subroutine42 & 0xFFFF
    723            }
   \                     ??CrossCallReturnLabel_54:
   \   000047   12....       LCALL   ?Subroutine89 & 0xFFFF
   \                     ??CrossCallReturnLabel_205:
   \   00004A   2403         ADD     A,#0x3
   \   00004C   2E           ADD     A,R6
   \   00004D   FE           MOV     R6,A
   \   00004E   05..         INC     ?V0 + 5
   \                     ??zcl_SendWriteRequest_0:
   \   000050   12....       LCALL   ?Subroutine37 & 0xFFFF
   \                     ??CrossCallReturnLabel_42:
   \   000053   40E7         JC      ??zcl_SendWriteRequest_1
    724          
    725            buf = osal_mem_alloc( dataLen );
   \   000055   12....       LCALL   ?Subroutine65 & 0xFFFF
    726            if ( buf != NULL )
   \                     ??CrossCallReturnLabel_90:
   \   000058   7001         JNZ     ??zcl_SendWriteRequest_2
   \   00005A   EB           MOV     A,R3
   \                     ??zcl_SendWriteRequest_2:
   \   00005B   607C         JZ      ??zcl_SendWriteRequest_3
    727            {
    728              // Load the buffer - serially
    729              pBuf = buf;
   \   00005D   AE..         MOV     R6,?V0 + 6
   \   00005F   AF..         MOV     R7,?V0 + 7
    730              for ( i = 0; i < writeCmd->numAttr; i++ )
   \   000061   75..00       MOV     ?V0 + 5,#0x0
   \   000064   8012         SJMP    ??zcl_SendWriteRequest_4
    731              { 
    732                statusRec = &(writeCmd->attrList[i]);
   \                     ??zcl_SendWriteRequest_5:
   \   000066   E5..         MOV     A,?V0 + 5
   \   000068   75F005       MOV     B,#0x5
   \   00006B   12....       LCALL   ?Subroutine1 & 0xFFFF
    733                
    734                *pBuf++ = LO_UINT16( statusRec->attrID );
    735                *pBuf++ = HI_UINT16( statusRec->attrID );
    736                *pBuf++ = statusRec->dataType;
    737                
    738                zclSerializeData( statusRec->dataType, statusRec->attrData, pBuf );
    739                
    740                attrDataLen = zclGetAttrDataLength( statusRec->dataType, statusRec->attrData );
    741                pBuf += attrDataLen; // move pass attribute data
    742              }
   \                     ??CrossCallReturnLabel_3:
   \   00006E   12....       LCALL   ?Subroutine44 & 0xFFFF
   \                     ??CrossCallReturnLabel_58:
   \   000071   2403         ADD     A,#0x3
   \   000073   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_169:
   \   000076   05..         INC     ?V0 + 5
   \                     ??zcl_SendWriteRequest_4:
   \   000078   12....       LCALL   ?Subroutine37 & 0xFFFF
   \                     ??CrossCallReturnLabel_43:
   \   00007B   40E9         JC      ??zcl_SendWriteRequest_5
    743          
    744              status = zcl_SendCommand( srcEP, dstAddr, clusterID, cmd, FALSE, 
    745                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \   00007D                ; Setup parameters for call to function zcl_SendCommand
   \   00007D   78..         MOV     R0,#?V0 + 6
   \   00007F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000082   78..         MOV     R0,#?V0 + 0
   \   000084   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000087   E5..         MOV     A,?V0 + 8
   \   000089   F5..         MOV     ?V0 + 0,A
   \   00008B   78..         MOV     R0,#?V0 + 0
   \   00008D   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000090   75..00       MOV     ?V0 + 0,#0x0
   \   000093   78..         MOV     R0,#?V0 + 0
   \   000095   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000098   E5..         MOV     A,?V0 + 9
   \   00009A   F5..         MOV     ?V0 + 0,A
   \   00009C   78..         MOV     R0,#?V0 + 0
   \   00009E   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000A1   E5..         MOV     A,?V0 + 10
   \   0000A3   F5..         MOV     ?V0 + 0,A
   \   0000A5   78..         MOV     R0,#?V0 + 0
   \   0000A7   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000AA   75..00       MOV     ?V0 + 0,#0x0
   \   0000AD   78..         MOV     R0,#?V0 + 0
   \   0000AF   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000B2   E5..         MOV     A,?V0 + 11
   \   0000B4   F5..         MOV     ?V0 + 0,A
   \   0000B6   78..         MOV     R0,#?V0 + 0
   \   0000B8   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000BB   740B         MOV     A,#0xb
   \   0000BD   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C0   12....       LCALL   ??Subroutine133_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_187:
   \   0000C3   740D         MOV     A,#0xd
   \   0000C5   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C8   12....       LCALL   ?Subroutine36 & 0xFFFF
   \                     ??CrossCallReturnLabel_39:
   \   0000CB   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000CE   E9           MOV     A,R1
   \   0000CF   FE           MOV     R6,A
    746              osal_mem_free( buf );
   \   0000D0                ; Setup parameters for call to function osal_mem_free
   \   0000D0   AA..         MOV     R2,?V0 + 6
   \   0000D2   AB..         MOV     R3,?V0 + 7
   \   0000D4   12....       LCALL   ??osal_mem_free?relay
   \   0000D7   8002         SJMP    ??zcl_SendWriteRequest_6
    747            }
    748            else
    749              status = ZMemError;
   \                     ??zcl_SendWriteRequest_3:
   \   0000D9   7E10         MOV     R6,#0x10
    750          
    751            return ( status);
   \                     ??zcl_SendWriteRequest_6:
   \   0000DB   02....       LJMP    ?Subroutine120 & 0xFFFF
    752          }
    753          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    754          ZStatus_t zcl_SendWriteRsp( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendWriteRsp:
    755                                      uint16 clusterID, zclWriteRspCmd_t *writeRspCmd,
    756                                      uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
    757          {
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 6,R1
   \   000007   EA           MOV     A,R2
   \   000008   FE           MOV     R6,A
   \   000009   EB           MOV     A,R3
   \   00000A   FF           MOV     R7,A
   \   00000B   8C..         MOV     ?V0 + 0,R4
   \   00000D   8D..         MOV     ?V0 + 1,R5
   \   00000F   7416         MOV     A,#0x16
   \   000011   12....       LCALL   ?XSTACK_DISP0_8
   \   000014   12....       LCALL   ?Subroutine57 & 0xFFFF
   \                     ??CrossCallReturnLabel_80:
   \   000017   12....       LCALL   ?XSTACK_DISP0_8
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   F5..         MOV     ?V0 + 7,A
   \   00001D   7419         MOV     A,#0x19
   \   00001F   12....       LCALL   ?XSTACK_DISP0_8
   \   000022   E0           MOVX    A,@DPTR
   \   000023   F5..         MOV     ?V0 + 10,A
   \   000025   741A         MOV     A,#0x1a
   \   000027   12....       LCALL   ?XSTACK_DISP0_8
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   F5..         MOV     ?V0 + 11,A
    758            uint8 dataLen;
    759            uint8 *buf;
    760            uint8 *pBuf;
    761            uint8 i;
    762            ZStatus_t status;
    763            
    764            dataLen = writeRspCmd->numAttr * ( 1 + 2 ); // status + attribute id
   \   00002D   75F003       MOV     B,#0x3
   \   000030   85..82       MOV     DPL,?V0 + 4
   \   000033   85..83       MOV     DPH,?V0 + 5
   \   000036   E0           MOVX    A,@DPTR
   \   000037   A4           MUL     AB
   \   000038   F5..         MOV     ?V0 + 12,A
    765          
    766            buf = osal_mem_alloc( dataLen );
   \   00003A                ; Setup parameters for call to function osal_mem_alloc
   \   00003A   FA           MOV     R2,A
   \   00003B   12....       LCALL   ?Subroutine64 & 0xFFFF
    767            if ( buf != NULL )
   \                     ??CrossCallReturnLabel_88:
   \   00003E   7001         JNZ     ??zcl_SendWriteRsp_0
   \   000040   EB           MOV     A,R3
   \                     ??zcl_SendWriteRsp_0:
   \   000041   7003         JNZ     $+5
   \   000043   02....       LJMP    ??zcl_SendWriteRsp_1 & 0xFFFF
    768            {
    769              // Load the buffer - serially
    770              pBuf = buf;
   \   000046   A8..         MOV     R0,?V0 + 2
   \   000048   A9..         MOV     R1,?V0 + 3
    771              for ( i = 0; i < writeRspCmd->numAttr; i++ )
   \   00004A   75..00       MOV     ?V0 + 8,#0x0
   \   00004D   802E         SJMP    ??zcl_SendWriteRsp_2
    772              { 
    773                *pBuf++ = writeRspCmd->attrList[i].status;
   \                     ??zcl_SendWriteRsp_3:
   \   00004F   E5..         MOV     A,?V0 + 8
   \   000051   75F003       MOV     B,#0x3
   \   000054   A4           MUL     AB
   \   000055   FA           MOV     R2,A
   \   000056   ABF0         MOV     R3,B
   \   000058   E5..         MOV     A,?V0 + 4
   \   00005A   2A           ADD     A,R2
   \   00005B   FA           MOV     R2,A
   \   00005C   E5..         MOV     A,?V0 + 5
   \   00005E   3B           ADDC    A,R3
   \   00005F   FB           MOV     R3,A
   \   000060   8A82         MOV     DPL,R2
   \   000062   8B83         MOV     DPH,R3
   \   000064   A3           INC     DPTR
   \   000065   12....       LCALL   ?Subroutine41 & 0xFFFF
    774                *pBuf++ = LO_UINT16( writeRspCmd->attrList[i].attrID );
   \                     ??CrossCallReturnLabel_173:
   \   000068   EA           MOV     A,R2
   \   000069   2402         ADD     A,#0x2
   \   00006B   0A           INC     R2
   \   00006C   0A           INC     R2
   \   00006D   EB           MOV     A,R3
   \   00006E   3400         ADDC    A,#0x0
   \   000070   FB           MOV     R3,A
   \   000071   8A82         MOV     DPL,R2
   \   000073   8B83         MOV     DPH,R3
   \   000075   12....       LCALL   ??Subroutine129_0 & 0xFFFF
    775                *pBuf++ = HI_UINT16( writeRspCmd->attrList[i].attrID );
   \                     ??CrossCallReturnLabel_180:
   \   000078   12....       LCALL   ?Subroutine28 & 0xFFFF
    776              }
   \                     ??CrossCallReturnLabel_182:
   \   00007B   05..         INC     ?V0 + 8
   \                     ??zcl_SendWriteRsp_2:
   \   00007D   85..82       MOV     DPL,?V0 + 4
   \   000080   85..83       MOV     DPH,?V0 + 5
   \   000083   E0           MOVX    A,@DPTR
   \   000084   FA           MOV     R2,A
   \   000085   E5..         MOV     A,?V0 + 8
   \   000087   C3           CLR     C
   \   000088   9A           SUBB    A,R2
   \   000089   40C4         JC      ??zcl_SendWriteRsp_3
    777              
    778              // If there's only a single status record and its status field is set to 
    779              // SUCCESS then omit the attribute ID field.
    780              if ( writeRspCmd->numAttr == 1 && writeRspCmd->attrList[0].status == ZCL_STATUS_SUCCESS )
   \   00008B   E0           MOVX    A,@DPTR
   \   00008C   6401         XRL     A,#0x1
   \   00008E   7007         JNZ     ??zcl_SendWriteRsp_4
   \   000090   A3           INC     DPTR
   \   000091   E0           MOVX    A,@DPTR
   \   000092   7003         JNZ     ??zcl_SendWriteRsp_4
    781                dataLen = 1;
   \   000094   75..01       MOV     ?V0 + 12,#0x1
    782                
    783              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_WRITE_RSP, FALSE,
    784                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \                     ??zcl_SendWriteRsp_4:
   \   000097                ; Setup parameters for call to function zcl_SendCommand
   \   000097   78..         MOV     R0,#?V0 + 2
   \   000099   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00009C   75..00       MOV     ?V0 + 13,#0x0
   \   00009F   78..         MOV     R0,#?V0 + 12
   \   0000A1   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000A4   E5..         MOV     A,?V0 + 11
   \   0000A6   F5..         MOV     ?V0 + 4,A
   \   0000A8   78..         MOV     R0,#?V0 + 4
   \   0000AA   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000AD   75..00       MOV     ?V0 + 4,#0x0
   \   0000B0   75..00       MOV     ?V0 + 5,#0x0
   \   0000B3   78..         MOV     R0,#?V0 + 4
   \   0000B5   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000B8   E5..         MOV     A,?V0 + 10
   \   0000BA   F5..         MOV     ?V0 + 4,A
   \   0000BC   78..         MOV     R0,#?V0 + 4
   \   0000BE   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000C1   E5..         MOV     A,?V0 + 7
   \   0000C3   F5..         MOV     ?V0 + 4,A
   \   0000C5   78..         MOV     R0,#?V0 + 4
   \   0000C7   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000CA   75..00       MOV     ?V0 + 4,#0x0
   \   0000CD   78..         MOV     R0,#?V0 + 4
   \   0000CF   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000D2   75..04       MOV     ?V0 + 4,#0x4
   \   0000D5   78..         MOV     R0,#?V0 + 4
   \   0000D7   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000DA   AC..         MOV     R4,?V0 + 0
   \   0000DC   AD..         MOV     R5,?V0 + 1
   \   0000DE   EE           MOV     A,R6
   \   0000DF   FA           MOV     R2,A
   \   0000E0   EF           MOV     A,R7
   \   0000E1   FB           MOV     R3,A
   \   0000E2   A9..         MOV     R1,?V0 + 6
   \   0000E4   12....       LCALL   ?Subroutine96 & 0xFFFF
   \                     ??CrossCallReturnLabel_134:
   \   0000E7   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000EA   E9           MOV     A,R1
   \   0000EB   FE           MOV     R6,A
    785              osal_mem_free( buf );
   \   0000EC                ; Setup parameters for call to function osal_mem_free
   \   0000EC   AA..         MOV     R2,?V0 + 2
   \   0000EE   AB..         MOV     R3,?V0 + 3
   \   0000F0   12....       LCALL   ??osal_mem_free?relay
   \   0000F3   8002         SJMP    ??zcl_SendWriteRsp_5
    786            }
    787            else
    788              status = ZMemError;
   \                     ??zcl_SendWriteRsp_1:
   \   0000F5   7E10         MOV     R6,#0x10
    789          
    790            return ( status );
   \                     ??zcl_SendWriteRsp_5:
   \   0000F7   02....       LJMP    ?Subroutine121 & 0xFFFF
    791          }
    792          #endif // ZCL_WRITE
    793          
    794          #ifdef ZCL_REPORT
    795          ZStatus_t zcl_SendConfigReportCmd( uint8 srcEP, afAddrType_t *dstAddr,
    796                                    uint16 clusterID, zclCfgReportCmd_t *cfgReportCmd,
    797                                    uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
    798          {
    799            uint8 *buf;
    800            uint8 *pBuf;
    801            uint8 dataLen = 0;
    802            zclCfgReportRec_t *reportRec;
    803            uint8 reportChangeLen; // length of Reportable Change field
    804            uint8 i;
    805            ZStatus_t status;
    806            
    807            // Find out the data length
    808            for ( i = 0; i < cfgReportCmd->numAttr; i++ )
    809            {
    810              reportRec = &(cfgReportCmd->attrList[i]);
    811              
    812              dataLen += 1 + 2; // Direction + Attribute ID
    813              reportChangeLen = 0;
    814              
    815              if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
    816              {
    817                dataLen += 1 + 2 + 2; // Data Type + Min + Max Reporting Intervals
    818                
    819                // Find out the size of the Reportable Change field (for Analog data types)
    820                if ( zclAnalogDataType( reportRec->dataType ) )
    821                {
    822                  reportChangeLen = zclGetDataTypeLength( reportRec->dataType );
    823                  dataLen += reportChangeLen;
    824                }
    825              }
    826              else
    827              {
    828                dataLen += 2; // Timeout Period
    829              }
    830            }
    831            
    832            buf = osal_mem_alloc( dataLen );
    833            if ( buf != NULL )
    834            {
    835              // Load the buffer - serially
    836              pBuf = buf;
    837              for ( i = 0; i < cfgReportCmd->numAttr; i++ )
    838              {
    839                reportRec = &(cfgReportCmd->attrList[i]);
    840                
    841                *pBuf++ = reportRec->direction;
    842                *pBuf++ = LO_UINT16( reportRec->attrID );
    843                *pBuf++ = HI_UINT16( reportRec->attrID );
    844                
    845                if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
    846                {
    847                  *pBuf++ = reportRec->dataType;
    848                  *pBuf++ = LO_UINT16( reportRec->minReportInt );
    849                  *pBuf++ = HI_UINT16( reportRec->minReportInt );
    850                  *pBuf++ = LO_UINT16( reportRec->maxReportInt );
    851                  *pBuf++ = HI_UINT16( reportRec->maxReportInt );
    852          
    853                  if ( zclAnalogDataType( reportRec->dataType ) )
    854                  {
    855                    zclSerializeData( reportRec->dataType, reportRec->reportableChange, pBuf );
    856                    reportChangeLen = zclGetDataTypeLength( reportRec->dataType );
    857                    pBuf += reportChangeLen;
    858                  }
    859                }
    860                else
    861                {
    862                  *pBuf++ = LO_UINT16( reportRec->timeoutPeriod );
    863                  *pBuf++ = HI_UINT16( reportRec->timeoutPeriod );
    864                } 
    865              } // for loop
    866              
    867              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_CONFIG_REPORT, FALSE, 
    868                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
    869              osal_mem_free( buf );
    870            }
    871            else
    872              status = ZMemError;
    873            
    874            return ( status );
    875          }
    876          
    877          /*********************************************************************
    878           * @fn      zcl_SendConfigReportRspCmd
    879           * @brief   Send a Configure Reporting Response command
    880           * @param   dstAddr - destination address
    881           *          clusterID - cluster ID
    882           *          cfgReportRspCmd - configure reporting response command to be sent
    883           *          direction - direction of the command
    884           *          seqNum - transaction sequence number
    885           * @return  ZSuccess if OK
    886           */
    887          ZStatus_t zcl_SendConfigReportRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
    888                              uint16 clusterID, zclCfgReportRspCmd_t *cfgReportRspCmd,
    889                              uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
    890          {
    891            uint8 dataLen;
    892            uint8 *buf;
    893            uint8 *pBuf;
    894            uint8 i;
    895            ZStatus_t status;
    896            
    897            // Atrribute list (Status, Direction and Attribute ID)
    898            dataLen = cfgReportRspCmd->numAttr * ( 1 + 1 + 2 ); 
    899            
    900            buf = osal_mem_alloc( dataLen );
    901            if ( buf != NULL )
    902            {
    903              // Load the buffer - serially
    904              pBuf = buf; 
    905              for ( i = 0; i < cfgReportRspCmd->numAttr; i++ )
    906              {
    907                *pBuf++ = cfgReportRspCmd->attrList[i].status;
    908                *pBuf++ = cfgReportRspCmd->attrList[i].direction;
    909                *pBuf++ = LO_UINT16( cfgReportRspCmd->attrList[i].attrID );
    910                *pBuf++ = HI_UINT16( cfgReportRspCmd->attrList[i].attrID );
    911              }
    912              
    913              // If there's only a single status record and its status field is set to 
    914              // SUCCESS then omit the attribute ID field.
    915              if ( cfgReportRspCmd->numAttr == 1 && cfgReportRspCmd->attrList[0].status == ZCL_STATUS_SUCCESS )
    916                dataLen = 1;
    917              
    918              status = zcl_SendCommand( srcEP, dstAddr, clusterID,
    919                                        ZCL_CMD_CONFIG_REPORT_RSP, FALSE, direction, 
    920                                        disableDefaultRsp, 0, seqNum, dataLen, buf );
    921              osal_mem_free( buf );
    922            }
    923            else
    924              status = ZMemError;
    925            
    926            return ( status );
    927          }
    928          
    929          /*********************************************************************
    930           * @fn      zcl_SendReadReportCfgCmd
    931           * @brief   Send a Read Reporting Configuration command
    932           * @param   dstAddr - destination address
    933           *          clusterID - cluster ID
    934           *          readReportCfgCmd - read reporting configuration command to be sent
    935           *          direction - direction of the command
    936           *          seqNum - transaction sequence number
    937           * @return  ZSuccess if OK
    938           */
    939          ZStatus_t zcl_SendReadReportCfgCmd( uint8 srcEP, afAddrType_t *dstAddr,
    940                            uint16 clusterID, zclReadReportCfgCmd_t *readReportCfgCmd,
    941                            uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
    942          {
    943            uint8 dataLen;
    944            uint8 *buf;
    945            uint8 *pBuf;
    946            uint8 i;
    947            ZStatus_t status;
    948           
    949            dataLen = readReportCfgCmd->numAttr * ( 1 + 2 ); // Direction + Atrribute ID
    950            
    951            buf = osal_mem_alloc( dataLen );
    952            if ( buf != NULL )
    953            {
    954              // Load the buffer - serially
    955              pBuf = buf;
    956              for ( i = 0; i < readReportCfgCmd->numAttr; i++ )
    957              {
    958                *pBuf++ = readReportCfgCmd->attrList[i].direction;
    959                *pBuf++ = LO_UINT16( readReportCfgCmd->attrList[i].attrID );
    960                *pBuf++ = HI_UINT16( readReportCfgCmd->attrList[i].attrID );
    961              }
    962              
    963              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ_REPORT_CFG, FALSE, 
    964                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
    965              osal_mem_free( buf );
    966            }
    967            else
    968              status = ZMemError;
    969            
    970            return ( status );
    971          }
    972          
    973          /*********************************************************************
    974           * @fn      zcl_SendReadReportCfgRspCmd
    975           * @brief   Send a Read Reporting Configuration Response command
    976           * @param   dstAddr - destination address
    977           *          clusterID - cluster ID
    978           *          readReportCfgRspCmd - read reporting configuration response command to be sent
    979           *          direction - direction of the command
    980           *          seqNum - transaction sequence number
    981           * @return  ZSuccess if OK
    982           */
    983          ZStatus_t zcl_SendReadReportCfgRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
    984                       uint16 clusterID, zclReadReportCfgRspCmd_t *readReportCfgRspCmd,
    985                       uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
    986          {
    987            uint8 *buf;
    988            uint8 *pBuf;
    989            uint8 dataLen = 0;
    990            zclReportCfgRspRec_t *reportRspRec;
    991            uint8 reportChangeLen;
    992            uint8 i;
    993            ZStatus_t status;
    994          
    995            // Find out the data length
    996            for ( i = 0; i < readReportCfgRspCmd->numAttr; i++ )
    997            {
    998              reportRspRec = &(readReportCfgRspCmd->attrList[i]);
    999              
   1000              dataLen += 1 + 1 + 2 ; // Status, Direction and Atrribute ID
   1001              
   1002              if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   1003              {
   1004                if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   1005                {
   1006                  dataLen += 1 + 2 + 2; // Data Type + Min + Max Reporting Intervals
   1007                
   1008                  if ( zclAnalogDataType( reportRspRec->dataType ) )
   1009                  {
   1010                    reportChangeLen = zclGetDataTypeLength( reportRspRec->dataType );
   1011                    dataLen += reportChangeLen; // Reportable Change field
   1012                  }
   1013                }
   1014                else
   1015                {
   1016                  dataLen += 2; // Timeout Period
   1017                }
   1018              }
   1019            }
   1020            
   1021            buf = osal_mem_alloc( dataLen );
   1022            if ( buf != NULL )
   1023            {
   1024              // Load the buffer - serially
   1025              pBuf = buf;
   1026          
   1027              for ( i = 0; i < readReportCfgRspCmd->numAttr; i++ )
   1028              {
   1029                reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   1030          
   1031                *pBuf++ = reportRspRec->status;
   1032                *pBuf++ = reportRspRec->direction;
   1033                *pBuf++ = LO_UINT16( reportRspRec->attrID );
   1034                *pBuf++ = HI_UINT16( reportRspRec->attrID );
   1035               
   1036                if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   1037                {
   1038                  if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   1039                  {
   1040                    *pBuf++ = reportRspRec->dataType;
   1041                    *pBuf++ = LO_UINT16( reportRspRec->minReportInt );
   1042                    *pBuf++ = HI_UINT16( reportRspRec->minReportInt );
   1043                    *pBuf++ = LO_UINT16( reportRspRec->maxReportInt );
   1044                    *pBuf++ = HI_UINT16( reportRspRec->maxReportInt );
   1045          
   1046                    if ( zclAnalogDataType( reportRspRec->dataType ) )
   1047                    {
   1048                      zclSerializeData( reportRspRec->dataType, 
   1049                                        reportRspRec->reportableChange, pBuf );
   1050                      reportChangeLen = zclGetDataTypeLength( reportRspRec->dataType );
   1051                      pBuf += reportChangeLen;
   1052                    }
   1053                  }
   1054                  else
   1055                  {
   1056                    *pBuf++ = LO_UINT16( reportRspRec->timeoutPeriod );
   1057                    *pBuf++ = HI_UINT16( reportRspRec->timeoutPeriod );
   1058                  }
   1059                }
   1060              }
   1061             
   1062              status = zcl_SendCommand( srcEP, dstAddr, clusterID,
   1063                                        ZCL_CMD_READ_REPORT_CFG_RSP, FALSE,
   1064                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1065              osal_mem_free( buf );
   1066            }
   1067            else
   1068              status = ZMemError;
   1069            
   1070            return ( status );
   1071          }
   1072          
   1073          /*********************************************************************
   1074           * @fn      zcl_SendReportCmd
   1075           * @brief   Send a Report command
   1076           * @param   dstAddr - destination address
   1077           *          clusterID - cluster ID
   1078           *          reportCmd - report command to be sent
   1079           *          direction - direction of the command
   1080           *          seqNum - transaction sequence number
   1081           * @return  ZSuccess if OK
   1082           */
   1083          ZStatus_t zcl_SendReportCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1084                                       uint16 clusterID, zclReportCmd_t *reportCmd,
   1085                                       uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1086          {
   1087            zclReport_t *reportRec;
   1088            uint8 attrDataLen;
   1089            uint8 dataLen = 0;
   1090            uint8 *buf;
   1091            uint8 *pBuf;
   1092            uint8 i;
   1093            ZStatus_t status;
   1094            
   1095            // calculate the size of the command
   1096            for ( i = 0; i < reportCmd->numAttr; i++ )
   1097            {
   1098              reportRec = &(reportCmd->attrList[i]);
   1099              
   1100              dataLen += 2 + 1; // Attribute ID + data type
   1101          
   1102              attrDataLen = zclGetAttrDataLength( reportRec->dataType, reportRec->attrData );
   1103              dataLen += attrDataLen; // Attribute Data
   1104            }
   1105            
   1106            buf = osal_mem_alloc( dataLen );
   1107            if ( buf != NULL )
   1108            {
   1109              // Load the buffer - serially
   1110              pBuf = buf;
   1111              for ( i = 0; i < reportCmd->numAttr; i++ )
   1112              {
   1113                reportRec = &(reportCmd->attrList[i]);
   1114                
   1115                *pBuf++ = LO_UINT16( reportRec->attrID );
   1116                *pBuf++ = HI_UINT16( reportRec->attrID );
   1117                *pBuf++ = reportRec->dataType;
   1118          
   1119                zclSerializeData( reportRec->dataType, reportRec->attrData, pBuf );
   1120                attrDataLen = zclGetAttrDataLength( reportRec->dataType, reportRec->attrData );
   1121                pBuf += attrDataLen; // move pass attribute data
   1122              }
   1123           
   1124              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_REPORT, FALSE, 
   1125                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1126              osal_mem_free( buf );
   1127            }
   1128            else
   1129              status = ZMemError;
   1130            
   1131            return ( status );
   1132          }
   1133          #endif // ZCL_REPORT
   1134                 
   1135          /*********************************************************************
   1136           * @fn      zcl_SendDefaultRspCmd
   1137           * @brief   Send a Default Response command
   1138           *
   1139           *          Note: The manufacturer code field should be set if this command is being sent
   1140           *           in response to a manufacturer specific command.
   1141           * @param   dstAddr - destination address
   1142           *          clusterID - cluster ID
   1143           *          defaultRspCmd - default response command to be sent
   1144           *          direction - direction of the command
   1145           *          manuCode - manufacturer code for proprietary extensions to a profile
   1146           *          seqNum - transaction sequence number
   1147           * @return  ZSuccess if OK
   1148           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1149          ZStatus_t zcl_SendDefaultRspCmd( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID,
   \                     zcl_SendDefaultRspCmd:
   1150                                           zclDefaultRspCmd_t *defaultRspCmd, uint8 direction,
   1151                                           uint8 disableDefaultRsp, uint16 manuCode, uint8 seqNum )
   1152          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   \   00000C   7410         MOV     A,#0x10
   \   00000E   12....       LCALL   ?XSTACK_DISP0_8
   \   000011   12....       LCALL   ?Subroutine56 & 0xFFFF
   \                     ??CrossCallReturnLabel_73:
   \   000014   7412         MOV     A,#0x12
   \   000016   12....       LCALL   ?XSTACK_DISP0_8
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   FF           MOV     R7,A
   \   00001B   7413         MOV     A,#0x13
   \   00001D   12....       LCALL   ?XSTACK_DISP0_8
   \   000020   E0           MOVX    A,@DPTR
   \   000021   F5..         MOV     ?V0 + 4,A
   \   000023   7414         MOV     A,#0x14
   \   000025   12....       LCALL   ?XSTACK_DISP0_8
   \   000028   E0           MOVX    A,@DPTR
   \   000029   F5..         MOV     ?V0 + 2,A
   \   00002B   A3           INC     DPTR
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   F5..         MOV     ?V0 + 3,A
   \   00002F   7416         MOV     A,#0x16
   \   000031   12....       LCALL   ?XSTACK_DISP0_8
   \   000034   E0           MOVX    A,@DPTR
   \   000035   F5..         MOV     ?V0 + 5,A
   1153            uint8 buf[2]; // Command ID and Status;
   1154          
   1155            // Load the buffer - serially
   1156            buf[0] = defaultRspCmd->commandID;
   \   000037   8882         MOV     DPL,R0
   \   000039   8983         MOV     DPH,R1
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   85..82       MOV     DPL,?XSP + 0
   \   00003F   85..83       MOV     DPH,?XSP + 1
   \   000042   12....       LCALL   ?Subroutine14 & 0xFFFF
   1157            buf[1] = defaultRspCmd->statusCode;
   \                     ??CrossCallReturnLabel_21:
   \   000045   E0           MOVX    A,@DPTR
   \   000046   C0E0         PUSH    A
   \   000048   7401         MOV     A,#0x1
   \   00004A   12....       LCALL   ?XSTACK_DISP0_8
   \   00004D   D0E0         POP     A
   \   00004F   F0           MOVX    @DPTR,A
   1158          
   1159            return ( zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DEFAULT_RSP, FALSE,
   1160                                      direction, disableDefaultRsp, manuCode, seqNum, 2, buf ) ); 
   \   000050                ; Setup parameters for call to function zcl_SendCommand
   \   000050   85..82       MOV     DPL,?XSP + 0
   \   000053   85..83       MOV     DPH,?XSP + 1
   \   000056   8582..       MOV     ?V0 + 0,DPL
   \   000059   8583..       MOV     ?V0 + 1,DPH
   \   00005C   78..         MOV     R0,#?V0 + 0
   \   00005E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000061   75..02       MOV     ?V0 + 0,#0x2
   \   000064   75..00       MOV     ?V0 + 1,#0x0
   \   000067   78..         MOV     R0,#?V0 + 0
   \   000069   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00006C   E5..         MOV     A,?V0 + 5
   \   00006E   F5..         MOV     ?V0 + 0,A
   \   000070   78..         MOV     R0,#?V0 + 0
   \   000072   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000075   78..         MOV     R0,#?V0 + 2
   \   000077   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00007A   E5..         MOV     A,?V0 + 4
   \   00007C   F5..         MOV     ?V0 + 0,A
   \   00007E   78..         MOV     R0,#?V0 + 0
   \   000080   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000083   EF           MOV     A,R7
   \   000084   F5..         MOV     ?V0 + 0,A
   \   000086   78..         MOV     R0,#?V0 + 0
   \   000088   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00008B   75..00       MOV     ?V0 + 0,#0x0
   \   00008E   78..         MOV     R0,#?V0 + 0
   \   000090   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000093   75..0B       MOV     ?V0 + 0,#0xb
   \   000096   78..         MOV     R0,#?V0 + 0
   \   000098   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00009B   EE           MOV     A,R6
   \   00009C   F9           MOV     R1,A
   \   00009D   12....       LCALL   ?Subroutine96 & 0xFFFF
   \                     ??CrossCallReturnLabel_135:
   \   0000A0   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000A3   7402         MOV     A,#0x2
   \   0000A5   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000A8   02....       LJMP    ?Subroutine111 & 0xFFFF
   1161          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine56:
   \   000000   12....       LCALL   ?Subroutine91 & 0xFFFF
   \                     ??CrossCallReturnLabel_224:
   \   000003   22           RET
   1162          
   1163          #ifdef ZCL_DISCOVER
   1164          /*********************************************************************
   1165           * @fn      zcl_SendDiscoverCmd
   1166           * @brief   Send a Discover command
   1167           * @param   dstAddr - destination address
   1168           *          clusterID - cluster ID
   1169           *          discoverCmd - discover command to be sent
   1170           *          direction - direction of the command
   1171           *          seqNum - transaction sequence number
   1172           * @return  ZSuccess if OK
   1173           */
   1174          ZStatus_t zcl_SendDiscoverCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1175                                      uint16 clusterID, zclDiscoverCmd_t *discoverCmd,
   1176                                      uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1177          {
   1178            uint8 dataLen = 2 + 1; // Start Attribute ID and Max Attribute IDs
   1179            uint8 *buf;
   1180            uint8 *pBuf;
   1181            ZStatus_t status;
   1182            
   1183            buf = osal_mem_alloc( dataLen );
   1184            if ( buf != NULL )
   1185            {
   1186              // Load the buffer - serially
   1187              pBuf = buf;
   1188              *pBuf++ = LO_UINT16(discoverCmd->startAttr);
   1189              *pBuf++ = HI_UINT16(discoverCmd->startAttr);
   1190              *pBuf++ = discoverCmd->maxAttrIDs;
   1191              
   1192              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER, FALSE, 
   1193                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1194              osal_mem_free( buf );
   1195            }
   1196            else
   1197              status = ZMemError;
   1198            
   1199            return ( status );
   1200          }
   1201          
   1202          /*********************************************************************
   1203           * @fn      zcl_SendDiscoverRspCmd
   1204           * @brief   Send a Discover Response command
   1205           * @param   dstAddr - destination address
   1206           *          clusterID - cluster ID
   1207           *          reportRspCmd - report response command to be sent
   1208           *          direction - direction of the command
   1209           *          seqNum - transaction sequence number
   1210           * @return  ZSuccess if OK
   1211           */
   1212          ZStatus_t zcl_SendDiscoverRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1213                                uint16 clusterID, zclDiscoverRspCmd_t *discoverRspCmd,
   1214                                uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1215          {
   1216            uint8 dataLen = 1; // Discovery complete
   1217            uint8 *buf;
   1218            uint8 *pBuf;
   1219            uint8 i;
   1220            ZStatus_t status;
   1221            
   1222            // calculate the size of the command
   1223            dataLen += discoverRspCmd->numAttr * (2 + 1); // Attribute ID and Data Type
   1224            
   1225            buf = osal_mem_alloc( dataLen );
   1226            if ( buf != NULL )
   1227            {
   1228              // Load the buffer - serially
   1229              pBuf = buf;
   1230              *pBuf++ = discoverRspCmd->discComplete;    
   1231              for ( i = 0; i < discoverRspCmd->numAttr; i++ )
   1232              {
   1233                *pBuf++ = LO_UINT16(discoverRspCmd->attrList[i].attrID);
   1234                *pBuf++ = HI_UINT16(discoverRspCmd->attrList[i].attrID);
   1235                *pBuf++ = discoverRspCmd->attrList[i].dataType;
   1236              }
   1237              
   1238              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_RSP, FALSE,
   1239                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1240              osal_mem_free( buf );
   1241            }
   1242            else
   1243              status = ZMemError;
   1244            
   1245            return ( status );
   1246          }
   1247          #endif // ZCL_DISCOVER
   1248          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1249          void zclProcessMessageMSG( afIncomingMSGPacket_t *pkt )
   \                     zclProcessMessageMSG:
   1250          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 55
   \   000005   74C9         MOV     A,#-0x37
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1251          #if defined(Coor_receiver) // The coordinator receive data
   1252            byte recv_data[30];  
   1253            uint16 len;
   1254          #endif
   1255            
   1256          #if defined(End_Device) || defined(Router_Device) // The End Device receive data
   1257            byte receive[20];
   1258            uint16 len;
   1259          #endif  
   1260          
   1261            endPointDesc_t *epDesc;
   1262            zclIncoming_t inMsg;
   1263            zclLibPlugin_t *pInPlugin;
   1264            zclDefaultRspCmd_t defautlRspCmd;
   1265            uint8 options;
   1266            uint8 securityEnable;
   1267            uint8 interPanMsg;
   1268            ZStatus_t status = ZFailure;
   1269          
   1270            if ( pkt->cmd.DataLength == 0 ) return;   // Error, ignore the message
   \   00000E   EE           MOV     A,R6
   \   00000F   241F         ADD     A,#0x1f
   \   000011   12....       LCALL   ?Subroutine69 & 0xFFFF
   \                     ??CrossCallReturnLabel_95:
   \   000014   7002         JNZ     ??zclProcessMessageMSG_0
   \   000016   A3           INC     DPTR
   \   000017   E0           MOVX    A,@DPTR
   \                     ??zclProcessMessageMSG_0:
   \   000018   7003         JNZ     $+5
   \   00001A   02....       LJMP    ??zclProcessMessageMSG_1 & 0xFFFF
   1271          
   1272          #if defined(Coor_receiver)
   1273            if (pkt->cmd.DataLength > 0)
   1274            {
   1275              for(len = 0; len < pkt->cmd.DataLength; len++) // Send the recv_data to UART
   \   00001D   7800         MOV     R0,#0x0
   \   00001F   7900         MOV     R1,#0x0
   \   000021   EE           MOV     A,R6
   \   000022   2421         ADD     A,#0x21
   \   000024   F5..         MOV     ?V0 + 4,A
   \   000026   EF           MOV     A,R7
   \   000027   3400         ADDC    A,#0x0
   \   000029   F5..         MOV     ?V0 + 5,A
   \   00002B   8021         SJMP    ??zclProcessMessageMSG_2
   1276              {
   1277                  recv_data[len] = pkt->cmd.Data[len+3]; // the cmd.Data[0~2] is cluster ID.
   \                     ??zclProcessMessageMSG_3:
   \   00002D   85..82       MOV     DPL,?V0 + 4
   \   000030   85..83       MOV     DPH,?V0 + 5
   \   000033   12....       LCALL   ?Subroutine48 & 0xFFFF
   1278              }
   \                     ??CrossCallReturnLabel_63:
   \   000036   A3           INC     DPTR
   \   000037   A3           INC     DPTR
   \   000038   E0           MOVX    A,@DPTR
   \   000039   C0E0         PUSH    A
   \   00003B   7419         MOV     A,#0x19
   \   00003D   12....       LCALL   ?XSTACK_DISP0_8
   \   000040   12....       LCALL   ?Subroutine75 & 0xFFFF
   \                     ??CrossCallReturnLabel_103:
   \   000043   D0E0         POP     A
   \   000045   F0           MOVX    @DPTR,A
   \   000046   E8           MOV     A,R0
   \   000047   2401         ADD     A,#0x1
   \   000049   08           INC     R0
   \   00004A   E9           MOV     A,R1
   \   00004B   3400         ADDC    A,#0x0
   \   00004D   F9           MOV     R1,A
   \                     ??zclProcessMessageMSG_2:
   \   00004E   12....       LCALL   ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_213:
   \   000051   C3           CLR     C
   \   000052   E8           MOV     A,R0
   \   000053   9A           SUBB    A,R2
   \   000054   E9           MOV     A,R1
   \   000055   9B           SUBB    A,R3
   \   000056   40D5         JC      ??zclProcessMessageMSG_3
   1279              
   1280              #define HI_UINT16(a) (((a) >> 8) & 0xFF)
   1281              #define LO_UINT16(a) ((a) & 0xFF)
   1282              
   1283              char entry[4];
   1284              uint8 hi = HI_UINT16( pkt->srcAddr.addr.shortAddr );
   \   000058   8E82         MOV     DPL,R6
   \   00005A   8F83         MOV     DPH,R7
   \   00005C   A3           INC     DPTR
   \   00005D   A3           INC     DPTR
   \   00005E   A3           INC     DPTR
   \   00005F   A3           INC     DPTR
   \   000060   A3           INC     DPTR
   \   000061   A3           INC     DPTR
   \   000062   12....       LCALL   ?Subroutine103 & 0xFFFF
   \                     ??CrossCallReturnLabel_288:
   \   000065   FC           MOV     R4,A
   1285              uint8 lo = LO_UINT16( pkt->srcAddr.addr.shortAddr );
   1286          
   1287              entry[0] = hi/16 + 48;  /* Little Endian for the radio RAM */
   \   000066   C4           SWAP    A
   \   000067   540F         ANL     A,#0xf
   \   000069   2430         ADD     A,#0x30
   \   00006B   C0E0         PUSH    A
   \   00006D   7410         MOV     A,#0x10
   \   00006F   12....       LCALL   ?XSTACK_DISP0_8
   \   000072   D0E0         POP     A
   \   000074   F0           MOVX    @DPTR,A
   1288              entry[1] = hi%16 + 48;
   \   000075   740F         MOV     A,#0xf
   \   000077   5C           ANL     A,R4
   \   000078   2430         ADD     A,#0x30
   \   00007A   C0E0         PUSH    A
   \   00007C   7411         MOV     A,#0x11
   \   00007E   12....       LCALL   ?XSTACK_DISP0_8
   \   000081   D0E0         POP     A
   \   000083   F0           MOVX    @DPTR,A
   1289              entry[2] = lo/16 + 48;
   \   000084   EA           MOV     A,R2
   \   000085   C4           SWAP    A
   \   000086   540F         ANL     A,#0xf
   \   000088   2430         ADD     A,#0x30
   \   00008A   C0E0         PUSH    A
   \   00008C   7412         MOV     A,#0x12
   \   00008E   12....       LCALL   ?XSTACK_DISP0_8
   \   000091   D0E0         POP     A
   \   000093   F0           MOVX    @DPTR,A
   1290              entry[3] = lo%16 + 48;
   \   000094   740F         MOV     A,#0xf
   \   000096   5A           ANL     A,R2
   \   000097   2430         ADD     A,#0x30
   \   000099   C0E0         PUSH    A
   \   00009B   7413         MOV     A,#0x13
   \   00009D   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A0   D0E0         POP     A
   \   0000A2   F0           MOVX    @DPTR,A
   1291              for (int k=0;k<4;k++)
   \   0000A3   7800         MOV     R0,#0x0
   \   0000A5   7900         MOV     R1,#0x0
   1292              {
   1293                if(entry[k]>57)
   \                     ??zclProcessMessageMSG_4:
   \   0000A7   7410         MOV     A,#0x10
   \   0000A9   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AC   12....       LCALL   ?Subroutine75 & 0xFFFF
   \                     ??CrossCallReturnLabel_104:
   \   0000AF   E0           MOVX    A,@DPTR
   \   0000B0   C3           CLR     C
   \   0000B1   943A         SUBB    A,#0x3a
   \   0000B3   4004         JC      ??zclProcessMessageMSG_5
   1294                  entry[k]+=7;
   \   0000B5   E0           MOVX    A,@DPTR
   \   0000B6   2407         ADD     A,#0x7
   \   0000B8   F0           MOVX    @DPTR,A
   1295              }
   \                     ??zclProcessMessageMSG_5:
   \   0000B9   E8           MOV     A,R0
   \   0000BA   2401         ADD     A,#0x1
   \   0000BC   08           INC     R0
   \   0000BD   E9           MOV     A,R1
   \   0000BE   3400         ADDC    A,#0x0
   \   0000C0   F9           MOV     R1,A
   \   0000C1   C3           CLR     C
   \   0000C2   E8           MOV     A,R0
   \   0000C3   9404         SUBB    A,#0x4
   \   0000C5   E9           MOV     A,R1
   \   0000C6   9400         SUBB    A,#0x0
   \   0000C8   A2D2         MOV     C,0xD0 /* PSW */.2
   \   0000CA   65D0         XRL     A,PSW
   \   0000CC   33           RLC     A
   \   0000CD   40D8         JC      ??zclProcessMessageMSG_4
   1296          
   1297              HalUARTWrite(MT_UART_DEFAULT_PORT, "3,", 2);//Cmd Type
   \   0000CF                ; Setup parameters for call to function HalUARTWrite
   \   0000CF   7C02         MOV     R4,#0x2
   \   0000D1   7D00         MOV     R5,#0x0
   \   0000D3   7A..         MOV     R2,#(`?<Constant "3,">` & 0xff)
   \   0000D5   7B..         MOV     R3,#((`?<Constant "3,">` >> 8) & 0xff)
   \   0000D7   12....       LCALL   ?Subroutine76 & 0xFFFF
   1298              HalUARTWrite(MT_UART_DEFAULT_PORT, ",", 1);//Comma   
   1299              HalUARTWrite(MT_UART_DEFAULT_PORT, entry, 4);//Device ID
                                                        ^
Warning[Pe167]: argument of type "char *" is incompatible with parameter of
          type "unsigned char *"
   \                     ??CrossCallReturnLabel_105:
   \   0000DA                ; Setup parameters for call to function HalUARTWrite
   \   0000DA   7C04         MOV     R4,#0x4
   \   0000DC   7D00         MOV     R5,#0x0
   \   0000DE   7410         MOV     A,#0x10
   \   0000E0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E3   AA82         MOV     R2,DPL
   \   0000E5   AB83         MOV     R3,DPH
   \   0000E7   12....       LCALL   ?Subroutine76 & 0xFFFF
   1300              HalUARTWrite(MT_UART_DEFAULT_PORT, ",", 1);//Comma
   1301              HalUARTWrite(MT_UART_DEFAULT_PORT, recv_data, pkt->cmd.DataLength-2);//Device Data
   \                     ??CrossCallReturnLabel_106:
   \   0000EA                ; Setup parameters for call to function HalUARTWrite
   \   0000EA   85..82       MOV     DPL,?V0 + 2
   \   0000ED   85..83       MOV     DPH,?V0 + 3
   \   0000F0   E0           MOVX    A,@DPTR
   \   0000F1   24FE         ADD     A,#-0x2
   \   0000F3   FC           MOV     R4,A
   \   0000F4   A3           INC     DPTR
   \   0000F5   E0           MOVX    A,@DPTR
   \   0000F6   34FF         ADDC    A,#-0x1
   \   0000F8   FD           MOV     R5,A
   \   0000F9   7419         MOV     A,#0x19
   \   0000FB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000FE   AA82         MOV     R2,DPL
   \   000100   AB83         MOV     R3,DPH
   \   000102   7900         MOV     R1,#0x0
   \   000104   12....       LCALL   ??HalUARTWrite?relay
   1302              HalUARTWrite(MT_UART_DEFAULT_PORT, "$\r\n", 3);//$\n
   \   000107                ; Setup parameters for call to function HalUARTWrite
   \   000107   7C03         MOV     R4,#0x3
   \   000109   7D00         MOV     R5,#0x0
   \   00010B   7A..         MOV     R2,#(`?<Constant "$\\r\\n">` & 0xff)
   \   00010D   7B..         MOV     R3,#((`?<Constant "$\\r\\n">` >> 8) & 0xff)
   \   00010F   7900         MOV     R1,#0x0
   \   000111   12....       LCALL   ??HalUARTWrite?relay
   1303              
   1304           //   HalUARTWrite(MT_UART_DEFAULT_PORT, recv_data, pkt->cmd.DataLength-2);    
   1305              //HalUARTWrite(MT_UART_DEFAULT_PORT, "\r\n", 3);
   1306            }
   1307          #endif
   1308          
   1309          // The device receive the uart command with RF
   1310          #if defined(End_Device) || defined(Router_Device)
   1311            if(pkt->cmd.DataLength > 0)
   1312            {
   1313              for(len = 0; len < pkt->cmd.DataLength; len++)
   1314              {
   1315                receive[len] = pkt->cmd.Data[len+3];
   1316              }
   1317              // Write receive coordinator command to UART, chrischris
   1318              HalUARTWrite(MT_UART_DEFAULT_PORT, receive, pkt->cmd.DataLength-2);
   1319                
   1320              return ;
   1321            }
   1322          #endif  
   1323            
   1324            // Initialize
   1325            inMsg.msg = pkt;
   \   000114   7402         MOV     A,#0x2
   \   000116   12....       LCALL   ?XSTACK_DISP0_8
   \   000119   EE           MOV     A,R6
   \   00011A   F0           MOVX    @DPTR,A
   \   00011B   A3           INC     DPTR
   \   00011C   EF           MOV     A,R7
   \   00011D   F0           MOVX    @DPTR,A
   1326            inMsg.attrCmd = NULL;
   \   00011E   740E         MOV     A,#0xe
   \   000120   12....       LCALL   ?XSTACK_DISP0_8
   \   000123   E4           CLR     A
   \   000124   F0           MOVX    @DPTR,A
   \   000125   A3           INC     DPTR
   \   000126   F0           MOVX    @DPTR,A
   1327            inMsg.pData = NULL;
   \   000127   740A         MOV     A,#0xa
   \   000129   12....       LCALL   ?XSTACK_DISP0_8
   \   00012C   E4           CLR     A
   \   00012D   F0           MOVX    @DPTR,A
   \   00012E   A3           INC     DPTR
   \   00012F   F0           MOVX    @DPTR,A
   1328            inMsg.pDataLen = 0;
   \   000130   740C         MOV     A,#0xc
   \   000132   12....       LCALL   ?XSTACK_DISP0_8
   \   000135   E4           CLR     A
   \   000136   F0           MOVX    @DPTR,A
   \   000137   A3           INC     DPTR
   \   000138   F0           MOVX    @DPTR,A
   1329          
   1330            inMsg.pData = zclParseHdr( &(inMsg.hdr), pkt->cmd.Data );
   \   000139                ; Setup parameters for call to function zclParseHdr
   \   000139   85..82       MOV     DPL,?V0 + 4
   \   00013C   85..83       MOV     DPH,?V0 + 5
   \   00013F   12....       LCALL   ??Subroutine133_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_188:
   \   000142   7404         MOV     A,#0x4
   \   000144   12....       LCALL   ?XSTACK_DISP0_8
   \   000147   AA82         MOV     R2,DPL
   \   000149   AB83         MOV     R3,DPH
   \   00014B   12....       LCALL   ??zclParseHdr?relay
   \   00014E   740A         MOV     A,#0xa
   \   000150   12....       LCALL   ?XSTACK_DISP0_8
   \   000153   12....       LCALL   ??Subroutine152_0 & 0xFFFF
   1331            inMsg.pDataLen = pkt->cmd.DataLength;
   1332            inMsg.pDataLen -= (uint16)(inMsg.pData - pkt->cmd.Data);
   \                     ??CrossCallReturnLabel_307:
   \   000156   85..82       MOV     DPL,?V0 + 2
   \   000159   85..83       MOV     DPH,?V0 + 3
   \   00015C   C082         PUSH    DPL
   \   00015E   C083         PUSH    DPH
   \   000160   740A         MOV     A,#0xa
   \   000162   12....       LCALL   ?XSTACK_DISP0_8
   \   000165   12....       LCALL   ?Subroutine56 & 0xFFFF
   \                     ??CrossCallReturnLabel_74:
   \   000168   D083         POP     DPH
   \   00016A   D082         POP     DPL
   \   00016C   E0           MOVX    A,@DPTR
   \   00016D   C3           CLR     C
   \   00016E   98           SUBB    A,R0
   \   00016F   F8           MOV     R0,A
   \   000170   A3           INC     DPTR
   \   000171   E0           MOVX    A,@DPTR
   \   000172   99           SUBB    A,R1
   \   000173   F9           MOV     R1,A
   \   000174   85..82       MOV     DPL,?V0 + 4
   \   000177   85..83       MOV     DPH,?V0 + 5
   \   00017A   E0           MOVX    A,@DPTR
   \   00017B   28           ADD     A,R0
   \   00017C   F8           MOV     R0,A
   \   00017D   A3           INC     DPTR
   \   00017E   E0           MOVX    A,@DPTR
   \   00017F   39           ADDC    A,R1
   \   000180   F9           MOV     R1,A
   \   000181   740C         MOV     A,#0xc
   \   000183   12....       LCALL   ?XSTACK_DISP0_8
   \   000186   12....       LCALL   ??Subroutine146_0 & 0xFFFF
   1333          
   1334            // Find the wanted endpoint
   1335            epDesc = afFindEndPointDesc( pkt->endPoint );
   \                     ??CrossCallReturnLabel_253:
   \   000189   EE           MOV     A,R6
   \   00018A   2414         ADD     A,#0x14
   \   00018C   12....       LCALL   ?Subroutine69 & 0xFFFF
   \                     ??CrossCallReturnLabel_96:
   \   00018F   F9           MOV     R1,A
   \   000190   12....       LCALL   ??afFindEndPointDesc?relay
   \   000193   8A..         MOV     ?V0 + 0,R2
   \   000195   8B..         MOV     ?V0 + 1,R3
   \   000197   A8..         MOV     R0,?V0 + 0
   \   000199   A9..         MOV     R1,?V0 + 1
   1336            if ( epDesc == NULL )
   \   00019B   E8           MOV     A,R0
   \   00019C   7001         JNZ     ??zclProcessMessageMSG_6
   \   00019E   E9           MOV     A,R1
   \                     ??zclProcessMessageMSG_6:
   \   00019F   7003         JNZ     $+5
   \   0001A1   02....       LJMP    ??zclProcessMessageMSG_1 & 0xFFFF
   1337              return;   // Error, ignore the message
   1338          
   1339            if ( pkt->clusterId == ZCL_INVALID_CLUSTER_ID )
   \   0001A4   EE           MOV     A,R6
   \   0001A5   2404         ADD     A,#0x4
   \   0001A7   F5..         MOV     ?V0 + 4,A
   \   0001A9   EF           MOV     A,R7
   \   0001AA   3400         ADDC    A,#0x0
   \   0001AC   F5..         MOV     ?V0 + 5,A
   \   0001AE   85..82       MOV     DPL,?V0 + 4
   \   0001B1   F583         MOV     DPH,A
   \   0001B3   12....       LCALL   ?Subroutine59 & 0xFFFF
   \                     ??CrossCallReturnLabel_84:
   \   0001B6   7003         JNZ     ??zclProcessMessageMSG_7
   \   0001B8   74FF         MOV     A,#-0x1
   \   0001BA   6B           XRL     A,R3
   \                     ??zclProcessMessageMSG_7:
   \   0001BB   7003         JNZ     $+5
   \   0001BD   02....       LJMP    ??zclProcessMessageMSG_1 & 0xFFFF
   1340              return;   // Error, ignore the message
   1341            
   1342            if ((epDesc->simpleDesc == NULL) ||
   1343                (zcl_DeviceOperational(pkt->endPoint, pkt->clusterId, inMsg.hdr.fc.type, inMsg.hdr.commandID,
   1344                                             epDesc->simpleDesc->AppProfId) == FALSE))
   \   0001C0   E8           MOV     A,R0
   \   0001C1   2403         ADD     A,#0x3
   \   0001C3   F5..         MOV     ?V0 + 6,A
   \   0001C5   E9           MOV     A,R1
   \   0001C6   3400         ADDC    A,#0x0
   \   0001C8   F5..         MOV     ?V0 + 7,A
   \   0001CA   85..82       MOV     DPL,?V0 + 6
   \   0001CD   F583         MOV     DPH,A
   \   0001CF   12....       LCALL   ?Subroutine40 & 0xFFFF
   \                     ??CrossCallReturnLabel_52:
   \   0001D2   7002         JNZ     ??zclProcessMessageMSG_8
   \   0001D4   E583         MOV     A,DPH
   \                     ??zclProcessMessageMSG_8:
   \   0001D6   7003         JNZ     $+5
   \   0001D8   02....       LJMP    ??zclProcessMessageMSG_1 & 0xFFFF
   \   0001DB                ; Setup parameters for call to function zcl_DeviceOperational
   \   0001DB   A3           INC     DPTR
   \   0001DC   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0001DF   740B         MOV     A,#0xb
   \   0001E1   12....       LCALL   ?XSTACK_DISP0_8
   \   0001E4   E0           MOVX    A,@DPTR
   \   0001E5   FD           MOV     R5,A
   \   0001E6   7406         MOV     A,#0x6
   \   0001E8   12....       LCALL   ?XSTACK_DISP0_8
   \   0001EB   E0           MOVX    A,@DPTR
   \   0001EC   5403         ANL     A,#0x3
   \   0001EE   FC           MOV     R4,A
   \   0001EF   85..82       MOV     DPL,?V0 + 2
   \   0001F2   85..83       MOV     DPH,?V0 + 3
   \   0001F5   E0           MOVX    A,@DPTR
   \   0001F6   F9           MOV     R1,A
   \   0001F7   12....       LCALL   ??zcl_DeviceOperational?relay
   \   0001FA   7402         MOV     A,#0x2
   \   0001FC   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001FF   E9           MOV     A,R1
   \   000200   7003         JNZ     $+5
   \   000202   02....       LJMP    ??zclProcessMessageMSG_1 & 0xFFFF
   1345            {
   1346              return; // Error, ignore the message
   1347            }
   1348          
   1349          #if defined ( INTER_PAN )
   1350            if ( StubAPS_InterPan( pkt->srcAddr.panId, pkt->srcAddr.endPoint ) )
   1351            {
   1352              // No foundation command is supported thru Inter-PAN communication
   1353              if ( zcl_ProfileCmd( inMsg.hdr.fc.type ) )
   1354                return;
   1355          
   1356              interPanMsg = TRUE; 
   1357              options = AF_TX_OPTIONS_NONE;
   1358            }
   1359            else
   1360          #endif
   1361            {
   1362              interPanMsg = FALSE;
   1363              options = zclGetClusterOption( pkt->endPoint, pkt->clusterId );
   \   000205                ; Setup parameters for call to function zclGetClusterOption
   \   000205   85..82       MOV     DPL,?V0 + 4
   \   000208   85..83       MOV     DPH,?V0 + 5
   \   00020B   12....       LCALL   ?Subroutine43 & 0xFFFF
   1364            }
   \                     ??CrossCallReturnLabel_55:
   \   00020E   E0           MOVX    A,@DPTR
   \   00020F   F9           MOV     R1,A
   \   000210   12....       LCALL   ??zclGetClusterOption?relay
   \   000213   E9           MOV     A,R1
   \   000214   FA           MOV     R2,A
   1365            
   1366            // Local and remote Security options must match except for Default Response command
   1367            if ( !zcl_DefaultRspCmd( inMsg.hdr ) )
   \   000215   7404         MOV     A,#0x4
   \   000217   12....       LCALL   ?XSTACK_DISP0_8
   \   00021A   E0           MOVX    A,@DPTR
   \   00021B   F8           MOV     R0,A
   \   00021C   5407         ANL     A,#0x7
   \   00021E   700D         JNZ     ??zclProcessMessageMSG_9
   \   000220   7409         MOV     A,#0x9
   \   000222   12....       LCALL   ?XSTACK_DISP0_8
   \   000225   E0           MOVX    A,@DPTR
   \   000226   640B         XRL     A,#0xb
   \   000228   7003         JNZ     $+5
   \   00022A   02....       LJMP    ??zclProcessMessageMSG_10 & 0xFFFF
   1368            {
   1369              securityEnable = ( options & AF_EN_SECURITY ) ? TRUE : FALSE;
   \                     ??zclProcessMessageMSG_9:
   \   00022D   EA           MOV     A,R2
   \   00022E   A2E6         MOV     C,0xE0 /* A   */.6
   \   000230   5004         JNC     ??zclProcessMessageMSG_11
   \   000232   D2F0         SETB    B.0
   \   000234   8002         SJMP    ??zclProcessMessageMSG_12
   \                     ??zclProcessMessageMSG_11:
   \   000236   C2F0         CLR     B.0
   \                     ??zclProcessMessageMSG_12:
   \   000238   A2F0         MOV     C,B.0
   \   00023A   E4           CLR     A
   \   00023B   92E0         MOV     0xE0 /* A   */.0,C
   \   00023D   F5..         MOV     ?V0 + 0,A
   1370              if ( pkt->SecurityUse != securityEnable )
   \   00023F   EE           MOV     A,R6
   \   000240   2419         ADD     A,#0x19
   \   000242   F582         MOV     DPL,A
   \   000244   EF           MOV     A,R7
   \   000245   12....       LCALL   ??Subroutine150_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_294:
   \   000248   65..         XRL     A,?V0 + 0
   \   00024A   7003         JNZ     $+5
   \   00024C   02....       LJMP    ??zclProcessMessageMSG_10 & 0xFFFF
   1371              {
   1372                if ( UNICAST_MSG( inMsg.msg ) )
   \   00024F   7402         MOV     A,#0x2
   \   000251   12....       LCALL   ?XSTACK_DISP0_8
   \   000254   12....       LCALL   ?Subroutine31 & 0xFFFF
   \                     ??CrossCallReturnLabel_34:
   \   000257   6003         JZ      $+5
   \   000259   02....       LJMP    ??zclProcessMessageMSG_1 & 0xFFFF
   \   00025C   7402         MOV     A,#0x2
   \   00025E   12....       LCALL   ?XSTACK_DISP0_8
   \   000261   12....       LCALL   ?Subroutine45 & 0xFFFF
   \                     ??CrossCallReturnLabel_59:
   \   000264   7002         JNZ     ??zclProcessMessageMSG_13
   \   000266   A3           INC     DPTR
   \   000267   E0           MOVX    A,@DPTR
   \                     ??zclProcessMessageMSG_13:
   \   000268   6003         JZ      $+5
   \   00026A   02....       LJMP    ??zclProcessMessageMSG_1 & 0xFFFF
   1373                {
   1374                  // Send a Default Response command back with no Application Link Key security
   1375                  if ( securityEnable )
   \   00026D   E5..         MOV     A,?V0 + 0
   \   00026F   6005         JZ      ??CrossCallReturnLabel_32
   1376                    zclSetSecurityOption( pkt->endPoint, pkt->clusterId, FALSE );
   \   000271                ; Setup parameters for call to function zclSetSecurityOption
   \   000271   7C00         MOV     R4,#0x0
   \   000273   12....       LCALL   ?Subroutine27 & 0xFFFF
   1377                  
   1378                  defautlRspCmd.statusCode = status;
   \                     ??CrossCallReturnLabel_32:
   \   000276   7401         MOV     A,#0x1
   \   000278   12....       LCALL   ?XSTACK_DISP0_8
   \   00027B   7401         MOV     A,#0x1
   \   00027D   F0           MOVX    @DPTR,A
   1379                  defautlRspCmd.commandID = inMsg.hdr.commandID;
   \   00027E   7409         MOV     A,#0x9
   \   000280   12....       LCALL   ?XSTACK_DISP0_8
   \   000283   12....       LCALL   ?Subroutine52 & 0xFFFF
   1380                  zcl_SendDefaultRspCmd( inMsg.msg->endPoint, &(inMsg.msg->srcAddr),
   1381                                         inMsg.msg->clusterId, &defautlRspCmd, 
   1382                                         ZCL_FRAME_SERVER_CLIENT_DIR, true, 
   1383                                         inMsg.hdr.manuCode, inMsg.hdr.transSeqNum );
   \                     ??CrossCallReturnLabel_67:
   \   000286   12....       LCALL   ?XSTACK_DISP0_8
   \   000289   E0           MOVX    A,@DPTR
   \   00028A   F5..         MOV     ?V0 + 1,A
   \   00028C   78..         MOV     R0,#?V0 + 1
   \   00028E   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000291   7407         MOV     A,#0x7
   \   000293   12....       LCALL   ?XSTACK_DISP0_8
   \   000296   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000299   75..01       MOV     ?V0 + 1,#0x1
   \   00029C   78..         MOV     R0,#?V0 + 1
   \   00029E   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0002A1   78..         MOV     R0,#?V0 + 1
   \   0002A3   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0002A6   7405         MOV     A,#0x5
   \   0002A8   12....       LCALL   ?XSTACK_DISP0_8
   \   0002AB   8582..       MOV     ?V0 + 6,DPL
   \   0002AE   8583..       MOV     ?V0 + 7,DPH
   \   0002B1   78..         MOV     R0,#?V0 + 6
   \   0002B3   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0002B6   7409         MOV     A,#0x9
   \   0002B8   12....       LCALL   ?XSTACK_DISP0_8
   \   0002BB   12....       LCALL   ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_194:
   \   0002BE   7409         MOV     A,#0x9
   \   0002C0   12....       LCALL   ?XSTACK_DISP0_8
   \   0002C3   12....       LCALL   ?Subroutine49 & 0xFFFF
   \                     ??CrossCallReturnLabel_65:
   \   0002C6   12....       LCALL   ?XSTACK_DISP0_8
   \   0002C9   12....       LCALL   ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_30:
   \   0002CC   12....       LCALL   ?DEALLOC_XSTACK8
   1384                  if ( securityEnable )
   \   0002CF   E5..         MOV     A,?V0 + 0
   \   0002D1   7003         JNZ     $+5
   \   0002D3   02....       LJMP    ??zclProcessMessageMSG_1 & 0xFFFF
   1385                    zclSetSecurityOption( pkt->endPoint, pkt->clusterId, TRUE );       
   \   0002D6                ; Setup parameters for call to function zclSetSecurityOption
   \   0002D6   7C01         MOV     R4,#0x1
   \   0002D8   12....       LCALL   ?Subroutine27 & 0xFFFF
   1386                }
   1387                return;   // Error, ignore the message
   1388              }
   1389            }
   \                     ??CrossCallReturnLabel_33:
   \   0002DB   02....       LJMP    ??zclProcessMessageMSG_1 & 0xFFFF
   1390            
   1391            // Is this a foundation type message
   1392            if ( zcl_ProfileCmd( inMsg.hdr.fc.type ) )
   \                     ??zclProcessMessageMSG_10:
   \   0002DE   E8           MOV     A,R0
   \   0002DF   5403         ANL     A,#0x3
   \   0002E1   6003         JZ      $+5
   \   0002E3   02....       LJMP    ??zclProcessMessageMSG_14 & 0xFFFF
   1393            { 
   1394              if ( inMsg.hdr.fc.manuSpecific )
   \   0002E6   E8           MOV     A,R0
   \   0002E7   5404         ANL     A,#0x4
   \   0002E9   6005         JZ      ??zclProcessMessageMSG_15
   1395              {
   1396                // We don't support any manufacturer specific command
   1397                status = ZCL_STATUS_UNSUP_MANU_GENERAL_COMMAND;
   \   0002EB   7A84         MOV     R2,#-0x7c
   \   0002ED   02....       LJMP    ??zclProcessMessageMSG_16 & 0xFFFF
   1398              }
   1399              else if ( ( inMsg.hdr.commandID <= ZCL_CMD_MAX ) && 
   1400                        ( zclCmdTable[inMsg.hdr.commandID].pfnParseInProfile != NULL ) )
   \                     ??zclProcessMessageMSG_15:
   \   0002F0   7409         MOV     A,#0x9
   \   0002F2   12....       LCALL   ?XSTACK_DISP0_8
   \   0002F5   E0           MOVX    A,@DPTR
   \   0002F6   F5..         MOV     ?V0 + 0,A
   \   0002F8   C3           CLR     C
   \   0002F9   940E         SUBB    A,#0xe
   \   0002FB   4003         JC      $+5
   \   0002FD   02....       LJMP    ??zclProcessMessageMSG_17 & 0xFFFF
   \   000300   75..00       MOV     ?V0 + 1,#0x0
   \   000303   7402         MOV     A,#0x2
   \   000305   78..         MOV     R0,#?V0 + 0
   \   000307   12....       LCALL   ?S_SHL
   \   00030A   12....       LCALL   ?Subroutine77 & 0xFFFF
   \                     ??CrossCallReturnLabel_107:
   \   00030D   F8           MOV     R0,A
   \   00030E   7401         MOV     A,#0x1
   \   000310   93           MOVC    A,@A+DPTR
   \   000311   F9           MOV     R1,A
   \   000312   E8           MOV     A,R0
   \   000313   7001         JNZ     ??zclProcessMessageMSG_18
   \   000315   E9           MOV     A,R1
   \                     ??zclProcessMessageMSG_18:
   \   000316   7003         JNZ     $+5
   \   000318   02....       LJMP    ??zclProcessMessageMSG_17 & 0xFFFF
   1401              {
   1402                zclParseCmd_t parseCmd;
   1403                
   1404                parseCmd.endpoint = pkt->endPoint;
   \   00031B   85..82       MOV     DPL,?V0 + 2
   \   00031E   85..83       MOV     DPH,?V0 + 3
   \   000321   E0           MOVX    A,@DPTR
   \   000322   C0E0         PUSH    A
   \   000324   7414         MOV     A,#0x14
   \   000326   12....       LCALL   ?XSTACK_DISP0_8
   \   000329   D0E0         POP     A
   \   00032B   F0           MOVX    @DPTR,A
   1405                parseCmd.dataLen = inMsg.pDataLen;
   \   00032C   740C         MOV     A,#0xc
   \   00032E   12....       LCALL   ?XSTACK_DISP0_8
   \   000331   12....       LCALL   ?Subroutine56 & 0xFFFF
   \                     ??CrossCallReturnLabel_75:
   \   000334   7415         MOV     A,#0x15
   \   000336   12....       LCALL   ?XSTACK_DISP0_8
   \   000339   12....       LCALL   ??Subroutine146_0 & 0xFFFF
   1406                parseCmd.pData = inMsg.pData;
   \                     ??CrossCallReturnLabel_254:
   \   00033C   740A         MOV     A,#0xa
   \   00033E   12....       LCALL   ?XSTACK_DISP0_8
   \   000341   12....       LCALL   ?Subroutine56 & 0xFFFF
   \                     ??CrossCallReturnLabel_76:
   \   000344   7417         MOV     A,#0x17
   \   000346   12....       LCALL   ?XSTACK_DISP0_8
   \   000349   12....       LCALL   ??Subroutine146_0 & 0xFFFF
   1407                
   1408                // Parse the command, remember that the return value is a pointer to allocated memory
   1409                inMsg.attrCmd = zclParseCmd( inMsg.hdr.commandID, &parseCmd );
   \                     ??CrossCallReturnLabel_255:
   \   00034C                ; Setup parameters for indirect call
   \   00034C   7414         MOV     A,#0x14
   \   00034E   12....       LCALL   ?XSTACK_DISP0_8
   \   000351   AA82         MOV     R2,DPL
   \   000353   AB83         MOV     R3,DPH
   \   000355   7409         MOV     A,#0x9
   \   000357   12....       LCALL   ?XSTACK_DISP0_8
   \   00035A   12....       LCALL   ?Subroutine53 & 0xFFFF
   \                     ??CrossCallReturnLabel_69:
   \   00035D   12....       LCALL   ?S_SHL
   \   000360   12....       LCALL   ?Subroutine77 & 0xFFFF
   \                     ??CrossCallReturnLabel_108:
   \   000363   C0E0         PUSH    A
   \   000365   7401         MOV     A,#0x1
   \   000367   93           MOVC    A,@A+DPTR
   \   000368   F583         MOV     DPH,A
   \   00036A   D082         POP     DPL
   \   00036C   12....       LCALL   ?CALL_IND
   \   00036F   740E         MOV     A,#0xe
   \   000371   12....       LCALL   ?XSTACK_DISP0_8
   \   000374   12....       LCALL   ??Subroutine152_0 & 0xFFFF
   1410                if ( (inMsg.attrCmd != NULL) && (zclCmdTable[inMsg.hdr.commandID].pfnProcessInProfile != NULL) )
   \                     ??CrossCallReturnLabel_308:
   \   000377   740E         MOV     A,#0xe
   \   000379   12....       LCALL   ?XSTACK_DISP0_8
   \   00037C   E0           MOVX    A,@DPTR
   \   00037D   7002         JNZ     ??zclProcessMessageMSG_19
   \   00037F   A3           INC     DPTR
   \   000380   E0           MOVX    A,@DPTR
   \                     ??zclProcessMessageMSG_19:
   \   000381   6047         JZ      ??zclProcessMessageMSG_20
   \   000383   7409         MOV     A,#0x9
   \   000385   12....       LCALL   ?XSTACK_DISP0_8
   \   000388   12....       LCALL   ?Subroutine53 & 0xFFFF
   \                     ??CrossCallReturnLabel_70:
   \   00038B   12....       LCALL   ?S_SHL
   \   00038E   E5..         MOV     A,?V0 + 0
   \   000390   24..         ADD     A,#((zclCmdTable + 2) & 0xff)
   \   000392   F582         MOV     DPL,A
   \   000394   E5..         MOV     A,?V0 + 1
   \   000396   34..         ADDC    A,#(((zclCmdTable + 2) >> 8) & 0xff)
   \   000398   F583         MOV     DPH,A
   \   00039A   12....       LCALL   ?Subroutine78 & 0xFFFF
   \                     ??CrossCallReturnLabel_109:
   \   00039D   E8           MOV     A,R0
   \   00039E   7001         JNZ     ??zclProcessMessageMSG_21
   \   0003A0   E9           MOV     A,R1
   \                     ??zclProcessMessageMSG_21:
   \   0003A1   601C         JZ      ??zclProcessMessageMSG_22
   1411                { 
   1412                  // Process the command
   1413                  if ( zclProcessCmd( inMsg.hdr.commandID, &inMsg ) == FALSE )
   \   0003A3                ; Setup parameters for indirect call
   \   0003A3   7402         MOV     A,#0x2
   \   0003A5   12....       LCALL   ?XSTACK_DISP0_8
   \   0003A8   AA82         MOV     R2,DPL
   \   0003AA   AB83         MOV     R3,DPH
   \   0003AC   8882         MOV     DPL,R0
   \   0003AE   8983         MOV     DPH,R1
   \   0003B0   12....       LCALL   ?CALL_IND
   1414                  {
   1415                    // Couldn't find attribute in the table.
   1416                  }
   1417                }
   1418                 
   1419                // Free the buffer
   1420                if ( inMsg.attrCmd )
   \   0003B3   740E         MOV     A,#0xe
   \   0003B5   12....       LCALL   ?XSTACK_DISP0_8
   \   0003B8   E0           MOVX    A,@DPTR
   \   0003B9   7002         JNZ     ??zclProcessMessageMSG_23
   \   0003BB   A3           INC     DPTR
   \   0003BC   E0           MOVX    A,@DPTR
   \                     ??zclProcessMessageMSG_23:
   \   0003BD   600B         JZ      ??zclProcessMessageMSG_20
   1421                  osal_mem_free( inMsg.attrCmd );
   \                     ??zclProcessMessageMSG_22:
   \   0003BF                ; Setup parameters for call to function osal_mem_free
   \   0003BF   740E         MOV     A,#0xe
   \   0003C1   12....       LCALL   ?XSTACK_DISP0_8
   \   0003C4   12....       LCALL   ??Subroutine137_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_207:
   \   0003C7   12....       LCALL   ??osal_mem_free?relay
   1422                
   1423                if ( CMD_HAS_RSP( inMsg.hdr.commandID ) )
   \                     ??zclProcessMessageMSG_20:
   \   0003CA   7409         MOV     A,#0x9
   \   0003CC   12....       LCALL   ?XSTACK_DISP0_8
   \   0003CF   E0           MOVX    A,@DPTR
   \   0003D0   FA           MOV     R2,A
   \   0003D1   7003         JNZ     $+5
   \   0003D3   02....       LJMP    ??zclProcessMessageMSG_1 & 0xFFFF
   \   0003D6   7402         MOV     A,#0x2
   \   0003D8   6A           XRL     A,R2
   \   0003D9   7003         JNZ     $+5
   \   0003DB   02....       LJMP    ??zclProcessMessageMSG_1 & 0xFFFF
   \   0003DE   7403         MOV     A,#0x3
   \   0003E0   6A           XRL     A,R2
   \   0003E1   7003         JNZ     $+5
   \   0003E3   02....       LJMP    ??zclProcessMessageMSG_1 & 0xFFFF
   \   0003E6   7406         MOV     A,#0x6
   \   0003E8   6A           XRL     A,R2
   \   0003E9   7003         JNZ     $+5
   \   0003EB   02....       LJMP    ??zclProcessMessageMSG_1 & 0xFFFF
   \   0003EE   7408         MOV     A,#0x8
   \   0003F0   6A           XRL     A,R2
   \   0003F1   7003         JNZ     $+5
   \   0003F3   02....       LJMP    ??zclProcessMessageMSG_1 & 0xFFFF
   \   0003F6   740C         MOV     A,#0xc
   \   0003F8   6A           XRL     A,R2
   \   0003F9   7003         JNZ     $+5
   \   0003FB   02....       LJMP    ??zclProcessMessageMSG_1 & 0xFFFF
   \   0003FE   740B         MOV     A,#0xb
   \   000400   6A           XRL     A,R2
   \   000401   7003         JNZ     $+5
   \   000403   02....       LJMP    ??zclProcessMessageMSG_1 & 0xFFFF
   1424                  return; // We're done
   1425                
   1426                status = ZSuccess;
   \   000406   7A00         MOV     R2,#0x0
   \   000408   02....       LJMP    ??zclProcessMessageMSG_16 & 0xFFFF
   1427              }
   1428              else
   1429              {
   1430                // Unsupported message
   1431                status = ZCL_STATUS_UNSUP_GENERAL_COMMAND;
   \                     ??zclProcessMessageMSG_17:
   \   00040B   7A82         MOV     R2,#-0x7e
   \   00040D   02....       LJMP    ??zclProcessMessageMSG_16 & 0xFFFF
   1432              }
   1433            }
   1434            else  // Not a foundation type message, so it must be specific to the cluster ID.
   1435            {
   1436              if (epDesc->simpleDesc == NULL)
   \                     ??zclProcessMessageMSG_14:
   \   000410   85..82       MOV     DPL,?V0 + 6
   \   000413   85..83       MOV     DPH,?V0 + 7
   \   000416   E0           MOVX    A,@DPTR
   \   000417   7002         JNZ     ??zclProcessMessageMSG_24
   \   000419   A3           INC     DPTR
   \   00041A   E0           MOVX    A,@DPTR
   \                     ??zclProcessMessageMSG_24:
   \   00041B   607D         JZ      ??zclProcessMessageMSG_25
   1437              {
   1438                pInPlugin = NULL;
   1439              }
   1440              else
   1441              {
   1442                // Find the appropriate plugin
   1443                pInPlugin = zclFindPlugin( pkt->clusterId, epDesc->simpleDesc->AppProfId );
   \   00041D   85..82       MOV     DPL,?V0 + 4
   \   000420   85..83       MOV     DPH,?V0 + 5
   \   000423   12....       LCALL   ?Subroutine59 & 0xFFFF
   \                     ??CrossCallReturnLabel_83:
   \   000426   7003         JNZ     ??zclProcessMessageMSG_26
   \   000428   74FF         MOV     A,#-0x1
   \   00042A   6B           XRL     A,R3
   \                     ??zclProcessMessageMSG_26:
   \   00042B   6035         JZ      ??zclProcessMessageMSG_27
   \   00042D   90....       MOV     DPTR,#plugins
   \   000430   8004         SJMP    ??zclProcessMessageMSG_28
   \                     ??zclProcessMessageMSG_29:
   \   000432   8882         MOV     DPL,R0
   \   000434   8983         MOV     DPH,R1
   \                     ??zclProcessMessageMSG_28:
   \   000436   12....       LCALL   ??Subroutine134_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_196:
   \   000439   7001         JNZ     ??zclProcessMessageMSG_30
   \   00043B   E9           MOV     A,R1
   \                     ??zclProcessMessageMSG_30:
   \   00043C   6024         JZ      ??zclProcessMessageMSG_27
   \   00043E   8882         MOV     DPL,R0
   \   000440   8983         MOV     DPH,R1
   \   000442   12....       LCALL   ??Subroutine132_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_192:
   \   000445   C3           CLR     C
   \   000446   EA           MOV     A,R2
   \   000447   9C           SUBB    A,R4
   \   000448   EB           MOV     A,R3
   \   000449   9D           SUBB    A,R5
   \   00044A   40E6         JC      ??zclProcessMessageMSG_29
   \   00044C   8882         MOV     DPL,R0
   \   00044E   8983         MOV     DPH,R1
   \   000450   A3           INC     DPTR
   \   000451   A3           INC     DPTR
   \   000452   A3           INC     DPTR
   \   000453   A3           INC     DPTR
   \   000454   C3           CLR     C
   \   000455   E0           MOVX    A,@DPTR
   \   000456   9A           SUBB    A,R2
   \   000457   A3           INC     DPTR
   \   000458   E0           MOVX    A,@DPTR
   \   000459   9B           SUBB    A,R3
   \   00045A   40D6         JC      ??zclProcessMessageMSG_29
   \   00045C   8882         MOV     DPL,R0
   \   00045E   8983         MOV     DPH,R1
   \   000460   8006         SJMP    ??zclProcessMessageMSG_31
   \                     ??zclProcessMessageMSG_27:
   \   000462   758200       MOV     DPL,#0x0
   \   000465   758300       MOV     DPH,#0x0
   1444              }
   1445              if ( pInPlugin && pInPlugin->pfnIncomingHdlr )
   \                     ??zclProcessMessageMSG_31:
   \   000468   E582         MOV     A,DPL
   \   00046A   7002         JNZ     ??zclProcessMessageMSG_32
   \   00046C   E583         MOV     A,DPH
   \                     ??zclProcessMessageMSG_32:
   \   00046E   602A         JZ      ??zclProcessMessageMSG_25
   \   000470   A3           INC     DPTR
   \   000471   A3           INC     DPTR
   \   000472   A3           INC     DPTR
   \   000473   12....       LCALL   ?Subroutine34 & 0xFFFF
   \                     ??CrossCallReturnLabel_198:
   \   000476   7001         JNZ     ??zclProcessMessageMSG_33
   \   000478   E9           MOV     A,R1
   \                     ??zclProcessMessageMSG_33:
   \   000479   601F         JZ      ??zclProcessMessageMSG_25
   1446              { 
   1447                // The return value of the plugin function will be ZSuccess - Supported and need default response
   1448                //                                                 ZFailure - Unsupported
   1449                //                                                 ZCL_STATUS_CMD_HAS_RSP - Supported and do not need default rsp
   1450                //                                                 ZCL_STATUS_INVALID_FIELD - Supported, but the incoming msg is wrong formatted
   1451                //                                                 ZCL_STATUS_INVALID_VALUE - Supported, but the request not achievable by the h/w
   1452                //                                                 ZCL_STATUS_SOFTWARE_FAILURE - Supported but ZStack memory allocation fails
   1453                status = pInPlugin->pfnIncomingHdlr( &inMsg );
   \   00047B                ; Setup parameters for indirect call
   \   00047B   7402         MOV     A,#0x2
   \   00047D   12....       LCALL   ?XSTACK_DISP0_8
   \   000480   AA82         MOV     R2,DPL
   \   000482   AB83         MOV     R3,DPH
   \   000484   8882         MOV     DPL,R0
   \   000486   8983         MOV     DPH,R1
   \   000488   12....       LCALL   ?CALL_IND
   \   00048B   E9           MOV     A,R1
   \   00048C   FA           MOV     R2,A
   1454                if ( status == ZCL_STATUS_CMD_HAS_RSP || ( interPanMsg && status == ZSuccess ) )
   \   00048D   74FF         MOV     A,#-0x1
   \   00048F   6A           XRL     A,R2
   \   000490   7003         JNZ     $+5
   \   000492   02....       LJMP    ??zclProcessMessageMSG_1 & 0xFFFF
   1455                  return; // We're done      
   1456              }
   1457              
   1458              if ( status == ZFailure )
   \   000495   7401         MOV     A,#0x1
   \   000497   6A           XRL     A,R2
   \   000498   7010         JNZ     ??zclProcessMessageMSG_16
   1459              {
   1460                // Unsupported message
   1461                if ( inMsg.hdr.fc.manuSpecific )
   \                     ??zclProcessMessageMSG_25:
   \   00049A   7404         MOV     A,#0x4
   \   00049C   12....       LCALL   ?XSTACK_DISP0_8
   \   00049F   E0           MOVX    A,@DPTR
   \   0004A0   5404         ANL     A,#0x4
   \   0004A2   6004         JZ      ??zclProcessMessageMSG_34
   1462                  status = ZCL_STATUS_UNSUP_MANU_CLUSTER_COMMAND;
   \   0004A4   7A83         MOV     R2,#-0x7d
   \   0004A6   8002         SJMP    ??zclProcessMessageMSG_16
   1463                else
   1464                  status = ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
   \                     ??zclProcessMessageMSG_34:
   \   0004A8   7A81         MOV     R2,#-0x7f
   1465              }
   1466            }
   1467            
   1468            if ( UNICAST_MSG( inMsg.msg ) && inMsg.hdr.fc.disableDefaultRsp == 0 )
   \                     ??zclProcessMessageMSG_16:
   \   0004AA   7402         MOV     A,#0x2
   \   0004AC   12....       LCALL   ?XSTACK_DISP0_8
   \   0004AF   12....       LCALL   ?Subroutine31 & 0xFFFF
   \                     ??CrossCallReturnLabel_35:
   \   0004B2   7070         JNZ     ??zclProcessMessageMSG_1
   \   0004B4   7402         MOV     A,#0x2
   \   0004B6   12....       LCALL   ?XSTACK_DISP0_8
   \   0004B9   12....       LCALL   ?Subroutine45 & 0xFFFF
   \                     ??CrossCallReturnLabel_60:
   \   0004BC   7002         JNZ     ??zclProcessMessageMSG_35
   \   0004BE   A3           INC     DPTR
   \   0004BF   E0           MOVX    A,@DPTR
   \                     ??zclProcessMessageMSG_35:
   \   0004C0   7062         JNZ     ??zclProcessMessageMSG_1
   \   0004C2   7404         MOV     A,#0x4
   \   0004C4   12....       LCALL   ?XSTACK_DISP0_8
   \   0004C7   E0           MOVX    A,@DPTR
   \   0004C8   5410         ANL     A,#0x10
   \   0004CA   7058         JNZ     ??zclProcessMessageMSG_1
   1469            {
   1470              // Send a Default Response command back
   1471              defautlRspCmd.statusCode = status;
   \   0004CC   7401         MOV     A,#0x1
   \   0004CE   12....       LCALL   ?XSTACK_DISP0_8
   \   0004D1   EA           MOV     A,R2
   \   0004D2   F0           MOVX    @DPTR,A
   1472              defautlRspCmd.commandID = inMsg.hdr.commandID;
   \   0004D3   7409         MOV     A,#0x9
   \   0004D5   12....       LCALL   ?XSTACK_DISP0_8
   \   0004D8   12....       LCALL   ?Subroutine52 & 0xFFFF
   1473              zcl_SendDefaultRspCmd( inMsg.msg->endPoint, &(inMsg.msg->srcAddr),
   1474                                     inMsg.msg->clusterId, &defautlRspCmd, 
   1475                                     ZCL_FRAME_SERVER_CLIENT_DIR, true, 
   1476                                     inMsg.hdr.manuCode, inMsg.hdr.transSeqNum );
   1477            }
   \                     ??CrossCallReturnLabel_68:
   \   0004DB   12....       LCALL   ?XSTACK_DISP0_8
   \   0004DE   E0           MOVX    A,@DPTR
   \   0004DF   F5..         MOV     ?V0 + 0,A
   \   0004E1   78..         MOV     R0,#?V0 + 0
   \   0004E3   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0004E6   7407         MOV     A,#0x7
   \   0004E8   12....       LCALL   ?XSTACK_DISP0_8
   \   0004EB   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0004EE   75..01       MOV     ?V0 + 0,#0x1
   \   0004F1   78..         MOV     R0,#?V0 + 0
   \   0004F3   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0004F6   78..         MOV     R0,#?V0 + 0
   \   0004F8   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0004FB   7405         MOV     A,#0x5
   \   0004FD   12....       LCALL   ?XSTACK_DISP0_8
   \   000500   8582..       MOV     ?V0 + 0,DPL
   \   000503   8583..       MOV     ?V0 + 1,DPH
   \   000506   78..         MOV     R0,#?V0 + 0
   \   000508   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00050B   7409         MOV     A,#0x9
   \   00050D   12....       LCALL   ?XSTACK_DISP0_8
   \   000510   12....       LCALL   ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_195:
   \   000513   7409         MOV     A,#0x9
   \   000515   12....       LCALL   ?XSTACK_DISP0_8
   \   000518   12....       LCALL   ?Subroutine49 & 0xFFFF
   \                     ??CrossCallReturnLabel_66:
   \   00051B   12....       LCALL   ?XSTACK_DISP0_8
   \   00051E   12....       LCALL   ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_31:
   \   000521   12....       LCALL   ?DEALLOC_XSTACK8
   \                     ??zclProcessMessageMSG_1:
   \   000524   7437         MOV     A,#0x37
   \   000526   12....       LCALL   ?DEALLOC_XSTACK8
   \   000529                REQUIRE ?Subroutine122
   \   000529                ; // Fall through to label ?Subroutine122
   1478          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine122:
   \   000000   7F08         MOV     R7,#0x8
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine77:
   \   000000   E5..         MOV     A,?V0 + 0
   \   000002   24..         ADD     A,#(zclCmdTable & 0xff)
   \   000004   F582         MOV     DPL,A
   \   000006   E5..         MOV     A,?V0 + 1
   \   000008   34..         ADDC    A,#((zclCmdTable >> 8) & 0xff)
   \   00000A   F583         MOV     DPH,A
   \   00000C   E4           CLR     A
   \   00000D   93           MOVC    A,@A+DPTR
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine76:
   \   000000   7900         MOV     R1,#0x0
   \   000002   12....       LCALL   ??HalUARTWrite?relay
   \   000005                ; Setup parameters for call to function HalUARTWrite
   \   000005                ; Setup parameters for call to function HalUARTWrite
   \   000005   7C01         MOV     R4,#0x1
   \   000007   7D00         MOV     R5,#0x0
   \   000009   7A..         MOV     R2,#(`?<Constant ",">` & 0xff)
   \   00000B   7B..         MOV     R3,#((`?<Constant ",">` >> 8) & 0xff)
   \   00000D   7900         MOV     R1,#0x0
   \   00000F   12....       LCALL   ??HalUARTWrite?relay
   \   000012   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine75:
   \   000000   E582         MOV     A,DPL
   \   000002   28           ADD     A,R0
   \   000003   F582         MOV     DPL,A
   \   000005   E583         MOV     A,DPH
   \   000007   39           ADDC    A,R1
   \   000008   F583         MOV     DPH,A
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine69:
   \   000000   F5..         MOV     ?V0 + 2,A
   \   000002   EF           MOV     A,R7
   \   000003   12....       LCALL   ?Subroutine95 & 0xFFFF
   \                     ??CrossCallReturnLabel_131:
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine95:
   \   000000   12....       LCALL   ?Subroutine106 & 0xFFFF
   \                     ??CrossCallReturnLabel_149:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine59:
   \   000000   12....       LCALL   ??Subroutine138_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_283:
   \   000003   74FF         MOV     A,#-0x1
   \   000005   6A           XRL     A,R2
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine53:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0 + 0,A
   \   000003   75..00       MOV     ?V0 + 1,#0x0
   \   000006   7402         MOV     A,#0x2
   \   000008   78..         MOV     R0,#?V0 + 0
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine52:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   85..82       MOV     DPL,?XSP + 0
   \   000004   85..83       MOV     DPH,?XSP + 1
   \   000007   F0           MOVX    @DPTR,A
   \   000008                ; Setup parameters for call to function zcl_SendDefaultRspCmd
   \   000008                ; Setup parameters for call to function zcl_SendDefaultRspCmd
   \   000008   7408         MOV     A,#0x8
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine49:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   2406         ADD     A,#0x6
   \   000003   FA           MOV     R2,A
   \   000004   A3           INC     DPTR
   \   000005   E0           MOVX    A,@DPTR
   \   000006   3400         ADDC    A,#0x0
   \   000008   FB           MOV     R3,A
   \   000009   7409         MOV     A,#0x9
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine45:
   \   000000   12....       LCALL   ?Subroutine88 & 0xFFFF
   \                     ??CrossCallReturnLabel_126:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine31:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   2415         ADD     A,#0x15
   \   000003   12....       LCALL   ?Subroutine92 & 0xFFFF
   \                     ??CrossCallReturnLabel_129:
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine92:
   \   000000   F8           MOV     R0,A
   \   000001   A3           INC     DPTR
   \   000002   E0           MOVX    A,@DPTR
   \   000003   12....       LCALL   ?Subroutine105 & 0xFFFF
   \                     ??CrossCallReturnLabel_147:
   \   000006   E0           MOVX    A,@DPTR
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine27:
   \   000000   85..82       MOV     DPL,?V0 + 4
   \   000003   85..83       MOV     DPH,?V0 + 5
   \   000006   12....       LCALL   ?Subroutine84 & 0xFFFF
   \                     ??CrossCallReturnLabel_122:
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   F9           MOV     R1,A
   \   00000B   12....       LCALL   ??zclSetSecurityOption?relay
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine26:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   2414         ADD     A,#0x14
   \   000003   12....       LCALL   ?Subroutine92 & 0xFFFF
   \                     ??CrossCallReturnLabel_128:
   \   000006   F9           MOV     R1,A
   \   000007   12....       LCALL   ??zcl_SendDefaultRspCmd?relay
   \   00000A   7407         MOV     A,#0x7
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine105:
   \   000000   3400         ADDC    A,#0x0
   \   000002   F9           MOV     R1,A
   \   000003   8882         MOV     DPL,R0
   \   000005   8983         MOV     DPH,R1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine78:
   \   000000   E4           CLR     A
   \   000001   93           MOVC    A,@A+DPTR
   \   000002   F8           MOV     R0,A
   \   000003   7401         MOV     A,#0x1
   \   000005   93           MOVC    A,@A+DPTR
   \   000006   F9           MOV     R1,A
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   12....       LCALL   ?Subroutine93 & 0xFFFF
   \                     ??CrossCallReturnLabel_266:
   \   000003                REQUIRE ??Subroutine131_0
   \   000003                ; // Fall through to label ??Subroutine131_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine131_0:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine132_0
   \   000002                ; // Fall through to label ??Subroutine132_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine132_0:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine133_0
   \   000002                ; // Fall through to label ??Subroutine133_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine34:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003                REQUIRE ??Subroutine134_0
   \   000003                ; // Fall through to label ??Subroutine134_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine134_0:
   \   000000   12....       LCALL   ?Subroutine91 & 0xFFFF
   \                     ??CrossCallReturnLabel_225:
   \   000003   E8           MOV     A,R0
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine60:
   \   000000   85..82       MOV     DPL,?V0 + 2
   \   000003   85..83       MOV     DPH,?V0 + 3
   \   000006                REQUIRE ??Subroutine137_0
   \   000006                ; // Fall through to label ??Subroutine137_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine137_0:
   \   000000   12....       LCALL   ??Subroutine138_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_285:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine146_0:
   \   000000   E8           MOV     A,R0
   \   000001                REQUIRE ??Subroutine147_0
   \   000001                ; // Fall through to label ??Subroutine147_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine147_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   E9           MOV     A,R1
   \   000003   F0           MOVX    @DPTR,A
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine48:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   28           ADD     A,R0
   \   000002   FA           MOV     R2,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   39           ADDC    A,R1
   \   000006   8A82         MOV     DPL,R2
   \   000008   F583         MOV     DPH,A
   \   00000A   A3           INC     DPTR
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine93:
   \   000000   12....       LCALL   ?Subroutine104 & 0xFFFF
   \                     ??CrossCallReturnLabel_269:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine104:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F583         MOV     DPH,A
   \   000006   8882         MOV     DPL,R0
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine106:
   \   000000   3400         ADDC    A,#0x0
   \   000002   F5..         MOV     ?V0 + 3,A
   \   000004                ; Setup parameters for call to function afFindEndPointDesc
   \   000004                ; Setup parameters for call to function zclGetAttrDataLength
   \   000004   85..82       MOV     DPL,?V0 + 2
   \   000007   F583         MOV     DPH,A
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine150_0:
   \   000000   3400         ADDC    A,#0x0
   \   000002   F583         MOV     DPH,A
   \   000004   E0           MOVX    A,@DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine43:
   \   000000   12....       LCALL   ?Subroutine84 & 0xFFFF
   \                     ??CrossCallReturnLabel_123:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine84:
   \   000000   12....       LCALL   ?Subroutine103 & 0xFFFF
   \                     ??CrossCallReturnLabel_292:
   \   000003   FB           MOV     R3,A
   \   000004   85..82       MOV     DPL,?V0 + 2
   \   000007   85..83       MOV     DPH,?V0 + 3
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine88:
   \   000000   12....       LCALL   ?Subroutine104 & 0xFFFF
   \                     ??CrossCallReturnLabel_268:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   22           RET
   1479          
   1480          /*********************************************************************
   1481           * @fn      zclParseHdr
   1482           * @brief   Parse header of the ZCL format
   1483           * @param   hdr - place to put the frame control information
   1484           *          pData - incoming buffer to parse
   1485           * @return  pointer past the header
   1486           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1487          uint8 *zclParseHdr( zclFrameHdr_t *hdr, uint8 *pData )
   \                     zclParseHdr:
   1488          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
   1489            // Clear the header
   1490            osal_memset( (uint8 *)hdr, 0, sizeof ( zclFrameHdr_t ) );
   \   00000D                ; Setup parameters for call to function osal_memset
   \   00000D   7C06         MOV     R4,#0x6
   \   00000F   7D00         MOV     R5,#0x0
   \   000011   7900         MOV     R1,#0x0
   \   000013   12....       LCALL   ??osal_memset?relay
   1491          
   1492            // Parse the Frame Control
   1493            hdr->fc.type = zcl_FCType( *pData );
   \   000016   85..82       MOV     DPL,?V0 + 0
   \   000019   85..83       MOV     DPH,?V0 + 1
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   54FC         ANL     A,#0xfc
   \   00001F   12....       LCALL   ??Subroutine144_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_242:
   \   000022   E0           MOVX    A,@DPTR
   \   000023   FA           MOV     R2,A
   \   000024   7403         MOV     A,#0x3
   \   000026   5A           ANL     A,R2
   \   000027   48           ORL     A,R0
   \   000028   F8           MOV     R0,A
   \   000029   85..82       MOV     DPL,?V0 + 0
   \   00002C   85..83       MOV     DPH,?V0 + 1
   \   00002F   12....       LCALL   ??Subroutine147_0 & 0xFFFF
   1494            hdr->fc.manuSpecific = zcl_FCManuSpecific( *pData ) ? 1 : 0;
   \                     ??CrossCallReturnLabel_252:
   \   000032   74FB         MOV     A,#-0x5
   \   000034   58           ANL     A,R0
   \   000035   FA           MOV     R2,A
   \   000036   8E82         MOV     DPL,R6
   \   000038   8F83         MOV     DPH,R7
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   A2E2         MOV     C,0xE0 /* A   */.2
   \   00003D   E4           CLR     A
   \   00003E   92E0         MOV     0xE0 /* A   */.0,C
   \   000040   F5..         MOV     ?V0 + 2,A
   \   000042   75..00       MOV     ?V0 + 3,#0x0
   \   000045   7402         MOV     A,#0x2
   \   000047   78..         MOV     R0,#?V0 + 2
   \   000049   12....       LCALL   ?S_SHL
   \   00004C   7404         MOV     A,#0x4
   \   00004E   55..         ANL     A,?V0 + 2
   \   000050   4A           ORL     A,R2
   \   000051   85..82       MOV     DPL,?V0 + 0
   \   000054   85..83       MOV     DPH,?V0 + 1
   \   000057   12....       LCALL   ?Subroutine12 & 0xFFFF
   1495            if ( zcl_FCDirection( *pData ) )
   \                     ??CrossCallReturnLabel_17:
   \   00005A   A2E3         MOV     C,0xE0 /* A   */.3
   \   00005C   85..82       MOV     DPL,?V0 + 0
   \   00005F   85..83       MOV     DPH,?V0 + 1
   \   000062   E0           MOVX    A,@DPTR
   \   000063   5004         JNC     ??zclParseHdr_0
   1496              hdr->fc.direction = ZCL_FRAME_SERVER_CLIENT_DIR;
   \   000065   4408         ORL     A,#0x8
   \   000067   8002         SJMP    ??zclParseHdr_1
   1497            else
   1498              hdr->fc.direction = ZCL_FRAME_CLIENT_SERVER_DIR;
   \                     ??zclParseHdr_0:
   \   000069   54F7         ANL     A,#0xf7
   \                     ??zclParseHdr_1:
   \   00006B   F0           MOVX    @DPTR,A
   \   00006C   A3           INC     DPTR
   \   00006D   E0           MOVX    A,@DPTR
   \   00006E   F0           MOVX    @DPTR,A
   1499            
   1500            hdr->fc.disableDefaultRsp = zcl_FCDisableDefaultRsp( *pData ) ? 1 : 0;
   \   00006F   85..82       MOV     DPL,?V0 + 0
   \   000072   85..83       MOV     DPH,?V0 + 1
   \   000075   E0           MOVX    A,@DPTR
   \   000076   54EF         ANL     A,#0xef
   \   000078   FA           MOV     R2,A
   \   000079   A3           INC     DPTR
   \   00007A   E0           MOVX    A,@DPTR
   \   00007B   FB           MOV     R3,A
   \   00007C   8E82         MOV     DPL,R6
   \   00007E   8F83         MOV     DPH,R7
   \   000080   E0           MOVX    A,@DPTR
   \   000081   A2E4         MOV     C,0xE0 /* A   */.4
   \   000083   E4           CLR     A
   \   000084   92E0         MOV     0xE0 /* A   */.0,C
   \   000086   F5..         MOV     ?V0 + 2,A
   \   000088   7404         MOV     A,#0x4
   \   00008A   78..         MOV     R0,#?V0 + 2
   \   00008C   12....       LCALL   ?S_SHL
   \   00008F   7410         MOV     A,#0x10
   \   000091   55..         ANL     A,?V0 + 2
   \   000093   4A           ORL     A,R2
   \   000094   F8           MOV     R0,A
   \   000095   EB           MOV     A,R3
   \   000096   F9           MOV     R1,A
   \   000097   85..82       MOV     DPL,?V0 + 0
   \   00009A   85..83       MOV     DPH,?V0 + 1
   \   00009D   E8           MOV     A,R0
   \   00009E   F0           MOVX    @DPTR,A
   \   00009F   A3           INC     DPTR
   \   0000A0   E9           MOV     A,R1
   \   0000A1   12....       LCALL   ??Subroutine141_0 & 0xFFFF
   1501            pData++;  // move past the frame control field
   1502          
   1503            // parse the manfacturer code
   1504            if ( hdr->fc.manuSpecific )
   \                     ??CrossCallReturnLabel_227:
   \   0000A4   E8           MOV     A,R0
   \   0000A5   5404         ANL     A,#0x4
   \   0000A7   6013         JZ      ??CrossCallReturnLabel_10
   1505            {
   1506              hdr->manuCode = BUILD_UINT16( pData[0], pData[1] );
   \   0000A9   12....       LCALL   ?Subroutine103 & 0xFFFF
   1507              pData += 2;
   1508            }
   \                     ??CrossCallReturnLabel_289:
   \   0000AC   F9           MOV     R1,A
   \   0000AD   EA           MOV     A,R2
   \   0000AE   85..82       MOV     DPL,?V0 + 0
   \   0000B1   85..83       MOV     DPH,?V0 + 1
   \   0000B4   A3           INC     DPTR
   \   0000B5   A3           INC     DPTR
   \   0000B6   F0           MOVX    @DPTR,A
   \   0000B7   A3           INC     DPTR
   \   0000B8   E9           MOV     A,R1
   \   0000B9   12....       LCALL   ?Subroutine9 & 0xFFFF
   1509          
   1510            // parse the Transaction Sequence Number
   1511            hdr->transSeqNum = *pData++;
   \                     ??CrossCallReturnLabel_10:
   \   0000BC   8E82         MOV     DPL,R6
   \   0000BE   8F83         MOV     DPH,R7
   \   0000C0   E0           MOVX    A,@DPTR
   \   0000C1   85..82       MOV     DPL,?V0 + 0
   \   0000C4   85..83       MOV     DPH,?V0 + 1
   \   0000C7   A3           INC     DPTR
   \   0000C8   A3           INC     DPTR
   \   0000C9   A3           INC     DPTR
   \   0000CA   12....       LCALL   ?Subroutine5 & 0xFFFF
   1512          
   1513            // parse the Cluster's command ID
   1514            hdr->commandID = *pData++;
   \                     ??CrossCallReturnLabel_8:
   \   0000CD   85..82       MOV     DPL,?V0 + 0
   \   0000D0   85..83       MOV     DPH,?V0 + 1
   \   0000D3   A3           INC     DPTR
   \   0000D4   A3           INC     DPTR
   \   0000D5   A3           INC     DPTR
   \   0000D6   A3           INC     DPTR
   \   0000D7   A3           INC     DPTR
   \   0000D8   12....       LCALL   ??Subroutine142_0 & 0xFFFF
   1515          
   1516            // Should point to the frame payload
   1517            return ( pData );
   \                     ??CrossCallReturnLabel_233:
   \   0000DB   AA82         MOV     R2,DPL
   \   0000DD   AB83         MOV     R3,DPH
   \   0000DF                REQUIRE ?Subroutine110
   \   0000DF                ; // Fall through to label ?Subroutine110
   1518          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine118:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   12....       LCALL   ?Subroutine79 & 0xFFFF
   \                     ??CrossCallReturnLabel_112:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine79:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   12....       LCALL   ?Subroutine108 & 0xFFFF
   \                     ??CrossCallReturnLabel_170:
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine141_0:
   \   000000   12....       LCALL   ?Subroutine80 & 0xFFFF
   \                     ??CrossCallReturnLabel_230:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine80:
   \   000000   12....       LCALL   ?Subroutine101 & 0xFFFF
   \                     ??CrossCallReturnLabel_236:
   \   000003   A3           INC     DPTR
   \   000004   AE82         MOV     R6,DPL
   \   000006   AF83         MOV     R7,DPH
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine108:
   \   000000   EE           MOV     A,R6
   \   000001   2402         ADD     A,#0x2
   \   000003   0E           INC     R6
   \   000004   0E           INC     R6
   \   000005   02....       LJMP    ?Subroutine115 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   A3           INC     DPTR
   \   000001   12....       LCALL   ?Subroutine80 & 0xFFFF
   \                     ??CrossCallReturnLabel_231:
   \   000004   E0           MOVX    A,@DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine142_0:
   \   000000   12....       LCALL   ?Subroutine101 & 0xFFFF
   \                     ??CrossCallReturnLabel_237:
   \   000003   A3           INC     DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine144_0:
   \   000000   F8           MOV     R0,A
   \   000001   A3           INC     DPTR
   \   000002   E0           MOVX    A,@DPTR
   \   000003   F9           MOV     R1,A
   \   000004   02....       LJMP    ?Subroutine118 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine101:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   02....       LJMP    ?Subroutine118 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   E9           MOV     A,R1
   \   000003   12....       LCALL   ?Subroutine101 & 0xFFFF
   \                     ??CrossCallReturnLabel_239:
   \   000006   E0           MOVX    A,@DPTR
   \   000007   22           RET
   1519          
   1520          /*********************************************************************
   1521           * @fn      zclBuildHdr
   1522           * @brief   Build header of the ZCL format
   1523           * @param   hdr - outgoing header information
   1524           *          pData - outgoing header space
   1525           * @return  pointer past the header
   1526           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1527          static uint8 *zclBuildHdr( zclFrameHdr_t *hdr, uint8 *pData )
   \                     zclBuildHdr:
   1528          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   1529            // Build the Frame Control byte
   1530            *pData = hdr->fc.type;
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   5403         ANL     A,#0x3
   \   00000C   8C82         MOV     DPL,R4
   \   00000E   8D83         MOV     DPH,R5
   \   000010   12....       LCALL   ??Subroutine130_0 & 0xFFFF
   1531            *pData |= hdr->fc.manuSpecific << 2;
   \                     ??CrossCallReturnLabel_185:
   \   000013   5404         ANL     A,#0x4
   \   000015   12....       LCALL   ?Subroutine16 & 0xFFFF
   1532            *pData |= hdr->fc.direction << 3;
   \                     ??CrossCallReturnLabel_183:
   \   000018   5408         ANL     A,#0x8
   \   00001A   12....       LCALL   ?Subroutine16 & 0xFFFF
   1533            *pData |= hdr->fc.disableDefaultRsp << 4;
   \                     ??CrossCallReturnLabel_184:
   \   00001D   5410         ANL     A,#0x10
   \   00001F   FE           MOV     R6,A
   \   000020   8C82         MOV     DPL,R4
   \   000022   8D83         MOV     DPH,R5
   \   000024   E0           MOVX    A,@DPTR
   \   000025   4E           ORL     A,R6
   \   000026   12....       LCALL   ?Subroutine8 & 0xFFFF
   1534            pData++;  // move past the frame control field
   1535          
   1536            // Add the manfacturer code
   1537            if ( hdr->fc.manuSpecific )
   \                     ??CrossCallReturnLabel_245:
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   5404         ANL     A,#0x4
   \   00002C   6013         JZ      ??CrossCallReturnLabel_72
   1538            {
   1539              *pData++ = LO_UINT16( hdr->manuCode );
   \   00002E   EA           MOV     A,R2
   \   00002F   2402         ADD     A,#0x2
   \   000031   F8           MOV     R0,A
   \   000032   EB           MOV     A,R3
   \   000033   12....       LCALL   ?Subroutine105 & 0xFFFF
   \                     ??CrossCallReturnLabel_145:
   \   000036   12....       LCALL   ?Subroutine54 & 0xFFFF
   1540              *pData++ = HI_UINT16( hdr->manuCode );
   \                     ??CrossCallReturnLabel_71:
   \   000039   8882         MOV     DPL,R0
   \   00003B   8983         MOV     DPH,R1
   \   00003D   A3           INC     DPTR
   \   00003E   12....       LCALL   ?Subroutine54 & 0xFFFF
   1541            }
   1542          
   1543            // Add the Transaction Sequence Number
   1544            *pData++ = hdr->transSeqNum;
   \                     ??CrossCallReturnLabel_72:
   \   000041   8A82         MOV     DPL,R2
   \   000043   8B83         MOV     DPH,R3
   \   000045   A3           INC     DPTR
   \   000046   A3           INC     DPTR
   \   000047   A3           INC     DPTR
   \   000048   A3           INC     DPTR
   \   000049   E0           MOVX    A,@DPTR
   \   00004A   8C82         MOV     DPL,R4
   \   00004C   8D83         MOV     DPH,R5
   \   00004E   12....       LCALL   ?Subroutine8 & 0xFFFF
   1545            
   1546            // Add the Cluster's command ID
   1547            *pData++ = hdr->commandID;
   \                     ??CrossCallReturnLabel_246:
   \   000051   A3           INC     DPTR
   \   000052   A3           INC     DPTR
   \   000053   A3           INC     DPTR
   \   000054   A3           INC     DPTR
   \   000055   A3           INC     DPTR
   \   000056   E0           MOVX    A,@DPTR
   \   000057   8C82         MOV     DPL,R4
   \   000059   8D83         MOV     DPH,R5
   \   00005B   F0           MOVX    @DPTR,A
   \   00005C   A3           INC     DPTR
   1548          
   1549            // Should point to the frame payload
   1550            return ( pData );
   \   00005D   AA82         MOV     R2,DPL
   \   00005F   AB83         MOV     R3,DPH
   \   000061   7F01         MOV     R7,#0x1
   \   000063   02....       LJMP    ?BANKED_LEAVE_XDATA
   1551          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine54:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8C82         MOV     DPL,R4
   \   000003   8D83         MOV     DPH,R5
   \   000005   F0           MOVX    @DPTR,A
   \   000006   A3           INC     DPTR
   \   000007   0C           INC     R4
   \   000008   AD83         MOV     R5,DPH
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   FE           MOV     R6,A
   \   000001   8C82         MOV     DPL,R4
   \   000003   8D83         MOV     DPH,R5
   \   000005   E0           MOVX    A,@DPTR
   \   000006   4E           ORL     A,R6
   \   000007                REQUIRE ??Subroutine130_0
   \   000007                ; // Fall through to label ??Subroutine130_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine130_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8A82         MOV     DPL,R2
   \   000003   8B83         MOV     DPH,R3
   \   000005   E0           MOVX    A,@DPTR
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   AC82         MOV     R4,DPL
   \   000004   AD83         MOV     R5,DPH
   \   000006                REQUIRE ?Subroutine117
   \   000006                ; // Fall through to label ?Subroutine117

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine117:
   \   000000   8A82         MOV     DPL,R2
   \   000002   8B83         MOV     DPH,R3
   \   000004   22           RET
   1552          
   1553          /*********************************************************************
   1554           * @fn      zclCalcHdrSize
   1555           * @brief   Calculate the number of bytes needed for an outgoing
   1556           *          ZCL header.
   1557           * @param   hdr - outgoing header information
   1558           * @return  returns the number of bytes needed
   1559           */
   1560          static uint8 zclCalcHdrSize( zclFrameHdr_t *hdr )
   1561          {
   1562            uint8 needed = (1 + 1 + 1); // frame control + transaction seq num + cmd ID
   1563          
   1564            // Add the manfacturer code
   1565            if ( hdr->fc.manuSpecific )
   1566              needed += 2;
   1567          
   1568            return ( needed );
   1569          }
   1570          
   1571          /*********************************************************************
   1572           * @fn      zclFindPlugin
   1573           * @brief   Find the right plugin for a cluster ID
   1574           * @param   clusterID - cluster ID to look for
   1575           *          profileID - profile ID
   1576           * @return  pointer to plugin, NULL if not found
   1577           */
   1578          static zclLibPlugin_t *zclFindPlugin( uint16 clusterID, uint16 profileID )
   1579          {
   1580            zclLibPlugin_t *pLoop;
   1581            
   1582            (void)profileID;  // Intentionally unreferenced parameter
   1583          
   1584            if ( clusterID != ZCL_INVALID_CLUSTER_ID )
   1585            {
   1586              pLoop = plugins;
   1587              while ( pLoop != NULL )
   1588              {
   1589                if ( clusterID >= pLoop->startClusterID && clusterID <= pLoop->endClusterID )
   1590                  return ( pLoop );
   1591                pLoop = pLoop->next;
   1592              }
   1593            }
   1594            return ( (zclLibPlugin_t *)NULL );
   1595          }
   1596          
   1597          /*********************************************************************
   1598           * @fn      zclFindAttrRec
   1599           * @brief   Find the attribute record that matchs the parameters
   1600           * @param   endpoint - Application's endpoint
   1601           *          clusterID - cluster ID
   1602           *          attrId - attribute looking for
   1603           * @return  TRUE if record found. FALSE, otherwise.
   1604           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1605          uint8 zclFindAttrRec( uint8 endpoint, uint16 clusterID, uint16 attrId, zclAttrRec_t *pAttr )
   \                     zclFindAttrRec:
   1606          {
   \   000000   74EE         MOV     A,#-0x12
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 18
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 2,R1
   \   000007   EA           MOV     A,R2
   \   000008   FE           MOV     R6,A
   \   000009   EB           MOV     A,R3
   \   00000A   FF           MOV     R7,A
   \   00000B   8C..         MOV     ?V0 + 0,R4
   \   00000D   8D..         MOV     ?V0 + 1,R5
   \   00000F   7412         MOV     A,#0x12
   \   000011   12....       LCALL   ?XSTACK_DISP0_8
   \   000014   12....       LCALL   ??Subroutine133_0 & 0xFFFF
   1607            uint8 x;
   1608            zclAttrRecsList *pLoop;
   1609          
   1610            pLoop = attrList;
   \                     ??CrossCallReturnLabel_189:
   \   000017   90....       MOV     DPTR,#attrList
   \   00001A   8004         SJMP    ??zclFindAttrRec_0
   1611          
   1612            while ( pLoop != NULL )
   1613            {
   1614              if ( pLoop->endpoint == endpoint )
   1615              {
   1616                for ( x = 0; x < pLoop->numAttributes; x++ )
   1617                {
   1618                  if ( pLoop->attrs[x].clusterID == clusterID && pLoop->attrs[x].attr.attrId == attrId )
   1619                  {
   1620                    *pAttr = pLoop->attrs[x];
   1621                    return ( TRUE ); // EMBEDDED RETURN
   1622                  }
   1623                }
   1624              }
   1625              pLoop = pLoop->next;
   \                     ??zclFindAttrRec_1:
   \   00001C   8A82         MOV     DPL,R2
   \   00001E   8B83         MOV     DPH,R3
   \                     ??zclFindAttrRec_0:
   \   000020   12....       LCALL   ??Subroutine126_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_179:
   \   000023   7001         JNZ     ??zclFindAttrRec_2
   \   000025   EB           MOV     A,R3
   \                     ??zclFindAttrRec_2:
   \   000026   7003         JNZ     $+5
   \   000028   02....       LJMP    ??zclFindAttrRec_3 & 0xFFFF
   \   00002B   8A82         MOV     DPL,R2
   \   00002D   8B83         MOV     DPH,R3
   \   00002F   A3           INC     DPTR
   \   000030   A3           INC     DPTR
   \   000031   E0           MOVX    A,@DPTR
   \   000032   65..         XRL     A,?V0 + 2
   \   000034   70E6         JNZ     ??zclFindAttrRec_1
   \   000036   75..00       MOV     ?V0 + 3,#0x0
   \   000039   EA           MOV     A,R2
   \   00003A   2404         ADD     A,#0x4
   \   00003C   F8           MOV     R0,A
   \   00003D   EB           MOV     A,R3
   \   00003E   3400         ADDC    A,#0x0
   \   000040   F9           MOV     R1,A
   \   000041   88..         MOV     ?V0 + 4,R0
   \   000043   89..         MOV     ?V0 + 5,R1
   \   000045   8002         SJMP    ??zclFindAttrRec_4
   \                     ??zclFindAttrRec_5:
   \   000047   05..         INC     ?V0 + 3
   \                     ??zclFindAttrRec_4:
   \   000049   8A82         MOV     DPL,R2
   \   00004B   8B83         MOV     DPH,R3
   \   00004D   A3           INC     DPTR
   \   00004E   A3           INC     DPTR
   \   00004F   A3           INC     DPTR
   \   000050   E0           MOVX    A,@DPTR
   \   000051   F8           MOV     R0,A
   \   000052   E5..         MOV     A,?V0 + 3
   \   000054   C3           CLR     C
   \   000055   98           SUBB    A,R0
   \   000056   50C4         JNC     ??zclFindAttrRec_1
   \   000058   85....       MOV     ?V0 + 8,?V0 + 3
   \   00005B   75..00       MOV     ?V0 + 9,#0x0
   \   00005E   7403         MOV     A,#0x3
   \   000060   78..         MOV     R0,#?V0 + 8
   \   000062   12....       LCALL   ?S_SHL
   \   000065   85....       MOV     ?V0 + 6,?V0 + 8
   \   000068   85....       MOV     ?V0 + 7,?V0 + 9
   \   00006B   85..82       MOV     DPL,?V0 + 4
   \   00006E   85..83       MOV     DPH,?V0 + 5
   \   000071   E0           MOVX    A,@DPTR
   \   000072   25..         ADD     A,?V0 + 6
   \   000074   F8           MOV     R0,A
   \   000075   A3           INC     DPTR
   \   000076   E0           MOVX    A,@DPTR
   \   000077   35..         ADDC    A,?V0 + 7
   \   000079   F9           MOV     R1,A
   \   00007A   8882         MOV     DPL,R0
   \   00007C   8983         MOV     DPH,R1
   \   00007E   12....       LCALL   ?Subroutine78 & 0xFFFF
   \                     ??CrossCallReturnLabel_110:
   \   000081   EE           MOV     A,R6
   \   000082   68           XRL     A,R0
   \   000083   7002         JNZ     ??zclFindAttrRec_6
   \   000085   EF           MOV     A,R7
   \   000086   69           XRL     A,R1
   \                     ??zclFindAttrRec_6:
   \   000087   70BE         JNZ     ??zclFindAttrRec_5
   \   000089   A3           INC     DPTR
   \   00008A   A3           INC     DPTR
   \   00008B   12....       LCALL   ?Subroutine78 & 0xFFFF
   \                     ??CrossCallReturnLabel_111:
   \   00008E   E5..         MOV     A,?V0 + 0
   \   000090   68           XRL     A,R0
   \   000091   7003         JNZ     ??zclFindAttrRec_7
   \   000093   E5..         MOV     A,?V0 + 1
   \   000095   69           XRL     A,R1
   \                     ??zclFindAttrRec_7:
   \   000096   70AF         JNZ     ??zclFindAttrRec_5
   \   000098   85..82       MOV     DPL,?V0 + 4
   \   00009B   85..83       MOV     DPH,?V0 + 5
   \   00009E   E0           MOVX    A,@DPTR
   \   00009F   25..         ADD     A,?V0 + 6
   \   0000A1   FA           MOV     R2,A
   \   0000A2   A3           INC     DPTR
   \   0000A3   E0           MOVX    A,@DPTR
   \   0000A4   35..         ADDC    A,?V0 + 7
   \   0000A6   8A82         MOV     DPL,R2
   \   0000A8   F583         MOV     DPH,A
   \   0000AA   7408         MOV     A,#0x8
   \   0000AC   12....       LCALL   ?MOVE_LONG8_XDATA_CODE
   \   0000AF   7901         MOV     R1,#0x1
   \   0000B1   8002         SJMP    ??zclFindAttrRec_8
   1626            }
   1627          
   1628            return ( FALSE );
   \                     ??zclFindAttrRec_3:
   \   0000B3   7900         MOV     R1,#0x0
   \                     ??zclFindAttrRec_8:
   \   0000B5   7F0A         MOV     R7,#0xa
   \   0000B7   02....       LJMP    ?BANKED_LEAVE_XDATA
   1629          }
   1630          
   1631          /*********************************************************************
   1632           * @fn      zclFindClusterOption
   1633           *
   1634           * @brief   Find the option record that matchs the cluster id
   1635           *
   1636           * @param   endpoint - Application's endpoint
   1637           * @param   clusterID - cluster ID looking for
   1638           *
   1639           * @return  pointer to clutser option, NULL if not found
   1640           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1641          static zclOptionRec_t *zclFindClusterOption( uint8 endpoint, uint16 clusterID )
   \                     zclFindClusterOption:
   1642          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 0,R1
   1643            uint8 x;
   1644            zclClusterOptionList *pLoop;
   1645          
   1646            pLoop = clusterOptionList;
   \   000007   90....       MOV     DPTR,#clusterOptionList
   \   00000A   8004         SJMP    ??zclFindClusterOption_0
   1647          
   1648            while ( pLoop != NULL )
   1649            {
   1650              if ( pLoop->endpoint == endpoint )
   1651              {
   1652                for ( x = 0; x < pLoop->numOptions; x++ )
   1653                {
   1654                  if ( pLoop->options[x].clusterID == clusterID )
   1655                    return ( &(pLoop->options[x]) ); // EMBEDDED RETURN
   1656                }
   1657              }
   1658              pLoop = pLoop->next;
   \                     ??zclFindClusterOption_1:
   \   00000C   8882         MOV     DPL,R0
   \   00000E   8983         MOV     DPH,R1
   \                     ??zclFindClusterOption_0:
   \   000010   12....       LCALL   ??Subroutine134_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_197:
   \   000013   7001         JNZ     ??zclFindClusterOption_2
   \   000015   E9           MOV     A,R1
   \                     ??zclFindClusterOption_2:
   \   000016   605F         JZ      ??zclFindClusterOption_3
   \   000018   8882         MOV     DPL,R0
   \   00001A   8983         MOV     DPH,R1
   \   00001C   A3           INC     DPTR
   \   00001D   A3           INC     DPTR
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   65..         XRL     A,?V0 + 0
   \   000021   70E9         JNZ     ??zclFindClusterOption_1
   \   000023   75..00       MOV     ?V0 + 2,#0x0
   \   000026   E8           MOV     A,R0
   \   000027   2404         ADD     A,#0x4
   \   000029   FC           MOV     R4,A
   \   00002A   E9           MOV     A,R1
   \   00002B   3400         ADDC    A,#0x0
   \   00002D   FD           MOV     R5,A
   \   00002E   EC           MOV     A,R4
   \   00002F   FE           MOV     R6,A
   \   000030   ED           MOV     A,R5
   \   000031   FF           MOV     R7,A
   \   000032   8002         SJMP    ??zclFindClusterOption_4
   \                     ??zclFindClusterOption_5:
   \   000034   05..         INC     ?V0 + 2
   \                     ??zclFindClusterOption_4:
   \   000036   8882         MOV     DPL,R0
   \   000038   8983         MOV     DPH,R1
   \   00003A   A3           INC     DPTR
   \   00003B   A3           INC     DPTR
   \   00003C   A3           INC     DPTR
   \   00003D   E0           MOVX    A,@DPTR
   \   00003E   FC           MOV     R4,A
   \   00003F   E5..         MOV     A,?V0 + 2
   \   000041   C3           CLR     C
   \   000042   9C           SUBB    A,R4
   \   000043   50C7         JNC     ??zclFindClusterOption_1
   \   000045   E5..         MOV     A,?V0 + 2
   \   000047   75F003       MOV     B,#0x3
   \   00004A   A4           MUL     AB
   \   00004B   FC           MOV     R4,A
   \   00004C   85F0..       MOV     ?V0 + 1,B
   \   00004F   AD..         MOV     R5,?V0 + 1
   \   000051   8E82         MOV     DPL,R6
   \   000053   8F83         MOV     DPH,R7
   \   000055   E0           MOVX    A,@DPTR
   \   000056   2C           ADD     A,R4
   \   000057   F5..         MOV     ?V0 + 1,A
   \   000059   A3           INC     DPTR
   \   00005A   E0           MOVX    A,@DPTR
   \   00005B   3D           ADDC    A,R5
   \   00005C   85..82       MOV     DPL,?V0 + 1
   \   00005F   F583         MOV     DPH,A
   \   000061   E0           MOVX    A,@DPTR
   \   000062   6A           XRL     A,R2
   \   000063   7003         JNZ     ??zclFindClusterOption_6
   \   000065   A3           INC     DPTR
   \   000066   E0           MOVX    A,@DPTR
   \   000067   6B           XRL     A,R3
   \                     ??zclFindClusterOption_6:
   \   000068   70CA         JNZ     ??zclFindClusterOption_5
   \   00006A   8E82         MOV     DPL,R6
   \   00006C   8F83         MOV     DPH,R7
   \   00006E   E0           MOVX    A,@DPTR
   \   00006F   2C           ADD     A,R4
   \   000070   FA           MOV     R2,A
   \   000071   A3           INC     DPTR
   \   000072   E0           MOVX    A,@DPTR
   \   000073   3D           ADDC    A,R5
   \   000074   FB           MOV     R3,A
   \   000075   8004         SJMP    ??zclFindClusterOption_7
   1659            }
   1660          
   1661            return ( NULL );
   \                     ??zclFindClusterOption_3:
   \   000077   7A00         MOV     R2,#0x0
   \   000079   7B00         MOV     R3,#0x0
   \                     ??zclFindClusterOption_7:
   \   00007B                REQUIRE ?Subroutine123
   \   00007B                ; // Fall through to label ?Subroutine123
   1662          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine123:
   \   000000   7F03         MOV     R7,#0x3
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
   1663          
   1664          /*********************************************************************
   1665           * @fn      zclGetClusterOption
   1666           *
   1667           * @brief   Get the option record that matchs the cluster id
   1668           *
   1669           * @param   endpoint - Application's endpoint
   1670           * @param   clusterID - cluster ID looking for
   1671           *
   1672           * @return  clutser option, AF_TX_OPTIONS_NONE if not found
   1673           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1674          static uint8 zclGetClusterOption( uint8 endpoint, uint16 clusterID )
   \                     zclGetClusterOption:
   1675          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   1676            uint8 option;
   1677            zclOptionRec_t *pOption;
   1678          
   1679             pOption = zclFindClusterOption( endpoint, clusterID );
   \   000005                ; Setup parameters for call to function zclFindClusterOption
   \   000005   12....       LCALL   ??zclFindClusterOption?relay
   \   000008   8A82         MOV     DPL,R2
   \   00000A   8B83         MOV     DPH,R3
   1680            if ( pOption != NULL )
   \   00000C   E582         MOV     A,DPL
   \   00000E   7002         JNZ     ??zclGetClusterOption_0
   \   000010   E583         MOV     A,DPH
   \                     ??zclGetClusterOption_0:
   \   000012   6008         JZ      ??zclGetClusterOption_1
   1681            {
   1682              option = pOption->option;
   1683              if ( !ZG_SECURE_ENABLED )
   1684                option &= (AF_EN_SECURITY ^ 0xFF); // make sure Application Link Key security is off
   1685          
   1686              return ( option ); // EMBEDDED RETURN
   \   000014   A3           INC     DPTR
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \   000017   54BF         ANL     A,#0xbf
   \   000019   F9           MOV     R1,A
   \   00001A   8002         SJMP    ??zclGetClusterOption_2
   1687            }
   1688          
   1689            return ( AF_TX_OPTIONS_NONE );
   \                     ??zclGetClusterOption_1:
   \   00001C   7900         MOV     R1,#0x0
   \                     ??zclGetClusterOption_2:
   \   00001E   80..         SJMP    ?Subroutine119
   1690          }
   1691          
   1692          /*********************************************************************
   1693           * @fn      zclSetSecurityOption
   1694           *
   1695           * @brief   Set the security option for the cluster id
   1696           *
   1697           * @param   endpoint - Application's endpoint
   1698           * @param   clusterID - cluster ID looking for
   1699           * @param   enable - whether to enable (TRUE) or disable (FALSE) security option
   1700           *
   1701           * @return  none
   1702           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1703          static void zclSetSecurityOption( uint8 endpoint, uint16 clusterID, uint8 enable )
   \                     zclSetSecurityOption:
   1704          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EC           MOV     A,R4
   \   000006   FE           MOV     R6,A
   1705            zclOptionRec_t *pOption;
   1706          
   1707            pOption = zclFindClusterOption( endpoint, clusterID );
   \   000007                ; Setup parameters for call to function zclFindClusterOption
   \   000007   12....       LCALL   ??zclFindClusterOption?relay
   \   00000A   8A..         MOV     ?V0 + 0,R2
   \   00000C   8B..         MOV     ?V0 + 1,R3
   \   00000E   A8..         MOV     R0,?V0 + 0
   \   000010   A9..         MOV     R1,?V0 + 1
   1708            if ( pOption != NULL )
   \   000012   E8           MOV     A,R0
   \   000013   7001         JNZ     ??zclSetSecurityOption_0
   \   000015   E9           MOV     A,R1
   \                     ??zclSetSecurityOption_0:
   \   000016   6016         JZ      ??zclSetSecurityOption_1
   1709            {
   1710              if ( enable )
   \   000018   E8           MOV     A,R0
   \   000019   2402         ADD     A,#0x2
   \   00001B   F582         MOV     DPL,A
   \   00001D   E9           MOV     A,R1
   \   00001E   3400         ADDC    A,#0x0
   \   000020   F583         MOV     DPH,A
   \   000022   EE           MOV     A,R6
   \   000023   6005         JZ      ??zclSetSecurityOption_2
   1711                pOption->option |= AF_EN_SECURITY;
   \   000025   E0           MOVX    A,@DPTR
   \   000026   D2E6         SETB    0xE0 /* A   */.6
   \   000028   8003         SJMP    ??zclSetSecurityOption_3
   1712              else
   1713                pOption->option &= (AF_EN_SECURITY ^ 0xFF);
   \                     ??zclSetSecurityOption_2:
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   C2E6         CLR     0xE0 /* A   */.6
   \                     ??zclSetSecurityOption_3:
   \   00002D   F0           MOVX    @DPTR,A
   1714            }
   1715          }
   \                     ??zclSetSecurityOption_1:
   \   00002E                REQUIRE ?Subroutine119
   \   00002E                ; // Fall through to label ?Subroutine119
   1716          
   1717          #ifdef ZCL_DISCOVER
   1718          /*********************************************************************
   1719           * @fn      zclFindNextAttrRec
   1720           *
   1721           * @brief   Find the attribute (or next) record that matchs the parameters
   1722           *
   1723           * @param   endpoint - Application's endpoint
   1724           * @param   clusterID - cluster ID
   1725           * @param   attr - attribute looking for
   1726           *
   1727           * @return  pointer to attribute record, NULL if not found
   1728           */
   1729          static uint8 zclFindNextAttrRec( uint8 endpoint, uint16 clusterID,
   1730                                           uint16 *attrId, zclAttrRec_t *pAttr )
   1731          {
   1732            uint16 x;
   1733            zclAttrRecsList *pLoop;
   1734          
   1735            pLoop = attrList;
   1736          
   1737            while ( pLoop != NULL )
   1738            {
   1739              if ( pLoop->endpoint == endpoint )
   1740              {
   1741                for ( x = 0; x < pLoop->numAttributes; x++ )
   1742                {
   1743                  if ( pLoop->attrs[x].clusterID == clusterID && pLoop->attrs[x].attr.attrId >= *attrId )
   1744                  {
   1745                    *pAttr = pLoop->attrs[x];
   1746                    
   1747                    // Update attribute ID
   1748                    *attrId = pAttr->attr.attrId; 
   1749                    return ( TRUE ); // EMBEDDED RETURN
   1750                  }
   1751                }
   1752              }
   1753              pLoop = pLoop->next;
   1754            }
   1755          
   1756            return ( FALSE );
   1757          }
   1758          #endif // ZCL_DISCOVER
   1759          
   1760          #if defined(ZCL_READ) || defined(ZCL_WRITE) || defined(ZCL_REPORT)
   1761          /*********************************************************************
   1762           * @fn      zclSerializeData
   1763           * @brief   Builds a buffer from the attribute data to sent out over
   1764           *          the air.
   1765           * @param   dataType - data types defined in zcl.h
   1766           *          attrData - pointer to the attribute data
   1767           *          buf - where to put the serialized data
   1768           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1769          static void zclSerializeData( uint8 dataType, void *attrData, uint8 *buf )
   \                     zclSerializeData:
   1770          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   EC           MOV     A,R4
   \   00000A   FA           MOV     R2,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FB           MOV     R3,A
   1771            uint8 *pStr;
   1772            uint8 len;
   1773          
   1774            switch ( dataType )
   \   00000D   8E..         MOV     ?V0 + 0,R6
   \   00000F   8F..         MOV     ?V0 + 1,R7
   \   000011   75..00       MOV     ?V0 + 2,#0x0
   \   000014   8A82         MOV     DPL,R2
   \   000016   8B83         MOV     DPH,R3
   \   000018   A3           INC     DPTR
   \   000019   AC82         MOV     R4,DPL
   \   00001B   AD83         MOV     R5,DPH
   \   00001D   E9           MOV     A,R1
   \   00001E   12....       LCALL   ?UC_SWITCH_SPARSE
   \                     `?<Jumptable for zclSerializeData>_0`:
   \   000021   03           DB        3
   \   000022   41           DB        65
   \   000023   42           DB        66
   \   000024   ....         DW        ??zclSerializeData_0
   \   000026   E0           DB        224
   \   000027   E2           DB        226
   \   000028   ....         DW        ??zclSerializeData_1
   \   00002A   E8           DB        232
   \   00002B   E9           DB        233
   \   00002C   ....         DW        ??zclSerializeData_2
   \   00002E   19           DB        25
   \   00002F   08           DB        8
   \   000030   ....         DW        ??zclSerializeData_3
   \   000032   09           DB        9
   \   000033   ....         DW        ??zclSerializeData_2
   \   000035   0A           DB        10
   \   000036   ....         DW        ??zclSerializeData_4
   \   000038   0B           DB        11
   \   000039   ....         DW        ??zclSerializeData_1
   \   00003B   10           DB        16
   \   00003C   ....         DW        ??zclSerializeData_3
   \   00003E   18           DB        24
   \   00003F   ....         DW        ??zclSerializeData_3
   \   000041   19           DB        25
   \   000042   ....         DW        ??zclSerializeData_2
   \   000044   1A           DB        26
   \   000045   ....         DW        ??zclSerializeData_4
   \   000047   1B           DB        27
   \   000048   ....         DW        ??zclSerializeData_1
   \   00004A   20           DB        32
   \   00004B   ....         DW        ??zclSerializeData_3
   \   00004D   21           DB        33
   \   00004E   ....         DW        ??zclSerializeData_2
   \   000050   22           DB        34
   \   000051   ....         DW        ??zclSerializeData_4
   \   000053   23           DB        35
   \   000054   ....         DW        ??zclSerializeData_1
   \   000056   24           DB        36
   \   000057   ....         DW        ??zclSerializeData_5
   \   000059   25           DB        37
   \   00005A   ....         DW        ??zclSerializeData_6
   \   00005C   28           DB        40
   \   00005D   ....         DW        ??zclSerializeData_3
   \   00005F   29           DB        41
   \   000060   ....         DW        ??zclSerializeData_2
   \   000062   2A           DB        42
   \   000063   ....         DW        ??zclSerializeData_4
   \   000065   2B           DB        43
   \   000066   ....         DW        ??zclSerializeData_1
   \   000068   30           DB        48
   \   000069   ....         DW        ??zclSerializeData_3
   \   00006B   31           DB        49
   \   00006C   ....         DW        ??zclSerializeData_2
   \   00006E   38           DB        56
   \   00006F   ....         DW        ??zclSerializeData_2
   \   000071   39           DB        57
   \   000072   ....         DW        ??zclSerializeData_1
   \   000074   EA           DB        234
   \   000075   ....         DW        ??zclSerializeData_1
   \   000077   F0           DB        240
   \   000078   ....         DW        ??zclSerializeData_7
   \   00007A   ....         DW        ??zclSerializeData_8
   1775            {
   1776              case ZCL_DATATYPE_DATA8:
   1777              case ZCL_DATATYPE_BOOLEAN:
   1778              case ZCL_DATATYPE_BITMAP8:
   1779              case ZCL_DATATYPE_INT8:
   1780              case ZCL_DATATYPE_UINT8:
   1781              case ZCL_DATATYPE_ENUM8:
   1782                *buf = *((uint8 *)attrData);
   \                     ??zclSerializeData_3:
   \   00007C   8E82         MOV     DPL,R6
   \   00007E   8F83         MOV     DPH,R7
   \                     ??zclSerializeData_9:
   \   000080   12....       LCALL   ??Subroutine145_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_247:
   \   000083   F0           MOVX    @DPTR,A
   \   000084   02....       LJMP    ??zclSerializeData_8 & 0xFFFF
   1783                 break;
   1784          
   1785              case ZCL_DATATYPE_DATA16:
   1786              case ZCL_DATATYPE_BITMAP16:
   1787              case ZCL_DATATYPE_UINT16:
   1788              case ZCL_DATATYPE_INT16: 
   1789              case ZCL_DATATYPE_ENUM16:
   1790              case ZCL_DATATYPE_SEMI_PREC:
   1791              case ZCL_DATATYPE_CLUSTER_ID:
   1792              case ZCL_DATATYPE_ATTR_ID:
   1793                *buf++ = LO_UINT16( *((uint16*)attrData) );
   \                     ??zclSerializeData_2:
   \   000087   12....       LCALL   ?Subroutine50 & 0xFFFF
   \                     ??CrossCallReturnLabel_250:
   \   00008A   12....       LCALL   ?Subroutine15 & 0xFFFF
   1794                *buf++ = HI_UINT16( *((uint16*)attrData) );
   \                     ??CrossCallReturnLabel_240:
   \   00008D   A3           INC     DPTR
   \   00008E   80F0         SJMP    ??zclSerializeData_9
   1795                break;
   1796          
   1797              case ZCL_DATATYPE_DATA24:
   1798              case ZCL_DATATYPE_BITMAP24: 
   1799              case ZCL_DATATYPE_UINT24:
   1800              case ZCL_DATATYPE_INT24:
   1801                *buf++ = BREAK_UINT32( *((uint32*)attrData), 0 );
   \                     ??zclSerializeData_4:
   \   000090   8E82         MOV     DPL,R6
   \   000092   8F83         MOV     DPH,R7
   \   000094   78..         MOV     R0,#?V0 + 0
   \   000096   12....       LCALL   ?L_MOV_X
   \   000099   8A82         MOV     DPL,R2
   \   00009B   8B83         MOV     DPH,R3
   \   00009D   E5..         MOV     A,?V0 + 0
   \   00009F   12....       LCALL   ?Subroutine15 & 0xFFFF
   1802                *buf++ = BREAK_UINT32( *((uint32*)attrData), 1 );
   \                     ??CrossCallReturnLabel_241:
   \   0000A2   78..         MOV     R0,#?V0 + 0
   \   0000A4   12....       LCALL   ?L_MOV_X
   \   0000A7   E5..         MOV     A,?V0 + 1
   \   0000A9   8A82         MOV     DPL,R2
   \   0000AB   8B83         MOV     DPH,R3
   \   0000AD   F0           MOVX    @DPTR,A
   \   0000AE   A3           INC     DPTR
   \   0000AF   0A           INC     R2
   \   0000B0   AB83         MOV     R3,DPH
   1803                *buf++ = BREAK_UINT32( *((uint32*)attrData), 2 );
   \   0000B2   8E82         MOV     DPL,R6
   \   0000B4   8F83         MOV     DPH,R7
   \   0000B6   78..         MOV     R0,#?V0 + 0
   \   0000B8   12....       LCALL   ?L_MOV_X
   \   0000BB   7410         MOV     A,#0x10
   \   0000BD   78..         MOV     R0,#?V0 + 0
   \   0000BF   12....       LCALL   ?UL_SHR
   \   0000C2   8A82         MOV     DPL,R2
   \   0000C4   8B83         MOV     DPH,R3
   \   0000C6   E5..         MOV     A,?V0 + 0
   \   0000C8   80B9         SJMP    ??CrossCallReturnLabel_247
   1804                break;
   1805                
   1806              case ZCL_DATATYPE_DATA32:
   1807              case ZCL_DATATYPE_BITMAP32:
   1808              case ZCL_DATATYPE_UINT32:
   1809              case ZCL_DATATYPE_INT32:
   1810              case ZCL_DATATYPE_SINGLE_PREC:
   1811              case ZCL_DATATYPE_TOD:
   1812              case ZCL_DATATYPE_DATE:
   1813              case ZCL_DATATYPE_UTC:
   1814              case ZCL_DATATYPE_BAC_OID:
   1815                buf = osal_buffer_uint32( buf, *((uint32*)attrData) );
   \                     ??zclSerializeData_1:
   \   0000CA                ; Setup parameters for call to function osal_buffer_uint32
   \   0000CA   8E82         MOV     DPL,R6
   \   0000CC   8F83         MOV     DPH,R7
   \   0000CE   12....       LCALL   ?PUSH_XSTACK8_X_FOUR
   \   0000D1   12....       LCALL   ??osal_buffer_uint32?relay
   \   0000D4   7404         MOV     A,#0x4
   \   0000D6   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000D9   8043         SJMP    ??zclSerializeData_8
   1816                break;
   1817                
   1818              case ZCL_DATATYPE_UINT40:
   1819                pStr = (uint8*)attrData;
   1820                osal_memcpy( buf, pStr, 5 );
   \                     ??zclSerializeData_5:
   \   0000DB                ; Setup parameters for call to function osal_memcpy
   \   0000DB   78..         MOV     R0,#?V0 + 0
   \   0000DD   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000E0   7C05         MOV     R4,#0x5
   \   0000E2   8032         SJMP    ??zclSerializeData_10
   1821                break;
   1822                
   1823              case ZCL_DATATYPE_UINT48:
   1824                pStr = (uint8*)attrData;
   1825                osal_memcpy( buf, pStr, 6 );
   \                     ??zclSerializeData_6:
   \   0000E4                ; Setup parameters for call to function osal_memcpy
   \   0000E4   78..         MOV     R0,#?V0 + 0
   \   0000E6   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000E9   7C06         MOV     R4,#0x6
   \   0000EB   8029         SJMP    ??zclSerializeData_10
   1826                break;
   1827                
   1828              case ZCL_DATATYPE_IEEE_ADDR:
   1829                pStr = (uint8*)attrData;
   1830                osal_memcpy( buf, pStr, 8 );
   \                     ??zclSerializeData_7:
   \   0000ED                ; Setup parameters for call to function osal_memcpy
   \   0000ED   78..         MOV     R0,#?V0 + 0
   \   0000EF   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000F2   7C08         MOV     R4,#0x8
   \   0000F4   8020         SJMP    ??zclSerializeData_10
   1831                break;
   1832                
   1833              case ZCL_DATATYPE_CHAR_STR:
   1834              case ZCL_DATATYPE_OCTET_STR:
   1835                pStr = (uint8*)attrData;
   1836                len = *pStr++;
   \                     ??zclSerializeData_0:
   \   0000F6   8E82         MOV     DPL,R6
   \   0000F8   8F83         MOV     DPH,R7
   \   0000FA   E0           MOVX    A,@DPTR
   \   0000FB   F5..         MOV     ?V0 + 3,A
   \   0000FD   A3           INC     DPTR
   \   0000FE   AE82         MOV     R6,DPL
   \   000100   AF83         MOV     R7,DPH
   1837                *buf++ = len;
   \   000102   8A82         MOV     DPL,R2
   \   000104   8B83         MOV     DPH,R3
   \   000106   F0           MOVX    @DPTR,A
   \   000107   EC           MOV     A,R4
   \   000108   FA           MOV     R2,A
   \   000109   ED           MOV     A,R5
   \   00010A   FB           MOV     R3,A
   1838                osal_memcpy( buf, pStr, len );
   \   00010B                ; Setup parameters for call to function osal_memcpy
   \   00010B   8E..         MOV     ?V0 + 0,R6
   \   00010D   8F..         MOV     ?V0 + 1,R7
   \   00010F   78..         MOV     R0,#?V0 + 0
   \   000111   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000114   AC..         MOV     R4,?V0 + 3
   \                     ??zclSerializeData_10:
   \   000116   7D00         MOV     R5,#0x0
   1839                break;
   1840                
   1841              case ZCL_DATATYPE_NO_DATA:
   1842              case ZCL_DATATYPE_UNKNOWN:
   1843                // Fall through
   1844          
   1845              default:
   1846                break;
   1847            }
   \   000118   12....       LCALL   ?Subroutine113 & 0xFFFF
   \                     ??CrossCallReturnLabel_161:
   \   00011B   12....       LCALL   ?DEALLOC_XSTACK8
   1848          }
   \                     ??zclSerializeData_8:
   \   00011E   02....       LJMP    ?Subroutine110 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   EC           MOV     A,R4
   \   000002   FA           MOV     R2,A
   \   000003   ED           MOV     A,R5
   \   000004   FB           MOV     R3,A
   \   000005                REQUIRE ?Subroutine118
   \   000005                ; // Fall through to label ?Subroutine118

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine50:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004                REQUIRE ??Subroutine145_0
   \   000004                ; // Fall through to label ??Subroutine145_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine145_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   02....       LJMP    ?Subroutine117 & 0xFFFF
   1849          #endif // ZCL_READ || ZCL_WRITE || ZCL_REPORT
   1850          
   1851          #ifdef ZCL_REPORT
   1852          /*********************************************************************
   1853           * @fn      zclAnalogDataType
   1854           * @brief   Checks to see if Data Type is Analog
   1855           * @param   dataType - data type
   1856           * @return  TRUE if data type is analog
   1857           */
   1858          uint8 zclAnalogDataType( uint8 dataType )
   1859          {
   1860            uint8 analog;
   1861            
   1862            switch ( dataType )
   1863            {
   1864              case ZCL_DATATYPE_UINT8:
   1865              case ZCL_DATATYPE_UINT16:
   1866              case ZCL_DATATYPE_UINT24:
   1867              case ZCL_DATATYPE_UINT32:
   1868              case ZCL_DATATYPE_UINT40:
   1869              case ZCL_DATATYPE_UINT48:
   1870              case ZCL_DATATYPE_INT8:
   1871              case ZCL_DATATYPE_INT16:
   1872              case ZCL_DATATYPE_INT24:
   1873              case ZCL_DATATYPE_INT32:
   1874              case ZCL_DATATYPE_SEMI_PREC:
   1875              case ZCL_DATATYPE_SINGLE_PREC:
   1876              case ZCL_DATATYPE_DOUBLE_PREC:
   1877              case ZCL_DATATYPE_TOD:
   1878              case ZCL_DATATYPE_DATE:
   1879              case ZCL_DATATYPE_UTC:
   1880                analog = TRUE;
   1881                break;
   1882                
   1883              default:
   1884                analog = FALSE;
   1885                break;
   1886            }
   1887            return ( analog );
   1888          }
   1889          
   1890          /*********************************************************************
   1891           * @fn      zcl_BuildAnalogData
   1892           * @brief   Build an analog arribute out of sequential bytes.
   1893           * @param   dataType - type of data
   1894           *          pData - pointer to data
   1895           *          pBuf - where to put the data
   1896           */
   1897          static void zcl_BuildAnalogData( uint8 dataType, uint8 *pData, uint8 *pBuf)
   1898          {
   1899            switch ( dataType )
   1900            {
   1901              case ZCL_DATATYPE_UINT8:
   1902              case ZCL_DATATYPE_INT8:
   1903                *pData = *pBuf;
   1904                break;
   1905          
   1906              case ZCL_DATATYPE_UINT16:
   1907              case ZCL_DATATYPE_INT16:
   1908              case ZCL_DATATYPE_SEMI_PREC:
   1909                *((uint16*)pData) = BUILD_UINT16( pBuf[0], pBuf[1] ); 
   1910                break;
   1911           
   1912              case ZCL_DATATYPE_UINT24:
   1913              case ZCL_DATATYPE_INT24:
   1914                *((uint32*)pData) = osal_build_uint32( pBuf, 3 );
   1915                break;
   1916                
   1917              case ZCL_DATATYPE_UINT32:
   1918              case ZCL_DATATYPE_INT32:
   1919              case ZCL_DATATYPE_SINGLE_PREC:
   1920              case ZCL_DATATYPE_TOD:
   1921              case ZCL_DATATYPE_DATE:
   1922              case ZCL_DATATYPE_UTC:
   1923                *((uint32*)pData) = osal_build_uint32( pBuf, 4 );
   1924                break;
   1925                
   1926              case ZCL_DATATYPE_DOUBLE_PREC:
   1927                *pData = 0;
   1928                break;
   1929           
   1930              default:
   1931                break;
   1932            }
   1933          }
   1934          #endif // ZCL_REPORT
   1935          
   1936          /*********************************************************************
   1937           * @fn      zclGetDataTypeLength
   1938           * @brief   Return the length of the datatype in length. 
   1939           *          NOTE: Should not be called for ZCL_DATATYPE_OCTECT_STR or 
   1940           *                ZCL_DATATYPE_CHAR_STR data types.
   1941           * @param   dataType - data type
   1942           * @return  length of data
   1943           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1944          uint8 zclGetDataTypeLength( uint8 dataType )
   \                     zclGetDataTypeLength:
   1945          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1946            uint8 len;
   1947            
   1948            switch ( dataType )
   \   000004   E9           MOV     A,R1
   \   000005   12....       LCALL   ?UC_SWITCH_SPARSE
   \                     `?<Jumptable for zclGetDataTypeLength>_0`:
   \   000008   02           DB        2
   \   000009   E0           DB        224
   \   00000A   E2           DB        226
   \   00000B   ....         DW        ??zclGetDataTypeLength_0
   \   00000D   E8           DB        232
   \   00000E   E9           DB        233
   \   00000F   ....         DW        ??zclGetDataTypeLength_1
   \   000011   1A           DB        26
   \   000012   08           DB        8
   \   000013   ....         DW        ??zclGetDataTypeLength_2
   \   000015   09           DB        9
   \   000016   ....         DW        ??zclGetDataTypeLength_1
   \   000018   0A           DB        10
   \   000019   ....         DW        ??zclGetDataTypeLength_3
   \   00001B   0B           DB        11
   \   00001C   ....         DW        ??zclGetDataTypeLength_0
   \   00001E   10           DB        16
   \   00001F   ....         DW        ??zclGetDataTypeLength_2
   \   000021   18           DB        24
   \   000022   ....         DW        ??zclGetDataTypeLength_2
   \   000024   19           DB        25
   \   000025   ....         DW        ??zclGetDataTypeLength_1
   \   000027   1A           DB        26
   \   000028   ....         DW        ??zclGetDataTypeLength_3
   \   00002A   1B           DB        27
   \   00002B   ....         DW        ??zclGetDataTypeLength_0
   \   00002D   20           DB        32
   \   00002E   ....         DW        ??zclGetDataTypeLength_2
   \   000030   21           DB        33
   \   000031   ....         DW        ??zclGetDataTypeLength_1
   \   000033   22           DB        34
   \   000034   ....         DW        ??zclGetDataTypeLength_3
   \   000036   23           DB        35
   \   000037   ....         DW        ??zclGetDataTypeLength_0
   \   000039   24           DB        36
   \   00003A   ....         DW        ??zclGetDataTypeLength_4
   \   00003C   25           DB        37
   \   00003D   ....         DW        ??zclGetDataTypeLength_5
   \   00003F   28           DB        40
   \   000040   ....         DW        ??zclGetDataTypeLength_2
   \   000042   29           DB        41
   \   000043   ....         DW        ??zclGetDataTypeLength_1
   \   000045   2A           DB        42
   \   000046   ....         DW        ??zclGetDataTypeLength_3
   \   000048   2B           DB        43
   \   000049   ....         DW        ??zclGetDataTypeLength_0
   \   00004B   30           DB        48
   \   00004C   ....         DW        ??zclGetDataTypeLength_2
   \   00004E   31           DB        49
   \   00004F   ....         DW        ??zclGetDataTypeLength_1
   \   000051   38           DB        56
   \   000052   ....         DW        ??zclGetDataTypeLength_1
   \   000054   39           DB        57
   \   000055   ....         DW        ??zclGetDataTypeLength_0
   \   000057   3A           DB        58
   \   000058   ....         DW        ??zclGetDataTypeLength_6
   \   00005A   EA           DB        234
   \   00005B   ....         DW        ??zclGetDataTypeLength_0
   \   00005D   F0           DB        240
   \   00005E   ....         DW        ??zclGetDataTypeLength_6
   \   000060   ....         DW        ??zclGetDataTypeLength_7
   1949            {
   1950              case ZCL_DATATYPE_DATA8:
   1951              case ZCL_DATATYPE_BOOLEAN:
   1952              case ZCL_DATATYPE_BITMAP8:
   1953              case ZCL_DATATYPE_INT8:
   1954              case ZCL_DATATYPE_UINT8:
   1955              case ZCL_DATATYPE_ENUM8:
   1956                len = 1;
   \                     ??zclGetDataTypeLength_2:
   \   000062   7901         MOV     R1,#0x1
   \   000064   801A         SJMP    ??zclGetDataTypeLength_8
   1957                break;
   1958                
   1959              case ZCL_DATATYPE_DATA16:
   1960              case ZCL_DATATYPE_BITMAP16:
   1961              case ZCL_DATATYPE_UINT16:
   1962              case ZCL_DATATYPE_INT16: 
   1963              case ZCL_DATATYPE_ENUM16:
   1964              case ZCL_DATATYPE_SEMI_PREC:
   1965              case ZCL_DATATYPE_CLUSTER_ID:
   1966              case ZCL_DATATYPE_ATTR_ID:
   1967                len = 2;
   \                     ??zclGetDataTypeLength_1:
   \   000066   7902         MOV     R1,#0x2
   \   000068   8016         SJMP    ??zclGetDataTypeLength_8
   1968                break;
   1969                
   1970              case ZCL_DATATYPE_DATA24:
   1971              case ZCL_DATATYPE_BITMAP24: 
   1972              case ZCL_DATATYPE_UINT24:
   1973              case ZCL_DATATYPE_INT24:
   1974                len = 3;
   \                     ??zclGetDataTypeLength_3:
   \   00006A   7903         MOV     R1,#0x3
   \   00006C   8012         SJMP    ??zclGetDataTypeLength_8
   1975                break;
   1976                
   1977              case ZCL_DATATYPE_DATA32:
   1978              case ZCL_DATATYPE_BITMAP32:
   1979              case ZCL_DATATYPE_UINT32:
   1980              case ZCL_DATATYPE_INT32:
   1981              case ZCL_DATATYPE_SINGLE_PREC:
   1982              case ZCL_DATATYPE_TOD:
   1983              case ZCL_DATATYPE_DATE:
   1984              case ZCL_DATATYPE_UTC:
   1985              case ZCL_DATATYPE_BAC_OID:
   1986                len = 4;
   \                     ??zclGetDataTypeLength_0:
   \   00006E   7904         MOV     R1,#0x4
   \   000070   800E         SJMP    ??zclGetDataTypeLength_8
   1987                break;                       
   1988                          
   1989             case ZCL_DATATYPE_UINT40:
   1990                 len = 5;
   \                     ??zclGetDataTypeLength_4:
   \   000072   7905         MOV     R1,#0x5
   \   000074   800A         SJMP    ??zclGetDataTypeLength_8
   1991                 break;
   1992                 
   1993             case ZCL_DATATYPE_UINT48:
   1994                 len = 6;
   \                     ??zclGetDataTypeLength_5:
   \   000076   7906         MOV     R1,#0x6
   \   000078   8006         SJMP    ??zclGetDataTypeLength_8
   1995                 break;
   1996                 
   1997             case ZCL_DATATYPE_DOUBLE_PREC:
   1998             case ZCL_DATATYPE_IEEE_ADDR:
   1999               len = 8;
   \                     ??zclGetDataTypeLength_6:
   \   00007A   7908         MOV     R1,#0x8
   \   00007C   8002         SJMP    ??zclGetDataTypeLength_8
   2000               break;
   2001          
   2002              case ZCL_DATATYPE_NO_DATA:
   2003              case ZCL_DATATYPE_UNKNOWN:
   2004                // Fall through
   2005                
   2006              default:
   2007                len = 0;
   \                     ??zclGetDataTypeLength_7:
   \   00007E   7900         MOV     R1,#0x0
   2008                break;
   2009            }  
   2010            return ( len );
   \                     ??zclGetDataTypeLength_8:
   \   000080   02....       LJMP    ?Subroutine109 & 0xFFFF
   2011          }
   2012          
   2013          /*********************************************************************
   2014           * @fn      zclGetAttrDataLength
   2015           * @brief   Return the length of the attribute.
   2016           * @param   dataType - data type
   2017           *          pData - pointer to data
   2018           * @return  returns atrribute lentgh
   2019           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2020          uint8 zclGetAttrDataLength( uint8  dataType, uint8 *pData)
   \                     zclGetAttrDataLength:
   2021          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2022            uint8 dataLen = 0;
   2023            
   2024            if ( dataType  == ZCL_DATATYPE_CHAR_STR || dataType == ZCL_DATATYPE_OCTET_STR )
   \   000004   7442         MOV     A,#0x42
   \   000006   69           XRL     A,R1
   \   000007   6005         JZ      ??zclGetAttrDataLength_0
   \   000009   7441         MOV     A,#0x41
   \   00000B   69           XRL     A,R1
   \   00000C   7009         JNZ     ??zclGetAttrDataLength_1
   2025            {
   2026              dataLen = *pData + 1; // string length + 1 for length field
   \                     ??zclGetAttrDataLength_0:
   \   00000E   8A82         MOV     DPL,R2
   \   000010   8B83         MOV     DPH,R3
   \   000012   E0           MOVX    A,@DPTR
   \   000013   04           INC     A
   \   000014   F9           MOV     R1,A
   \   000015   8003         SJMP    ??zclGetAttrDataLength_2
   2027            }
   2028            else
   2029            {
   2030              dataLen = zclGetDataTypeLength( dataType );
   \                     ??zclGetAttrDataLength_1:
   \   000017                ; Setup parameters for call to function zclGetDataTypeLength
   \   000017   12....       LCALL   ??zclGetDataTypeLength?relay
   2031            }
   2032          
   2033            return ( dataLen );
   \                     ??zclGetAttrDataLength_2:
   \   00001A   02....       LJMP    ?Subroutine109 & 0xFFFF
   2034          }
   2035          
   2036          /*********************************************************************
   2037           * @fn      zclReadAttrData
   2038           * @brief   Read the attribute's current value into pAttrData.
   2039           * @param   pAttrData - where to put attribute data
   2040           *          pAttr - pointer to attribute
   2041           * @return Success
   2042           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2043          uint8 zclReadAttrData( uint8 *pAttrData, zclAttrRec_t *pAttr )
   \                     zclReadAttrData:
   2044          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   2045            uint8 dataLen;
   2046              
   2047            dataLen = zclGetAttrDataLength( pAttr->attr.dataType, (uint8*)(pAttr->attr.dataPtr) );
   \   000009   EC           MOV     A,R4
   \   00000A   2406         ADD     A,#0x6
   \   00000C   F8           MOV     R0,A
   \   00000D   ED           MOV     A,R5
   \   00000E   3400         ADDC    A,#0x0
   \   000010   F9           MOV     R1,A
   \   000011   88..         MOV     ?V0 + 0,R0
   \   000013   89..         MOV     ?V0 + 1,R1
   \   000015                ; Setup parameters for call to function zclGetAttrDataLength
   \   000015   8882         MOV     DPL,R0
   \   000017   F583         MOV     DPH,A
   \   000019   12....       LCALL   ??Subroutine137_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_208:
   \   00001C   8C82         MOV     DPL,R4
   \   00001E   8D83         MOV     DPH,R5
   \   000020   12....       LCALL   ?Subroutine29 & 0xFFFF
   2048            osal_memcpy( pAttrData, pAttr->attr.dataPtr, dataLen );
   \                     ??CrossCallReturnLabel_200:
   \   000023                ; Setup parameters for call to function osal_memcpy
   \   000023   85..82       MOV     DPL,?V0 + 0
   \   000026   85..83       MOV     DPH,?V0 + 1
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   F5..         MOV     ?V0 + 0,A
   \   00002C   A3           INC     DPTR
   \   00002D   E0           MOVX    A,@DPTR
   \   00002E   F5..         MOV     ?V0 + 1,A
   \   000030   75..00       MOV     ?V0 + 2,#0x0
   \   000033   78..         MOV     R0,#?V0 + 0
   \   000035   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000038   EA           MOV     A,R2
   \   000039   FC           MOV     R4,A
   \   00003A   7D00         MOV     R5,#0x0
   \   00003C   EE           MOV     A,R6
   \   00003D   FA           MOV     R2,A
   \   00003E   EF           MOV     A,R7
   \   00003F   FB           MOV     R3,A
   \   000040   12....       LCALL   ?Subroutine113 & 0xFFFF
   \                     ??CrossCallReturnLabel_162:
   \   000043   12....       LCALL   ?DEALLOC_XSTACK8
   2049            return ( ZCL_STATUS_SUCCESS );
   \   000046   7900         MOV     R1,#0x0
   \   000048   02....       LJMP    ?Subroutine123 & 0xFFFF
   2050          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine29:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine135_0
   \   000002                ; // Fall through to label ??Subroutine135_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine135_0:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine136_0
   \   000002                ; // Fall through to label ??Subroutine136_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine136_0:
   \   000000   12....       LCALL   ?Subroutine89 & 0xFFFF
   \                     ??CrossCallReturnLabel_206:
   \   000003   FA           MOV     R2,A
   \   000004   22           RET
   2051          
   2052          #ifdef ZCL_WRITE
   2053          /*********************************************************************
   2054           * @fn      zclWriteAttrData
   2055           * @brief   Write the received data.
   2056           * @param   pAttr - where to write data to
   2057           *          pWriteRec - data to be written
   2058           * @return  Successful if data was written
   2059           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2060          static uint8 zclWriteAttrData( zclAttrRec_t *pAttr, zclWriteRec_t *pWriteRec )
   \                     zclWriteAttrData:
   2061          {
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
   2062            uint8 len;
   2063          
   2064            if ( zcl_AccessCtrlWrite( pAttr->attr.accessControl ) )
   \   00000D   8A82         MOV     DPL,R2
   \   00000F   8B83         MOV     DPH,R3
   \   000011   A3           INC     DPTR
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   A3           INC     DPTR
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \   000017   A2E1         MOV     C,0xE0 /* A   */.1
   \   000019   5058         JNC     ??zclWriteAttrData_0
   2065            {
   2066              if ( zcl_ValidateAttrDataCB && !zcl_ValidateAttrDataCB( pAttr, pWriteRec ) )
   \   00001B   90....       MOV     DPTR,#zcl_ValidateAttrDataCB
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   7002         JNZ     ??zclWriteAttrData_1
   \   000021   A3           INC     DPTR
   \   000022   E0           MOVX    A,@DPTR
   \                     ??zclWriteAttrData_1:
   \   000023   6010         JZ      ??zclWriteAttrData_2
   \   000025                ; Setup parameters for indirect call
   \   000025   90....       MOV     DPTR,#zcl_ValidateAttrDataCB
   \   000028   12....       LCALL   ??Subroutine148_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_262:
   \   00002B   12....       LCALL   ?CALL_IND
   \   00002E   E9           MOV     A,R1
   \   00002F   7004         JNZ     ??zclWriteAttrData_2
   2067                return ( ZCL_STATUS_INVALID_VALUE );
   \   000031   7987         MOV     R1,#-0x79
   \   000033   8040         SJMP    ??zclWriteAttrData_3
   2068              
   2069              len = zclGetAttrDataLength( pAttr->attr.dataType, pWriteRec->attrData );
   \                     ??zclWriteAttrData_2:
   \   000035   EE           MOV     A,R6
   \   000036   2403         ADD     A,#0x3
   \   000038   EF           MOV     A,R7
   \   000039   3400         ADDC    A,#0x0
   \   00003B   0E           INC     R6
   \   00003C   0E           INC     R6
   \   00003D   0E           INC     R6
   \   00003E   FF           MOV     R7,A
   \   00003F                ; Setup parameters for call to function zclGetAttrDataLength
   \   00003F   8E82         MOV     DPL,R6
   \   000041   8F83         MOV     DPH,R7
   \   000043   12....       LCALL   ??Subroutine137_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_209:
   \   000046   85..82       MOV     DPL,?V0 + 0
   \   000049   85..83       MOV     DPH,?V0 + 1
   \   00004C   12....       LCALL   ?Subroutine29 & 0xFFFF
   2070              osal_memcpy( pAttr->attr.dataPtr, pWriteRec->attrData, len );
   \                     ??CrossCallReturnLabel_201:
   \   00004F                ; Setup parameters for call to function osal_memcpy
   \   00004F   8E82         MOV     DPL,R6
   \   000051   8F83         MOV     DPH,R7
   \   000053   12....       LCALL   ?Subroutine35 & 0xFFFF
   \                     ??CrossCallReturnLabel_166:
   \   000056   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000059   EA           MOV     A,R2
   \   00005A   FC           MOV     R4,A
   \   00005B   7D00         MOV     R5,#0x0
   \   00005D   85..82       MOV     DPL,?V0 + 0
   \   000060   85..83       MOV     DPH,?V0 + 1
   \   000063   A3           INC     DPTR
   \   000064   A3           INC     DPTR
   \   000065   A3           INC     DPTR
   \   000066   A3           INC     DPTR
   \   000067   A3           INC     DPTR
   \   000068   A3           INC     DPTR
   \   000069   12....       LCALL   ?Subroutine51 & 0xFFFF
   \                     ??CrossCallReturnLabel_156:
   \   00006C   12....       LCALL   ?DEALLOC_XSTACK8
   2071              return ( ZCL_STATUS_SUCCESS );
   \   00006F   7900         MOV     R1,#0x0
   \   000071   8002         SJMP    ??zclWriteAttrData_3
   2072            }
   2073            return ( ZCL_STATUS_READ_ONLY );
   \                     ??zclWriteAttrData_0:
   \   000073   7988         MOV     R1,#-0x78
   \                     ??zclWriteAttrData_3:
   \   000075   7F07         MOV     R7,#0x7
   \   000077   02....       LJMP    ?BANKED_LEAVE_XDATA
   2074          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine114:
   \   000000   75..00       MOV     ?V0 + 6,#0x0
   \   000003   78..         MOV     R0,#?V0 + 4
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine148_0:
   \   000000   12....       LCALL   ?Subroutine93 & 0xFFFF
   \                     ??CrossCallReturnLabel_267:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine51:
   \   000000   12....       LCALL   ??Subroutine138_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_282:
   \   000003   02....       LJMP    ?Subroutine113 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine35:
   \   000000   12....       LCALL   ?Subroutine82 & 0xFFFF
   \                     ??CrossCallReturnLabel_118:
   \   000003   02....       LJMP    ?Subroutine114 & 0xFFFF
   2075          #endif // ZCL_WRITE
   2076          
   2077          #ifdef ZCL_READ
   2078          /*********************************************************************
   2079           * @fn      zclParseInReadCmd
   2080           * @brief   Parse the "Profile" Read Commands
   2081           *          NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2082           *                FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2083           * @param   pCmd - pointer to incoming data to parse
   2084           * @return  pointer to the parsed command structure
   2085           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2086          void *zclParseInReadCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReadCmd:
   2087          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   2088            zclReadCmd_t *readCmd;
   2089            uint8 *pBuf = pCmd->pData;
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   12....       LCALL   ?Subroutine34 & 0xFFFF
   \                     ??CrossCallReturnLabel_199:
   \   00000C   FE           MOV     R6,A
   \   00000D   E9           MOV     A,R1
   \   00000E   FF           MOV     R7,A
   2090            
   2091            readCmd = (zclReadCmd_t *)osal_mem_alloc( sizeof ( zclReadCmd_t ) + pCmd->dataLen );
   \   00000F   12....       LCALL   ?Subroutine32 & 0xFFFF
   2092            if ( readCmd != NULL )
   \                     ??CrossCallReturnLabel_36:
   \   000012   7001         JNZ     ??zclParseInReadCmd_0
   \   000014   EB           MOV     A,R3
   \                     ??zclParseInReadCmd_0:
   \   000015   6049         JZ      ??zclParseInReadCmd_1
   2093            {
   2094              uint8 i;
   2095              
   2096              readCmd->numAttr = pCmd->dataLen / 2; // Atrribute ID
   \   000017   85..82       MOV     DPL,?V0 + 0
   \   00001A   85..83       MOV     DPH,?V0 + 1
   \   00001D   E0           MOVX    A,@DPTR
   \   00001E   F8           MOV     R0,A
   \   00001F   A3           INC     DPTR
   \   000020   E0           MOVX    A,@DPTR
   \   000021   C3           CLR     C
   \   000022   13           RRC     A
   \   000023   E8           MOV     A,R0
   \   000024   13           RRC     A
   \   000025   8A82         MOV     DPL,R2
   \   000027   8B83         MOV     DPH,R3
   \   000029   F0           MOVX    @DPTR,A
   2097              for ( i = 0; i < readCmd->numAttr; i++ )
   \   00002A   75..00       MOV     ?V0 + 0,#0x0
   \   00002D   8025         SJMP    ??zclParseInReadCmd_2
   2098              {
   2099                readCmd->attrID[i] = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??zclParseInReadCmd_3:
   \   00002F   8E82         MOV     DPL,R6
   \   000031   8F83         MOV     DPH,R7
   \   000033   12....       LCALL   ?Subroutine90 & 0xFFFF
   2100                pBuf += 2;
   2101              }
   \                     ??CrossCallReturnLabel_277:
   \   000036   F9           MOV     R1,A
   \   000037   E4           CLR     A
   \   000038   2C           ADD     A,R4
   \   000039   E9           MOV     A,R1
   \   00003A   FD           MOV     R5,A
   \   00003B   E5..         MOV     A,?V0 + 0
   \   00003D   33           RLC     A
   \   00003E   F8           MOV     R0,A
   \   00003F   E4           CLR     A
   \   000040   33           RLC     A
   \   000041   F9           MOV     R1,A
   \   000042   EA           MOV     A,R2
   \   000043   28           ADD     A,R0
   \   000044   F582         MOV     DPL,A
   \   000046   EB           MOV     A,R3
   \   000047   39           ADDC    A,R1
   \   000048   F583         MOV     DPH,A
   \   00004A   A3           INC     DPTR
   \   00004B   EC           MOV     A,R4
   \   00004C   F0           MOVX    @DPTR,A
   \   00004D   A3           INC     DPTR
   \   00004E   ED           MOV     A,R5
   \   00004F   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_11:
   \   000052   05..         INC     ?V0 + 0
   \                     ??zclParseInReadCmd_2:
   \   000054   8A82         MOV     DPL,R2
   \   000056   8B83         MOV     DPH,R3
   \   000058   E0           MOVX    A,@DPTR
   \   000059   FC           MOV     R4,A
   \   00005A   E5..         MOV     A,?V0 + 0
   \   00005C   C3           CLR     C
   \   00005D   9C           SUBB    A,R4
   \   00005E   40CF         JC      ??zclParseInReadCmd_3
   2102            }
   2103            return ( (void *)readCmd );
   \                     ??zclParseInReadCmd_1:
   \   000060   02....       LJMP    ?Subroutine110 & 0xFFFF
   2104          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine32:
   \   000000   8A82         MOV     DPL,R2
   \   000002   8B83         MOV     DPH,R3
   \   000004   A3           INC     DPTR
   \   000005   8582..       MOV     ?V0 + 0,DPL
   \   000008   8583..       MOV     ?V0 + 1,DPH
   \   00000B                ; Setup parameters for call to function osal_mem_alloc
   \   00000B                ; Setup parameters for call to function osal_mem_alloc
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   2401         ADD     A,#0x1
   \   00000E   FA           MOV     R2,A
   \   00000F   A3           INC     DPTR
   \   000010   E0           MOVX    A,@DPTR
   \   000011   3400         ADDC    A,#0x0
   \   000013   FB           MOV     R3,A
   \   000014   12....       LCALL   ??osal_mem_alloc?relay
   \   000017   EA           MOV     A,R2
   \   000018   22           RET
   2105          
   2106          /*********************************************************************
   2107           * @fn      zclParseInReadRspCmd
   2108           * @brief   Parse the "Profile" Read Response Commands
   2109           *          NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2110           *                FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2111           * @param   pCmd - pointer to incoming data to parse
   2112           * @return  pointer to the parsed command structure
   2113           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine62:
   \   000000   E9           MOV     A,R1
   \   000001   F5..         MOV     ?V0 + 4,A
   \   000003   FC           MOV     R4,A
   \   000004   7D00         MOV     R5,#0x0
   \   000006   AA..         MOV     R2,?V0 + 2
   \   000008   AB..         MOV     R3,?V0 + 3
   \   00000A                REQUIRE ?Subroutine113
   \   00000A                ; // Fall through to label ?Subroutine113

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2114          static void *zclParseInReadRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReadRspCmd:
   2115          {
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   12....       LCALL   ?Subroutine38 & 0xFFFF
   2116            zclReadRspCmd_t *readRspCmd;
   2117            zclReadRspStatus_t *statusRec;
   2118            uint8 *pBuf = pCmd->pData;
   2119            uint8 *dataPtr;
   2120            uint8 numAttr = 0;
   2121            uint8 hdrLen;
   2122            uint8 dataLen = 0;
   \                     ??CrossCallReturnLabel_44:
   \   000008   801B         SJMP    ??zclParseInReadRspCmd_0
   2123            uint8 attrDataLen;
   2124            uint8 dataType;
   2125            uint8 status;
   2126            uint8 i;
   2127            
   2128            // find out the number of attributes and the length of attribute data
   2129            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   2130            {
   2131              numAttr++;
   \                     ??zclParseInReadRspCmd_1:
   \   00000A   12....       LCALL   ?Subroutine71 & 0xFFFF
   2132          
   2133              pBuf += 2; // move pass attribute id
   2134              
   2135              status = *pBuf++;  
   \                     ??CrossCallReturnLabel_154:
   \   00000D   A3           INC     DPTR
   \   00000E   AE82         MOV     R6,DPL
   \   000010   AF83         MOV     R7,DPH
   2136              if ( status == ZCL_STATUS_SUCCESS )
   \   000012   7011         JNZ     ??zclParseInReadRspCmd_0
   2137              {
   2138                dataType = *pBuf++;
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F9           MOV     R1,A
   \   000016   A3           INC     DPTR
   \   000017   0E           INC     R6
   \   000018   12....       LCALL   ?Subroutine67 & 0xFFFF
   2139          
   2140                attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   2141                pBuf += attrDataLen; // move pass attribute data
   2142                
   2143                if ( PADDING_NEEDED( attrDataLen ) ) // add padding if needed
   \                     ??CrossCallReturnLabel_91:
   \   00001B   5002         JNC     ??zclParseInReadRspCmd_2
   2144                  attrDataLen++;
   \   00001D   05..         INC     ?V0 + 8
   2145                dataLen += attrDataLen;
   \                     ??zclParseInReadRspCmd_2:
   \   00001F   E5..         MOV     A,?V0 + 8
   \   000021   25..         ADD     A,?V0 + 6
   \   000023   F5..         MOV     ?V0 + 6,A
   2146              }
   2147            }
   \                     ??zclParseInReadRspCmd_0:
   \   000025   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_221:
   \   000028   40E0         JC      ??zclParseInReadRspCmd_1
   2148           
   2149            hdrLen = sizeof( zclReadRspCmd_t ) + ( numAttr * sizeof( zclReadRspStatus_t ) ); // calculate the length of the response header
   \   00002A   75F006       MOV     B,#0x6
   \   00002D   12....       LCALL   ?Subroutine61 & 0xFFFF
   2150            
   2151            readRspCmd = (zclReadRspCmd_t *)osal_mem_alloc( hdrLen + dataLen );
   2152            if ( readRspCmd != NULL )
   \                     ??CrossCallReturnLabel_215:
   \   000030   7001         JNZ     ??zclParseInReadRspCmd_3
   \   000032   EB           MOV     A,R3
   \                     ??zclParseInReadRspCmd_3:
   \   000033   6049         JZ      ??zclParseInReadRspCmd_4
   2153            {
   2154              pBuf = pCmd->pData;
   \   000035   12....       LCALL   ?Subroutine23 & 0xFFFF
   2155              dataPtr = (uint8 *)( (uint8 *)readRspCmd + hdrLen );
   2156                  
   2157              readRspCmd->numAttr = numAttr;
   2158              for ( i = 0; i < numAttr; i++ )
   \                     ??CrossCallReturnLabel_26:
   \   000038   803D         SJMP    ??zclParseInReadRspCmd_5
   2159              {
   2160                statusRec = &(readRspCmd->attrList[i]);
   \                     ??zclParseInReadRspCmd_6:
   \   00003A   E5..         MOV     A,?V0 + 9
   \   00003C   75F006       MOV     B,#0x6
   \   00003F   12....       LCALL   ?Subroutine3 & 0xFFFF
   2161                
   2162                statusRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   2163                pBuf += 2;
   2164                
   2165                statusRec->status = *pBuf++;
   \                     ??CrossCallReturnLabel_152:
   \   000042   12....       LCALL   ?Subroutine6 & 0xFFFF
   2166                if ( statusRec->status == ZCL_STATUS_SUCCESS )
   \                     ??CrossCallReturnLabel_228:
   \   000045   702E         JNZ     ??CrossCallReturnLabel_93
   2167                {
   2168                  statusRec->dataType = *pBuf++;
   \   000047   E0           MOVX    A,@DPTR
   \   000048   F9           MOV     R1,A
   \   000049   85..82       MOV     DPL,?V0 + 10
   \   00004C   85..83       MOV     DPH,?V0 + 11
   \   00004F   A3           INC     DPTR
   \   000050   A3           INC     DPTR
   \   000051   A3           INC     DPTR
   \   000052   12....       LCALL   ??Subroutine142_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_234:
   \   000055   0E           INC     R6
   \   000056   AF83         MOV     R7,DPH
   2169          
   2170                  attrDataLen = zclGetAttrDataLength( statusRec->dataType, pBuf );
   \   000058                ; Setup parameters for call to function zclGetAttrDataLength
   \   000058   12....       LCALL   ?Subroutine73 & 0xFFFF
   2171                  osal_memcpy( dataPtr, pBuf, attrDataLen);
   \                     ??CrossCallReturnLabel_164:
   \   00005B   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00005E   12....       LCALL   ?Subroutine62 & 0xFFFF
   \                     ??CrossCallReturnLabel_157:
   \   000061   12....       LCALL   ?DEALLOC_XSTACK8
   2172                  statusRec->data = dataPtr;
   \   000064   85..82       MOV     DPL,?V0 + 10
   \   000067   85..83       MOV     DPH,?V0 + 11
   \   00006A   A3           INC     DPTR
   \   00006B   12....       LCALL   ?Subroutine4 & 0xFFFF
   2173                  
   2174                  pBuf += attrDataLen; // move pass attribute data
   2175                 
   2176                  if ( PADDING_NEEDED( attrDataLen ) ) // advance attribute data pointer
   \                     ??CrossCallReturnLabel_6:
   \   00006E   5002         JNC     ??zclParseInReadRspCmd_7
   2177                    attrDataLen++;
   \   000070   05..         INC     ?V0 + 8
   2178                  dataPtr += attrDataLen;
   \                     ??zclParseInReadRspCmd_7:
   \   000072   12....       LCALL   ?Subroutine68 & 0xFFFF
   2179                }
   2180              }
   \                     ??CrossCallReturnLabel_93:
   \   000075   05..         INC     ?V0 + 9
   \                     ??zclParseInReadRspCmd_5:
   \   000077   E5..         MOV     A,?V0 + 9
   \   000079   C3           CLR     C
   \   00007A   95..         SUBB    A,?V0 + 7
   \   00007C   40BC         JC      ??zclParseInReadRspCmd_6
   2181            }
   2182            return ( (void *)readRspCmd );
   \                     ??zclParseInReadRspCmd_4:
   \   00007E                REQUIRE ?Subroutine124
   \   00007E                ; // Fall through to label ?Subroutine124
   2183          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine124:
   \   000000   AA..         MOV     R2,?V0 + 0
   \   000002   AB..         MOV     R3,?V0 + 1
   \   000004   7F0C         MOV     R7,#0xc
   \   000006   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine61:
   \   000000   E5..         MOV     A,?V0 + 7
   \   000002   A4           MUL     AB
   \   000003   04           INC     A
   \   000004   FA           MOV     R2,A
   \   000005   8A82         MOV     DPL,R2
   \   000007   8582..       MOV     ?V0 + 4,DPL
   \   00000A                ; Setup parameters for call to function osal_mem_alloc
   \   00000A                ; Setup parameters for call to function osal_mem_alloc
   \   00000A   85....       MOV     ?V0 + 0,?V0 + 6
   \   00000D   E5..         MOV     A,?V0 + 0
   \   00000F   25..         ADD     A,?V0 + 4
   \   000011   FA           MOV     R2,A
   \   000012   E4           CLR     A
   \   000013   3400         ADDC    A,#0x0
   \   000015   FB           MOV     R3,A
   \   000016                REQUIRE ??Subroutine139_0
   \   000016                ; // Fall through to label ??Subroutine139_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine139_0:
   \   000000   12....       LCALL   ?Subroutine94 & 0xFFFF
   \                     ??CrossCallReturnLabel_218:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   85..82       MOV     DPL,?V0 + 0
   \   000003   85..83       MOV     DPH,?V0 + 1
   \   000006   A3           INC     DPTR
   \   000007                REQUIRE ??Subroutine140_0
   \   000007                ; // Fall through to label ??Subroutine140_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine140_0:
   \   000000   12....       LCALL   ?Subroutine91 & 0xFFFF
   \                     ??CrossCallReturnLabel_226:
   \   000003   85..82       MOV     DPL,?V0 + 2
   \   000006   85..83       MOV     DPH,?V0 + 3
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   28           ADD     A,R0
   \   00000B   F8           MOV     R0,A
   \   00000C   A3           INC     DPTR
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   39           ADDC    A,R1
   \   00000F   F9           MOV     R1,A
   \   000010   C3           CLR     C
   \   000011   EE           MOV     A,R6
   \   000012   98           SUBB    A,R0
   \   000013   EF           MOV     A,R7
   \   000014   99           SUBB    A,R1
   \   000015   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   85..82       MOV     DPL,?V0 + 10
   \   000003   85..83       MOV     DPH,?V0 + 11
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008                REQUIRE ??Subroutine141_0
   \   000008                ; // Fall through to label ??Subroutine141_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine73:
   \   000000   EE           MOV     A,R6
   \   000001   FA           MOV     R2,A
   \   000002   EF           MOV     A,R7
   \   000003   FB           MOV     R3,A
   \   000004   12....       LCALL   ??zclGetAttrDataLength?relay
   \   000007   E9           MOV     A,R1
   \   000008   F5..         MOV     ?V0 + 8,A
   \   00000A                ; Setup parameters for call to function osal_memcpy
   \   00000A                ; Setup parameters for call to function osal_memcpy
   \   00000A   8E..         MOV     ?V0 + 4,R6
   \   00000C   8F..         MOV     ?V0 + 5,R7
   \   00000E                REQUIRE ?Subroutine114
   \   00000E                ; // Fall through to label ?Subroutine114

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine71:
   \   000000   05..         INC     ?V0 + 7
   \   000002   12....       LCALL   ?Subroutine99 & 0xFFFF
   \                     ??CrossCallReturnLabel_139:
   \   000005                REQUIRE ?Subroutine112
   \   000005                ; // Fall through to label ?Subroutine112

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine112:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004   E0           MOVX    A,@DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine68:
   \   000000   85....       MOV     ?V0 + 4,?V0 + 8
   \   000003   E5..         MOV     A,?V0 + 2
   \   000005   25..         ADD     A,?V0 + 4
   \   000007   F5..         MOV     ?V0 + 2,A
   \   000009   E5..         MOV     A,?V0 + 3
   \   00000B   3400         ADDC    A,#0x0
   \   00000D   F5..         MOV     ?V0 + 3,A
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine67:
   \   000000   AF83         MOV     R7,DPH
   \   000002                ; Setup parameters for call to function zclGetAttrDataLength
   \   000002                ; Setup parameters for call to function zclGetAttrDataLength
   \   000002   EE           MOV     A,R6
   \   000003   FA           MOV     R2,A
   \   000004   EF           MOV     A,R7
   \   000005   FB           MOV     R3,A
   \   000006   12....       LCALL   ??zclGetAttrDataLength?relay
   \   000009   E9           MOV     A,R1
   \   00000A   F5..         MOV     ?V0 + 8,A
   \   00000C   F5..         MOV     ?V0 + 4,A
   \   00000E   EE           MOV     A,R6
   \   00000F   25..         ADD     A,?V0 + 4
   \   000011   FE           MOV     R6,A
   \   000012   EF           MOV     A,R7
   \   000013   3400         ADDC    A,#0x0
   \   000015   FF           MOV     R7,A
   \   000016   E9           MOV     A,R1
   \   000017   A2E0         MOV     C,0xE0 /* A   */.0
   \   000019   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine38:
   \   000000   8A..         MOV     ?V0 + 0,R2
   \   000002   8B..         MOV     ?V0 + 1,R3
   \   000004   EA           MOV     A,R2
   \   000005   2403         ADD     A,#0x3
   \   000007   F5..         MOV     ?V0 + 2,A
   \   000009   EB           MOV     A,R3
   \   00000A   12....       LCALL   ?Subroutine95 & 0xFFFF
   \                     ??CrossCallReturnLabel_130:
   \   00000D   FE           MOV     R6,A
   \   00000E   A3           INC     DPTR
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   FF           MOV     R7,A
   \   000011   75..00       MOV     ?V0 + 7,#0x0
   \   000014   75..00       MOV     ?V0 + 6,#0x0
   \   000017   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   85..82       MOV     DPL,?V0 + 2
   \   000003   85..83       MOV     DPH,?V0 + 3
   \   000006   E0           MOVX    A,@DPTR
   \   000007   FE           MOV     R6,A
   \   000008   A3           INC     DPTR
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   FF           MOV     R7,A
   \   00000B   EA           MOV     A,R2
   \   00000C   25..         ADD     A,?V0 + 4
   \   00000E   F5..         MOV     ?V0 + 2,A
   \   000010   EB           MOV     A,R3
   \   000011   3400         ADDC    A,#0x0
   \   000013   F5..         MOV     ?V0 + 3,A
   \   000015   8A82         MOV     DPL,R2
   \   000017   8B83         MOV     DPH,R3
   \   000019   E5..         MOV     A,?V0 + 7
   \   00001B   F0           MOVX    @DPTR,A
   \   00001C   75..00       MOV     ?V0 + 9,#0x0
   \   00001F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003   E5..         MOV     A,?V0 + 2
   \   000005   F0           MOVX    @DPTR,A
   \   000006   A3           INC     DPTR
   \   000007   E5..         MOV     A,?V0 + 3
   \   000009   F0           MOVX    @DPTR,A
   \   00000A   EE           MOV     A,R6
   \   00000B   25..         ADD     A,?V0 + 4
   \   00000D   FE           MOV     R6,A
   \   00000E   EF           MOV     A,R7
   \   00000F   3400         ADDC    A,#0x0
   \   000011   FF           MOV     R7,A
   \   000012   E5..         MOV     A,?V0 + 8
   \   000014   A2E0         MOV     C,0xE0 /* A   */.0
   \   000016   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   12....       LCALL   ?Subroutine98 & 0xFFFF
   \                     ??CrossCallReturnLabel_137:
   \   000003   A3           INC     DPTR
   \   000004   8582..       MOV     ?V0 + 10,DPL
   \   000007   8583..       MOV     ?V0 + 11,DPH
   \   00000A   8E82         MOV     DPL,R6
   \   00000C   8F83         MOV     DPH,R7
   \   00000E   12....       LCALL   ?Subroutine103 & 0xFFFF
   \                     ??CrossCallReturnLabel_290:
   \   000011   F9           MOV     R1,A
   \   000012   EA           MOV     A,R2
   \   000013   85..82       MOV     DPL,?V0 + 10
   \   000016   85..83       MOV     DPH,?V0 + 11
   \   000019   F0           MOVX    @DPTR,A
   \   00001A   A3           INC     DPTR
   \   00001B   E9           MOV     A,R1
   \   00001C   12....       LCALL   ?Subroutine79 & 0xFFFF
   \                     ??CrossCallReturnLabel_113:
   \   00001F   02....       LJMP    ?Subroutine112 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine99:
   \   000000   12....       LCALL   ?Subroutine108 & 0xFFFF
   \                     ??CrossCallReturnLabel_171:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine98:
   \   000000   A4           MUL     AB
   \   000001   F8           MOV     R0,A
   \   000002   A9F0         MOV     R1,B
   \   000004   E5..         MOV     A,?V0 + 0
   \   000006   28           ADD     A,R0
   \   000007   F582         MOV     DPL,A
   \   000009   E5..         MOV     A,?V0 + 1
   \   00000B   39           ADDC    A,R1
   \   00000C   F583         MOV     DPH,A
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine94:
   \   000000   12....       LCALL   ??osal_mem_alloc?relay
   \   000003   8A..         MOV     ?V0 + 0,R2
   \   000005   8B..         MOV     ?V0 + 1,R3
   \   000007   EA           MOV     A,R2
   \   000008   22           RET
   2184          #endif // ZCL_READ
   2185          
   2186          #ifdef ZCL_WRITE
   2187          /*********************************************************************
   2188           * @fn      zclParseInWriteCmd
   2189           * @brief   Parse the "Profile" Write, Write Undivided and Write No
   2190           *          Response Commands
   2191           *          NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2192           *                FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2193           * @param   pCmd - pointer to incoming data to parse
   2194           * @return  pointer to the parsed command structure
   2195           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2196          void *zclParseInWriteCmd( zclParseCmd_t *pCmd )
   \                     zclParseInWriteCmd:
   2197          {
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   12....       LCALL   ?Subroutine38 & 0xFFFF
   2198            zclWriteCmd_t *writeCmd;
   2199            zclWriteRec_t *statusRec;
   2200            uint8 *pBuf = pCmd->pData;
   2201            uint8 attrDataLen;
   2202            uint8 *dataPtr;
   2203            uint8 numAttr = 0;
   2204            uint8 hdrLen;
   2205            uint8 dataLen = 0;
   \                     ??CrossCallReturnLabel_45:
   \   000008   8014         SJMP    ??zclParseInWriteCmd_0
   2206            uint8 dataType;
   2207            uint8 i;
   2208          
   2209            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) ) // find out the number of attributes and the length of attribute data
   2210            {
   2211              numAttr++;
   \                     ??zclParseInWriteCmd_1:
   \   00000A   12....       LCALL   ?Subroutine71 & 0xFFFF
   2212          
   2213              pBuf += 2; // move pass attribute id
   2214          
   2215              dataType = *pBuf++;
   \                     ??CrossCallReturnLabel_155:
   \   00000D   F9           MOV     R1,A
   \   00000E   A3           INC     DPTR
   \   00000F   AE82         MOV     R6,DPL
   \   000011   12....       LCALL   ?Subroutine67 & 0xFFFF
   2216          
   2217              attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   2218              pBuf += attrDataLen; // move pass attribute data
   2219              
   2220              if ( PADDING_NEEDED( attrDataLen ) ) // add padding if needed
   \                     ??CrossCallReturnLabel_92:
   \   000014   5002         JNC     ??zclParseInWriteCmd_2
   2221                attrDataLen++;
   \   000016   05..         INC     ?V0 + 8
   2222              dataLen += attrDataLen;
   \                     ??zclParseInWriteCmd_2:
   \   000018   E5..         MOV     A,?V0 + 8
   \   00001A   25..         ADD     A,?V0 + 6
   \   00001C   F5..         MOV     ?V0 + 6,A
   2223            }
   \                     ??zclParseInWriteCmd_0:
   \   00001E   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_222:
   \   000021   40E7         JC      ??zclParseInWriteCmd_1
   2224            
   2225            hdrLen = sizeof( zclWriteCmd_t ) + ( numAttr * sizeof( zclWriteRec_t ) ); // calculate the length of the response header
   \   000023   75F005       MOV     B,#0x5
   \   000026   12....       LCALL   ?Subroutine61 & 0xFFFF
   2226            
   2227            writeCmd = (zclWriteCmd_t *)osal_mem_alloc( hdrLen + dataLen );
   2228            if ( writeCmd != NULL )
   \                     ??CrossCallReturnLabel_216:
   \   000029   7001         JNZ     ??zclParseInWriteCmd_3
   \   00002B   EB           MOV     A,R3
   \                     ??zclParseInWriteCmd_3:
   \   00002C   6036         JZ      ??zclParseInWriteCmd_4
   2229            {
   2230              pBuf = pCmd->pData;
   \   00002E   12....       LCALL   ?Subroutine23 & 0xFFFF
   2231              dataPtr = (uint8 *)( (uint8 *)writeCmd + hdrLen );
   2232          
   2233              writeCmd->numAttr = numAttr;
   2234              for ( i = 0; i < numAttr; i++ )
   \                     ??CrossCallReturnLabel_27:
   \   000031   802A         SJMP    ??zclParseInWriteCmd_5
   2235              {
   2236                statusRec = &(writeCmd->attrList[i]);
   \                     ??zclParseInWriteCmd_6:
   \   000033   E5..         MOV     A,?V0 + 9
   \   000035   75F005       MOV     B,#0x5
   \   000038   12....       LCALL   ?Subroutine3 & 0xFFFF
   2237                
   2238                statusRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   2239                pBuf += 2;
   2240                statusRec->dataType = *pBuf++;
   \                     ??CrossCallReturnLabel_153:
   \   00003B   F9           MOV     R1,A
   \   00003C   12....       LCALL   ?Subroutine6 & 0xFFFF
   2241          
   2242                attrDataLen = zclGetAttrDataLength( statusRec->dataType, pBuf );
   \                     ??CrossCallReturnLabel_229:
   \   00003F                ; Setup parameters for call to function zclGetAttrDataLength
   \   00003F   12....       LCALL   ?Subroutine73 & 0xFFFF
   2243                osal_memcpy( dataPtr, pBuf, attrDataLen);
   \                     ??CrossCallReturnLabel_165:
   \   000042   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000045   12....       LCALL   ?Subroutine62 & 0xFFFF
   \                     ??CrossCallReturnLabel_158:
   \   000048   12....       LCALL   ?DEALLOC_XSTACK8
   2244                statusRec->attrData = dataPtr;
   \   00004B   85..82       MOV     DPL,?V0 + 10
   \   00004E   85..83       MOV     DPH,?V0 + 11
   \   000051   12....       LCALL   ?Subroutine4 & 0xFFFF
   2245                
   2246                pBuf += attrDataLen; // move pass attribute data
   2247          
   2248                if ( PADDING_NEEDED( attrDataLen ) ) // advance attribute data pointer
   \                     ??CrossCallReturnLabel_7:
   \   000054   5002         JNC     ??zclParseInWriteCmd_7
   2249                  attrDataLen++;
   \   000056   05..         INC     ?V0 + 8
   2250                dataPtr += attrDataLen;
   \                     ??zclParseInWriteCmd_7:
   \   000058   12....       LCALL   ?Subroutine68 & 0xFFFF
   2251              }
   \                     ??CrossCallReturnLabel_94:
   \   00005B   05..         INC     ?V0 + 9
   \                     ??zclParseInWriteCmd_5:
   \   00005D   E5..         MOV     A,?V0 + 9
   \   00005F   C3           CLR     C
   \   000060   95..         SUBB    A,?V0 + 7
   \   000062   40CF         JC      ??zclParseInWriteCmd_6
   2252            }
   2253            
   2254            return ( (void *)writeCmd );
   \                     ??zclParseInWriteCmd_4:
   \   000064   02....       LJMP    ?Subroutine124 & 0xFFFF
   2255          }
   2256          
   2257          /*********************************************************************
   2258           * @fn      zclParseInWriteRspCmd
   2259           * @brief   Parse the "Profile" Write Response Commands
   2260           *          NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2261           *                FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2262           * @param   pCmd - pointer to incoming data to parse
   2263           * @return  pointer to the parsed command structure
   2264           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2265          static void *zclParseInWriteRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInWriteRspCmd:
   2266          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   2267            zclWriteRspCmd_t *writeRspCmd;
   2268            uint8 *pBuf = pCmd->pData;
   \   000005   EA           MOV     A,R2
   \   000006   2403         ADD     A,#0x3
   \   000008   F5..         MOV     ?V0 + 2,A
   \   00000A   EB           MOV     A,R3
   \   00000B   12....       LCALL   ?Subroutine70 & 0xFFFF
   \                     ??CrossCallReturnLabel_97:
   \   00000E   12....       LCALL   ?Subroutine39 & 0xFFFF
   2269            uint8 i = 0;
   \                     ??CrossCallReturnLabel_47:
   \   000011   75..00       MOV     ?V0 + 4,#0x0
   2270          
   2271            writeRspCmd = (zclWriteRspCmd_t *)osal_mem_alloc( sizeof ( zclWriteRspCmd_t ) + pCmd->dataLen );
   \   000014   12....       LCALL   ?Subroutine32 & 0xFFFF
   2272            if ( writeRspCmd != NULL )
   \                     ??CrossCallReturnLabel_37:
   \   000017   7001         JNZ     ??zclParseInWriteRspCmd_0
   \   000019   EB           MOV     A,R3
   \                     ??zclParseInWriteRspCmd_0:
   \   00001A   605C         JZ      ??zclParseInWriteRspCmd_1
   2273            {
   2274              if ( pCmd->dataLen == 1 )
   \   00001C   85..82       MOV     DPL,?V0 + 0
   \   00001F   85..83       MOV     DPH,?V0 + 1
   \   000022   E0           MOVX    A,@DPTR
   \   000023   6401         XRL     A,#0x1
   \   000025   7002         JNZ     ??zclParseInWriteRspCmd_2
   \   000027   A3           INC     DPTR
   \   000028   E0           MOVX    A,@DPTR
   \                     ??zclParseInWriteRspCmd_2:
   \   000029   703B         JNZ     ??CrossCallReturnLabel_138
   2275              {
   2276                writeRspCmd->attrList[i++].status = *pBuf; // special case when all writes were successfull
   \   00002B   12....       LCALL   ?Subroutine50 & 0xFFFF
   2277              }
   \                     ??CrossCallReturnLabel_251:
   \   00002E   A3           INC     DPTR
   \   00002F   F0           MOVX    @DPTR,A
   \   000030   75..01       MOV     ?V0 + 4,#0x1
   \   000033   803C         SJMP    ??zclParseInWriteRspCmd_3
   2278              else
   2279              {
   2280                while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   2281                {
   2282                  writeRspCmd->attrList[i].status = *pBuf++;
   \                     ??zclParseInWriteRspCmd_4:
   \   000035   E5..         MOV     A,?V0 + 4
   \   000037   75F003       MOV     B,#0x3
   \   00003A   A4           MUL     AB
   \   00003B   F8           MOV     R0,A
   \   00003C   A9F0         MOV     R1,B
   \   00003E   EA           MOV     A,R2
   \   00003F   28           ADD     A,R0
   \   000040   F8           MOV     R0,A
   \   000041   EB           MOV     A,R3
   \   000042   39           ADDC    A,R1
   \   000043   F9           MOV     R1,A
   \   000044   8E82         MOV     DPL,R6
   \   000046   8F83         MOV     DPH,R7
   \   000048   E0           MOVX    A,@DPTR
   \   000049   8882         MOV     DPL,R0
   \   00004B   8983         MOV     DPH,R1
   \   00004D   12....       LCALL   ?Subroutine5 & 0xFFFF
   2283                  writeRspCmd->attrList[i++].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??CrossCallReturnLabel_9:
   \   000050   F5..         MOV     ?V0 + 6,A
   \   000052   A3           INC     DPTR
   \   000053   E0           MOVX    A,@DPTR
   \   000054   FD           MOV     R5,A
   \   000055   E5..         MOV     A,?V0 + 6
   \   000057   8882         MOV     DPL,R0
   \   000059   8983         MOV     DPH,R1
   \   00005B   A3           INC     DPTR
   \   00005C   A3           INC     DPTR
   \   00005D   F0           MOVX    @DPTR,A
   \   00005E   A3           INC     DPTR
   \   00005F   ED           MOV     A,R5
   \   000060   F0           MOVX    @DPTR,A
   \   000061   05..         INC     ?V0 + 4
   2284                  pBuf += 2;
   \   000063   12....       LCALL   ?Subroutine99 & 0xFFFF
   2285                }
   \                     ??CrossCallReturnLabel_138:
   \   000066   85..82       MOV     DPL,?V0 + 0
   \   000069   85..83       MOV     DPH,?V0 + 1
   \   00006C   12....       LCALL   ??Subroutine140_0 & 0xFFFF
   2286              }
   \                     ??CrossCallReturnLabel_220:
   \   00006F   40C4         JC      ??zclParseInWriteRspCmd_4
   2287              writeRspCmd->numAttr = i; 
   \                     ??zclParseInWriteRspCmd_3:
   \   000071   8A82         MOV     DPL,R2
   \   000073   8B83         MOV     DPH,R3
   \   000075   E5..         MOV     A,?V0 + 4
   \   000077   F0           MOVX    @DPTR,A
   2288            }
   2289            return ( (void *)writeRspCmd );
   \                     ??zclParseInWriteRspCmd_1:
   \   000078   02....       LJMP    ?Subroutine122 & 0xFFFF
   2290          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine70:
   \   000000   12....       LCALL   ?Subroutine106 & 0xFFFF
   \                     ??CrossCallReturnLabel_148:
   \   000003   22           RET
   2291          #endif // ZCL_WRITE
   2292          
   2293          #ifdef ZCL_REPORT
   2294          /*********************************************************************
   2295           * @fn      zclParseInConfigReportCmd
   2296           * @brief   Parse the "Profile" Configure Reporting Command
   2297           *          NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2298           *                FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2299           * @param   pCmd - pointer to incoming data to parse
   2300           * @return  pointer to the parsed command structure
   2301           */
   2302          void *zclParseInConfigReportCmd( zclParseCmd_t *pCmd )
   2303          {
   2304            zclCfgReportCmd_t *cfgReportCmd;
   2305            zclCfgReportRec_t *reportRec;
   2306            uint8 *pBuf = pCmd->pData;
   2307            uint8 *dataPtr;
   2308            uint8 numAttr = 0;
   2309            uint8 direction;
   2310            uint8 dataType;
   2311            uint8 hdrLen;
   2312            uint8 dataLen = 0;
   2313            uint8 reportChangeLen; // length of Reportable Change field
   2314            uint8 i;
   2315           
   2316            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) ) // Calculate the length of the Request command
   2317            {
   2318              numAttr++;
   2319              
   2320              direction = *pBuf++;
   2321              pBuf += 2; // move pass the attribute ID
   2322              
   2323              if ( direction == ZCL_SEND_ATTR_REPORTS ) // Is there a Reportable Change field?
   2324              {
   2325                dataType = *pBuf++;
   2326                pBuf += 4; // move pass the Min and Max Reporting Intervals
   2327           
   2328                if ( zclAnalogDataType( dataType ) ) // For attributes of 'discrete' data types this field is omitted
   2329                {
   2330                  reportChangeLen = zclGetDataTypeLength( dataType );
   2331                  pBuf += reportChangeLen;
   2332                  
   2333                  if ( PADDING_NEEDED( reportChangeLen ) ) // add padding if needed
   2334                    reportChangeLen++;
   2335                  dataLen += reportChangeLen;
   2336                }
   2337              }
   2338              else
   2339              {
   2340                pBuf += 2; // move pass the Timeout Period
   2341              }
   2342            } // while loop
   2343          
   2344            hdrLen = sizeof( zclCfgReportCmd_t ) + ( numAttr * sizeof( zclCfgReportRec_t ) );
   2345            
   2346            cfgReportCmd = (zclCfgReportCmd_t *)osal_mem_alloc( hdrLen + dataLen );
   2347            if ( cfgReportCmd != NULL )
   2348            { 
   2349              pBuf = pCmd->pData;
   2350              dataPtr = (uint8 *)( (uint8 *)cfgReportCmd + hdrLen );
   2351              
   2352              cfgReportCmd->numAttr = numAttr;
   2353              for ( i = 0; i < numAttr; i++ )
   2354              {
   2355                reportRec = &(cfgReportCmd->attrList[i]);
   2356                
   2357                osal_memset( reportRec, 0, sizeof( zclCfgReportRec_t ) );
   2358                  
   2359                reportRec->direction = *pBuf++;
   2360                reportRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   2361                pBuf += 2;
   2362                if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
   2363                {
   2364                 
   2365                  reportRec->dataType = *pBuf++; // Attribute to be reported
   2366                  reportRec->minReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   2367                  pBuf += 2;
   2368                  reportRec->maxReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   2369                  pBuf += 2;
   2370                 
   2371                  if ( zclAnalogDataType( reportRec->dataType ) ) // For attributes of 'discrete' data types this field is omitted
   2372                  {
   2373                    zcl_BuildAnalogData( reportRec->dataType, dataPtr, pBuf);
   2374                    reportRec->reportableChange = dataPtr;
   2375                    
   2376                    reportChangeLen = zclGetDataTypeLength( reportRec->dataType );
   2377                    pBuf += reportChangeLen;
   2378                   
   2379                    if ( PADDING_NEEDED( reportChangeLen ) ) // advance attribute data pointer
   2380                      reportChangeLen++;
   2381                    dataPtr += reportChangeLen;
   2382                  }
   2383                }
   2384                else
   2385                {
   2386                  reportRec->timeoutPeriod = BUILD_UINT16( pBuf[0], pBuf[1] ); // Attribute reports to be received
   2387                  pBuf += 2;
   2388                }
   2389              } // while loop
   2390            }
   2391            return ( (void *)cfgReportCmd );
   2392          }
   2393          
   2394          /*********************************************************************
   2395           * @fn      zclParseInConfigReportRspCmd
   2396           * @brief   Parse the "Profile" Configure Reporting Response Command
   2397           *          NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2398           *                FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2399           * @param   pCmd - pointer to incoming data to parse
   2400           * @return  pointer to the parsed command structure
   2401           */
   2402          static void *zclParseInConfigReportRspCmd( zclParseCmd_t *pCmd )
   2403          {
   2404            zclCfgReportRspCmd_t *cfgReportRspCmd;
   2405            uint8 *pBuf = pCmd->pData;
   2406            uint8 numAttr;
   2407            uint8 i; 
   2408            
   2409            numAttr = pCmd->dataLen / ( 1 + 1 + 2 ); // Status + Direction + Attribute ID
   2410            
   2411            cfgReportRspCmd = (zclCfgReportRspCmd_t *)osal_mem_alloc( sizeof( zclCfgReportRspCmd_t ) 
   2412                                                      + ( numAttr * sizeof( zclCfgReportStatus_t ) ) );
   2413            if ( cfgReportRspCmd != NULL )
   2414            {
   2415              cfgReportRspCmd->numAttr = numAttr;
   2416              for ( i = 0; i < cfgReportRspCmd->numAttr; i++ )
   2417              {
   2418                cfgReportRspCmd->attrList[i].status = *pBuf++;
   2419                cfgReportRspCmd->attrList[i].direction = *pBuf++;
   2420                cfgReportRspCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   2421                pBuf += 2;
   2422              }
   2423            }
   2424            return ( (void *)cfgReportRspCmd );  
   2425          }
   2426          
   2427          /*********************************************************************
   2428           * @fn      zclParseInReadReportCfgCmd
   2429           * @brief   Parse the "Profile" Read Reporting Configuration Command
   2430           *          NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2431           *                FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2432           * @param   pCmd - pointer to incoming data to parse
   2433           * @return  pointer to the parsed command structure
   2434           */
   2435          void *zclParseInReadReportCfgCmd( zclParseCmd_t *pCmd )
   2436          {
   2437            zclReadReportCfgCmd_t *readReportCfgCmd;
   2438            uint8 *pBuf = pCmd->pData;
   2439            uint8 numAttr;
   2440            uint8 i;
   2441            
   2442            numAttr = pCmd->dataLen / ( 1 + 2 ); // Direction + Attribute ID
   2443            
   2444            readReportCfgCmd = (zclReadReportCfgCmd_t *)osal_mem_alloc( sizeof( zclReadReportCfgCmd_t ) 
   2445                                                            + ( numAttr * sizeof( zclReadReportCfgRec_t ) ) );
   2446            if ( readReportCfgCmd != NULL )
   2447            {
   2448              readReportCfgCmd->numAttr = numAttr;
   2449              for ( i = 0; i < readReportCfgCmd->numAttr; i++)
   2450              {
   2451                readReportCfgCmd->attrList[i].direction = *pBuf++;;
   2452                readReportCfgCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   2453                pBuf += 2;
   2454              }
   2455            }
   2456            return ( (void *)readReportCfgCmd );
   2457          }
   2458          
   2459          /*********************************************************************
   2460           * @fn      zclParseInReadReportCfgRspCmd
   2461           * @brief   Parse the "Profile" Read Reporting Configuration Response Command
   2462           *          NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2463           *                FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2464           * @param   pCmd - pointer to incoming data to parse
   2465           * @return  pointer to the parsed command structure
   2466           */
   2467          static void *zclParseInReadReportCfgRspCmd( zclParseCmd_t *pCmd )
   2468          {
   2469            zclReadReportCfgRspCmd_t *readReportCfgRspCmd;
   2470            zclReportCfgRspRec_t *reportRspRec;
   2471            uint8 reportChangeLen;
   2472            uint8 *pBuf = pCmd->pData;
   2473            uint8 *dataPtr;
   2474            uint8 numAttr = 0;
   2475            uint8 hdrLen;
   2476            uint8 dataLen = 0;
   2477            uint8 status;
   2478            uint8 direction;
   2479            uint8 dataType;
   2480            uint8 i;
   2481            
   2482            // Calculate the length of the response command
   2483            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   2484            { 
   2485              numAttr++;
   2486              
   2487              status = *pBuf++;
   2488              direction = *pBuf++; 
   2489              pBuf += 2; // move pass the attribute ID
   2490              
   2491              if ( status == ZCL_STATUS_SUCCESS )
   2492              {
   2493                if ( direction == ZCL_SEND_ATTR_REPORTS )
   2494                {
   2495                  dataType = *pBuf++;
   2496                  pBuf += 4; // move pass the Min and Max Reporting Intervals
   2497           
   2498                  // For attributes of 'discrete' data types this field is omitted
   2499                  if ( zclAnalogDataType( dataType ) )
   2500                  {
   2501                    reportChangeLen = zclGetDataTypeLength( dataType );
   2502                    pBuf += reportChangeLen;
   2503                    
   2504                    // add padding if needed
   2505                    if ( PADDING_NEEDED( reportChangeLen ) )
   2506                      reportChangeLen++;
   2507                    dataLen += reportChangeLen;
   2508                  }
   2509                }
   2510                else
   2511                {
   2512                  pBuf += 2; // move pass the Timeout field
   2513                }
   2514              }
   2515            } // while loop
   2516            
   2517            hdrLen = sizeof( zclReadReportCfgRspCmd_t ) + ( numAttr * sizeof( zclReportCfgRspRec_t ) );
   2518            
   2519            readReportCfgRspCmd = (zclReadReportCfgRspCmd_t *)osal_mem_alloc( hdrLen + dataLen );
   2520            if ( readReportCfgRspCmd != NULL )
   2521            {
   2522              pBuf = pCmd->pData;
   2523              dataPtr = (uint8 *)( (uint8 *)readReportCfgRspCmd + hdrLen );
   2524              
   2525              readReportCfgRspCmd->numAttr = numAttr;
   2526              for ( i = 0; i < numAttr; i++ )
   2527              {
   2528                reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   2529                
   2530                reportRspRec->status = *pBuf++;
   2531                reportRspRec->direction = *pBuf++;
   2532                reportRspRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   2533                pBuf += 2;
   2534           
   2535                if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   2536                {
   2537                  if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   2538                  {
   2539                    reportRspRec->dataType = *pBuf++;
   2540                    reportRspRec->minReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   2541                    pBuf += 2;
   2542                    reportRspRec->maxReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   2543                    pBuf += 2;
   2544          
   2545                    if ( zclAnalogDataType( reportRspRec->dataType ) )
   2546                    {
   2547                      zcl_BuildAnalogData( reportRspRec->dataType, dataPtr, pBuf);
   2548                      reportRspRec->reportableChange = dataPtr;
   2549                      
   2550                      reportChangeLen = zclGetDataTypeLength( reportRspRec->dataType ); 
   2551                      pBuf += reportChangeLen;
   2552                      
   2553                      // advance attribute data pointer
   2554                      if ( PADDING_NEEDED( reportChangeLen ) )
   2555                        reportChangeLen++;
   2556                      dataPtr += reportChangeLen;
   2557                    }
   2558                  }
   2559                  else
   2560                  {
   2561                    reportRspRec->timeoutPeriod = BUILD_UINT16( pBuf[0], pBuf[1] );
   2562                    pBuf += 2;
   2563                  }
   2564                }
   2565              } 
   2566            }
   2567            
   2568            return ( (void *)readReportCfgRspCmd );
   2569          }
   2570          
   2571          /*********************************************************************
   2572           * @fn      zclParseInReportCmd
   2573           * @brief   Parse the "Profile" Report Command
   2574           *          NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2575           *                FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2576           * @param   pCmd - pointer to incoming data to parse
   2577           * @return  pointer to the parsed command structure
   2578           */
   2579          void *zclParseInReportCmd( zclParseCmd_t *pCmd )
   2580          {
   2581            zclReportCmd_t *reportCmd;
   2582            zclReport_t *reportRec;
   2583            uint8 *pBuf = pCmd->pData;
   2584            uint8 attrDataLen;
   2585            uint8 *dataPtr;
   2586            uint8 numAttr = 0;
   2587            uint8 hdrLen;
   2588            uint8 dataLen = 0;
   2589            uint8 dataType;
   2590            uint8 i;
   2591          
   2592            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) ) // find out the number of attributes and the length of attribute data
   2593            {
   2594              numAttr++;
   2595          
   2596              pBuf += 2; // move pass attribute id
   2597              dataType = *pBuf++;
   2598              attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   2599              pBuf += attrDataLen; // move pass attribute data
   2600                
   2601              if ( PADDING_NEEDED( attrDataLen ) ) // add padding if needed
   2602                attrDataLen++;
   2603              dataLen += attrDataLen;
   2604            }
   2605            
   2606            hdrLen = sizeof( zclReportCmd_t ) + ( numAttr * sizeof( zclReport_t ) );
   2607            
   2608            reportCmd = (zclReportCmd_t *)osal_mem_alloc( hdrLen + dataLen );
   2609            if (reportCmd != NULL )
   2610            {
   2611              pBuf = pCmd->pData;
   2612              dataPtr = (uint8 *)( (uint8 *)reportCmd + hdrLen );
   2613              
   2614              reportCmd->numAttr = numAttr;
   2615              for ( i = 0; i < numAttr; i++ )
   2616              {
   2617                reportRec = &(reportCmd->attrList[i]);
   2618                
   2619                reportRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   2620                pBuf += 2;
   2621                reportRec->dataType = *pBuf++;
   2622          
   2623                attrDataLen = zclGetAttrDataLength( reportRec->dataType, pBuf );  
   2624                osal_memcpy( dataPtr, pBuf, attrDataLen );
   2625                reportRec->attrData = dataPtr;
   2626                
   2627                pBuf += attrDataLen; // move pass attribute data
   2628                
   2629                if ( PADDING_NEEDED( attrDataLen ) ) // advance attribute data pointer
   2630                  attrDataLen++;
   2631                dataPtr += attrDataLen;
   2632              }
   2633            }
   2634            return ( (void *)reportCmd );
   2635          }
   2636          #endif // ZCL_REPORT
   2637          
   2638          /*********************************************************************
   2639           * @fn      zclParseInDefaultRspCmd
   2640           * @brief   Parse the "Profile" Default Response Command
   2641           *          NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2642           *                FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2643           * @param   pCmd - pointer to incoming data to parse
   2644           * @return  pointer to the parsed command structure
   2645           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2646          static void *zclParseInDefaultRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInDefaultRspCmd:
   2647          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   2648            zclDefaultRspCmd_t *defaultRspCmd;
   2649            uint8 *pBuf = pCmd->pData;
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   12....       LCALL   ?Subroutine39 & 0xFFFF
   2650          
   2651            defaultRspCmd = (zclDefaultRspCmd_t *)osal_mem_alloc( sizeof ( zclDefaultRspCmd_t ) );
   \                     ??CrossCallReturnLabel_48:
   \   00000F                ; Setup parameters for call to function osal_mem_alloc
   \   00000F   7A02         MOV     R2,#0x2
   \   000011   7B00         MOV     R3,#0x0
   \   000013   12....       LCALL   ??osal_mem_alloc?relay
   2652            if ( defaultRspCmd != NULL )
   \   000016   EA           MOV     A,R2
   \   000017   7001         JNZ     ??zclParseInDefaultRspCmd_0
   \   000019   EB           MOV     A,R3
   \                     ??zclParseInDefaultRspCmd_0:
   \   00001A   600D         JZ      ??zclParseInDefaultRspCmd_1
   2653            {
   2654              defaultRspCmd->commandID = *pBuf++;
   \   00001C   8E82         MOV     DPL,R6
   \   00001E   8F83         MOV     DPH,R7
   \   000020   E0           MOVX    A,@DPTR
   \   000021   12....       LCALL   ?Subroutine7 & 0xFFFF
   2655              defaultRspCmd->statusCode = *pBuf;
   \                     ??CrossCallReturnLabel_235:
   \   000024   12....       LCALL   ??Subroutine145_0 & 0xFFFF
   2656            }
   \                     ??CrossCallReturnLabel_248:
   \   000027   A3           INC     DPTR
   \   000028   F0           MOVX    @DPTR,A
   2657            return ( (void *)defaultRspCmd );
   \                     ??zclParseInDefaultRspCmd_1:
   \   000029   02....       LJMP    ?Subroutine119 & 0xFFFF
   2658          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   8A82         MOV     DPL,R2
   \   000002   8B83         MOV     DPH,R3
   \   000004                REQUIRE ??Subroutine142_0
   \   000004                ; // Fall through to label ??Subroutine142_0
   2659          
   2660          #ifdef ZCL_DISCOVER
   2661          /*********************************************************************
   2662           * @fn      zclParseInDiscCmd
   2663           * @brief   Parse the "Profile" Discovery Commands
   2664           *          NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2665           *                FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2666           * @param   pCmd - pointer to incoming data to parse
   2667           * @return  pointer to the parsed command structure
   2668           */
   2669          void *zclParseInDiscCmd( zclParseCmd_t *pCmd )
   2670          {
   2671            zclDiscoverCmd_t *discoverCmd;
   2672            uint8 *pBuf = pCmd->pData;
   2673          
   2674            discoverCmd = (zclDiscoverCmd_t *)osal_mem_alloc( sizeof ( zclDiscoverCmd_t ) );
   2675            if ( discoverCmd != NULL )
   2676            {
   2677              discoverCmd->startAttr = BUILD_UINT16( pBuf[0], pBuf[1] );
   2678              pBuf += 2;
   2679              discoverCmd->maxAttrIDs = *pBuf;
   2680            }
   2681            return ( (void *)discoverCmd );
   2682          }
   2683          
   2684          /*********************************************************************
   2685           * @fn      zclParseInDiscRspCmd
   2686           * @brief   Parse the "Profile" Discovery Response Commands
   2687           *          NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2688           *                FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2689           * @param   pCmd - pointer to incoming data to parse
   2690           * @return  pointer to the parsed command structure
   2691           */
   2692          #define ZCLDISCRSPCMD_DATALEN(a)  ((a)-1) // data len - Discovery Complete
   2693          static void *zclParseInDiscRspCmd( zclParseCmd_t *pCmd )
   2694          {
   2695            zclDiscoverRspCmd_t *discoverRspCmd;
   2696            uint8 *pBuf = pCmd->pData;
   2697            uint8 numAttr = ZCLDISCRSPCMD_DATALEN(pCmd->dataLen) / ( 2 + 1 ); // Attr ID + Data Type
   2698            uint8 i;
   2699          
   2700            discoverRspCmd = (zclDiscoverRspCmd_t *)osal_mem_alloc( sizeof ( zclDiscoverRspCmd_t ) 
   2701                                                           + ( numAttr * sizeof(zclDiscoverInfo_t) ) );
   2702            if ( discoverRspCmd != NULL )
   2703            {
   2704              discoverRspCmd->discComplete = *pBuf++;
   2705              discoverRspCmd->numAttr = numAttr;
   2706              
   2707              for ( i = 0; i < numAttr; i++ )
   2708              {
   2709                discoverRspCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   2710                pBuf += 2;
   2711                discoverRspCmd->attrList[i].dataType = *pBuf++;;
   2712              }
   2713            }
   2714            return ( (void *)discoverRspCmd );
   2715          }
   2716          #endif // ZCL_DISCOVER
   2717          
   2718          #ifdef ZCL_READ
   2719          /*********************************************************************
   2720           * @fn      zclProcessInReadCmd
   2721           * @brief   Process the "Profile" Read Command
   2722           * @param   pInMsg - incoming message to process
   2723           * @return  TRUE if command processed. FALSE, otherwise.
   2724           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2725          static uint8 zclProcessInReadCmd( zclIncoming_t *pInMsg )
   \                     zclProcessInReadCmd:
   2726          {
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 4,R2
   \   00000C   8B..         MOV     ?V0 + 5,R3
   2727            zclReadCmd_t *readCmd;
   2728            zclReadRspCmd_t *readRspCmd;
   2729            zclReadRspStatus_t *statusRec;
   2730            zclAttrRec_t attrRec;
   2731            uint8 len;
   2732            uint8 i;
   2733            
   2734            readCmd = (zclReadCmd_t *)pInMsg->attrCmd;
   \   00000E   12....       LCALL   ?Subroutine66 & 0xFFFF
   \                     ??CrossCallReturnLabel_297:
   \   000011   F5..         MOV     ?V0 + 2,A
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F5..         MOV     ?V0 + 3,A
   2735            
   2736            // calculate the length of the response status record
   2737            len = sizeof( zclReadRspCmd_t ) + (readCmd->numAttr * sizeof( zclReadRspStatus_t ));
   2738            
   2739            readRspCmd = osal_mem_alloc( len );
   \   000017                ; Setup parameters for call to function osal_mem_alloc
   \   000017   75F006       MOV     B,#0x6
   \   00001A   85..82       MOV     DPL,?V0 + 2
   \   00001D   F583         MOV     DPH,A
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   A4           MUL     AB
   \   000021   04           INC     A
   \   000022   FA           MOV     R2,A
   \   000023   7B00         MOV     R3,#0x0
   \   000025   12....       LCALL   ??Subroutine139_0 & 0xFFFF
   2740            if ( readRspCmd == NULL )
   \                     ??CrossCallReturnLabel_217:
   \   000028   7001         JNZ     ??zclProcessInReadCmd_0
   \   00002A   EB           MOV     A,R3
   \                     ??zclProcessInReadCmd_0:
   \   00002B   7005         JNZ     ??zclProcessInReadCmd_1
   2741              return FALSE; // EMBEDDED RETURN
   \   00002D   7900         MOV     R1,#0x0
   \   00002F   02....       LJMP    ??zclProcessInReadCmd_2 & 0xFFFF
   2742          
   2743            readRspCmd->numAttr = readCmd->numAttr;
   \                     ??zclProcessInReadCmd_1:
   \   000032   85..82       MOV     DPL,?V0 + 2
   \   000035   85..83       MOV     DPH,?V0 + 3
   \   000038   12....       LCALL   ??Subroutine145_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_249:
   \   00003B   F0           MOVX    @DPTR,A
   2744            for (i = 0; i < readCmd->numAttr; i++)
   \   00003C   75..00       MOV     ?V0 + 6,#0x0
   \   00003F   800B         SJMP    ??zclProcessInReadCmd_3
   2745            {
   2746              statusRec = &(readRspCmd->attrList[i]);
   2747              statusRec->attrID = readCmd->attrID[i];
   2748              
   2749              if ( zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, readCmd->attrID[i], &attrRec ) )
   2750              {
   2751                statusRec->data = attrRec.attr.dataPtr;
   2752                statusRec->status = ZCL_STATUS_SUCCESS;
   2753                statusRec->dataType = attrRec.attr.dataType;
   2754              }
   2755              else
   2756              {
   2757                statusRec->status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   \                     ??zclProcessInReadCmd_4:
   \   000041   7486         MOV     A,#-0x7a
   \   000043   85..82       MOV     DPL,?V0 + 10
   \   000046   85..83       MOV     DPH,?V0 + 11
   \                     ??zclProcessInReadCmd_5:
   \   000049   F0           MOVX    @DPTR,A
   2758              }
   \   00004A   05..         INC     ?V0 + 6
   \                     ??zclProcessInReadCmd_3:
   \   00004C   85..82       MOV     DPL,?V0 + 2
   \   00004F   85..83       MOV     DPH,?V0 + 3
   \   000052   E0           MOVX    A,@DPTR
   \   000053   FA           MOV     R2,A
   \   000054   E5..         MOV     A,?V0 + 6
   \   000056   C3           CLR     C
   \   000057   9A           SUBB    A,R2
   \   000058   4003         JC      $+5
   \   00005A   02....       LJMP    ??zclProcessInReadCmd_6 & 0xFFFF
   \   00005D   85..82       MOV     DPL,?V0 + 6
   \   000060   A882         MOV     R0,DPL
   \   000062   E8           MOV     A,R0
   \   000063   75F006       MOV     B,#0x6
   \   000066   A4           MUL     AB
   \   000067   FA           MOV     R2,A
   \   000068   ABF0         MOV     R3,B
   \   00006A   E5..         MOV     A,?V0 + 0
   \   00006C   2A           ADD     A,R2
   \   00006D   F582         MOV     DPL,A
   \   00006F   E5..         MOV     A,?V0 + 1
   \   000071   3B           ADDC    A,R3
   \   000072   F583         MOV     DPH,A
   \   000074   A3           INC     DPTR
   \   000075   AE82         MOV     R6,DPL
   \   000077   AF83         MOV     R7,DPH
   \   000079   E8           MOV     A,R0
   \   00007A   C3           CLR     C
   \   00007B   33           RLC     A
   \   00007C   F8           MOV     R0,A
   \   00007D   E4           CLR     A
   \   00007E   33           RLC     A
   \   00007F   F9           MOV     R1,A
   \   000080   12....       LCALL   ?Subroutine107 & 0xFFFF
   \                     ??CrossCallReturnLabel_150:
   \   000083   AA82         MOV     R2,DPL
   \   000085   AB83         MOV     R3,DPH
   \   000087   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_243:
   \   00008A   12....       LCALL   ??Subroutine146_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_256:
   \   00008D   EE           MOV     A,R6
   \   00008E   2402         ADD     A,#0x2
   \   000090   F5..         MOV     ?V0 + 10,A
   \   000092   EF           MOV     A,R7
   \   000093   3400         ADDC    A,#0x0
   \   000095   F5..         MOV     ?V0 + 11,A
   \   000097   12....       LCALL   ?Subroutine86 & 0xFFFF
   \                     ??CrossCallReturnLabel_303:
   \   00009A                ; Setup parameters for call to function zclFindAttrRec
   \   00009A   85..82       MOV     DPL,?XSP + 0
   \   00009D   85..83       MOV     DPH,?XSP + 1
   \   0000A0   8582..       MOV     ?V0 + 12,DPL
   \   0000A3   8583..       MOV     ?V0 + 13,DPH
   \   0000A6   78..         MOV     R0,#?V0 + 12
   \   0000A8   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000AB   8A82         MOV     DPL,R2
   \   0000AD   8B83         MOV     DPH,R3
   \   0000AF   12....       LCALL   ??Subroutine149_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_272:
   \   0000B2   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000B5   E9           MOV     A,R1
   \   0000B6   6089         JZ      ??zclProcessInReadCmd_4
   \   0000B8   7406         MOV     A,#0x6
   \   0000BA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BD   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_244:
   \   0000C0   A3           INC     DPTR
   \   0000C1   A3           INC     DPTR
   \   0000C2   A3           INC     DPTR
   \   0000C3   A3           INC     DPTR
   \   0000C4   12....       LCALL   ??Subroutine146_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_257:
   \   0000C7   E4           CLR     A
   \   0000C8   85..82       MOV     DPL,?V0 + 10
   \   0000CB   85..83       MOV     DPH,?V0 + 11
   \   0000CE   F0           MOVX    @DPTR,A
   \   0000CF   7404         MOV     A,#0x4
   \   0000D1   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D4   E0           MOVX    A,@DPTR
   \   0000D5   8E82         MOV     DPL,R6
   \   0000D7   8F83         MOV     DPH,R7
   \   0000D9   A3           INC     DPTR
   \   0000DA   A3           INC     DPTR
   \   0000DB   A3           INC     DPTR
   \   0000DC   02....       LJMP    ??zclProcessInReadCmd_5 & 0xFFFF
   2759            }
   2760            
   2761            // Build and send Read Response command
   2762            zcl_SendReadRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr), pInMsg->msg->clusterId,
   2763                             readRspCmd, ZCL_FRAME_SERVER_CLIENT_DIR,
   2764                             true, pInMsg->hdr.transSeqNum );
   \                     ??zclProcessInReadCmd_6:
   \   0000DF   12....       LCALL   ?Subroutine86 & 0xFFFF
   \                     ??CrossCallReturnLabel_304:
   \   0000E2                ; Setup parameters for call to function zcl_SendReadRsp
   \   0000E2   85..82       MOV     DPL,?V0 + 4
   \   0000E5   85..83       MOV     DPH,?V0 + 5
   \   0000E8   A3           INC     DPTR
   \   0000E9   A3           INC     DPTR
   \   0000EA   A3           INC     DPTR
   \   0000EB   A3           INC     DPTR
   \   0000EC   A3           INC     DPTR
   \   0000ED   A3           INC     DPTR
   \   0000EE   E0           MOVX    A,@DPTR
   \   0000EF   F5..         MOV     ?V0 + 2,A
   \   0000F1   78..         MOV     R0,#?V0 + 2
   \   0000F3   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000F6   75..01       MOV     ?V0 + 2,#0x1
   \   0000F9   78..         MOV     R0,#?V0 + 2
   \   0000FB   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000FE   78..         MOV     R0,#?V0 + 2
   \   000100   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000103   78..         MOV     R0,#?V0 + 0
   \   000105   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000108   85..82       MOV     DPL,?V0 + 8
   \   00010B   85..83       MOV     DPH,?V0 + 9
   \   00010E   12....       LCALL   ??Subroutine131_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_193:
   \   000111   E5..         MOV     A,?V0 + 8
   \   000113   2406         ADD     A,#0x6
   \   000115   FA           MOV     R2,A
   \   000116   E5..         MOV     A,?V0 + 9
   \   000118   3400         ADDC    A,#0x0
   \   00011A   FB           MOV     R3,A
   \   00011B   E5..         MOV     A,?V0 + 8
   \   00011D   2414         ADD     A,#0x14
   \   00011F   F582         MOV     DPL,A
   \   000121   E5..         MOV     A,?V0 + 9
   \   000123   12....       LCALL   ??Subroutine150_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_295:
   \   000126   F9           MOV     R1,A
   \   000127   12....       LCALL   ??zcl_SendReadRsp?relay
   \   00012A   7405         MOV     A,#0x5
   \   00012C   12....       LCALL   ?DEALLOC_XSTACK8
   2765            osal_mem_free( readRspCmd );
   \   00012F                ; Setup parameters for call to function osal_mem_free
   \   00012F   AA..         MOV     R2,?V0 + 0
   \   000131   AB..         MOV     R3,?V0 + 1
   \   000133   12....       LCALL   ??osal_mem_free?relay
   2766              
   2767            return TRUE;
   \   000136   7901         MOV     R1,#0x1
   \                     ??zclProcessInReadCmd_2:
   \   000138   7408         MOV     A,#0x8
   \   00013A   12....       LCALL   ?DEALLOC_XSTACK8
   \   00013D   02....       LJMP    ??Subroutine128_0 & 0xFFFF
   2768          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine86:
   \   000000   85..82       MOV     DPL,?V0 + 4
   \   000003   85..83       MOV     DPH,?V0 + 5
   \   000006                REQUIRE ??Subroutine143_0
   \   000006                ; // Fall through to label ??Subroutine143_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine143_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0 + 8,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V0 + 9,A
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine55:
   \   000000   E0           MOVX    A,@DPTR
   \   000001                REQUIRE ??Subroutine144_0
   \   000001                ; // Fall through to label ??Subroutine144_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine149_0:
   \   000000   12....       LCALL   ?Subroutine90 & 0xFFFF
   \                     ??CrossCallReturnLabel_280:
   \   000003   FD           MOV     R5,A
   \   000004   85..82       MOV     DPL,?V0 + 8
   \   000007   85..83       MOV     DPH,?V0 + 9
   \   00000A   A3           INC     DPTR
   \   00000B   12....       LCALL   ?Subroutine85 & 0xFFFF
   \                     ??CrossCallReturnLabel_287:
   \   00000E   E5..         MOV     A,?V0 + 8
   \   000010   2414         ADD     A,#0x14
   \   000012   F582         MOV     DPL,A
   \   000014   E5..         MOV     A,?V0 + 9
   \   000016   3400         ADDC    A,#0x0
   \   000018   F583         MOV     DPH,A
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   F9           MOV     R1,A
   \   00001C   12....       LCALL   ??zclFindAttrRec?relay
   \   00001F   7402         MOV     A,#0x2
   \   000021   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine66:
   \   000000   EA           MOV     A,R2
   \   000001   240C         ADD     A,#0xc
   \   000003   F582         MOV     DPL,A
   \   000005   EB           MOV     A,R3
   \   000006                REQUIRE ??Subroutine150_0
   \   000006                ; // Fall through to label ??Subroutine150_0
   2769          #endif // ZCL_READ
   2770          
   2771          #ifdef ZCL_WRITE
   2772          /*********************************************************************
   2773           * @fn      processInWriteCmd
   2774           * @brief   Process the "Profile" Write and Write No Response Commands
   2775           * @param   pInMsg - incoming message to process
   2776           * @return  TRUE if command processed. FALSE, otherwise.
   2777           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   F9           MOV     R1,A
   \   000001   85..82       MOV     DPL,?XSP + 0
   \   000004   85..83       MOV     DPH,?XSP + 1
   \   000007                REQUIRE ??Subroutine146_0
   \   000007                ; // Fall through to label ??Subroutine146_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2778          static uint8 zclProcessInWriteCmd( zclIncoming_t *pInMsg )
   \                     zclProcessInWriteCmd:
   2779          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 10
   \   000005   74F6         MOV     A,#-0xa
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 6,R2
   \   00000C   8B..         MOV     ?V0 + 7,R3
   2780            zclWriteCmd_t *writeCmd;
   2781            zclWriteRec_t *statusRec;
   2782            zclWriteRspCmd_t *writeRspCmd;
   2783            zclAttrRec_t attrRec;
   2784            uint8 sendRsp = FALSE;
   \   00000E   75..00       MOV     ?V0 + 4,#0x0
   2785            uint8 status;
   2786            uint8 i, j = 0;
   \   000011   75..00       MOV     ?V0 + 2,#0x0
   2787          
   2788            writeCmd = (zclWriteCmd_t *)pInMsg->attrCmd;
   \   000014   12....       LCALL   ?Subroutine66 & 0xFFFF
   \                     ??CrossCallReturnLabel_298:
   \   000017   F8           MOV     R0,A
   \   000018   A3           INC     DPTR
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   12....       LCALL   ?Subroutine13 & 0xFFFF
   2789            if ( pInMsg->hdr.commandID == ZCL_CMD_WRITE )
   \                     ??CrossCallReturnLabel_260:
   \   00001D   8A82         MOV     DPL,R2
   \   00001F   8B83         MOV     DPH,R3
   \   000021   A3           INC     DPTR
   \   000022   A3           INC     DPTR
   \   000023   A3           INC     DPTR
   \   000024   A3           INC     DPTR
   \   000025   A3           INC     DPTR
   \   000026   A3           INC     DPTR
   \   000027   A3           INC     DPTR
   \   000028   E0           MOVX    A,@DPTR
   \   000029   6402         XRL     A,#0x2
   \   00002B   7013         JNZ     ??zclProcessInWriteCmd_0
   2790            {
   2791              // We need to send a response back - allocate space for it
   2792              writeRspCmd = (zclWriteRspCmd_t *)osal_mem_alloc( sizeof( zclWriteRspCmd_t ) 
   2793                      + sizeof( zclWriteRspStatus_t ) * writeCmd->numAttr );
   \   00002D                ; Setup parameters for call to function osal_mem_alloc
   \   00002D   12....       LCALL   ?Subroutine47 & 0xFFFF
   \                     ??CrossCallReturnLabel_263:
   \   000030   12....       LCALL   ?Subroutine24 & 0xFFFF
   2794              if ( writeRspCmd == NULL )
   \                     ??CrossCallReturnLabel_28:
   \   000033   7001         JNZ     ??zclProcessInWriteCmd_1
   \   000035   EB           MOV     A,R3
   \                     ??zclProcessInWriteCmd_1:
   \   000036   7005         JNZ     ??zclProcessInWriteCmd_2
   2795                return FALSE; // EMBEDDED RETURN
   \   000038   7900         MOV     R1,#0x0
   \   00003A   02....       LJMP    ??zclProcessInWriteCmd_3 & 0xFFFF
   2796              sendRsp = TRUE;
   \                     ??zclProcessInWriteCmd_2:
   \   00003D   75..01       MOV     ?V0 + 4,#0x1
   2797            }
   2798            
   2799            for (i = 0; i < writeCmd->numAttr; i++)
   \                     ??zclProcessInWriteCmd_0:
   \   000040   75..00       MOV     ?V0 + 3,#0x0
   \   000043   801F         SJMP    ??zclProcessInWriteCmd_4
   2800            {
   2801              statusRec = &(writeCmd->attrList[i]);
   2802              if ( zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, statusRec->attrID, &attrRec ) )
   2803              {
   2804                if ( statusRec->dataType == attrRec.attr.dataType )
   2805                {
   2806                  status = zclWriteAttrData( &attrRec, statusRec );
   2807          
   2808                  if ( sendRsp && status != ZCL_STATUS_SUCCESS ) // If successful, a write attribute status record shall NOT be generated
   2809                  {
   2810                    writeRspCmd->attrList[j].status = status; // Attribute is read only - move on to the next write attribute record
   2811                    writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   2812                  }
   2813                }
   2814                else
   2815                {
   2816                  if ( sendRsp ) // Attribute data type is incorrect - move on to the next write attribute record
   2817                  {
   2818                    writeRspCmd->attrList[j].status = ZCL_STATUS_INVALID_DATA_TYPE;
   2819                    writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   2820                  }
   2821                }
   2822              }
   2823              else
   2824              {
   2825                if ( sendRsp ) // Attribute is not supported - move on to the next write attribute record
   \                     ??zclProcessInWriteCmd_5:
   \   000045   E5..         MOV     A,?V0 + 4
   \   000047   6019         JZ      ??zclProcessInWriteCmd_6
   2826                {
   2827                  writeRspCmd->attrList[j].status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   \   000049   7486         MOV     A,#-0x7a
   \                     ??zclProcessInWriteCmd_7:
   \   00004B   85..82       MOV     DPL,?V0 + 14
   \   00004E   85..83       MOV     DPH,?V0 + 15
   2828                  writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   2829                }
   2830              }
   \   000051   12....       LCALL   ?Subroutine101 & 0xFFFF
   \                     ??CrossCallReturnLabel_238:
   \   000054   12....       LCALL   ?Subroutine56 & 0xFFFF
   \                     ??CrossCallReturnLabel_77:
   \   000057   85..82       MOV     DPL,?V0 + 12
   \   00005A   85..83       MOV     DPH,?V0 + 13
   \   00005D   12....       LCALL   ??Subroutine146_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_258:
   \   000060   05..         INC     ?V0 + 2
   \                     ??zclProcessInWriteCmd_6:
   \   000062   05..         INC     ?V0 + 3
   \                     ??zclProcessInWriteCmd_4:
   \   000064   12....       LCALL   ?Subroutine47 & 0xFFFF
   \                     ??CrossCallReturnLabel_264:
   \   000067   E0           MOVX    A,@DPTR
   \   000068   FA           MOV     R2,A
   \   000069   E5..         MOV     A,?V0 + 3
   \   00006B   C3           CLR     C
   \   00006C   9A           SUBB    A,R2
   \   00006D   4003         JC      $+5
   \   00006F   02....       LJMP    ??zclProcessInWriteCmd_8 & 0xFFFF
   \   000072   E5..         MOV     A,?V0 + 3
   \   000074   75F005       MOV     B,#0x5
   \   000077   A4           MUL     AB
   \   000078   F8           MOV     R0,A
   \   000079   A9F0         MOV     R1,B
   \   00007B   85..82       MOV     DPL,?XSP + 0
   \   00007E   85..83       MOV     DPH,?XSP + 1
   \   000081   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_64:
   \   000084   AE82         MOV     R6,DPL
   \   000086   AF83         MOV     R7,DPH
   \   000088   E5..         MOV     A,?V0 + 2
   \   00008A   75F003       MOV     B,#0x3
   \   00008D   12....       LCALL   ?Subroutine98 & 0xFFFF
   \                     ??CrossCallReturnLabel_136:
   \   000090   E582         MOV     A,DPL
   \   000092   2402         ADD     A,#0x2
   \   000094   F5..         MOV     ?V0 + 12,A
   \   000096   E583         MOV     A,DPH
   \   000098   3400         ADDC    A,#0x0
   \   00009A   F5..         MOV     ?V0 + 13,A
   \   00009C   A3           INC     DPTR
   \   00009D   8582..       MOV     ?V0 + 14,DPL
   \   0000A0   8583..       MOV     ?V0 + 15,DPH
   \   0000A3   85..82       MOV     DPL,?V0 + 6
   \   0000A6   85..83       MOV     DPH,?V0 + 7
   \   0000A9   12....       LCALL   ??Subroutine151_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_300:
   \   0000AC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AF   8582..       MOV     ?V0 + 10,DPL
   \   0000B2   8583..       MOV     ?V0 + 11,DPH
   \   0000B5   78..         MOV     R0,#?V0 + 10
   \   0000B7   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000BA   8E82         MOV     DPL,R6
   \   0000BC   8F83         MOV     DPH,R7
   \   0000BE   12....       LCALL   ??Subroutine149_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_273:
   \   0000C1   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000C4   E9           MOV     A,R1
   \   0000C5   7003         JNZ     $+5
   \   0000C7   02....       LJMP    ??zclProcessInWriteCmd_5 & 0xFFFF
   \   0000CA   8E82         MOV     DPL,R6
   \   0000CC   8F83         MOV     DPH,R7
   \   0000CE   A3           INC     DPTR
   \   0000CF   A3           INC     DPTR
   \   0000D0   E0           MOVX    A,@DPTR
   \   0000D1   FA           MOV     R2,A
   \   0000D2   7406         MOV     A,#0x6
   \   0000D4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D7   E0           MOVX    A,@DPTR
   \   0000D8   6A           XRL     A,R2
   \   0000D9   7022         JNZ     ??zclProcessInWriteCmd_9
   \   0000DB                ; Setup parameters for call to function zclWriteAttrData
   \   0000DB   EE           MOV     A,R6
   \   0000DC   FC           MOV     R4,A
   \   0000DD   EF           MOV     A,R7
   \   0000DE   FD           MOV     R5,A
   \   0000DF   7402         MOV     A,#0x2
   \   0000E1   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E4   AA82         MOV     R2,DPL
   \   0000E6   AB83         MOV     R3,DPH
   \   0000E8   12....       LCALL   ??zclWriteAttrData?relay
   \   0000EB   E9           MOV     A,R1
   \   0000EC   FA           MOV     R2,A
   \   0000ED   E5..         MOV     A,?V0 + 4
   \   0000EF   7003         JNZ     $+5
   \   0000F1   02....       LJMP    ??zclProcessInWriteCmd_6 & 0xFFFF
   \   0000F4   EA           MOV     A,R2
   \   0000F5   7003         JNZ     $+5
   \   0000F7   02....       LJMP    ??zclProcessInWriteCmd_6 & 0xFFFF
   \   0000FA   02....       LJMP    ??zclProcessInWriteCmd_7 & 0xFFFF
   \                     ??zclProcessInWriteCmd_9:
   \   0000FD   E5..         MOV     A,?V0 + 4
   \   0000FF   7003         JNZ     $+5
   \   000101   02....       LJMP    ??zclProcessInWriteCmd_6 & 0xFFFF
   \   000104   748D         MOV     A,#-0x73
   \   000106   02....       LJMP    ??zclProcessInWriteCmd_7 & 0xFFFF
   2831            } // for loop
   2832          
   2833            if ( sendRsp )
   \                     ??zclProcessInWriteCmd_8:
   \   000109   E5..         MOV     A,?V0 + 4
   \   00010B   604A         JZ      ??zclProcessInWriteCmd_10
   2834            {
   2835              writeRspCmd->numAttr = j;
   \   00010D   85..82       MOV     DPL,?V0 + 0
   \   000110   85..83       MOV     DPH,?V0 + 1
   \   000113   E5..         MOV     A,?V0 + 2
   \   000115   F0           MOVX    @DPTR,A
   2836              if ( writeRspCmd->numAttr == 0 )
   \   000116   7003         JNZ     ??CrossCallReturnLabel_12
   2837              {
   2838                // Since all records were written successful, include a single status record in the resonse command 
   2839                // with the status field set to SUCCESS and the attribute ID field omitted.
   2840                writeRspCmd->attrList[0].status = ZCL_STATUS_SUCCESS;
   \   000118   12....       LCALL   ?Subroutine10 & 0xFFFF
   2841                writeRspCmd->numAttr = 1;
   2842              }
   2843              zcl_SendWriteRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   2844                                pInMsg->msg->clusterId, writeRspCmd, ZCL_FRAME_SERVER_CLIENT_DIR, 
   2845                                true, pInMsg->hdr.transSeqNum );
   \                     ??CrossCallReturnLabel_12:
   \   00011B   85..82       MOV     DPL,?V0 + 6
   \   00011E   85..83       MOV     DPH,?V0 + 7
   \   000121   12....       LCALL   ?Subroutine39 & 0xFFFF
   \                     ??CrossCallReturnLabel_49:
   \   000124                ; Setup parameters for call to function zcl_SendWriteRsp
   \   000124   85..82       MOV     DPL,?V0 + 6
   \   000127   85..83       MOV     DPH,?V0 + 7
   \   00012A   A3           INC     DPTR
   \   00012B   A3           INC     DPTR
   \   00012C   A3           INC     DPTR
   \   00012D   A3           INC     DPTR
   \   00012E   A3           INC     DPTR
   \   00012F   A3           INC     DPTR
   \   000130   E0           MOVX    A,@DPTR
   \   000131   F5..         MOV     ?V0 + 2,A
   \   000133   78..         MOV     R0,#?V0 + 2
   \   000135   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000138   75..01       MOV     ?V0 + 2,#0x1
   \   00013B   78..         MOV     R0,#?V0 + 2
   \   00013D   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000140   78..         MOV     R0,#?V0 + 2
   \   000142   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000145   78..         MOV     R0,#?V0 + 0
   \   000147   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00014A   12....       LCALL   ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_24:
   \   00014D   12....       LCALL   ?DEALLOC_XSTACK8
   2846              osal_mem_free( writeRspCmd );
   \   000150                ; Setup parameters for call to function osal_mem_free
   \   000150   AA..         MOV     R2,?V0 + 0
   \   000152   AB..         MOV     R3,?V0 + 1
   \   000154   12....       LCALL   ??osal_mem_free?relay
   2847            }
   2848            return TRUE; 
   \                     ??zclProcessInWriteCmd_10:
   \   000157   7901         MOV     R1,#0x1
   \                     ??zclProcessInWriteCmd_3:
   \   000159   740A         MOV     A,#0xa
   \   00015B   02....       LJMP    ??Subroutine127_0 & 0xFFFF
   2849          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine47:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine148_0
   \   000006                ; // Fall through to label ??Subroutine148_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine151_0:
   \   000000   12....       LCALL   ??Subroutine143_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_305:
   \   000003                ; Setup parameters for call to function zclFindAttrRec
   \   000003                ; Setup parameters for call to function zclFindAttrRec
   \   000003                ; Setup parameters for call to function zclFindAttrRec
   \   000003   7402         MOV     A,#0x2
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   75F003       MOV     B,#0x3
   \   000004   A4           MUL     AB
   \   000005   F8           MOV     R0,A
   \   000006   A9F0         MOV     R1,B
   \   000008   7401         MOV     A,#0x1
   \   00000A   28           ADD     A,R0
   \   00000B   FA           MOV     R2,A
   \   00000C   E4           CLR     A
   \   00000D   39           ADDC    A,R1
   \   00000E   FB           MOV     R3,A
   \   00000F   12....       LCALL   ?Subroutine94 & 0xFFFF
   \                     ??CrossCallReturnLabel_219:
   \   000012   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   12....       LCALL   ?Subroutine90 & 0xFFFF
   \                     ??CrossCallReturnLabel_278:
   \   00000B   FD           MOV     R5,A
   \   00000C   EE           MOV     A,R6
   \   00000D   2406         ADD     A,#0x6
   \   00000F   FA           MOV     R2,A
   \   000010   EF           MOV     A,R7
   \   000011   3400         ADDC    A,#0x0
   \   000013   FB           MOV     R3,A
   \   000014   EE           MOV     A,R6
   \   000015   2414         ADD     A,#0x14
   \   000017   F582         MOV     DPL,A
   \   000019   EF           MOV     A,R7
   \   00001A   3400         ADDC    A,#0x0
   \   00001C   F583         MOV     DPH,A
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   F9           MOV     R1,A
   \   000020   12....       LCALL   ??zcl_SendWriteRsp?relay
   \   000023   7405         MOV     A,#0x5
   \   000025   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   E4           CLR     A
   \   000001   A3           INC     DPTR
   \   000002   F0           MOVX    @DPTR,A
   \   000003   7401         MOV     A,#0x1
   \   000005   85..82       MOV     DPL,?V0 + 0
   \   000008   85..83       MOV     DPH,?V0 + 1
   \   00000B   F0           MOVX    @DPTR,A
   \   00000C   22           RET
   2850          
   2851          /*********************************************************************
   2852           * @fn      zclRevertWriteUndividedCmd
   2853           * @brief   Revert the "Profile" Write Undevided Command
   2854           * @param   pInMsg - incoming message to process
   2855           *          curWriteRec - old data
   2856           *          numAttr - number of attributes to be reverted
   2857           */
   2858          static void zclRevertWriteUndividedCmd( zclIncoming_t *pInMsg, zclWriteRec_t *curWriteRec, uint16 numAttr )
   2859          {
   2860            zclWriteRec_t *statusRec;
   2861            zclAttrRec_t attrRec;
   2862            uint8 dataLen;
   2863            uint8 i;
   2864          
   2865            statusRec = curWriteRec;
   2866            for (i = 0; i < numAttr; i++)
   2867            {
   2868              statusRec = &(curWriteRec[i]);
   2869              
   2870              if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, statusRec->attrID, &attrRec ) )
   2871                break; // should never happen
   2872           
   2873              // Just copy the old data back - no need to validate the data
   2874              dataLen = zclGetAttrDataLength( attrRec.attr.dataType, statusRec->attrData );
   2875              osal_memcpy( attrRec.attr.dataPtr, statusRec->attrData, dataLen );
   2876            } // for loop
   2877          }
   2878          
   2879          /*********************************************************************
   2880           * @fn      zclProcessInWriteUndividedCmd
   2881           * @brief   Process the "Profile" Write Undivided Command
   2882           * @param   pInMsg - incoming message to process
   2883           * @return  TRUE if command processed. FALSE, otherwise.
   2884           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   85..82       MOV     DPL,?V0 + 2
   \   000003   85..83       MOV     DPH,?V0 + 3
   \   000006                REQUIRE ??Subroutine149_0
   \   000006                ; // Fall through to label ??Subroutine149_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2885          static uint8 zclProcessInWriteUndividedCmd( zclIncoming_t *pInMsg )
   \                     zclProcessInWriteUndividedCmd:
   2886          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 18
   \   000005   74EE         MOV     A,#-0x12
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 14,R2
   \   00000C   8B..         MOV     ?V0 + 15,R3
   2887            zclWriteCmd_t *writeCmd;
   2888            zclWriteRec_t *statusRec;
   2889            zclWriteRec_t *curWriteRec;
   2890            zclWriteRec_t *curStatusRec;
   2891            zclWriteRspCmd_t *writeRspCmd;
   2892            zclAttrRec_t attrRec;
   2893            uint8 *curDataPtr;
   2894            uint8 hdrLen;
   2895            uint8 dataLen;
   2896            uint8 curLen = 0;
   \   00000E   75..00       MOV     ?V0 + 4,#0x0
   2897            uint8 status;
   2898            uint8 i, j = 0;
   \   000011   7F00         MOV     R7,#0x0
   2899          
   2900            writeCmd = (zclWriteCmd_t *)pInMsg->attrCmd;
   \   000013   12....       LCALL   ?Subroutine66 & 0xFFFF
   \                     ??CrossCallReturnLabel_299:
   \   000016   F5..         MOV     ?V0 + 6,A
   \   000018   A3           INC     DPTR
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   F5..         MOV     ?V0 + 7,A
   2901            
   2902            // Allocate space for Write Response Command
   2903            writeRspCmd = (zclWriteRspCmd_t *)osal_mem_alloc( sizeof( zclWriteRspCmd_t ) + sizeof( zclWriteRspStatus_t )* writeCmd->numAttr );
   \   00001C                ; Setup parameters for call to function osal_mem_alloc
   \   00001C   85..82       MOV     DPL,?V0 + 6
   \   00001F   F583         MOV     DPH,A
   \   000021   12....       LCALL   ?Subroutine24 & 0xFFFF
   2904            
   2905            if ( writeRspCmd == NULL )
   \                     ??CrossCallReturnLabel_29:
   \   000024   7001         JNZ     ??zclProcessInWriteUndividedCmd_0
   \   000026   EB           MOV     A,R3
   \                     ??zclProcessInWriteUndividedCmd_0:
   \   000027   7005         JNZ     ??zclProcessInWriteUndividedCmd_1
   2906              return FALSE; // EMBEDDED RETURN
   \                     ??zclProcessInWriteUndividedCmd_2:
   \   000029   7900         MOV     R1,#0x0
   \   00002B   02....       LJMP    ??zclProcessInWriteUndividedCmd_3 & 0xFFFF
   2907            
   2908            // If any attribute cannot be written, no attribute values are changed. Hence,
   2909            // make sure all the attributes are supported and writable
   2910            for (i = 0; i < writeCmd->numAttr; i++)
   \                     ??zclProcessInWriteUndividedCmd_1:
   \   00002E   7E00         MOV     R6,#0x0
   \   000030   801C         SJMP    ??zclProcessInWriteUndividedCmd_4
   2911            {
   2912              statusRec = &(writeCmd->attrList[i]);
   2913              
   2914              if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, statusRec->attrID, &attrRec ) )
   2915              {
   2916                // Attribute is not supported - stop here
   2917                writeRspCmd->attrList[j].status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   2918                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   2919                break;
   2920              }
   2921              
   2922              if ( statusRec->dataType != attrRec.attr.dataType )
   2923              {
   2924                // Attribute data type is incorrect - stope here
   2925                writeRspCmd->attrList[j].status = ZCL_STATUS_INVALID_DATA_TYPE;
   2926                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   2927                break;
   2928              }
   2929              
   2930              if ( !zcl_AccessCtrlWrite( attrRec.attr.accessControl ) )
   2931              {
   2932                // Attribute is not writable - stop here
   2933                writeRspCmd->attrList[j].status = ZCL_STATUS_READ_ONLY;
   2934                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   2935                break;
   2936              }  
   2937              dataLen = zclGetAttrDataLength( statusRec->dataType, statusRec->attrData );
   \                     ??zclProcessInWriteUndividedCmd_5:
   \   000032                ; Setup parameters for call to function zclGetAttrDataLength
   \   000032   85..82       MOV     DPL,?V0 + 2
   \   000035   85..83       MOV     DPH,?V0 + 3
   \   000038   A3           INC     DPTR
   \   000039   A3           INC     DPTR
   \   00003A   A3           INC     DPTR
   \   00003B   12....       LCALL   ??Subroutine137_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_210:
   \   00003E   12....       LCALL   ??zclGetAttrDataLength?relay
   \   000041   E9           MOV     A,R1
   \   000042   FA           MOV     R2,A
   2938              
   2939              // add padding if needed
   2940              if ( PADDING_NEEDED( dataLen ) )
   \   000043   A2E0         MOV     C,0xE0 /* A   */.0
   \   000045   5001         JNC     ??zclProcessInWriteUndividedCmd_6
   2941                dataLen++;
   \   000047   0A           INC     R2
   2942              curLen += dataLen;
   \                     ??zclProcessInWriteUndividedCmd_6:
   \   000048   EA           MOV     A,R2
   \   000049   25..         ADD     A,?V0 + 4
   \   00004B   F5..         MOV     ?V0 + 4,A
   \   00004D   0E           INC     R6
   \                     ??zclProcessInWriteUndividedCmd_4:
   \   00004E   85..82       MOV     DPL,?V0 + 6
   \   000051   85..83       MOV     DPH,?V0 + 7
   \   000054   E0           MOVX    A,@DPTR
   \   000055   FA           MOV     R2,A
   \   000056   EE           MOV     A,R6
   \   000057   C3           CLR     C
   \   000058   9A           SUBB    A,R2
   \   000059   505D         JNC     ??zclProcessInWriteUndividedCmd_7
   \   00005B   12....       LCALL   ?Subroutine72 & 0xFFFF
   \                     ??CrossCallReturnLabel_99:
   \   00005E   12....       LCALL   ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_301:
   \   000061   12....       LCALL   ?XSTACK_DISP0_8
   \   000064   8582..       MOV     ?V0 + 10,DPL
   \   000067   8583..       MOV     ?V0 + 11,DPH
   \   00006A   78..         MOV     R0,#?V0 + 10
   \   00006C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00006F   12....       LCALL   ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_270:
   \   000072   12....       LCALL   ?DEALLOC_XSTACK8
   \   000075   E9           MOV     A,R1
   \   000076   7004         JNZ     ??zclProcessInWriteUndividedCmd_8
   \   000078   7486         MOV     A,#-0x7a
   \   00007A   8023         SJMP    ??zclProcessInWriteUndividedCmd_9
   \                     ??zclProcessInWriteUndividedCmd_8:
   \   00007C   85..82       MOV     DPL,?V0 + 2
   \   00007F   85..83       MOV     DPH,?V0 + 3
   \   000082   A3           INC     DPTR
   \   000083   A3           INC     DPTR
   \   000084   E0           MOVX    A,@DPTR
   \   000085   F9           MOV     R1,A
   \   000086   7406         MOV     A,#0x6
   \   000088   12....       LCALL   ?XSTACK_DISP0_8
   \   00008B   E0           MOVX    A,@DPTR
   \   00008C   69           XRL     A,R1
   \   00008D   6004         JZ      ??zclProcessInWriteUndividedCmd_10
   \   00008F   748D         MOV     A,#-0x73
   \   000091   800C         SJMP    ??zclProcessInWriteUndividedCmd_9
   \                     ??zclProcessInWriteUndividedCmd_10:
   \   000093   7407         MOV     A,#0x7
   \   000095   12....       LCALL   ?XSTACK_DISP0_8
   \   000098   E0           MOVX    A,@DPTR
   \   000099   A2E1         MOV     C,0xE0 /* A   */.1
   \   00009B   4095         JC      ??zclProcessInWriteUndividedCmd_5
   \   00009D   7488         MOV     A,#-0x78
   \                     ??zclProcessInWriteUndividedCmd_9:
   \   00009F   85..82       MOV     DPL,?V0 + 0
   \   0000A2   85..83       MOV     DPH,?V0 + 1
   \   0000A5   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_22:
   \   0000A8   F8           MOV     R0,A
   \   0000A9   A3           INC     DPTR
   \   0000AA   E0           MOVX    A,@DPTR
   \   0000AB   F9           MOV     R1,A
   \   0000AC   85..82       MOV     DPL,?V0 + 0
   \   0000AF   85..83       MOV     DPH,?V0 + 1
   \   0000B2   A3           INC     DPTR
   \   0000B3   A3           INC     DPTR
   \   0000B4   12....       LCALL   ??Subroutine146_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_259:
   \   0000B7   0F           INC     R7
   2943            } // for loop
   2944            
   2945            writeRspCmd->numAttr = j;
   \                     ??zclProcessInWriteUndividedCmd_7:
   \   0000B8   EF           MOV     A,R7
   \   0000B9   85..82       MOV     DPL,?V0 + 0
   \   0000BC   85..83       MOV     DPH,?V0 + 1
   \   0000BF   F0           MOVX    @DPTR,A
   2946            if ( writeRspCmd->numAttr == 0 ) // All attributes can be written
   \   0000C0   6003         JZ      $+5
   \   0000C2   02....       LJMP    ??zclProcessInWriteUndividedCmd_11 & 0xFFFF
   2947            {
   2948              // calculate the length of the current data header
   2949              hdrLen = j * sizeof( zclWriteRec_t );
   \   0000C5   75F005       MOV     B,#0x5
   \   0000C8   A4           MUL     AB
   \   0000C9   FA           MOV     R2,A
   2950            
   2951              // Allocate space to keep a copy of the current data
   2952              curWriteRec = (zclWriteRec_t *) osal_mem_alloc( hdrLen + curLen ); 
   \   0000CA   8A82         MOV     DPL,R2
   \   0000CC   8582..       MOV     ?V0 + 2,DPL
   \   0000CF                ; Setup parameters for call to function osal_mem_alloc
   \   0000CF   E5..         MOV     A,?V0 + 4
   \   0000D1   25..         ADD     A,?V0 + 2
   \   0000D3   FA           MOV     R2,A
   \   0000D4   E4           CLR     A
   \   0000D5   3400         ADDC    A,#0x0
   \   0000D7   FB           MOV     R3,A
   \   0000D8   12....       LCALL   ??osal_mem_alloc?relay
   \   0000DB   8A..         MOV     ?V0 + 12,R2
   \   0000DD   8B..         MOV     ?V0 + 13,R3
   2953              if ( curWriteRec == NULL )
   \   0000DF   EA           MOV     A,R2
   \   0000E0   7001         JNZ     ??zclProcessInWriteUndividedCmd_12
   \   0000E2   EB           MOV     A,R3
   \                     ??zclProcessInWriteUndividedCmd_12:
   \   0000E3   700A         JNZ     ??zclProcessInWriteUndividedCmd_13
   2954              {
   2955                osal_mem_free(writeRspCmd );
   \   0000E5                ; Setup parameters for call to function osal_mem_free
   \   0000E5   AA..         MOV     R2,?V0 + 0
   \   0000E7   AB..         MOV     R3,?V0 + 1
   \   0000E9   12....       LCALL   ??osal_mem_free?relay
   2956                return FALSE; // EMBEDDED RETURN
   \   0000EC   02....       LJMP    ??zclProcessInWriteUndividedCmd_2 & 0xFFFF
   2957              }
   2958          
   2959              curDataPtr = (uint8 *)((uint8 *)curWriteRec + hdrLen);
   \                     ??zclProcessInWriteUndividedCmd_13:
   \   0000EF   EA           MOV     A,R2
   \   0000F0   25..         ADD     A,?V0 + 2
   \   0000F2   F5..         MOV     ?V0 + 4,A
   \   0000F4   EB           MOV     A,R3
   \   0000F5   3400         ADDC    A,#0x0
   \   0000F7   F5..         MOV     ?V0 + 5,A
   2960              
   2961              // Write the new data over
   2962              for (i = 0; i < writeCmd->numAttr; i++)
   \   0000F9   7E00         MOV     R6,#0x0
   \   0000FB   8023         SJMP    ??zclProcessInWriteUndividedCmd_14
   2963              {
   2964                statusRec = &(writeCmd->attrList[i]);
   2965                curStatusRec = &(curWriteRec[i]);
   2966              
   2967                if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, statusRec->attrID, &attrRec ) )
   2968                  break; // should never happen
   2969          
   2970                // Keep a copy of the current data before before writing the new data over
   2971                curStatusRec->attrID = statusRec->attrID;
   2972                zclReadAttrData( curDataPtr, &attrRec );
   2973                curStatusRec->attrData = curDataPtr;
   2974                
   2975                status = zclWriteAttrData( &attrRec, statusRec );
   2976                   
   2977                // If successful, a write attribute status record shall NOT be generated
   2978                if ( status != ZCL_STATUS_SUCCESS )
   2979                {
   2980                  writeRspCmd->attrList[j].status = status;
   2981                  writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   2982                    
   2983                  // Since this write failed, we need to revert all the pervious writes
   2984                  zclRevertWriteUndividedCmd( pInMsg, curWriteRec, i);
   2985                  break;
   2986                }
   2987                
   2988                dataLen = zclGetAttrDataLength( statusRec->dataType, statusRec->attrData );
   \                     ??zclProcessInWriteUndividedCmd_15:
   \   0000FD                ; Setup parameters for call to function zclGetAttrDataLength
   \   0000FD   85..82       MOV     DPL,?V0 + 2
   \   000100   85..83       MOV     DPH,?V0 + 3
   \   000103   A3           INC     DPTR
   \   000104   A3           INC     DPTR
   \   000105   A3           INC     DPTR
   \   000106   12....       LCALL   ?Subroutine43 & 0xFFFF
   \                     ??CrossCallReturnLabel_56:
   \   000109   12....       LCALL   ??Subroutine135_0 & 0xFFFF
   2989                
   2990                // add padding if needed
   2991                if ( PADDING_NEEDED( dataLen ) )
   \                     ??CrossCallReturnLabel_202:
   \   00010C   A2E0         MOV     C,0xE0 /* A   */.0
   \   00010E   5001         JNC     ??zclProcessInWriteUndividedCmd_16
   2992                  dataLen++;
   \   000110   0A           INC     R2
   2993                curDataPtr += dataLen;
   \                     ??zclProcessInWriteUndividedCmd_16:
   \   000111   8A..         MOV     ?V0 + 2,R2
   \   000113   E5..         MOV     A,?V0 + 4
   \   000115   25..         ADD     A,?V0 + 2
   \   000117   F5..         MOV     ?V0 + 4,A
   \   000119   E5..         MOV     A,?V0 + 5
   \   00011B   3400         ADDC    A,#0x0
   \   00011D   F5..         MOV     ?V0 + 5,A
   \   00011F   0E           INC     R6
   \                     ??zclProcessInWriteUndividedCmd_14:
   \   000120   85..82       MOV     DPL,?V0 + 6
   \   000123   85..83       MOV     DPH,?V0 + 7
   \   000126   E0           MOVX    A,@DPTR
   \   000127   FA           MOV     R2,A
   \   000128   EE           MOV     A,R6
   \   000129   C3           CLR     C
   \   00012A   9A           SUBB    A,R2
   \   00012B   4003         JC      $+5
   \   00012D   02....       LJMP    ??zclProcessInWriteUndividedCmd_17 & 0xFFFF
   \   000130   12....       LCALL   ?Subroutine72 & 0xFFFF
   \                     ??CrossCallReturnLabel_100:
   \   000133   E5..         MOV     A,?V0 + 12
   \   000135   28           ADD     A,R0
   \   000136   F8           MOV     R0,A
   \   000137   E5..         MOV     A,?V0 + 13
   \   000139   39           ADDC    A,R1
   \   00013A   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_261:
   \   00013D   12....       LCALL   ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_302:
   \   000140   12....       LCALL   ?XSTACK_DISP0_8
   \   000143   8582..       MOV     ?V0 + 10,DPL
   \   000146   8583..       MOV     ?V0 + 11,DPH
   \   000149   78..         MOV     R0,#?V0 + 10
   \   00014B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00014E   12....       LCALL   ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_271:
   \   000151   12....       LCALL   ?DEALLOC_XSTACK8
   \   000154   E9           MOV     A,R1
   \   000155   7003         JNZ     $+5
   \   000157   02....       LJMP    ??zclProcessInWriteUndividedCmd_17 & 0xFFFF
   \   00015A   12....       LCALL   ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_214:
   \   00015D   12....       LCALL   ?Subroutine47 & 0xFFFF
   \                     ??CrossCallReturnLabel_265:
   \   000160   12....       LCALL   ??Subroutine152_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_309:
   \   000163                ; Setup parameters for call to function zclReadAttrData
   \   000163   7402         MOV     A,#0x2
   \   000165   12....       LCALL   ?XSTACK_DISP0_8
   \   000168   AC82         MOV     R4,DPL
   \   00016A   AD83         MOV     R5,DPH
   \   00016C   AA..         MOV     R2,?V0 + 4
   \   00016E   AB..         MOV     R3,?V0 + 5
   \   000170   12....       LCALL   ??zclReadAttrData?relay
   \   000173   85..82       MOV     DPL,?XSP + 0
   \   000176   85..83       MOV     DPH,?XSP + 1
   \   000179   12....       LCALL   ?Subroutine46 & 0xFFFF
   \                     ??CrossCallReturnLabel_61:
   \   00017C   E5..         MOV     A,?V0 + 4
   \   00017E   F0           MOVX    @DPTR,A
   \   00017F   A3           INC     DPTR
   \   000180   E5..         MOV     A,?V0 + 5
   \   000182   F0           MOVX    @DPTR,A
   \   000183                ; Setup parameters for call to function zclWriteAttrData
   \   000183   AC..         MOV     R4,?V0 + 2
   \   000185   AD..         MOV     R5,?V0 + 3
   \   000187   7402         MOV     A,#0x2
   \   000189   12....       LCALL   ?XSTACK_DISP0_8
   \   00018C   AA82         MOV     R2,DPL
   \   00018E   AB83         MOV     R3,DPH
   \   000190   12....       LCALL   ??zclWriteAttrData?relay
   \   000193   E9           MOV     A,R1
   \   000194   FB           MOV     R3,A
   \   000195   7003         JNZ     $+5
   \   000197   02....       LJMP    ??zclProcessInWriteUndividedCmd_15 & 0xFFFF
   \   00019A   EF           MOV     A,R7
   \   00019B   75F003       MOV     B,#0x3
   \   00019E   A4           MUL     AB
   \   00019F   F8           MOV     R0,A
   \   0001A0   A9F0         MOV     R1,B
   \   0001A2   E5..         MOV     A,?V0 + 0
   \   0001A4   28           ADD     A,R0
   \   0001A5   F8           MOV     R0,A
   \   0001A6   E5..         MOV     A,?V0 + 1
   \   0001A8   39           ADDC    A,R1
   \   0001A9   F9           MOV     R1,A
   \   0001AA   EB           MOV     A,R3
   \   0001AB   8882         MOV     DPL,R0
   \   0001AD   8983         MOV     DPH,R1
   \   0001AF   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_23:
   \   0001B2   FA           MOV     R2,A
   \   0001B3   A3           INC     DPTR
   \   0001B4   E0           MOVX    A,@DPTR
   \   0001B5   FB           MOV     R3,A
   \   0001B6   8882         MOV     DPL,R0
   \   0001B8   8983         MOV     DPH,R1
   \   0001BA   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_311:
   \   0001BD   0F           INC     R7
   \   0001BE   8E82         MOV     DPL,R6
   \   0001C0   8582..       MOV     ?V0 + 8,DPL
   \   0001C3   7E00         MOV     R6,#0x0
   \   0001C5   8032         SJMP    ??zclProcessInWriteUndividedCmd_18
   2994              } // for loop
   \                     ??zclProcessInWriteUndividedCmd_19:
   \   0001C7   E5..         MOV     A,?V0 + 2
   \   0001C9   2403         ADD     A,#0x3
   \   0001CB   F5..         MOV     ?V0 + 2,A
   \   0001CD   E5..         MOV     A,?V0 + 3
   \   0001CF   12....       LCALL   ?Subroutine70 & 0xFFFF
   \                     ??CrossCallReturnLabel_98:
   \   0001D2   12....       LCALL   ??Subroutine137_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_211:
   \   0001D5   740E         MOV     A,#0xe
   \   0001D7   12....       LCALL   ?XSTACK_DISP0_8
   \   0001DA   12....       LCALL   ??Subroutine136_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_203:
   \   0001DD                ; Setup parameters for call to function osal_memcpy
   \   0001DD   85..82       MOV     DPL,?V0 + 2
   \   0001E0   85..83       MOV     DPH,?V0 + 3
   \   0001E3   12....       LCALL   ?Subroutine35 & 0xFFFF
   \                     ??CrossCallReturnLabel_167:
   \   0001E6   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0001E9   EA           MOV     A,R2
   \   0001EA   FC           MOV     R4,A
   \   0001EB   7D00         MOV     R5,#0x0
   \   0001ED   7413         MOV     A,#0x13
   \   0001EF   12....       LCALL   ?XSTACK_DISP0_8
   \   0001F2   12....       LCALL   ?Subroutine51 & 0xFFFF
   \                     ??CrossCallReturnLabel_163:
   \   0001F5   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001F8   0E           INC     R6
   \                     ??zclProcessInWriteUndividedCmd_18:
   \   0001F9   8E..         MOV     ?V0 + 2,R6
   \   0001FB   C3           CLR     C
   \   0001FC   E5..         MOV     A,?V0 + 2
   \   0001FE   95..         SUBB    A,?V0 + 8
   \   000200   E4           CLR     A
   \   000201   9400         SUBB    A,#0x0
   \   000203   505B         JNC     ??zclProcessInWriteUndividedCmd_17
   \   000205   EE           MOV     A,R6
   \   000206   75F005       MOV     B,#0x5
   \   000209   A4           MUL     AB
   \   00020A   F8           MOV     R0,A
   \   00020B   A9F0         MOV     R1,B
   \   00020D   E5..         MOV     A,?V0 + 12
   \   00020F   28           ADD     A,R0
   \   000210   F5..         MOV     ?V0 + 2,A
   \   000212   E5..         MOV     A,?V0 + 13
   \   000214   39           ADDC    A,R1
   \   000215   F5..         MOV     ?V0 + 3,A
   \   000217   85..82       MOV     DPL,?V0 + 14
   \   00021A   85..83       MOV     DPH,?V0 + 15
   \   00021D   12....       LCALL   ?Subroutine82 & 0xFFFF
   \                     ??CrossCallReturnLabel_117:
   \   000220                ; Setup parameters for call to function zclFindAttrRec
   \   000220   740A         MOV     A,#0xa
   \   000222   12....       LCALL   ?XSTACK_DISP0_8
   \   000225   8582..       MOV     ?V0 + 6,DPL
   \   000228   8583..       MOV     ?V0 + 7,DPH
   \   00022B   78..         MOV     R0,#?V0 + 6
   \   00022D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000230   85..82       MOV     DPL,?V0 + 2
   \   000233   85..83       MOV     DPH,?V0 + 3
   \   000236   12....       LCALL   ??Subroutine133_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_190:
   \   000239   85..82       MOV     DPL,?V0 + 4
   \   00023C   85..83       MOV     DPH,?V0 + 5
   \   00023F   A3           INC     DPTR
   \   000240   A3           INC     DPTR
   \   000241   A3           INC     DPTR
   \   000242   A3           INC     DPTR
   \   000243   12....       LCALL   ??Subroutine137_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_212:
   \   000246   E5..         MOV     A,?V0 + 4
   \   000248   2414         ADD     A,#0x14
   \   00024A   F582         MOV     DPL,A
   \   00024C   E5..         MOV     A,?V0 + 5
   \   00024E   12....       LCALL   ??Subroutine150_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_296:
   \   000251   F9           MOV     R1,A
   \   000252   12....       LCALL   ??zclFindAttrRec?relay
   \   000255   7402         MOV     A,#0x2
   \   000257   12....       LCALL   ?DEALLOC_XSTACK8
   \   00025A   E9           MOV     A,R1
   \   00025B   6003         JZ      $+5
   \   00025D   02....       LJMP    ??zclProcessInWriteUndividedCmd_19 & 0xFFFF
   2995            
   2996              writeRspCmd->numAttr = j;
   \                     ??zclProcessInWriteUndividedCmd_17:
   \   000260   EF           MOV     A,R7
   \   000261   85..82       MOV     DPL,?V0 + 0
   \   000264   85..83       MOV     DPH,?V0 + 1
   \   000267   F0           MOVX    @DPTR,A
   2997              if ( writeRspCmd->numAttr  == 0 )
   \   000268   7003         JNZ     ??CrossCallReturnLabel_13
   2998              {
   2999                // Since all records were written successful, include a single status record in the resonse command
   3000                // with the status field set to SUCCESS and the attribute ID field omitted.
   3001                writeRspCmd->attrList[0].status = ZCL_STATUS_SUCCESS;
   \   00026A   12....       LCALL   ?Subroutine10 & 0xFFFF
   3002                writeRspCmd->numAttr = 1;
   3003              }
   3004          
   3005              osal_mem_free( curWriteRec );
   \                     ??CrossCallReturnLabel_13:
   \   00026D                ; Setup parameters for call to function osal_mem_free
   \   00026D   AA..         MOV     R2,?V0 + 12
   \   00026F   AB..         MOV     R3,?V0 + 13
   \   000271   12....       LCALL   ??osal_mem_free?relay
   3006            }
   3007            
   3008            zcl_SendWriteRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   3009                              pInMsg->msg->clusterId, writeRspCmd, ZCL_FRAME_SERVER_CLIENT_DIR, 
   3010                              true, pInMsg->hdr.transSeqNum );  
   \                     ??zclProcessInWriteUndividedCmd_11:
   \   000274   85..82       MOV     DPL,?V0 + 14
   \   000277   85..83       MOV     DPH,?V0 + 15
   \   00027A   12....       LCALL   ?Subroutine39 & 0xFFFF
   \                     ??CrossCallReturnLabel_50:
   \   00027D                ; Setup parameters for call to function zcl_SendWriteRsp
   \   00027D   85..82       MOV     DPL,?V0 + 14
   \   000280   85..83       MOV     DPH,?V0 + 15
   \   000283   A3           INC     DPTR
   \   000284   A3           INC     DPTR
   \   000285   A3           INC     DPTR
   \   000286   A3           INC     DPTR
   \   000287   A3           INC     DPTR
   \   000288   A3           INC     DPTR
   \   000289   E0           MOVX    A,@DPTR
   \   00028A   F5..         MOV     ?V0 + 2,A
   \   00028C   78..         MOV     R0,#?V0 + 2
   \   00028E   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000291   75..01       MOV     ?V0 + 2,#0x1
   \   000294   78..         MOV     R0,#?V0 + 2
   \   000296   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000299   78..         MOV     R0,#?V0 + 2
   \   00029B   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00029E   78..         MOV     R0,#?V0 + 0
   \   0002A0   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0002A3   12....       LCALL   ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_25:
   \   0002A6   12....       LCALL   ?DEALLOC_XSTACK8
   3011            osal_mem_free( writeRspCmd );
   \   0002A9                ; Setup parameters for call to function osal_mem_free
   \   0002A9   AA..         MOV     R2,?V0 + 0
   \   0002AB   AB..         MOV     R3,?V0 + 1
   \   0002AD   12....       LCALL   ??osal_mem_free?relay
   3012           
   3013            return TRUE; 
   \   0002B0   7901         MOV     R1,#0x1
   \                     ??zclProcessInWriteUndividedCmd_3:
   \   0002B2   02....       LJMP    ?Subroutine125 & 0xFFFF
   3014          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine72:
   \   000000   EE           MOV     A,R6
   \   000001   75F005       MOV     B,#0x5
   \   000004   A4           MUL     AB
   \   000005   F8           MOV     R0,A
   \   000006   A9F0         MOV     R1,B
   \   000008   E5..         MOV     A,?V0 + 6
   \   00000A   28           ADD     A,R0
   \   00000B   F582         MOV     DPL,A
   \   00000D   E5..         MOV     A,?V0 + 7
   \   00000F   39           ADDC    A,R1
   \   000010   F583         MOV     DPH,A
   \   000012   A3           INC     DPTR
   \   000013   8582..       MOV     ?V0 + 2,DPL
   \   000016   8583..       MOV     ?V0 + 3,DPH
   \   000019   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine30:
   \   000000   85..82       MOV     DPL,?V0 + 14
   \   000003   85..83       MOV     DPH,?V0 + 15
   \   000006                REQUIRE ??Subroutine151_0
   \   000006                ; // Fall through to label ??Subroutine151_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   A3           INC     DPTR
   \   000001   F0           MOVX    @DPTR,A
   \   000002   85..82       MOV     DPL,?V0 + 2
   \   000005   85..83       MOV     DPH,?V0 + 3
   \   000008   E0           MOVX    A,@DPTR
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine46:
   \   000000   12....       LCALL   ?Subroutine88 & 0xFFFF
   \                     ??CrossCallReturnLabel_127:
   \   000003   A3           INC     DPTR
   \   000004   22           RET
   3015          #endif // ZCL_WRITE
   3016          
   3017          #ifdef ZCL_DISCOVER
   3018          /*********************************************************************
   3019           * @fn      zclProcessInDiscCmd
   3020           * @brief   Process the "Profile" Discover Command
   3021           * @param   pInMsg - incoming message to process
   3022           * @return  TRUE if command processed. FALSE, otherwise.
   3023           */
   3024          static uint8 zclProcessInDiscCmd( zclIncoming_t *pInMsg )
   3025          {
   3026            zclDiscoverCmd_t *discoverCmd;
   3027            zclDiscoverRspCmd_t *discoverRspCmd;
   3028            uint8 discComplete = TRUE;
   3029            zclAttrRec_t attrRec;
   3030            uint16 attrID;
   3031            uint8 i;
   3032            
   3033            discoverCmd = (zclDiscoverCmd_t *)pInMsg->attrCmd;
   3034            
   3035            // Find out the number of attributes supported within the specified range
   3036            for ( i = 0, attrID = discoverCmd->startAttr; i < discoverCmd->maxAttrIDs; i++, attrID++ )
   3037            {
   3038              if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, &attrID, &attrRec ) )
   3039                break;
   3040            }
   3041            
   3042            // Allocate space for the response command
   3043            discoverRspCmd = (zclDiscoverRspCmd_t *)osal_mem_alloc( sizeof (zclDiscoverRspCmd_t) 
   3044                                                                   + sizeof ( zclDiscoverInfo_t ) * i );
   3045            if ( discoverRspCmd == NULL )
   3046              return FALSE; // EMEDDED RETURN
   3047            
   3048            discoverRspCmd->numAttr = i;
   3049            if ( discoverRspCmd->numAttr != 0 )
   3050            {
   3051              for ( i = 0, attrID = discoverCmd->startAttr; i < discoverRspCmd->numAttr; i++, attrID++ )
   3052              {
   3053                if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, &attrID, &attrRec ) )
   3054                  break; // Attribute not supported
   3055                
   3056                discoverRspCmd->attrList[i].attrID = attrRec.attr.attrId;
   3057                discoverRspCmd->attrList[i].dataType = attrRec.attr.dataType;
   3058              }
   3059              
   3060              // Are there more attributes to be discovered?
   3061              if ( zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, &attrID, &attrRec ) )
   3062                discComplete = FALSE;
   3063            }
   3064            
   3065            discoverRspCmd->discComplete = discComplete;
   3066            zcl_SendDiscoverRspCmd( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr, 
   3067                                    pInMsg->msg->clusterId, discoverRspCmd, ZCL_FRAME_SERVER_CLIENT_DIR, 
   3068                                    true, pInMsg->hdr.transSeqNum );
   3069            osal_mem_free( discoverRspCmd );
   3070            
   3071            return TRUE;
   3072          }
   3073          #endif // ZCL_DISCOVER
   3074          
   3075          /*********************************************************************
   3076           * @fn      zclSendMsg
   3077           * @brief   Send an incoming message to the Application
   3078           * @param   pInMsg - incoming message to process
   3079           * @return  TRUE
   3080           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3081          static uint8 zclSendMsg( zclIncoming_t *pInMsg )
   \                     zclSendMsg:
   3082          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   3083            zclIncomingMsg_t *pCmd;
   3084              
   3085            if ( zcl_RegisteredMsgTaskID == TASK_NO_TASK )
   \   000009   90....       MOV     DPTR,#zcl_RegisteredMsgTaskID
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   64FF         XRL     A,#0xff
   \   00000F   7005         JNZ     ??zclSendMsg_0
   3086              return ( TRUE );
   \                     ??zclSendMsg_1:
   \   000011   7901         MOV     R1,#0x1
   \   000013   02....       LJMP    ?Subroutine119 & 0xFFFF
   3087            
   3088            pCmd = (zclIncomingMsg_t *)osal_msg_allocate( sizeof ( zclIncomingMsg_t ) );
   \                     ??zclSendMsg_0:
   \   000016                ; Setup parameters for call to function osal_msg_allocate
   \   000016   7A18         MOV     R2,#0x18
   \   000018   7B00         MOV     R3,#0x0
   \   00001A   12....       LCALL   ??osal_msg_allocate?relay
   3089            if ( pCmd != NULL )
   \   00001D   EA           MOV     A,R2
   \   00001E   7001         JNZ     ??zclSendMsg_2
   \   000020   EB           MOV     A,R3
   \                     ??zclSendMsg_2:
   \   000021   60EE         JZ      ??zclSendMsg_1
   3090            {
   3091              // fill in the message
   3092              pCmd->hdr.event = ZCL_INCOMING_MSG;
   \   000023   7434         MOV     A,#0x34
   \   000025   12....       LCALL   ?Subroutine7 & 0xFFFF
   3093              pCmd->zclHdr    = pInMsg->hdr;
   \                     ??CrossCallReturnLabel_232:
   \   000028   A3           INC     DPTR
   \   000029   EA           MOV     A,R2
   \   00002A   2402         ADD     A,#0x2
   \   00002C   FC           MOV     R4,A
   \   00002D   EB           MOV     A,R3
   \   00002E   3400         ADDC    A,#0x0
   \   000030   FD           MOV     R5,A
   \   000031   7406         MOV     A,#0x6
   \   000033   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
   3094              pCmd->clusterId = pInMsg->msg->clusterId;
   \   000036   8E82         MOV     DPL,R6
   \   000038   8F83         MOV     DPH,R7
   \   00003A   12....       LCALL   ?Subroutine46 & 0xFFFF
   \                     ??CrossCallReturnLabel_62:
   \   00003D   A3           INC     DPTR
   \   00003E   12....       LCALL   ?Subroutine56 & 0xFFFF
   \                     ??CrossCallReturnLabel_78:
   \   000041   8A82         MOV     DPL,R2
   \   000043   8B83         MOV     DPH,R3
   \   000045   A3           INC     DPTR
   \   000046   A3           INC     DPTR
   \   000047   A3           INC     DPTR
   \   000048   A3           INC     DPTR
   \   000049   A3           INC     DPTR
   \   00004A   A3           INC     DPTR
   \   00004B   A3           INC     DPTR
   \   00004C   A3           INC     DPTR
   \   00004D   E8           MOV     A,R0
   \   00004E   12....       LCALL   ?Subroutine12 & 0xFFFF
   3095              pCmd->srcAddr   = pInMsg->msg->srcAddr;
   \                     ??CrossCallReturnLabel_18:
   \   000051   F8           MOV     R0,A
   \   000052   A3           INC     DPTR
   \   000053   E0           MOVX    A,@DPTR
   \   000054   F583         MOV     DPH,A
   \   000056   8882         MOV     DPL,R0
   \   000058   A3           INC     DPTR
   \   000059   A3           INC     DPTR
   \   00005A   A3           INC     DPTR
   \   00005B   A3           INC     DPTR
   \   00005C   A3           INC     DPTR
   \   00005D   A3           INC     DPTR
   \   00005E   EA           MOV     A,R2
   \   00005F   240A         ADD     A,#0xa
   \   000061   FC           MOV     R4,A
   \   000062   EB           MOV     A,R3
   \   000063   3400         ADDC    A,#0x0
   \   000065   FD           MOV     R5,A
   \   000066   740C         MOV     A,#0xc
   \   000068   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
   3096              pCmd->attrCmd   = pInMsg->attrCmd;
   \   00006B   EE           MOV     A,R6
   \   00006C   240C         ADD     A,#0xc
   \   00006E   F8           MOV     R0,A
   \   00006F   EF           MOV     A,R7
   \   000070   12....       LCALL   ?Subroutine105 & 0xFFFF
   \                     ??CrossCallReturnLabel_146:
   \   000073   12....       LCALL   ??Subroutine133_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_191:
   \   000076   EA           MOV     A,R2
   \   000077   2416         ADD     A,#0x16
   \   000079   F582         MOV     DPL,A
   \   00007B   EB           MOV     A,R3
   \   00007C   3400         ADDC    A,#0x0
   \   00007E   F583         MOV     DPH,A
   \   000080   EC           MOV     A,R4
   \   000081   F0           MOVX    @DPTR,A
   \   000082   A3           INC     DPTR
   \   000083   ED           MOV     A,R5
   \   000084   F0           MOVX    @DPTR,A
   3097              
   3098              // Application will free the attrCmd buffer
   3099              pInMsg->attrCmd = NULL;
   \   000085   8882         MOV     DPL,R0
   \   000087   8983         MOV     DPH,R1
   \   000089   E4           CLR     A
   \   00008A   F0           MOVX    @DPTR,A
   \   00008B   A3           INC     DPTR
   \   00008C   F0           MOVX    @DPTR,A
   3100              
   3101              /* send message through task message */
   3102              osal_msg_send( zcl_RegisteredMsgTaskID, (uint8 *)pCmd );
   \   00008D                ; Setup parameters for call to function osal_msg_send
   \   00008D   90....       MOV     DPTR,#zcl_RegisteredMsgTaskID
   \   000090   E0           MOVX    A,@DPTR
   \   000091   F9           MOV     R1,A
   \   000092   12....       LCALL   ??osal_msg_send?relay
   \   000095   02....       LJMP    ??zclSendMsg_1 & 0xFFFF
   3103            }
   3104            return ( TRUE );
   3105          }

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for zcl_RegisteredMsgTaskID>`:
   \   000000   FF           DB 255

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_Init?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_Init

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_event_loop?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_event_loop

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_registerPlugin?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerPlugin

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_registerAttrList?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerAttrList

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_registerClusterOptionList?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerClusterOptionList

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_registerValidateAttrData?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerValidateAttrData

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_registerForMsg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerForMsg

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_DeviceOperational?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_DeviceOperational

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendCommand?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendCommand

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendRead?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendRead

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendReadRsp?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendReadRsp

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendWriteRequest?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendWriteRequest

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendWriteRsp?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendWriteRsp

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendDefaultRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendDefaultRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclProcessMessageMSG?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclProcessMessageMSG

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseHdr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseHdr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclBuildHdr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclBuildHdr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclFindAttrRec?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclFindAttrRec

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclFindClusterOption?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclFindClusterOption

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclGetClusterOption?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetClusterOption

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclSetSecurityOption?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclSetSecurityOption

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclSerializeData?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclSerializeData

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclGetDataTypeLength?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetDataTypeLength

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclGetAttrDataLength?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetAttrDataLength

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclReadAttrData?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclReadAttrData

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclWriteAttrData?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclWriteAttrData

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInReadCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInReadCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInReadRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInReadRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInWriteCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInWriteCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInWriteRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInWriteRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInDefaultRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInDefaultRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclProcessInReadCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclProcessInReadCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclProcessInWriteCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclProcessInWriteCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclProcessInWriteUndividedCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclProcessInWriteUndividedCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclSendMsg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclSendMsg

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "3,">`:
   \   000000   332C00       DB "3,"

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant ",">`:
   \   000000   2C00         DB ","

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "$\\r\\n">`:
   \   000000   240D0A00     DB "$\015\012"
   3106          
   3107          /*********************************************************************
   3108          *********************************************************************/

   Maximum stack usage in bytes:

     Function                      ISTACK PSTACK XSTACK
     --------                      ------ ------ ------
     zclBuildHdr                       1      0     54
     zclFindAttrRec                    1      0     62
     zclFindClusterOption              1      0     21
     zclGetAttrDataLength              2      0     42
       -> zclGetDataTypeLength         4      0      0
     zclGetClusterOption               0      0     81
       -> zclFindClusterOption         0      0     20
     zclGetDataTypeLength              2      0      0
     zclParseHdr                       1      0     83
       -> osal_memset                  0      0     24
     zclParseInDefaultRspCmd           1      0     10
       -> osal_mem_alloc               0      0     20
     zclParseInReadCmd                 1      0     12
       -> osal_mem_alloc               0      0     24
     zclParseInReadRspCmd              1      0     23
       -> zclGetAttrDataLength         0      0     40
       -> osal_mem_alloc               0      0     40
       -> zclGetAttrDataLength         0      0     40
       -> osal_memcpy                  0      0     46
     zclParseInWriteCmd                1      0     23
       -> zclGetAttrDataLength         0      0     40
       -> osal_mem_alloc               0      0     40
       -> zclGetAttrDataLength         0      0     40
       -> osal_memcpy                  0      0     46
     zclParseInWriteRspCmd             1      0     16
       -> osal_mem_alloc               0      0     32
     zclProcessInReadCmd               1      0     35
       -> osal_mem_alloc               0      0     60
       -> zclFindAttrRec               0      0     64
       -> zcl_SendReadRsp              0      0     70
       -> osal_mem_free                0      0     60
     zclProcessInWriteCmd              1      0     39
       -> osal_mem_alloc               0      0     68
       -> zclFindAttrRec               0      0     72
       -> zclWriteAttrData             0      0     68
       -> zcl_SendWriteRsp             0      0     78
       -> osal_mem_free                0      0     68
     zclProcessInWriteUndividedCmd     1      0     47
       -> osal_mem_alloc               0      0     84
       -> zclGetAttrDataLength         0      0     84
       -> zclFindAttrRec               0      0     88
       -> osal_mem_alloc               0      0     84
       -> osal_mem_free                0      0     84
       -> zclGetAttrDataLength         0      0     84
       -> zclFindAttrRec               0      0     88
       -> zclReadAttrData              0      0     84
       -> zclWriteAttrData             0      0     84
       -> zclGetAttrDataLength         0      0     84
       -> osal_memcpy                  0      0     90
       -> zclFindAttrRec               0      0     88
       -> osal_mem_free                0      0     84
       -> zcl_SendWriteRsp             0      0     94
       -> osal_mem_free                0      0     84
     zclProcessMessageMSG              2      0     90
       -> HalUARTWrite                 0      0    142
       -> HalUARTWrite                 0      0    142
       -> HalUARTWrite                 0      0    142
       -> HalUARTWrite                 0      0    142
       -> HalUARTWrite                 0      0    142
       -> HalUARTWrite                 0      0    142
       -> zclParseHdr                  0      0    142
       -> afFindEndPointDesc           0      0    142
       -> zcl_DeviceOperational        0      0    146
       -> zclGetClusterOption          0      0    142
       -> zclSetSecurityOption         0      0    142
       -> zcl_SendDefaultRspCmd        0      0    156
       -> zclSetSecurityOption         0      0    142
       -> osal_mem_free                0      0    142
       -> zcl_SendDefaultRspCmd        0      0    156
     zclReadAttrData                   0      0     56
       -> zclGetAttrDataLength         0      0     22
       -> osal_memcpy                  0      0     28
     zclSendMsg                        1      0     10
       -> osal_msg_allocate            0      0     20
       -> osal_msg_send                0      0     20
     zclSerializeData                  1      0     44
       -> osal_buffer_uint32           0      0     32
       -> osal_memcpy                  0      0     30
       -> osal_memcpy                  0      0     30
       -> osal_memcpy                  0      0     30
       -> osal_memcpy                  0      0     30
     zclSetSecurityOption              0      0     81
       -> zclFindClusterOption         0      0     20
     zclWriteAttrData                  0      0     60
       -> zclGetAttrDataLength         0      0     30
       -> osal_memcpy                  0      0     36
     zcl_DeviceOperational             1      0     94
       -> zclFindAttrRec               0      0     42
       -> zclReadAttrData              0      0     38
     zcl_Init                          2      0      0
     zcl_SendCommand                   1      0     90
       -> osal_memcpy                  0      0     90
       -> afFindEndPointDesc           0      0     84
       -> zclGetClusterOption          0      0     84
       -> osal_memset                  0      0     84
       -> zcl_DeviceOperational        0      0     88
       -> osal_mem_alloc               0      0     84
       -> zclBuildHdr                  0      0     90
       -> osal_memcpy                  0      0     90
       -> AF_DataRequest               0      0    102
       -> osal_mem_free                0      0     84
     zcl_SendDefaultRspCmd             1      0    105
       -> zcl_SendCommand              0      0     54
     zcl_SendRead                      1      0     38
       -> osal_mem_alloc               0      0     44
       -> zcl_SendCommand              0      0     66
       -> osal_mem_free                0      0     44
     zcl_SendReadRsp                   1      0     74
       -> zclGetAttrDataLength         0      0     56
       -> osal_mem_alloc               0      0     56
       -> zclSerializeData             0      0     56
       -> zclGetAttrDataLength         0      0     56
       -> zcl_SendCommand              0      0     78
       -> osal_mem_free                0      0     56
     zcl_SendWriteRequest              1      0     45
       -> zclGetAttrDataLength         0      0     56
       -> osal_mem_alloc               0      0     56
       -> zclSerializeData             0      0     56
       -> zclGetAttrDataLength         0      0     56
       -> zcl_SendCommand              0      0     78
       -> osal_mem_free                0      0     56
     zcl_SendWriteRsp                  1      0     80
       -> osal_mem_alloc               0      0     44
       -> zcl_SendCommand              0      0     66
       -> osal_mem_free                0      0     44
     zcl_event_loop                    0      0     12
       -> osal_msg_receive             0      0     24
       -> zclProcessMessageMSG         0      0     24
       -> osal_msg_deallocate          0      0     24
       -> osal_msg_receive             0      0     24
       -> osal_msg_send                0      0     24
     zcl_registerAttrList              1      0     12
       -> osal_mem_alloc               0      0     24
     zcl_registerClusterOptionList     1      0     12
       -> osal_mem_alloc               0      0     24
     zcl_registerForMsg                2      0      0
     zcl_registerPlugin                0      0     16
       -> osal_mem_alloc               0      0     28
     zcl_registerValidateAttrData      2      0      0


   Segment part sizes:

     Function/Label                             Bytes
     --------------                             -----
     zcl_TaskID                                    1
     zcl_RegisteredMsgTaskID                       1
     zcl_ValidateAttrDataCB                        2
     zcl_SeqNum                                    1
     plugins                                       2
     attrList                                      2
     clusterOptionList                             2
     zcl_TransID                                   1
     zclCmdTable                                  56
     zcl_Init                                     31
     ?Subroutine109                                7
     zcl_event_loop                              102
     ?Subroutine110                                5
     zcl_registerPlugin                          127
     ?Subroutine111                                5
     ?Subroutine33                                 5
     ??Subroutine126_0                             5
     ?Subroutine11                                 8
     ?Subroutine14                                 4
     ?Subroutine100                                7
     ?Subroutine90                                 5
     ??Subroutine138_0                             5
     ?Subroutine103                                5
     ?Subroutine39                                 6
     ?Subroutine17                                 2
     ??Subroutine152_0                             6
     zcl_registerAttrList                         59
     ?Subroutine63                                25
     ?Subroutine0                                 28
     ?Subroutine81                                 6
     zcl_registerClusterOptionList                59
     zcl_registerValidateAttrData                 14
     zcl_registerForMsg                           20
     zcl_DeviceOperational                       118
     ?Subroutine119                                5
     zcl_SendCommand                             514
     ?Subroutine125                                4
     ??Subroutine127_0                             8
     ?Subroutine40                                10
     ?Subroutine113                                6
     ?Subroutine91                                 6
     ?Subroutine82                                 8
     zcl_SendRead                                218
     ?Subroutine121                                2
     ??Subroutine128_0                             5
     ?Subroutine28                                 5
     ??Subroutine129_0                            11
     ?Subroutine116                                5
     ?Subroutine96                                 6
     ?Subroutine64                                11
     ?Subroutine57                                 6
     ?Subroutine41                                10
     ?Subroutine120                                4
     zcl_SendReadRsp                             251
     ?Subroutine89                                 7
     ?Subroutine74                                 4
     ?Subroutine97                                 7
     ?Subroutine65                                21
     ?Subroutine58                                10
     ?Subroutine44                                16
     ?Subroutine87                                 5
     ?Subroutine102                               11
     ?Subroutine42                                10
     ?Subroutine37                                13
     ?Subroutine36                                 9
     ?Subroutine20                                28
     ?Subroutine115                                5
     ?Subroutine83                                19
     ?Subroutine2                                 21
     ?Subroutine1                                 25
     ??Subroutine133_0                             5
     ?Subroutine85                                 3
     ?Subroutine107                               12
     zcl_SendWriteRequest                        222
     zcl_SendWriteRsp                            250
     zcl_SendDefaultRspCmd                       171
     ?Subroutine56                                 4
     zclProcessMessageMSG                       1321
     ?Subroutine122                                5
     ?Subroutine77                                15
     ?Subroutine76                                19
     ?Subroutine75                                11
     ?Subroutine69                                 7
     ?Subroutine95                                 5
     ?Subroutine59                                 7
     ?Subroutine53                                11
     ?Subroutine52                                11
     ?Subroutine49                                12
     ?Subroutine45                                 5
     ?Subroutine31                                 7
     ?Subroutine92                                 8
     ?Subroutine27                                15
     ?Subroutine26                                13
     ?Subroutine105                                8
     ?Subroutine78                                 8
     ?Subroutine25                                 3
     ??Subroutine131_0                             2
     ??Subroutine132_0                             2
     ?Subroutine34                                 3
     ??Subroutine134_0                             5
     ?Subroutine60                                 6
     ??Subroutine137_0                             4
     ??Subroutine146_0                             1
     ??Subroutine147_0                             5
     ?Subroutine48                                12
     ?Subroutine93                                 4
     ?Subroutine104                                9
     ?Subroutine106                               10
     ??Subroutine150_0                             6
     ?Subroutine43                                 4
     ?Subroutine84                                11
     ?Subroutine88                                 6
     zclParseHdr                                 223
     ?Subroutine118                                5
     ?Subroutine9                                  4
     ?Subroutine79                                 5
     ??Subroutine141_0                             4
     ?Subroutine80                                 9
     ?Subroutine108                                8
     ?Subroutine5                                  6
     ??Subroutine142_0                             5
     ??Subroutine144_0                             7
     ?Subroutine101                                4
     ?Subroutine12                                 8
     zclBuildHdr                                 102
     ?Subroutine54                                11
     ?Subroutine16                                 7
     ??Subroutine130_0                             7
     ?Subroutine8                                  6
     ?Subroutine117                                5
     zclFindAttrRec                              186
     zclFindClusterOption                        123
     ?Subroutine123                                5
     zclGetClusterOption                          32
     zclSetSecurityOption                         46
     zclSerializeData                            289
     ?Subroutine15                                 5
     ?Subroutine50                                 4
     ??Subroutine145_0                             4
     zclGetDataTypeLength                        131
     zclGetAttrDataLength                         29
     zclReadAttrData                              75
     ?Subroutine29                                 2
     ??Subroutine135_0                             2
     ??Subroutine136_0                             5
     zclWriteAttrData                            122
     ?Subroutine114                                6
     ??Subroutine148_0                             4
     ?Subroutine51                                 6
     ?Subroutine35                                 6
     zclParseInReadCmd                            99
     ?Subroutine32                                25
     ?Subroutine62                                10
     zclParseInReadRspCmd                        126
     ?Subroutine124                                9
     ?Subroutine61                                22
     ??Subroutine139_0                             4
     ?Subroutine21                                 7
     ??Subroutine140_0                            22
     ?Subroutine6                                  8
     ?Subroutine73                                14
     ?Subroutine71                                 5
     ?Subroutine112                                6
     ?Subroutine68                                16
     ?Subroutine67                                26
     ?Subroutine38                                24
     ?Subroutine23                                32
     ?Subroutine4                                 23
     ?Subroutine3                                 34
     ?Subroutine99                                 4
     ?Subroutine98                                15
     ?Subroutine94                                 9
     zclParseInWriteCmd                          103
     zclParseInWriteRspCmd                       123
     ?Subroutine70                                 4
     zclParseInDefaultRspCmd                      44
     ?Subroutine7                                  4
     zclProcessInReadCmd                         320
     ?Subroutine86                                 6
     ??Subroutine143_0                             8
     ?Subroutine55                                 1
     ??Subroutine149_0                            34
     ?Subroutine66                                 6
     ?Subroutine13                                 7
     zclProcessInWriteCmd                        350
     ?Subroutine47                                 6
     ??Subroutine151_0                             6
     ?Subroutine24                                19
     ?Subroutine22                                38
     ?Subroutine10                                13
     ?Subroutine19                                 6
     zclProcessInWriteUndividedCmd               693
     ?Subroutine72                                26
     ?Subroutine30                                 6
     ?Subroutine18                                10
     ?Subroutine46                                 5
     zclSendMsg                                  152
     ?<Initializer for zcl_RegisteredMsgTaskID>    1
     ??zcl_Init?relay                              6
     ??zcl_event_loop?relay                        6
     ??zcl_registerPlugin?relay                    6
     ??zcl_registerAttrList?relay                  6
     ??zcl_registerClusterOptionList?relay         6
     ??zcl_registerValidateAttrData?relay          6
     ??zcl_registerForMsg?relay                    6
     ??zcl_DeviceOperational?relay                 6
     ??zcl_SendCommand?relay                       6
     ??zcl_SendRead?relay                          6
     ??zcl_SendReadRsp?relay                       6
     ??zcl_SendWriteRequest?relay                  6
     ??zcl_SendWriteRsp?relay                      6
     ??zcl_SendDefaultRspCmd?relay                 6
     ??zclProcessMessageMSG?relay                  6
     ??zclParseHdr?relay                           6
     ??zclBuildHdr?relay                           6
     ??zclFindAttrRec?relay                        6
     ??zclFindClusterOption?relay                  6
     ??zclGetClusterOption?relay                   6
     ??zclSetSecurityOption?relay                  6
     ??zclSerializeData?relay                      6
     ??zclGetDataTypeLength?relay                  6
     ??zclGetAttrDataLength?relay                  6
     ??zclReadAttrData?relay                       6
     ??zclWriteAttrData?relay                      6
     ??zclParseInReadCmd?relay                     6
     ??zclParseInReadRspCmd?relay                  6
     ??zclParseInWriteCmd?relay                    6
     ??zclParseInWriteRspCmd?relay                 6
     ??zclParseInDefaultRspCmd?relay               6
     ??zclProcessInReadCmd?relay                   6
     ??zclProcessInWriteCmd?relay                  6
     ??zclProcessInWriteUndividedCmd?relay         6
     ??zclSendMsg?relay                            6
     ?<Constant "3,">                              3
     ?<Constant ",">                               2
     ?<Constant "$\r\n">                           4

 
 8 256 bytes in segment BANKED_CODE
   210 bytes in segment BANK_RELAYS
    56 bytes in segment CODE_C
     1 byte  in segment XDATA_I
     1 byte  in segment XDATA_ID
     9 bytes in segment XDATA_ROM_C
    11 bytes in segment XDATA_Z
 
 8 523 bytes of CODE  memory
     9 bytes of CONST memory
    12 bytes of XDATA memory

Errors: none
Warnings: 1
