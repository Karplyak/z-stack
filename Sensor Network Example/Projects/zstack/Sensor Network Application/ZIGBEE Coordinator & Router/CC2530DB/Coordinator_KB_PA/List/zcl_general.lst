###############################################################################
#                                                                             #
# IAR C/C++ Compiler V7.51A/W32 for 8051                02/Sep/2013  22:55:42 #
# Copyright 2004-2009 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  D:\GitHub\z-stack\Sensor Network                   #
#                          Example\Components\stack\zcl\zcl_general.c         #
#    Command line       =  -f "D:\GitHub\z-stack\Sensor Network               #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\..\..\..\Tools\CC2530DB\f8wCoord.c #
#                          fg" (-DCPU32MHZ -DROOT=__near_func                 #
#                          -DMAC_CFG_APP_PENDING_QUEUE=TRUE                   #
#                          -DZDO_COORDINATOR -DRTR_NWK -DBLINK_LEDS) -f       #
#                          "D:\GitHub\z-stack\Sensor Network                  #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig. #
#                          cfg" (-DSECURE=0 -DZG_SECURE_DYNAMIC=0             #
#                          -DREFLECTOR -DDEFAULT_CHANLIST=0x00000800          #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116 "-DCONST=const __code"    #
#                          -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=TRUE      #
#                          -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100            #
#                          -DRESPONSE_POLL_RATE=100 -DREJOIN_POLL_RATE=440)   #
#                          -f "D:\GitHub\z-stack\Sensor Network               #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\..\..\..\Tools\CC2530DB\f8wZCL.cfg #
#                          " (-DZCL_READ -DZCL_WRITE -DZCL_BASIC              #
#                          -DZCL_IDENTIFY -DZCL_ON_OFF -DZCL_KEY_ESTABLISH    #
#                          -DZCL_LOAD_CONTROL -DZCL_SIMPLE_METERING           #
#                          -DZCL_PRICING) -DZCL_MESSAGE                       #
#                          "D:\GitHub\z-stack\Sensor Network                  #
#                          Example\Components\stack\zcl\zcl_general.c" -D     #
#                          CC2530 -D ZTOOL_P1 -D MT_TASK -D MT_APP_FUNC -D    #
#                          MT_SYS_FUNC -D MT_ZDO_FUNC -D LCD_SUPPORTED=DEBUG  #
#                          -D Coor_receiver -D xHAL_KEYPAD -D xPA2591 -lC     #
#                          "D:\GitHub\z-stack\Sensor Network                  #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\Coordinator_KB_PA\List\" -lA       #
#                          "D:\GitHub\z-stack\Sensor Network                  #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\Coordinator_KB_PA\List\"           #
#                          --diag_suppress Pe001,Pa010 -o                     #
#                          "D:\GitHub\z-stack\Sensor Network                  #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\Coordinator_KB_PA\Obj\" -e         #
#                          --require_prototypes --debug --core=plain          #
#                          --dptr=16,1 --data_model=large                     #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data_rom                  #
#                          --nr_virtual_regs 16 -I "D:\GitHub\z-stack\Sensor  #
#                          Network Example\Projects\zstack\Sensor Network     #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\" -I "D:\GitHub\z-stack\Sensor     #
#                          Network Example\Projects\zstack\Sensor Network     #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\..\SOURCE\" -I                     #
#                          "D:\GitHub\z-stack\Sensor Network                  #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\..\..\SOURCE\" -I                  #
#                          "D:\GitHub\z-stack\Sensor Network                  #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\..\..\..\ZMAIN\TI2530DB\" -I       #
#                          "D:\GitHub\z-stack\Sensor Network                  #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\..\..\..\..\..\COMPONENTS\MT\" -I  #
#                          "D:\GitHub\z-stack\Sensor Network                  #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\INCL #
#                          UDE\" -I "D:\GitHub\z-stack\Sensor Network         #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\TARG #
#                          ET\CC2530KB\" -I "D:\GitHub\z-stack\Sensor         #
#                          Network Example\Projects\zstack\Sensor Network     #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\..\..\..\..\..\COMPONENTS\OSAL\MCU #
#                          \CCSOC\" -I "D:\GitHub\z-stack\Sensor Network      #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\..\..\..\..\..\COMPONENTS\OSAL\INC #
#                          LUDE\" -I "D:\GitHub\z-stack\Sensor Network        #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\AF #
#                          \" -I "D:\GitHub\z-stack\Sensor Network            #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\NW #
#                          K\" -I "D:\GitHub\z-stack\Sensor Network           #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SE #
#                          C\" -I "D:\GitHub\z-stack\Sensor Network           #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SA #
#                          PI\" -I "D:\GitHub\z-stack\Sensor Network          #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SY #
#                          S\" -I "D:\GitHub\z-stack\Sensor Network           #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\ZC #
#                          L\" -I "D:\GitHub\z-stack\Sensor Network           #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\ZD #
#                          O\" -I "D:\GitHub\z-stack\Sensor Network           #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\..\..\..\..\..\COMPONENTS\ZMAC\F8W #
#                          \" -I "D:\GitHub\z-stack\Sensor Network            #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\..\..\..\..\..\COMPONENTS\ZMAC\"   #
#                          -I "D:\GitHub\z-stack\Sensor Network               #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\..\..\..\..\..\COMPONENTS\SERVICES #
#                          \SADDR\" -I "D:\GitHub\z-stack\Sensor Network      #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\..\..\..\..\..\COMPONENTS\SERVICES #
#                          \SDATA\" -I "D:\GitHub\z-stack\Sensor Network      #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\INCL #
#                          UDE\" -I "D:\GitHub\z-stack\Sensor Network         #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\HIGH #
#                          _LEVEL\" -I "D:\GitHub\z-stack\Sensor Network      #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\LOW_ #
#                          LEVEL\srf04\" -I "D:\GitHub\z-stack\Sensor         #
#                          Network Example\Projects\zstack\Sensor Network     #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\LOW_ #
#                          LEVEL\srf04\SINGLE_CHIP\" -I "C:\Program Files     #
#                          (x86)\IAR Systems\Embedded Workbench               #
#                          5.3\8051\INC\" -I "C:\Program Files (x86)\IAR      #
#                          Systems\Embedded Workbench 5.3\8051\INC\CLIB\"     #
#                          -Ohz                                               #
#    List file          =  D:\GitHub\z-stack\Sensor Network                   #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\Coordinator_KB_PA\List\zcl_general #
#                          .lst                                               #
#    Object file        =  D:\GitHub\z-stack\Sensor Network                   #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Coordinator &                   #
#                          Router\CC2530DB\Coordinator_KB_PA\Obj\zcl_general. #
#                          r51                                                #
#                                                                             #
#                                                                             #
###############################################################################

D:\GitHub\z-stack\Sensor Network Example\Components\stack\zcl\zcl_general.c
      1          /**************************************************************************************************
      2            Filename:       zcl_general.c
      3            Revised:        $Date: 2009-10-26 15:51:02 -0700 (Mon, 26 Oct 2009) $
      4            Revision:       $Revision: 20979 $
      5          
      6            Description:    Zigbee Cluster Library - General.  This application receives all
      7                            ZCL messages and initially parses them before passing to application.
      8          
      9          
     10            Copyright 2006-2008 Texas Instruments Incorporated. All rights reserved.
     11          
     12            Should you have any questions regarding your right to use this Software,
     13            contact Texas Instruments Incorporated at www.TI.com.
     14          **************************************************************************************************/
     15          
     16          /*********************************************************************
     17           * INCLUDES
     18           */
     19          #include "ZComDef.h"
     20          #include "OSAL.h"
     21          #include "OSAL_Nv.h"
     22          #include "zcl.h"
     23          #include "zcl_general.h"
     24          #include "ZDApp.h"
     25          
     26          #if defined ( INTER_PAN )
     27            #include "stub_aps.h"
     28          #endif
     29          
     30          /*********************************************************************
     31           * MACROS
     32           */
     33          #define locationTypeAbsolute( a )          ( (a) & LOCATION_TYPE_ABSOLUTE )
     34          #define locationType2D( a )                ( (a) & LOCATION_TYPE_2_D )
     35          #define locationTypeCoordinateSystem( a )  ( (a) & LOCATION_TYPE_COORDINATE_SYSTEM )
     36          
     37          #ifdef ZCL_SCENES
     38          #define zclGeneral_ScenesRemaingCapacity() ( ZCL_GEN_MAX_SCENES - zclGeneral_CountAllScenes() )
     39          #endif // ZCL_SCENES
     40          
     41          /*********************************************************************
     42           * CONSTANTS
     43           */
     44          
     45          /*********************************************************************
     46           * TYPEDEFS
     47           */
     48          typedef struct zclGenCBRec
     49          {
     50            struct zclGenCBRec        *next;
     51            uint8                     endpoint; // Used to link it into the endpoint descriptor
     52            zclGeneral_AppCallbacks_t *CBs;     // Pointer to Callback function
     53          } zclGenCBRec_t;
     54          
     55          typedef struct zclGenSceneItem
     56          {
     57            struct zclGenSceneItem    *next;
     58            uint8                     endpoint; // Used to link it into the endpoint descriptor
     59            zclGeneral_Scene_t        scene;    // Scene info
     60          } zclGenSceneItem_t;
     61          
     62          typedef struct zclGenAlarmItem
     63          {
     64            struct zclGenAlarmItem    *next;
     65            uint8                     endpoint; // Used to link it into the endpoint descriptor
     66            zclGeneral_Alarm_t        alarm;    // Alarm info
     67          } zclGenAlarmItem_t;
     68          
     69          // Scene NV types
     70          typedef struct
     71          {
     72            uint16                    numRecs;
     73          } nvGenScenesHdr_t;
     74          
     75          typedef struct zclGenSceneNVItem
     76          {
     77            uint8                     endpoint;
     78            zclGeneral_Scene_t        scene;
     79          } zclGenSceneNVItem_t;
     80          
     81          /*********************************************************************
     82           * GLOBAL VARIABLES
     83           */
     84          
     85          /*********************************************************************
     86           * GLOBAL FUNCTIONS
     87           */
     88          
     89          /*********************************************************************
     90           * LOCAL VARIABLES
     91           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     92          static zclGenCBRec_t *zclGenCBs = (zclGenCBRec_t *)NULL;
   \                     zclGenCBs:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     93          static uint8 zclGenPluginRegisted = FALSE;
   \                     zclGenPluginRegisted:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
     94          #ifdef ZCL_SCENES
     95          static zclGenSceneItem_t *zclGenSceneTable = (zclGenSceneItem_t *)NULL;
     96          #endif // ZCL_SCENES
     97          #ifdef ZCL_ALARMS
     98          static zclGenAlarmItem_t *zclGenAlarmTable = (zclGenAlarmItem_t *)NULL;
     99          #endif // ZCL_ALARMS
    100          
    101          /*********************************************************************
    102           * LOCAL FUNCTIONS
    103           */
    104          static ZStatus_t zclGeneral_HdlIncoming( zclIncoming_t *pInMsg );
    105          static ZStatus_t zclGeneral_HdlInSpecificCommands( zclIncoming_t *pInMsg );
    106          static zclGeneral_AppCallbacks_t *zclGeneral_FindCallbacks( uint8 endpoint );
    107          
    108          // Device Configuration and Installation clusters
    109          #ifdef ZCL_BASIC
    110          static ZStatus_t zclGeneral_ProcessInBasic( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    111          #endif // ZCL_BASIC
    112          
    113          #ifdef ZCL_IDENTIFY
    114          static ZStatus_t zclGeneral_ProcessInIdentity( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    115          #endif // ZCL_IDENTIFY
    116          
    117          // Groups and Scenes clusters
    118          #ifdef ZCL_GROUPS
    119          static ZStatus_t zclGeneral_ProcessInGroupsServer( zclIncoming_t *pInMsg );
    120          static ZStatus_t zclGeneral_ProcessInGroupsClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    121          static ZStatus_t zclGeneral_AddGroup( uint8 endPoint, aps_Group_t *group, uint8 *pData );
    122          #endif // ZCL_GROUPS
    123          
    124          #ifdef ZCL_SCENES
    125          static ZStatus_t zclGeneral_ProcessInScenesServer( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    126          static ZStatus_t zclGeneral_ProcessInScenesClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    127          #endif // ZCL_SCENES
    128          
    129          // On/Off and Level Control Configuration clusters
    130          #ifdef ZCL_ON_OFF
    131          static ZStatus_t zclGeneral_ProcessInOnOff( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    132          #endif // ZCL_ONOFF
    133          
    134          #ifdef ZCL_LEVEL_CTRL
    135          static ZStatus_t zclGeneral_ProcessInLevelControl( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    136          #endif // ZCL_LEVEL_CTRL
    137          
    138          // Alarms cluster
    139          #ifdef ZCL_ALARMS
    140          static ZStatus_t zclGeneral_ProcessInAlarmsServer( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    141          static ZStatus_t zclGeneral_ProcessInAlarmsClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    142          #endif // ZCL_ALARMS
    143          
    144          // Location cluster
    145          #ifdef ZCL_LOCATION
    146          static ZStatus_t zclGeneral_ProcessInLocationServer( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    147          static ZStatus_t zclGeneral_ProcessInLocationClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    148          #endif // ZCL_LOCATION
    149          
    150          #ifdef ZCL_SCENES
    151          static uint8 zclGeneral_ScenesInitNV( void );
    152          static void zclGeneral_ScenesSetDefaultNV( void );
    153          static void zclGeneral_ScenesWriteNV( void );
    154          static uint16 zclGeneral_ScenesRestoreFromNV( void );
    155          #endif // ZCL_SCENES
    156          
    157          /*********************************************************************
    158           * @fn      zclGeneral_RegisterCmdCallbacks
    159           *
    160           * @brief   Register an applications command callbacks
    161           *
    162           * @param   endpoint - application's endpoint
    163           * @param   callbacks - pointer to the callback record.
    164           *
    165           * @return  ZMemError if not able to allocate
    166           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    167          ZStatus_t zclGeneral_RegisterCmdCallbacks( uint8 endpoint, zclGeneral_AppCallbacks_t *callbacks )
   \                     zclGeneral_RegisterCmdCallbacks:
    168          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 0,R1
   \   000007   EA           MOV     A,R2
   \   000008   FE           MOV     R6,A
   \   000009   EB           MOV     A,R3
   \   00000A   FF           MOV     R7,A
    169            zclGenCBRec_t *pNewItem;
    170            zclGenCBRec_t *pLoop;
    171          
    172            // Register as a ZCL Plugin
    173            if ( zclGenPluginRegisted == FALSE )
   \   00000B   90....       MOV     DPTR,#zclGenPluginRegisted
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   7021         JNZ     ??zclGeneral_RegisterCmdCallbacks_0
    174            {
    175              zcl_registerPlugin( ZCL_CLUSTER_ID_GEN_BASIC,
    176                                  ZCL_CLUSTER_ID_GEN_LOCATION,
    177                                  zclGeneral_HdlIncoming );
   \   000011                ; Setup parameters for call to function zcl_registerPlugin
   \   000011   75....       MOV     ?V0 + 2,#(??zclGeneral_HdlIncoming?relay & 0xff)
   \   000014   75....       MOV     ?V0 + 3,#((??zclGeneral_HdlIncoming?relay >> 8) & 0xff)
   \   000017   78..         MOV     R0,#?V0 + 2
   \   000019   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00001C   7C0B         MOV     R4,#0xb
   \   00001E   7D00         MOV     R5,#0x0
   \   000020   7A00         MOV     R2,#0x0
   \   000022   7B00         MOV     R3,#0x0
   \   000024   12....       LCALL   ??zcl_registerPlugin?relay
   \   000027   7402         MOV     A,#0x2
   \   000029   12....       LCALL   ?DEALLOC_XSTACK8
    178          
    179          #ifdef ZCL_SCENES
    180              // Initialize NV items
    181              zclGeneral_ScenesInitNV();
    182          
    183              // Restore the Scene table
    184              zclGeneral_ScenesRestoreFromNV();
    185          #endif // ZCL_SCENES
    186          
    187              zclGenPluginRegisted = TRUE;
   \   00002C   7401         MOV     A,#0x1
   \   00002E   90....       MOV     DPTR,#zclGenPluginRegisted
   \   000031   F0           MOVX    @DPTR,A
    188            }
    189          
    190            // Fill in the new profile list
    191            pNewItem = osal_mem_alloc( sizeof( zclGenCBRec_t ) );
   \                     ??zclGeneral_RegisterCmdCallbacks_0:
   \   000032                ; Setup parameters for call to function osal_mem_alloc
   \   000032   7A05         MOV     R2,#0x5
   \   000034   7B00         MOV     R3,#0x0
   \   000036   12....       LCALL   ??osal_mem_alloc?relay
   \   000039   8A..         MOV     ?V0 + 2,R2
   \   00003B   8B..         MOV     ?V0 + 3,R3
   \   00003D   A8..         MOV     R0,?V0 + 2
   \   00003F   A9..         MOV     R1,?V0 + 3
    192            if ( pNewItem == NULL )
   \   000041   E8           MOV     A,R0
   \   000042   7001         JNZ     ??zclGeneral_RegisterCmdCallbacks_1
   \   000044   E9           MOV     A,R1
   \                     ??zclGeneral_RegisterCmdCallbacks_1:
   \   000045   7004         JNZ     ??zclGeneral_RegisterCmdCallbacks_2
    193              return (ZMemError);
   \   000047   7910         MOV     R1,#0x10
   \   000049   804E         SJMP    ??zclGeneral_RegisterCmdCallbacks_3
    194          
    195            pNewItem->next = (zclGenCBRec_t *)NULL;
   \                     ??zclGeneral_RegisterCmdCallbacks_2:
   \   00004B   8882         MOV     DPL,R0
   \   00004D   8983         MOV     DPH,R1
   \   00004F   E4           CLR     A
   \   000050   F0           MOVX    @DPTR,A
   \   000051   A3           INC     DPTR
   \   000052   F0           MOVX    @DPTR,A
    196            pNewItem->endpoint = endpoint;
   \   000053   8882         MOV     DPL,R0
   \   000055   8983         MOV     DPH,R1
   \   000057   A3           INC     DPTR
   \   000058   A3           INC     DPTR
   \   000059   E5..         MOV     A,?V0 + 0
   \   00005B   F0           MOVX    @DPTR,A
    197            pNewItem->CBs = callbacks;
   \   00005C   8882         MOV     DPL,R0
   \   00005E   8983         MOV     DPH,R1
   \   000060   A3           INC     DPTR
   \   000061   A3           INC     DPTR
   \   000062   A3           INC     DPTR
   \   000063   EE           MOV     A,R6
   \   000064   F0           MOVX    @DPTR,A
   \   000065   A3           INC     DPTR
   \   000066   EF           MOV     A,R7
   \   000067   F0           MOVX    @DPTR,A
    198          
    199            // Find spot in list
    200            if (  zclGenCBs == NULL )
   \   000068   90....       MOV     DPTR,#zclGenCBs
   \   00006B   E0           MOVX    A,@DPTR
   \   00006C   7002         JNZ     ??zclGeneral_RegisterCmdCallbacks_4
   \   00006E   A3           INC     DPTR
   \   00006F   E0           MOVX    A,@DPTR
   \                     ??zclGeneral_RegisterCmdCallbacks_4:
   \   000070   90....       MOV     DPTR,#zclGenCBs
   \   000073   601D         JZ      ??zclGeneral_RegisterCmdCallbacks_5
    201            {
    202              zclGenCBs = pNewItem;
    203            }
    204            else
    205            {
    206              // Look for end of list
    207              pLoop = zclGenCBs;
   \   000075   E0           MOVX    A,@DPTR
   \   000076   FC           MOV     R4,A
   \   000077   A3           INC     DPTR
   \   000078   E0           MOVX    A,@DPTR
   \   000079   8003         SJMP    ??zclGeneral_RegisterCmdCallbacks_6
    208              while ( pLoop->next != NULL )
    209                pLoop = pLoop->next;
   \                     ??zclGeneral_RegisterCmdCallbacks_7:
   \   00007B   EA           MOV     A,R2
   \   00007C   FC           MOV     R4,A
   \   00007D   EB           MOV     A,R3
   \                     ??zclGeneral_RegisterCmdCallbacks_6:
   \   00007E   FD           MOV     R5,A
   \   00007F   8C82         MOV     DPL,R4
   \   000081   8D83         MOV     DPH,R5
   \   000083   E0           MOVX    A,@DPTR
   \   000084   FA           MOV     R2,A
   \   000085   A3           INC     DPTR
   \   000086   E0           MOVX    A,@DPTR
   \   000087   FB           MOV     R3,A
   \   000088   EA           MOV     A,R2
   \   000089   7001         JNZ     ??zclGeneral_RegisterCmdCallbacks_8
   \   00008B   EB           MOV     A,R3
   \                     ??zclGeneral_RegisterCmdCallbacks_8:
   \   00008C   70ED         JNZ     ??zclGeneral_RegisterCmdCallbacks_7
    210          
    211              // Put new item at end of list
    212              pLoop->next = pNewItem;
   \   00008E   8C82         MOV     DPL,R4
   \   000090   8D83         MOV     DPH,R5
   \                     ??zclGeneral_RegisterCmdCallbacks_5:
   \   000092   E8           MOV     A,R0
   \   000093   F0           MOVX    @DPTR,A
   \   000094   A3           INC     DPTR
   \   000095   E9           MOV     A,R1
   \   000096   F0           MOVX    @DPTR,A
    213            }
    214          
    215            return ( ZSuccess );
   \   000097   7900         MOV     R1,#0x0
   \                     ??zclGeneral_RegisterCmdCallbacks_3:
   \   000099                REQUIRE ?Subroutine9
   \   000099                ; // Fall through to label ?Subroutine9
    216          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   7F04         MOV     R7,#0x4
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    217          
    218          #ifdef ZCL_IDENTIFY
    219          /*********************************************************************
    220           * @fn      zclGeneral_SendIdentify
    221           *
    222           * @brief   Call to send out an Identify Command
    223           *
    224           * @param   srcEP - Sending application's endpoint
    225           * @param   dstAddr - where you want the message to go
    226           * @param   identifyTime - how long the device will continue to identify itself (in seconds)
    227           * @param   seqNum - identification number for the transaction
    228           *
    229           * @return  ZStatus_t
    230           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    231          ZStatus_t zclGeneral_SendIdentify( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zclGeneral_SendIdentify:
    232                                uint16 identifyTime, uint8 disableDefaultRsp, uint8 seqNum )
    233          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   740C         MOV     A,#0xc
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   FE           MOV     R6,A
   \   000011   740D         MOV     A,#0xd
   \   000013   12....       LCALL   ?XSTACK_DISP0_8
   \   000016   12....       LCALL   ?Subroutine1 & 0xFFFF
    234            uint8 buf[2];
    235          
    236            buf[0] = LO_UINT16( identifyTime );
    237            buf[1] = HI_UINT16( identifyTime );
   \                     ??CrossCallReturnLabel_2:
   \   000019   12....       LCALL   ?XSTACK_DISP0_8
   \   00001C   12....       LCALL   ?Subroutine0 & 0xFFFF
    238          
    239            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_IDENTIFY,
    240                                    COMMAND_IDENTIFY, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    241                                    disableDefaultRsp, 0, seqNum, 2, buf );
   \                     ??CrossCallReturnLabel_0:
   \   00001F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000022   75..02       MOV     ?V0 + 0,#0x2
   \   000025   75..00       MOV     ?V0 + 1,#0x0
   \   000028   78..         MOV     R0,#?V0 + 0
   \   00002A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00002D   EF           MOV     A,R7
   \   00002E   F5..         MOV     ?V0 + 0,A
   \   000030   78..         MOV     R0,#?V0 + 0
   \   000032   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000035   75..00       MOV     ?V0 + 0,#0x0
   \   000038   78..         MOV     R0,#?V0 + 0
   \   00003A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003D   EE           MOV     A,R6
   \   00003E   F5..         MOV     ?V0 + 0,A
   \   000040   78..         MOV     R0,#?V0 + 0
   \   000042   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000045   75..00       MOV     ?V0 + 0,#0x0
   \   000048   78..         MOV     R0,#?V0 + 0
   \   00004A   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00004D   75..01       MOV     ?V0 + 0,#0x1
   \   000050                REQUIRE ?Subroutine10
   \   000050                ; // Fall through to label ?Subroutine10

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   78..         MOV     R0,#?V0 + 0
   \   000002   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000005   75..00       MOV     ?V0 + 0,#0x0
   \   000008   78..         MOV     R0,#?V0 + 0
   \   00000A   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00000D   7C03         MOV     R4,#0x3
   \   00000F   7D00         MOV     R5,#0x0
   \   000011   12....       LCALL   ??zcl_SendCommand?relay
   \   000014   740B         MOV     A,#0xb
   \   000016   12....       LCALL   ?DEALLOC_XSTACK8
   \   000019   7402         MOV     A,#0x2
   \   00001B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00001E                REQUIRE ??Subroutine11_0
   \   00001E                ; // Fall through to label ??Subroutine11_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine11_0:
   \   000000   7F02         MOV     R7,#0x2
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FF           MOV     R7,A
   \   000002   EC           MOV     A,R4
   \   000003   85..82       MOV     DPL,?XSP + 0
   \   000006   85..83       MOV     DPH,?XSP + 1
   \   000009   F0           MOVX    @DPTR,A
   \   00000A   7401         MOV     A,#0x1
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   ED           MOV     A,R5
   \   000001   F0           MOVX    @DPTR,A
   \   000002                ; Setup parameters for call to function zcl_SendCommand
   \   000002                ; Setup parameters for call to function zcl_SendCommand
   \   000002   85..82       MOV     DPL,?XSP + 0
   \   000005   85..83       MOV     DPH,?XSP + 1
   \   000008   8582..       MOV     ?V0 + 0,DPL
   \   00000B   8583..       MOV     ?V0 + 1,DPH
   \   00000E   78..         MOV     R0,#?V0 + 0
   \   000010   22           RET
    242          }
    243          
    244          /*********************************************************************
    245           * @fn      zclGeneral_SendIdentifyQueryResponse
    246           *
    247           * @brief   Call to send out an Identify Query Response Command
    248           *
    249           * @param   srcEP - Sending application's endpoint
    250           * @param   dstAddr - where you want the message to go
    251           * @param   timeout - how long the device will continue to identify itself (in seconds)
    252           * @param   seqNum - identification number for the transaction
    253           *
    254           * @return  ZStatus_t
    255           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    256          ZStatus_t zclGeneral_SendIdentifyQueryResponse( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zclGeneral_SendIdentifyQueryResponse:
    257                                      uint16 timeout, uint8 disableDefaultRsp, uint8 seqNum )
    258          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   740C         MOV     A,#0xc
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   FE           MOV     R6,A
   \   000011   740D         MOV     A,#0xd
   \   000013   12....       LCALL   ?XSTACK_DISP0_8
   \   000016   12....       LCALL   ?Subroutine1 & 0xFFFF
    259            uint8 buf[2];
    260          
    261            buf[0] = LO_UINT16( timeout );
    262            buf[1] = HI_UINT16( timeout );
   \                     ??CrossCallReturnLabel_3:
   \   000019   12....       LCALL   ?XSTACK_DISP0_8
   \   00001C   12....       LCALL   ?Subroutine0 & 0xFFFF
    263          
    264            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_IDENTIFY,
    265                                    COMMAND_IDENTIFY_QUERY_RSP, TRUE,
    266                                    ZCL_FRAME_SERVER_CLIENT_DIR, disableDefaultRsp, 0, seqNum, 2, buf );
   \                     ??CrossCallReturnLabel_1:
   \   00001F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000022   75..02       MOV     ?V0 + 0,#0x2
   \   000025   75..00       MOV     ?V0 + 1,#0x0
   \   000028   78..         MOV     R0,#?V0 + 0
   \   00002A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00002D   EF           MOV     A,R7
   \   00002E   F5..         MOV     ?V0 + 0,A
   \   000030   78..         MOV     R0,#?V0 + 0
   \   000032   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000035   75..00       MOV     ?V0 + 0,#0x0
   \   000038   78..         MOV     R0,#?V0 + 0
   \   00003A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003D   EE           MOV     A,R6
   \   00003E   F5..         MOV     ?V0 + 0,A
   \   000040   78..         MOV     R0,#?V0 + 0
   \   000042   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000045   75..01       MOV     ?V0 + 0,#0x1
   \   000048   78..         MOV     R0,#?V0 + 0
   \   00004A   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00004D   80..         SJMP    ?Subroutine10
    267          }
    268          #endif // ZCL_IDENTIFY
    269          
    270          #ifdef ZCL_GROUPS
    271          /*********************************************************************
    272           * @fn      zclGeneral_SendGroupRequest
    273           *
    274           * @brief   Send a Group Request to a device.  You can also use the
    275           *          appropriate macro.
    276           *
    277           * @param   srcEP - Sending Apps endpoint
    278           * @param   dstAddr - where to send the request
    279           * @param   cmd - one of the following:
    280           *              COMMAND_GROUP_VIEW
    281           *              COMMAND_GROUP_REMOVE
    282           * @param   groupID -
    283           *
    284           * @return  ZStatus_t
    285           */
    286          ZStatus_t zclGeneral_SendGroupRequest( uint8 srcEP, afAddrType_t *dstAddr,
    287                               uint8 cmd, uint16 groupID, uint8 disableDefaultRsp, uint8 seqNum )
    288          {
    289            uint8 buf[2];
    290          
    291            buf[0] = LO_UINT16( groupID );
    292            buf[1] = HI_UINT16( groupID );
    293          
    294            return ( zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
    295                                      cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    296                                      disableDefaultRsp, 0, seqNum, 2, buf ) );
    297          }
    298          
    299          /*********************************************************************
    300           * @fn      zclGeneral_SendAddGroupRequest
    301           *
    302           * @brief   Send the Add Group Request to a device
    303           *
    304           * @param   srcEP - Sending Apps endpoint
    305           * @param   dstAddr - where to send the request
    306           * @param   cmd - one of the following:
    307           *                COMMAND_GROUP_ADD
    308           *                COMMAND_GROUP_ADD_IF_IDENTIFYING
    309           * @param   groupID - pointer to the group structure
    310           * @param   groupName - pointer to Group Name.  This is a Zigbee
    311           *          string data type, so the first byte is the length of the
    312           *          name (in bytes), then the name.
    313           *
    314           * @return  ZStatus_t
    315           */
    316          ZStatus_t zclGeneral_SendAddGroupRequest( uint8 srcEP, afAddrType_t *dstAddr,
    317                                                    uint8 cmd, uint16 groupID, uint8 *groupName,
    318                                                    uint8 disableDefaultRsp, uint8 seqNum )
    319          {
    320            uint8 *buf;
    321            uint8 *pBuf;
    322            uint8 len;
    323            ZStatus_t status;
    324          
    325            len = 2;    // Group ID
    326            len += groupName[0] + 1;  // String + 1 for length
    327          
    328            buf = osal_mem_alloc( len );
    329            if ( buf )
    330            {
    331              pBuf = buf;
    332              *pBuf++ = LO_UINT16( groupID );
    333              *pBuf++ = HI_UINT16( groupID );
    334              *pBuf++ = groupName[0]; // string length
    335              osal_memcpy( pBuf, &(groupName[1]), groupName[0] );
    336          
    337              status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
    338                                        cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    339                                        disableDefaultRsp, 0, seqNum, len, buf );
    340              osal_mem_free( buf );
    341            }
    342            else
    343              status = ZMemError;
    344          
    345            return ( status );
    346          }
    347          
    348          /*********************************************************************
    349           * @fn      zclGeneral_SendGroupGetMembershipRequest
    350           *
    351           * @brief   Send a Get Group Membership (Resposne) Command to a device
    352           *
    353           * @param   srcEP - Sending Apps endpoint
    354           * @param   dstAddr - where to send the request
    355           * @param   cmd - one of the following:
    356           *                COMMAND_GROUP_GET_MEMBERSHIP
    357           *                COMMAND_GROUP_GET_MEMBERSHIP_RSP
    358           * @param   groupID - pointer to the group structure
    359           * @param   groupName - pointer to Group Name.  This is a Zigbee
    360           *          string data type, so the first byte is the length of the
    361           *          name (in bytes), then the name.
    362           *
    363           * @return  ZStatus_t
    364           */
    365          ZStatus_t zclGeneral_SendGroupGetMembershipRequest( uint8 srcEP, afAddrType_t *dstAddr,
    366                                        uint8 cmd, uint8 rspCmd, uint8 direction, uint8 capacity,
    367                                        uint8 grpCnt, uint16 *grpList, uint8 disableDefaultRsp, uint8 seqNum )
    368          {
    369            uint8 *buf;
    370            uint8 *pBuf;
    371            uint8 len = 0;
    372            uint8 i;
    373            ZStatus_t status;
    374          
    375            if ( rspCmd )
    376              len++;  // Capacity
    377          
    378            len++;  // Group Count
    379            len += sizeof ( uint16 ) * grpCnt;  // Group List
    380          
    381            buf = osal_mem_alloc( len );
    382            if ( buf )
    383            {
    384              pBuf = buf;
    385              if ( rspCmd )
    386                *pBuf++ = capacity;
    387          
    388              *pBuf++ = grpCnt;
    389              for ( i = 0; i < grpCnt; i++ )
    390              {
    391                *pBuf++ = LO_UINT16( grpList[i] );
    392                *pBuf++ = HI_UINT16( grpList[i] );
    393              }
    394          
    395              status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
    396                                        cmd, TRUE, direction,
    397                                        disableDefaultRsp, 0, seqNum, len, buf );
    398              osal_mem_free( buf );
    399            }
    400            else
    401              status = ZMemError;
    402          
    403            return ( status );
    404          }
    405          
    406          /*********************************************************************
    407           * @fn      zclGeneral_SendGroupResponse
    408           *
    409           * @brief   Send Group Response (not Group View Response)
    410           *
    411           * @param   srcEP - Sending application's endpoint
    412           * @param   dstAddr - where you want the message to go
    413           * @param   cmd - either COMMAND_GROUP_ADD_RSP or COMMAND_GROUP_REMOVE_RSP
    414           * @param   status - group command status
    415           * @param   groupID - what group
    416           *
    417           * @return  ZStatus_t
    418           */
    419          ZStatus_t zclGeneral_SendGroupResponse( uint8 srcEP, afAddrType_t *dstAddr,
    420                                                  uint8 cmd, uint8 status, uint16 groupID,
    421                                                  uint8 disableDefaultRsp, uint8 seqNum )
    422          {
    423            uint8 buf[3];
    424          
    425            buf[0] = status;
    426            buf[1] = LO_UINT16( groupID );
    427            buf[2] = HI_UINT16( groupID );
    428          
    429            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
    430                                    cmd, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
    431                                    disableDefaultRsp, 0, seqNum, 3, buf );
    432          }
    433          
    434          /*********************************************************************
    435           * @fn      zclGeneral_SendGroupViewResponse
    436           *
    437           * @brief   Call to send Group Response Command
    438           *
    439           * @param   srcEP - Sending application's endpoint
    440           * @param   dstAddr - where you want the message to go
    441           * @param   cmd - either COMMAND_GROUP_ADD_RSP or COMMAND_GROUP_REMOVE_RSP
    442           * @param   status - group command status
    443           * @param   grp - group info
    444           *
    445           * @return  ZStatus_t
    446           */
    447          ZStatus_t zclGeneral_SendGroupViewResponse( uint8 srcEP, afAddrType_t *dstAddr,
    448                           uint8 status, aps_Group_t *grp, uint8 disableDefaultRsp, uint8 seqNum )
    449          {
    450            uint8 *buf;
    451            uint8 len;
    452            ZStatus_t stat;
    453          
    454            len = 1 + 2; // Status + Group ID
    455          
    456            if ( status == ZCL_STATUS_SUCCESS )
    457              len += grp->name[0] + 1;  // String + 1 for length
    458          
    459            buf = osal_mem_alloc( len );
    460            if ( buf )
    461            {
    462              buf[0] = status;
    463              buf[1] = LO_UINT16( grp->ID );
    464              buf[2] = HI_UINT16( grp->ID );
    465          
    466              if ( status == ZCL_STATUS_SUCCESS )
    467              {
    468                buf[3] = grp->name[0]; // string length
    469                osal_memcpy( &buf[4], (&grp->name[1]), grp->name[0] );
    470              }
    471          
    472              stat = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
    473                                      COMMAND_GROUP_VIEW_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
    474                                      disableDefaultRsp, 0, seqNum, len, buf );
    475              osal_mem_free( buf );
    476            }
    477            else
    478              stat = ZMemError;
    479          
    480            return ( stat );
    481          }
    482          #endif // ZCL_GROUPS
    483          
    484          #ifdef ZCL_SCENES
    485          /*********************************************************************
    486           * @fn      zclGeneral_SendAddScene
    487           *
    488           * @brief   Send the Add Scene Request to a device
    489           *
    490           * @param   srcEP - Sending Apps endpoint
    491           * @param   dstAddr - where to send the request
    492           * @param   scene - pointer to the scene structure
    493           *
    494           * @return  ZStatus_t
    495           */
    496          ZStatus_t zclGeneral_SendAddScene( uint8 srcEP, afAddrType_t *dstAddr,
    497                                zclGeneral_Scene_t *scene, uint8 disableDefaultRsp, uint8 seqNum )
    498          {
    499            uint8 *buf;
    500            uint8 *pBuf;
    501            uint8 len;
    502            ZStatus_t status;
    503          
    504            len = 2 + 1 + 2;    // Group ID + Scene ID + transition time
    505            len += scene->name[0] + 1; // String + 1 for length
    506          
    507            // Add something for the extension field length
    508            len += scene->extLen;
    509          
    510            buf = osal_mem_alloc( len );
    511            if ( buf )
    512            {
    513              pBuf = buf;
    514              *pBuf++ = LO_UINT16( scene->groupID );
    515              *pBuf++ = HI_UINT16( scene->groupID );
    516              *pBuf++ = scene->ID;
    517              *pBuf++ = LO_UINT16( scene->transTime );
    518              *pBuf++ = HI_UINT16( scene->transTime );
    519              *pBuf++ = scene->name[0]; // string length
    520              osal_memcpy( pBuf, &(scene->name[1]), scene->name[0] );
    521              pBuf += scene->name[0]; // move pass name
    522          
    523              // Add the extension fields
    524              if ( scene->extLen > 0 )
    525                osal_memcpy( pBuf, scene->extField, scene->extLen );
    526          
    527              status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    528                                        COMMAND_SCENE_ADD, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    529                                        disableDefaultRsp, 0, seqNum, len, buf );
    530              osal_mem_free( buf );
    531            }
    532            else
    533              status = ZMemError;
    534          
    535            return ( status );
    536          }
    537          
    538          /*********************************************************************
    539           * @fn      zclGeneral_SendSceneRequest
    540           *
    541           * @brief   Send a Scene Request to a device.  You can also use the
    542           *          appropriate macro.
    543           *
    544           * @param   srcEP - Sending Apps endpoint
    545           * @param   dstAddr - where to send the request
    546           * @param   cmd - one of the following:
    547           *              COMMAND_SCENE_VIEW
    548           *              COMMAND_SCENE_REMOVE
    549           *              COMMAND_SCENE_REMOVE_ALL
    550           *              COMMAND_SCENE_STORE
    551           *              COMMAND_SCENE_RECALL
    552           *              COMMAND_SCENE_GET_MEMBERSHIP
    553           * @param   groupID - group ID
    554           * @param   sceneID - scene ID (not applicable to COMMAND_SCENE_REMOVE_ALL and
    555           *                    COMMAND_SCENE_GET_MEMBERSHIP)
    556           * @return  ZStatus_t
    557           */
    558          ZStatus_t zclGeneral_SendSceneRequest( uint8 srcEP, afAddrType_t *dstAddr,
    559                                                 uint8 cmd, uint16 groupID, uint8 sceneID,
    560                                                 uint8 disableDefaultRsp, uint8 seqNum )
    561          {
    562            uint8 buf[3];
    563            uint8 len = 2;
    564          
    565            buf[0] = LO_UINT16( groupID );
    566            buf[1] = HI_UINT16( groupID );
    567          
    568            if ( cmd != COMMAND_SCENE_REMOVE_ALL && cmd != COMMAND_SCENE_GET_MEMBERSHIP )
    569            {
    570              buf[2] = sceneID;
    571              len++;
    572            }
    573          
    574            return ( zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    575                                      cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    576                                      disableDefaultRsp, 0, seqNum, len, buf ) );
    577          }
    578          
    579          /*********************************************************************
    580           * @fn      zclGeneral_SendSceneResponse
    581           *
    582           * @brief   Send Group Response (not Group View Response)
    583           *
    584           * @param   srcEP - Sending application's endpoint
    585           * @param   dstAddr - where you want the message to go
    586           * @param   cmd - either COMMAND_SCENE_ADD_RSP, COMMAND_SCENE_REMOVE_RSP
    587           *                COMMAND_SCENE_STORE_RSP, or COMMAND_SCENE_REMOVE_ALL_RSP
    588           * @param   status - scene command status
    589           * @param   groupID - what group
    590           * @param   sceneID - what scene (not applicable to COMMAND_SCENE_REMOVE_ALL_RSP)
    591           *
    592           * @return  ZStatus_t
    593           */
    594          ZStatus_t zclGeneral_SendSceneResponse( uint8 srcEP, afAddrType_t *dstAddr,
    595                                            uint8 cmd, uint8 status, uint16 groupID,
    596                                            uint8 sceneID, uint8 disableDefaultRsp, uint8 seqNum )
    597          {
    598            uint8 buf[4];
    599            uint8 len = 1 + 2; // Status + Group ID
    600          
    601            buf[0] = status;
    602            buf[1] = LO_UINT16( groupID );
    603            buf[2] = HI_UINT16( groupID );
    604          
    605            if ( cmd != COMMAND_SCENE_REMOVE_ALL_RSP )
    606            {
    607              buf[3] = sceneID;
    608              len++;
    609            }
    610          
    611            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    612                                    cmd, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
    613                                    disableDefaultRsp, 0, seqNum, len, buf );
    614          }
    615          
    616          /*********************************************************************
    617           * @fn      zclGeneral_SendSceneViewResponse
    618           *
    619           * @brief   Call to send Scene Response Command
    620           *
    621           * @param   srcEP - Sending application's endpoint
    622           * @param   dstAddr - where you want the message to go
    623           * @param   status - scene command status
    624           * @param   scene - scene info
    625           *
    626           * @return  ZStatus_t
    627           */
    628          ZStatus_t zclGeneral_SendSceneViewResponse( uint8 srcEP, afAddrType_t *dstAddr,
    629                                                 uint8 status, zclGeneral_Scene_t *scene,
    630                                                 uint8 disableDefaultRsp, uint8 seqNum )
    631          {
    632            uint8 *buf;
    633            uint8 *pBuf;
    634            uint8 len = 1 + 2 + 1; // Status + Group ID + Scene ID
    635            ZStatus_t stat;
    636          
    637            if ( status == ZCL_STATUS_SUCCESS )
    638            {
    639              len += 2; // Transition Time
    640              len += scene->name[0] + 1; // string + 1 for length
    641          
    642              // Add something for the extension field length
    643              len += scene->extLen;
    644            }
    645          
    646            buf = osal_mem_alloc( len );
    647            if ( buf )
    648            {
    649              pBuf = buf;
    650              *pBuf++ = status;
    651              *pBuf++ = LO_UINT16( scene->groupID );
    652              *pBuf++ = HI_UINT16( scene->groupID );
    653              *pBuf++ = scene->ID;
    654              if ( status == ZCL_STATUS_SUCCESS )
    655              {
    656                *pBuf++ = LO_UINT16( scene->transTime );
    657                *pBuf++ = HI_UINT16( scene->transTime );
    658                *pBuf++ = scene->name[0]; // string length
    659                if ( scene->name[0] != 0 )
    660                {
    661                  osal_memcpy( pBuf, &(scene->name[1]), scene->name[0] );
    662                  pBuf += scene->name[0]; // move pass name
    663                }
    664          
    665                // Add the extension fields
    666                if ( scene->extLen > 0 )
    667                  osal_memcpy( pBuf, scene->extField, scene->extLen );
    668              }
    669          
    670              stat = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    671                                      COMMAND_SCENE_VIEW_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
    672                                      disableDefaultRsp, 0, seqNum, len, buf );
    673              osal_mem_free( buf );
    674            }
    675            else
    676              stat = ZMemError;
    677          
    678            return ( stat );
    679          }
    680          
    681          /*********************************************************************
    682           * @fn      zclGeneral_SendSceneGetMembershipResponse
    683           *
    684           * @brief   Call to send Scene Get Membership Response Command
    685           *
    686           * @param   srcEP - Sending application's endpoint
    687           * @param   dstAddr - where you want the message to go
    688           * @param   status - scene command status
    689           * @param   capacity - remaining capacity of the scene table
    690           * @param   sceneCnt - number of scenes in the scene list
    691           * @param   sceneList - list of scene IDs
    692           * @param   groupID - group ID that scene belongs to
    693           * @param   seqNum - sequence number
    694           *
    695           * @return  ZStatus_t
    696           */
    697          ZStatus_t zclGeneral_SendSceneGetMembershipResponse( uint8 srcEP, afAddrType_t *dstAddr,
    698                                 uint8 status, uint8 capacity, uint8 sceneCnt, uint8 *sceneList,
    699                                 uint16 groupID, uint8 disableDefaultRsp, uint8 seqNum )
    700          {
    701            uint8 *buf;
    702            uint8 *pBuf;
    703            uint8 len = 1 + 1 + 2; // Status + Capacity + Group ID;
    704            uint8 i;
    705            ZStatus_t stat;
    706          
    707            if ( status == ZCL_STATUS_SUCCESS )
    708            {
    709              len++; // Scene Count
    710              len += sceneCnt; // Scene List (Scene ID is a single octet)
    711            }
    712          
    713            buf = osal_mem_alloc( len );
    714            if ( buf )
    715            {
    716              pBuf = buf;
    717              *pBuf++ = status;
    718              *pBuf++ = capacity;
    719              *pBuf++ = LO_UINT16( groupID );
    720              *pBuf++ = HI_UINT16( groupID );
    721              if ( status == ZCL_STATUS_SUCCESS )
    722              {
    723                *pBuf++ = sceneCnt;
    724                for ( i = 0; i < sceneCnt; i++ )
    725                  *pBuf++ = sceneList[i];
    726              }
    727          
    728              stat = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    729                                      COMMAND_SCENE_GET_MEMBERSHIP_RSP, TRUE,
    730                                      ZCL_FRAME_SERVER_CLIENT_DIR, disableDefaultRsp, 0, seqNum, len, buf );
    731              osal_mem_free( buf );
    732            }
    733            else
    734              stat = ZMemError;
    735          
    736            return ( stat );
    737          }
    738          #endif // ZCL_SCENES
    739          
    740          #ifdef ZCL_LEVEL_CTRL
    741          /*********************************************************************
    742           * @fn      zclGeneral_SendLevelControlMoveToLevelRequest
    743           *
    744           * @brief   Call to send out a Level Control Request. You can also use
    745           *          the appropriate macro.
    746           *
    747           * @param   srcEP - Sending application's endpoint
    748           * @param   dstAddr - where you want the message to go
    749           * @param   cmd - one of the following:
    750           *              COMMAND_LEVEL_MOVE_TO_LEVEL or
    751           *              COMMAND_LEVEL_MOVE_TO_LEVEL_WITH_ON_OFF
    752           * @param   level - what level to move to
    753           * @param   transitionTime - how long to take to get to the level (in seconds)
    754           *
    755           * @return  ZStatus_t
    756           */
    757          ZStatus_t zclGeneral_SendLevelControlMoveToLevelRequest( uint8 srcEP, afAddrType_t *dstAddr,
    758                                                                   uint8 cmd, uint8 level, uint16 transTime,
    759                                                                   uint8 disableDefaultRsp, uint8 seqNum )
    760          {
    761            uint8 buf[3];
    762          
    763            buf[0] = level;
    764            buf[1] = LO_UINT16( transTime );
    765            buf[2] = HI_UINT16( transTime );
    766          
    767            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL,
    768                                    cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    769                                    disableDefaultRsp, 0, seqNum, 3, buf );
    770          }
    771          
    772          /*********************************************************************
    773           * @fn      zclGeneral_SendLevelControlMoveRequest
    774           *
    775           * @brief   Call to send out a Level Control Request. You can also use
    776           *          the appropriate macro.
    777           *
    778           * @param   srcEP - Sending application's endpoint
    779           * @param   dstAddr - where you want the message to go
    780           * @param   cmd - one of the following:
    781           *              COMMAND_LEVEL_MOVE or
    782           *              COMMAND_LEVEL_MOVE_WITH_ON_OFF
    783           * @param   moveMode - LEVEL_MOVE_UP or
    784           *                     LEVEL_MOVE_DOWN
    785           * @param   rate - number of steps to take per second
    786           *
    787           * @return  ZStatus_t
    788           */
    789          ZStatus_t zclGeneral_SendLevelControlMoveRequest( uint8 srcEP, afAddrType_t *dstAddr,
    790                                                            uint8 cmd, uint8 moveMode, uint8 rate,
    791                                                            uint8 disableDefaultRsp, uint8 seqNum )
    792          {
    793            uint8 buf[2];
    794          
    795            buf[0] = moveMode;
    796            buf[1] = rate;
    797          
    798            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL,
    799                                    cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    800                                    disableDefaultRsp, 0, seqNum, 2, buf );
    801          }
    802          
    803          /*********************************************************************
    804           * @fn      zclGeneral_SendLevelControlStepRequest
    805           *
    806           * @brief   Call to send out a Level Control Request. You can also use
    807           *          the appropriate macro.
    808           *
    809           * @param   srcEP - Sending application's endpoint
    810           * @param   dstAddr - where you want the message to go
    811           * @param   cmd - one of the following:
    812           *              COMMAND_LEVEL_STEP
    813           *              COMMAND_LEVEL_STEP_WITH_ON_OFF
    814           * @param   stepMode - LEVEL_STEP_UP or
    815           *                     LEVEL_STEP_DOWN
    816           * @param   amount - number of levels to step
    817           * @param   transitionTime - time, in 1/10ths of a second, to take to perform the step
    818           *
    819           * @return  ZStatus_t
    820           */
    821          ZStatus_t zclGeneral_SendLevelControlStepRequest( uint8 srcEP, afAddrType_t *dstAddr,
    822                                   uint8 cmd, uint8 stepMode, uint8 stepSize, uint16 transTime,
    823                                   uint8 disableDefaultRsp, uint8 seqNum )
    824          {
    825            uint8 buf[4];
    826          
    827            buf[0] = stepMode;
    828            buf[1] = stepSize;
    829            buf[2] = LO_UINT16( transTime );
    830            buf[3] = HI_UINT16( transTime );
    831          
    832            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL,
    833                                    cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    834                                    disableDefaultRsp, 0, seqNum, 4, buf );
    835          }
    836          #endif // ZCL_LEVEL_CTRL
    837          
    838          #ifdef ZCL_ALARMS
    839          /*********************************************************************
    840           * @fn      zclGeneral_SendAlarmRequest
    841           *
    842           * @brief   Call to send out an Alarm Request Command
    843           *
    844           * @param   srcEP - Sending application's endpoint
    845           * @param   dstAddr - where you want the message to go
    846           * @param   cmd - either COMMAND_ALARMS_RESET or COMMAND_ALARMS_ALARM
    847           * @param   alarmCode - code for the cause of the alarm
    848           * @param   clusterID - cluster whose attribute generate the alarm
    849           *
    850           * @return  ZStatus_t
    851           */
    852          ZStatus_t zclGeneral_SendAlarmRequest( uint8 srcEP, afAddrType_t *dstAddr,
    853                                                 uint8 cmd, uint8 alarmCode, uint16 clusterID,
    854                                                 uint8 disableDefaultRsp, uint8 seqNum )
    855          {
    856            uint8 buf[3];
    857          
    858            buf[0] = alarmCode;
    859            buf[1] = LO_UINT16( clusterID );
    860            buf[2] = HI_UINT16( clusterID );
    861          
    862            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ALARMS,
    863                                    cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    864                                    disableDefaultRsp, 0, seqNum, 3, buf );
    865          }
    866          
    867          /*********************************************************************
    868           * @fn      zclGeneral_SendAlarmGetRespnose
    869           *
    870           * @brief   Call to send out an Alarm Get Response Command
    871           *
    872           * @param   srcEP - Sending application's endpoint
    873           * @param   dstAddr - where you want the message to go
    874           * @param   status - SUCCESS or NOT_FOUND
    875           * @param   alarmCode - code for the cause of the alarm
    876           * @param   clusterID - cluster whose attribute generate the alarm
    877           * @param   timeStamp - time at which the alarm occured
    878           *
    879           * @return  ZStatus_t
    880           */
    881          ZStatus_t zclGeneral_SendAlarmGetRespnose( uint8 srcEP, afAddrType_t *dstAddr,
    882                                        uint8 status, uint8 alarmCode, uint16 clusterID,
    883                                        uint32 timeStamp, uint8 disableDefaultRsp, uint8 seqNum )
    884          {
    885            uint8 buf[8];
    886            uint8 len = 1; // Status
    887          
    888            buf[0] = status;
    889            if ( status == ZCL_STATUS_SUCCESS )
    890            {
    891              len += 1 + 2 + 4; // Alarm code + Cluster ID + Time stamp
    892              buf[1] = alarmCode;
    893              buf[2] = LO_UINT16( clusterID );
    894              buf[3] = HI_UINT16( clusterID );
    895              osal_buffer_uint32( &buf[4], timeStamp );
    896            }
    897          
    898            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ALARMS,
    899                                    COMMAND_ALARMS_GET_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
    900                                    disableDefaultRsp, 0, seqNum, len, buf );
    901          }
    902          #endif // ZCL_ALARMS
    903          
    904          #ifdef ZCL_LOCATION
    905          /*********************************************************************
    906           * @fn      zclGeneral_SendLocationSetAbsolute
    907           *
    908           * @brief   Call to send out a Set Absolute Location Command
    909           *
    910           * @param   srcEP - Sending application's endpoint
    911           * @param   dstAddr - where you want the message to go
    912           * @param   absLoc - absolute location info
    913           *
    914           * @return  ZStatus_t
    915           */
    916          ZStatus_t zclGeneral_SendLocationSetAbsolute( uint8 srcEP, afAddrType_t *dstAddr,
    917                                                        zclLocationAbsolute_t *absLoc,
    918                                                        uint8 disableDefaultRsp, uint8 seqNum )
    919          {
    920             uint8 buf[10]; // 5 fields (2 octects each)
    921          
    922             buf[0] = LO_UINT16( absLoc->coordinate1 );
    923             buf[1] = HI_UINT16( absLoc->coordinate1 );
    924             buf[2] = LO_UINT16( absLoc->coordinate2 );
    925             buf[3] = HI_UINT16( absLoc->coordinate2 );
    926             buf[4] = LO_UINT16( absLoc->coordinate3 );
    927             buf[5] = HI_UINT16( absLoc->coordinate3 );
    928             buf[6] = LO_UINT16( absLoc->power );
    929             buf[7] = HI_UINT16( absLoc->power );
    930             buf[8] = LO_UINT16( absLoc->pathLossExponent );
    931             buf[9] = HI_UINT16( absLoc->pathLossExponent );
    932          
    933             return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
    934                                     COMMAND_LOCATION_SET_ABSOLUTE, TRUE,
    935                                     ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, 10, buf );
    936          }
    937          
    938          ZStatus_t zclGeneral_SendLocationSetDevCfg( uint8 srcEP, afAddrType_t *dstAddr,
    939                                                      zclLocationDevCfg_t *devCfg,
    940                                                      uint8 disableDefaultRsp, uint8 seqNum )
    941          {
    942             uint8 buf[9];  // 4 fields (2 octects each) + 1 field with 1 octect
    943          
    944             buf[0] = LO_UINT16( devCfg->power );
    945             buf[1] = HI_UINT16( devCfg->power );
    946             buf[2] = LO_UINT16( devCfg->pathLossExponent );
    947             buf[3] = HI_UINT16( devCfg->pathLossExponent );
    948             buf[4] = LO_UINT16( devCfg->calcPeriod );
    949             buf[5] = HI_UINT16( devCfg->calcPeriod );
    950             buf[6] = devCfg->numMeasurements;
    951             buf[7] = LO_UINT16( devCfg->reportPeriod );
    952             buf[8] = HI_UINT16( devCfg->reportPeriod );
    953          
    954             return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
    955                                     COMMAND_LOCATION_SET_DEV_CFG, TRUE,
    956                                     ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, 9, buf );
    957          }
    958          
    959          ZStatus_t zclGeneral_SendLocationGetDevCfg( uint8 srcEP, afAddrType_t *dstAddr,
    960                                 uint8 *targetAddr, uint8 disableDefaultRsp, uint8 seqNum )
    961          {
    962            uint8 buf[8];
    963          
    964            osal_cpyExtAddr( buf, targetAddr );
    965          
    966            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
    967                                    COMMAND_LOCATION_GET_DEV_CFG, TRUE,
    968                                    ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, 8, buf );
    969          }
    970          
    971          ZStatus_t zclGeneral_SendLocationGetData( uint8 srcEP, afAddrType_t *dstAddr,
    972                                                    zclLocationGetData_t *locData,
    973                                                    uint8 disableDefaultRsp, uint8 seqNum )
    974          {
    975            uint8 buf[10]; // bitmap (1) + number responses (1) + IEEE Address (8)
    976            uint8 *pBuf = buf;
    977            uint8 len = 2; // bitmap + number responses
    978          
    979            *pBuf  = locData->absoluteOnly;
    980            *pBuf |= locData->recalculate << 1;
    981            *pBuf |= locData->brdcastIndicator << 2;
    982            *pBuf |= locData->brdcastResponse << 3;
    983            *pBuf |= locData->compactResponse << 4;
    984            pBuf++;  // move past the bitmap field
    985          
    986            *pBuf++ = locData->numResponses;
    987          
    988            if ( locData->brdcastIndicator == 0 )
    989            {
    990              osal_cpyExtAddr( pBuf, locData->targetAddr );
    991              len += 8; // ieee addr
    992            }
    993          
    994            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
    995                                    COMMAND_LOCATION_GET_DATA, TRUE,
    996                                    ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, len, buf );
    997          }
    998          
    999          ZStatus_t zclGeneral_SendLocationDevCfgResponse( uint8 srcEP, afAddrType_t *dstAddr,
   1000                                                           zclLocationDevCfgRsp_t *devCfg,
   1001                                                           uint8 disableDefaultRsp, uint8 seqNum )
   1002          {
   1003            uint8 buf[10]; // 4 fields (2 octects each) + 2 fields (1 octect each)
   1004            uint8 len = 1; // Status
   1005          
   1006            buf[0] = devCfg->status;
   1007            if ( devCfg->status == ZCL_STATUS_SUCCESS )
   1008            {
   1009              buf[1] = LO_UINT16( devCfg->data.power );
   1010              buf[2] = HI_UINT16( devCfg->data.power );
   1011              buf[3] = LO_UINT16( devCfg->data.pathLossExponent );
   1012              buf[4] = HI_UINT16( devCfg->data.pathLossExponent );
   1013              buf[5] = LO_UINT16( devCfg->data.calcPeriod );
   1014              buf[6] = HI_UINT16( devCfg->data.calcPeriod );
   1015              buf[7] = devCfg->data.numMeasurements;
   1016              buf[8] = LO_UINT16( devCfg->data.reportPeriod );
   1017              buf[9] = HI_UINT16( devCfg->data.reportPeriod );
   1018              len += 9;
   1019            }
   1020          
   1021            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
   1022                                    COMMAND_LOCATION_DEV_CFG_RSP, TRUE,
   1023                                    ZCL_FRAME_SERVER_CLIENT_DIR, disableDefaultRsp, 0, seqNum, len, buf );
   1024          }
   1025          
   1026          /*********************************************************************
   1027           * @fn      zclGeneral_SendLocationData
   1028           *
   1029           * @brief   Call to send out location data
   1030           *
   1031           * @param   srcEP - Sending application's endpoint
   1032           * @param   dstAddr - where you want the message to go
   1033           * @param   status - indicates whether response to request was successful or not
   1034           * @param   locData - location information and channel parameters being sent
   1035           *
   1036           * @return  ZStatus_t
   1037           */
   1038          ZStatus_t zclGeneral_SendLocationData( uint8 srcEP, afAddrType_t *dstAddr, uint8 cmd,
   1039                                                 uint8 status, zclLocationData_t *locData,
   1040                                                 uint8 disableDefaultRsp, uint8 seqNum )
   1041          {
   1042            uint8 buf[16];
   1043            uint8 *pBuf = buf;
   1044            uint8 len = 0;
   1045          
   1046            if ( cmd == COMMAND_LOCATION_DATA_RSP )
   1047            {
   1048              // Only response command includes a status field
   1049              *pBuf++ = status;
   1050              len++;
   1051            }
   1052          
   1053            if ( cmd != COMMAND_LOCATION_DATA_RSP || status == ZCL_STATUS_SUCCESS )
   1054            {
   1055              // Notification or Response with successful status
   1056              *pBuf++ = locData->type;
   1057              *pBuf++ = LO_UINT16( locData->absLoc.coordinate1 );
   1058              *pBuf++ = HI_UINT16( locData->absLoc.coordinate1 );
   1059              *pBuf++ = LO_UINT16( locData->absLoc.coordinate2 );
   1060              *pBuf++ = HI_UINT16( locData->absLoc.coordinate2 );
   1061              len += 5;
   1062          
   1063              if ( locationType2D(locData->type) == 0 )
   1064              {
   1065                // 2D location doesn't have coordinate 3
   1066                *pBuf++ = LO_UINT16( locData->absLoc.coordinate3 );
   1067                *pBuf++ = HI_UINT16( locData->absLoc.coordinate3 );
   1068                len += 2;
   1069              }
   1070          
   1071              if ( cmd != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
   1072              {
   1073                // Compact notification doesn't include these fields
   1074                *pBuf++ = LO_UINT16( locData->absLoc.power );
   1075                *pBuf++ = HI_UINT16( locData->absLoc.power );
   1076                *pBuf++ = LO_UINT16( locData->absLoc.pathLossExponent );
   1077                *pBuf++ = HI_UINT16( locData->absLoc.pathLossExponent );
   1078                len += 4;
   1079              }
   1080          
   1081              if ( locationTypeAbsolute(locData->type) == 0 )
   1082              {
   1083                // Absolute location doesn't include these fields
   1084                if ( cmd != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
   1085                {
   1086                  // Compact notification doesn't include this field
   1087                  *pBuf++ = locData->calcLoc.locationMethod;
   1088                  len++;
   1089                }
   1090          
   1091                *pBuf++ = locData->calcLoc.qualityMeasure;
   1092                *pBuf++ = LO_UINT16( locData->calcLoc.locationAge );
   1093                *pBuf++ = HI_UINT16( locData->calcLoc.locationAge );
   1094                len += 3;
   1095              }
   1096            }
   1097          
   1098            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
   1099                                    cmd, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
   1100                                    disableDefaultRsp, 0, seqNum, len, buf );
   1101          }
   1102          #endif // ZCL_LOCATION
   1103          
   1104          /*********************************************************************
   1105           * @fn      zclGeneral_FindCallbacks
   1106           *
   1107           * @brief   Find the callbacks for an endpoint
   1108           *
   1109           * @param   endpoint - endpoint to find the application callbacks for
   1110           *
   1111           * @return  pointer to the callbacks
   1112           */
   1113          static zclGeneral_AppCallbacks_t *zclGeneral_FindCallbacks( uint8 endpoint )
   1114          {
   1115            zclGenCBRec_t *pCBs;
   1116          
   1117            pCBs = zclGenCBs;
   1118            while ( pCBs )
   1119            {
   1120              if ( pCBs->endpoint == endpoint )
   1121                return ( pCBs->CBs );
   1122              pCBs = pCBs->next;
   1123            }
   1124            return ( (zclGeneral_AppCallbacks_t *)NULL );
   1125          }
   1126          
   1127          /*********************************************************************
   1128           * @fn      zclGeneral_HdlIncoming
   1129           *
   1130           * @brief   Callback from ZCL to process incoming Commands specific
   1131           *          to this cluster library or Profile commands for attributes
   1132           *          that aren't in the attribute list
   1133           *
   1134           *
   1135           * @param   pInMsg - pointer to the incoming message
   1136           *
   1137           * @return  ZStatus_t
   1138           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1139          static ZStatus_t zclGeneral_HdlIncoming( zclIncoming_t *pInMsg )
   \                     zclGeneral_HdlIncoming:
   1140          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1141            ZStatus_t stat = ZSuccess;
   1142          
   1143          #if defined ( INTER_PAN )
   1144            if ( StubAPS_InterPan( pInMsg->msg->srcAddr.panId, pInMsg->msg->srcAddr.endPoint ) )
   1145              return ( stat ); // Cluster not supported thru Inter-PAN
   1146          #endif
   1147            if ( zcl_ClusterCmd( pInMsg->hdr.fc.type ) )
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   F8           MOV     R0,A
   \   00000C   5403         ANL     A,#0x3
   \   00000E   6401         XRL     A,#0x1
   \   000010   700A         JNZ     ??zclGeneral_HdlIncoming_0
   1148            {
   1149              // Is this a manufacturer specific command?
   1150              if ( pInMsg->hdr.fc.manuSpecific == 0 )
   \   000012   E8           MOV     A,R0
   \   000013   5404         ANL     A,#0x4
   \   000015   7005         JNZ     ??zclGeneral_HdlIncoming_0
   1151              {
   1152                stat = zclGeneral_HdlInSpecificCommands( pInMsg );
   \   000017                ; Setup parameters for call to function zclGeneral_HdlInSpecificCommands
   \   000017   12....       LCALL   ??zclGeneral_HdlInSpecificCommands?relay
   \   00001A   8002         SJMP    ??zclGeneral_HdlIncoming_1
   1153              }
   1154              else
   1155              {
   1156                // We don't support any manufacturer specific command.
   1157                stat = ZFailure;
   \                     ??zclGeneral_HdlIncoming_0:
   \   00001C   7901         MOV     R1,#0x1
   1158              }
   1159            }
   1160            else
   1161            {
   1162              // Handle all the normal (Read, Write...) commands -- should never get here
   1163              stat = ZFailure;
   1164            }
   1165            return ( stat );
   \                     ??zclGeneral_HdlIncoming_1:
   \   00001E   D083         POP     DPH
   \   000020   D082         POP     DPL
   \   000022   02....       LJMP    ?BRET
   1166          }
   1167          
   1168          /*********************************************************************
   1169           * @fn      zclGeneral_HdlInSpecificCommands
   1170           *
   1171           * @brief   Callback from ZCL to process incoming Commands specific
   1172           *          to this cluster library
   1173          
   1174           * @param   pInMsg - pointer to the incoming message
   1175           *
   1176           * @return  ZStatus_t
   1177           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1178          static ZStatus_t zclGeneral_HdlInSpecificCommands( zclIncoming_t *pInMsg )
   \                     zclGeneral_HdlInSpecificCommands:
   1179          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   1180            ZStatus_t stat;
   1181            zclGeneral_AppCallbacks_t *pCBs;
   1182          
   1183            // make sure endpoint exists
   1184            pCBs = zclGeneral_FindCallbacks( pInMsg->msg->endPoint );
   \   000005   8A82         MOV     DPL,R2
   \   000007   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_10:
   \   00000A   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_12:
   \   00000D   FC           MOV     R4,A
   \   00000E   90....       MOV     DPTR,#zclGenCBs
   \                     ??zclGeneral_HdlInSpecificCommands_0:
   \   000011   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_14:
   \   000014   7001         JNZ     ??zclGeneral_HdlInSpecificCommands_1
   \   000016   E9           MOV     A,R1
   \                     ??zclGeneral_HdlInSpecificCommands_1:
   \   000017   6065         JZ      ??zclGeneral_HdlInSpecificCommands_2
   \   000019   8882         MOV     DPL,R0
   \   00001B   8983         MOV     DPH,R1
   \   00001D   A3           INC     DPTR
   \   00001E   A3           INC     DPTR
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   6C           XRL     A,R4
   \   000021   8882         MOV     DPL,R0
   \   000023   8983         MOV     DPH,R1
   \   000025   70EA         JNZ     ??zclGeneral_HdlInSpecificCommands_0
   \   000027   A3           INC     DPTR
   \   000028   A3           INC     DPTR
   \   000029   A3           INC     DPTR
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   FC           MOV     R4,A
   \   00002C   A3           INC     DPTR
   \   00002D   E0           MOVX    A,@DPTR
   \   00002E   FD           MOV     R5,A
   1185            if ( pCBs == NULL )
   \   00002F   EC           MOV     A,R4
   \   000030   7001         JNZ     ??zclGeneral_HdlInSpecificCommands_3
   \   000032   ED           MOV     A,R5
   \                     ??zclGeneral_HdlInSpecificCommands_3:
   \   000033   6049         JZ      ??zclGeneral_HdlInSpecificCommands_2
   1186              return ( ZFailure );
   1187          
   1188            switch ( pInMsg->msg->clusterId )
   \   000035   8E82         MOV     DPL,R6
   \   000037   8F83         MOV     DPH,R7
   \   000039   A3           INC     DPTR
   \   00003A   A3           INC     DPTR
   \   00003B   A3           INC     DPTR
   \   00003C   A3           INC     DPTR
   \   00003D   E0           MOVX    A,@DPTR
   \   00003E   F5..         MOV     ?V0 + 0,A
   \   000040   A3           INC     DPTR
   \   000041   E0           MOVX    A,@DPTR
   \   000042   707A         JNZ     ??zclGeneral_HdlInSpecificCommands_4
   \   000044   E5..         MOV     A,?V0 + 0
   \   000046   12....       LCALL   ?UC_SWITCH_SPARSE
   \                     `?<Jumptable for zclGeneral_HdlInSpecificComman_0`:
   \   000049   00           DB        0
   \   00004A   03           DB        3
   \   00004B   00           DB        0
   \   00004C   ....         DW        ??zclGeneral_HdlInSpecificCommands_5
   \   00004E   03           DB        3
   \   00004F   ....         DW        ??zclGeneral_HdlInSpecificCommands_6
   \   000051   06           DB        6
   \   000052   ....         DW        ??zclGeneral_HdlInSpecificCommands_7
   \   000054   ....         DW        ??zclGeneral_HdlInSpecificCommands_4
   1189            {
   1190          #ifdef ZCL_BASIC
   1191              case ZCL_CLUSTER_ID_GEN_BASIC:
   1192                stat = zclGeneral_ProcessInBasic( pInMsg, pCBs );
   \                     ??zclGeneral_HdlInSpecificCommands_5:
   \   000056   8A82         MOV     DPL,R2
   \   000058   8B83         MOV     DPH,R3
   \   00005A   A3           INC     DPTR
   \   00005B   A3           INC     DPTR
   \   00005C   E0           MOVX    A,@DPTR
   \   00005D   5408         ANL     A,#0x8
   \   00005F   7059         JNZ     ??zclGeneral_HdlInSpecificCommands_8
   \   000061   8A82         MOV     DPL,R2
   \   000063   8B83         MOV     DPH,R3
   \   000065   A3           INC     DPTR
   \   000066   A3           INC     DPTR
   \   000067   A3           INC     DPTR
   \   000068   A3           INC     DPTR
   \   000069   A3           INC     DPTR
   \   00006A   A3           INC     DPTR
   \   00006B   A3           INC     DPTR
   \   00006C   E0           MOVX    A,@DPTR
   \   00006D   704F         JNZ     ??zclGeneral_HdlInSpecificCommands_4
   \   00006F   8C82         MOV     DPL,R4
   \   000071   8D83         MOV     DPH,R5
   \   000073   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   000076   7002         JNZ     ??zclGeneral_HdlInSpecificCommands_9
   \   000078   E583         MOV     A,DPH
   \                     ??zclGeneral_HdlInSpecificCommands_9:
   \   00007A   603E         JZ      ??zclGeneral_HdlInSpecificCommands_8
   \   00007C                ; Setup parameters for indirect call
   \   00007C   8039         SJMP    ??zclGeneral_HdlInSpecificCommands_10
   \                     ??zclGeneral_HdlInSpecificCommands_2:
   \   00007E   803E         SJMP    ??zclGeneral_HdlInSpecificCommands_4
   1193                break;
   1194          #endif // ZCL_BASIC
   1195          
   1196          #ifdef ZCL_IDENTIFY
   1197              case ZCL_CLUSTER_ID_GEN_IDENTIFY:
   1198                stat = zclGeneral_ProcessInIdentity( pInMsg, pCBs );
   \                     ??zclGeneral_HdlInSpecificCommands_6:
   \   000080                ; Setup parameters for call to function zclGeneral_ProcessInIdentity
   \   000080   12....       LCALL   ??zclGeneral_ProcessInIdentity?relay
   \   000083   803B         SJMP    ??zclGeneral_HdlInSpecificCommands_11
   1199                break;
   1200          #endif // ZCL_IDENTIFY
   1201          
   1202          #ifdef ZCL_GROUPS
   1203              case ZCL_CLUSTER_ID_GEN_GROUPS:
   1204                if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   1205                  stat = zclGeneral_ProcessInGroupsServer( pInMsg );
   1206                else
   1207                  stat = zclGeneral_ProcessInGroupsClient( pInMsg, pCBs );
   1208                break;
   1209          #endif // ZCL_GROUPS
   1210          
   1211          #ifdef ZCL_SCENES
   1212              case ZCL_CLUSTER_ID_GEN_SCENES:
   1213                if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   1214                  stat = zclGeneral_ProcessInScenesServer( pInMsg, pCBs );
   1215                else
   1216                  stat = zclGeneral_ProcessInScenesClient( pInMsg, pCBs );
   1217                break;
   1218          #endif // ZCL_SCENES
   1219          
   1220          #ifdef ZCL_ON_OFF
   1221              case ZCL_CLUSTER_ID_GEN_ON_OFF:
   1222                stat = zclGeneral_ProcessInOnOff( pInMsg, pCBs );
   \                     ??zclGeneral_HdlInSpecificCommands_7:
   \   000085   8A82         MOV     DPL,R2
   \   000087   8B83         MOV     DPH,R3
   \   000089   A3           INC     DPTR
   \   00008A   A3           INC     DPTR
   \   00008B   E0           MOVX    A,@DPTR
   \   00008C   5408         ANL     A,#0x8
   \   00008E   702A         JNZ     ??zclGeneral_HdlInSpecificCommands_8
   \   000090   8A82         MOV     DPL,R2
   \   000092   8B83         MOV     DPH,R3
   \   000094   A3           INC     DPTR
   \   000095   A3           INC     DPTR
   \   000096   A3           INC     DPTR
   \   000097   A3           INC     DPTR
   \   000098   A3           INC     DPTR
   \   000099   A3           INC     DPTR
   \   00009A   A3           INC     DPTR
   \   00009B   E0           MOVX    A,@DPTR
   \   00009C   FA           MOV     R2,A
   \   00009D   C3           CLR     C
   \   00009E   9403         SUBB    A,#0x3
   \   0000A0   501C         JNC     ??zclGeneral_HdlInSpecificCommands_4
   \   0000A2   8C82         MOV     DPL,R4
   \   0000A4   8D83         MOV     DPH,R5
   \   0000A6   A3           INC     DPTR
   \   0000A7   A3           INC     DPTR
   \   0000A8   A3           INC     DPTR
   \   0000A9   A3           INC     DPTR
   \   0000AA   A3           INC     DPTR
   \   0000AB   A3           INC     DPTR
   \   0000AC   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   0000AF   7002         JNZ     ??zclGeneral_HdlInSpecificCommands_12
   \   0000B1   E583         MOV     A,DPH
   \                     ??zclGeneral_HdlInSpecificCommands_12:
   \   0000B3   6005         JZ      ??zclGeneral_HdlInSpecificCommands_8
   \   0000B5                ; Setup parameters for indirect call
   \   0000B5   EA           MOV     A,R2
   \   0000B6   F9           MOV     R1,A
   \                     ??zclGeneral_HdlInSpecificCommands_10:
   \   0000B7   12....       LCALL   ?CALL_IND
   \                     ??zclGeneral_HdlInSpecificCommands_8:
   \   0000BA   7900         MOV     R1,#0x0
   \   0000BC   8002         SJMP    ??zclGeneral_HdlInSpecificCommands_11
   1223                break;
   1224          #endif // ZCL_ON_OFF
   1225          
   1226          #ifdef ZCL_LEVEL_CTRL
   1227              case ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL:
   1228                stat = zclGeneral_ProcessInLevelControl( pInMsg, pCBs );
   1229                break;
   1230          #endif // ZCL_LEVEL_CTRL
   1231          
   1232          #ifdef ZCL_ALARMS
   1233              case ZCL_CLUSTER_ID_GEN_ALARMS:
   1234                if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   1235                  stat = zclGeneral_ProcessInAlarmsServer( pInMsg, pCBs );
   1236                else
   1237                  stat = zclGeneral_ProcessInAlarmsClient( pInMsg, pCBs );
   1238                break;
   1239          #endif // ZCL_ALARMS
   1240          
   1241          #ifdef ZCL_LOCATION
   1242              case ZCL_CLUSTER_ID_GEN_LOCATION:
   1243                if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   1244                  stat = zclGeneral_ProcessInLocationServer( pInMsg, pCBs );
   1245                else
   1246                  stat = zclGeneral_ProcessInLocationClient( pInMsg, pCBs );
   1247                break;
   1248          #endif // ZCL_LOCATION
   1249          
   1250              case ZCL_CLUSTER_ID_GEN_POWER_CFG:
   1251              case ZCL_CLUSTER_ID_GEN_DEVICE_TEMP_CONFIG:
   1252              case ZCL_CLUSTER_ID_GEN_ON_OFF_SWITCH_CONFIG:
   1253              case ZCL_CLUSTER_ID_GEN_TIME:
   1254              default:
   1255                stat = ZFailure;
   \                     ??zclGeneral_HdlInSpecificCommands_4:
   \   0000BE   7901         MOV     R1,#0x1
   1256                break;
   1257            }
   1258          
   1259            return ( stat );
   \                     ??zclGeneral_HdlInSpecificCommands_11:
   \   0000C0   02....       LJMP    ??Subroutine11_0 & 0xFFFF
   1260          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_18:
   \   000003   E582         MOV     A,DPL
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   8882         MOV     DPL,R0
   \   000007   8983         MOV     DPH,R1
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   8B83         MOV     DPH,R3
   \   000002   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_16:
   \   000005   FE           MOV     R6,A
   \   000006   E9           MOV     A,R1
   \   000007   FF           MOV     R7,A
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   E8           MOV     A,R0
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   EE           MOV     A,R6
   \   000001   2414         ADD     A,#0x14
   \   000003   F582         MOV     DPL,A
   \   000005   EF           MOV     A,R7
   \   000006   3400         ADDC    A,#0x0
   \   000008   F583         MOV     DPH,A
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   22           RET
   1261          
   1262          #ifdef ZCL_BASIC
   1263          /*********************************************************************
   1264           * @fn      zclGeneral_ProcessInBasic
   1265           *
   1266           * @brief   Process in the received Basic Command.
   1267           *
   1268           * @param   pInMsg - pointer to the incoming message
   1269           *
   1270           * @return  ZStatus_t
   1271           */
   1272          static ZStatus_t zclGeneral_ProcessInBasic( zclIncoming_t *pInMsg,
   1273                                                      zclGeneral_AppCallbacks_t *pCBs )
   1274          {
   1275            if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   1276            {
   1277              if ( pInMsg->hdr.commandID > COMMAND_BASIC_RESET_FACT_DEFAULT )
   1278                return ( ZFailure );   // Error ignore the command
   1279          
   1280              if ( pCBs->pfnBasicReset )
   1281                pCBs->pfnBasicReset();
   1282            }
   1283            // no Client command
   1284          
   1285            return ( ZSuccess );
   1286          }
   1287          #endif // ZCL_BASIC
   1288          
   1289          #ifdef ZCL_IDENTIFY
   1290          /*********************************************************************
   1291           * @fn      zclGeneral_ProcessInIdentity
   1292           *
   1293           * @brief   Process in the received Identity Command.
   1294           *
   1295           * @param   pInMsg - pointer to the incoming message
   1296           *
   1297           * @return  ZStatus_t
   1298           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1299          static ZStatus_t zclGeneral_ProcessInIdentity( zclIncoming_t *pInMsg,
   \                     zclGeneral_ProcessInIdentity:
   1300                                                         zclGeneral_AppCallbacks_t *pCBs )
   1301          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 14
   \   000005   74F2         MOV     A,#-0xe
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 0,R2
   \   00000C   8B..         MOV     ?V0 + 1,R3
   1302            if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   \   00000E   8A82         MOV     DPL,R2
   \   000010   8B83         MOV     DPH,R3
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   A3           INC     DPTR
   \   000015   A3           INC     DPTR
   \   000016   A3           INC     DPTR
   \   000017   A3           INC     DPTR
   \   000018   A3           INC     DPTR
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   FA           MOV     R2,A
   \   00001B   85..82       MOV     DPL,?V0 + 0
   \   00001E   8B83         MOV     DPH,R3
   \   000020   A3           INC     DPTR
   \   000021   A3           INC     DPTR
   \   000022   E0           MOVX    A,@DPTR
   \   000023   5408         ANL     A,#0x8
   \   000025   6003         JZ      $+5
   \   000027   02....       LJMP    ??zclGeneral_ProcessInIdentity_0 & 0xFFFF
   1303            {
   1304              if ( pInMsg->hdr.commandID > COMMAND_IDENTIFY_QUERY )
   \   00002A   EA           MOV     A,R2
   \   00002B   C3           CLR     C
   \   00002C   9402         SUBB    A,#0x2
   \   00002E   4005         JC      ??zclGeneral_ProcessInIdentity_1
   1305                return ( ZFailure );   // Error ignore the command
   \                     ??zclGeneral_ProcessInIdentity_2:
   \   000030   7901         MOV     R1,#0x1
   \   000032   02....       LJMP    ??zclGeneral_ProcessInIdentity_3 & 0xFFFF
   1306          
   1307              if ( pInMsg->hdr.commandID == COMMAND_IDENTIFY )
   \                     ??zclGeneral_ProcessInIdentity_1:
   \   000035   EA           MOV     A,R2
   \   000036   700D         JNZ     ??zclGeneral_ProcessInIdentity_4
   1308              {
   1309                if ( pCBs->pfnIdentify )
   \   000038   8C82         MOV     DPL,R4
   \   00003A   8D83         MOV     DPH,R5
   \   00003C   12....       LCALL   ?Subroutine4 & 0xFFFF
   1310                {
   1311                  zclIdentify_t cmd;
   1312          
   1313                  cmd.srcAddr = &(pInMsg->msg->srcAddr);
   1314                  cmd.identifyTime = BUILD_UINT16( pInMsg->pData[0], pInMsg->pData[1] );
   1315          
   1316                  pCBs->pfnIdentify( &cmd );
   1317                }
   1318              }
   \                     ??CrossCallReturnLabel_8:
   \   00003F   7001         JNZ     ??zclGeneral_ProcessInIdentity_5
   \   000041   ED           MOV     A,R5
   \                     ??zclGeneral_ProcessInIdentity_5:
   \   000042   02....       LJMP    ??zclGeneral_ProcessInIdentity_6 & 0xFFFF
   1319              else
   1320              {
   1321                zclAttrRec_t attrRec;
   1322                uint16 identifyTime = 0;
   \                     ??zclGeneral_ProcessInIdentity_4:
   \   000045   7404         MOV     A,#0x4
   \   000047   12....       LCALL   ?XSTACK_DISP0_8
   \   00004A   E4           CLR     A
   \   00004B   F0           MOVX    @DPTR,A
   \   00004C   A3           INC     DPTR
   \   00004D   F0           MOVX    @DPTR,A
   1323          
   1324                // Retrieve Identify Time
   1325                if ( zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, ATTRID_IDENTIFY_TIME, &attrRec ) )
   \   00004E   85..82       MOV     DPL,?V0 + 0
   \   000051   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_11:
   \   000054                ; Setup parameters for call to function zclFindAttrRec
   \   000054   7406         MOV     A,#0x6
   \   000056   12....       LCALL   ?XSTACK_DISP0_8
   \   000059   8582..       MOV     ?V0 + 2,DPL
   \   00005C   8583..       MOV     ?V0 + 3,DPH
   \   00005F   78..         MOV     R0,#?V0 + 2
   \   000061   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000064   7C00         MOV     R4,#0x0
   \   000066   7D00         MOV     R5,#0x0
   \   000068   8E82         MOV     DPL,R6
   \   00006A   8F83         MOV     DPH,R7
   \   00006C   A3           INC     DPTR
   \   00006D   A3           INC     DPTR
   \   00006E   A3           INC     DPTR
   \   00006F   A3           INC     DPTR
   \   000070   E0           MOVX    A,@DPTR
   \   000071   FA           MOV     R2,A
   \   000072   A3           INC     DPTR
   \   000073   E0           MOVX    A,@DPTR
   \   000074   12....       LCALL   ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_6:
   \   000077   12....       LCALL   ??zclFindAttrRec?relay
   \   00007A   7402         MOV     A,#0x2
   \   00007C   12....       LCALL   ?DEALLOC_XSTACK8
   \   00007F   E9           MOV     A,R1
   \   000080   6015         JZ      ??zclGeneral_ProcessInIdentity_7
   1326                  zclReadAttrData( (uint8 *)&identifyTime, &attrRec );
   \   000082                ; Setup parameters for call to function zclReadAttrData
   \   000082   7406         MOV     A,#0x6
   \   000084   12....       LCALL   ?XSTACK_DISP0_8
   \   000087   AC82         MOV     R4,DPL
   \   000089   AD83         MOV     R5,DPH
   \   00008B   7404         MOV     A,#0x4
   \   00008D   12....       LCALL   ?XSTACK_DISP0_8
   \   000090   AA82         MOV     R2,DPL
   \   000092   AB83         MOV     R3,DPH
   \   000094   12....       LCALL   ??zclReadAttrData?relay
   1327          
   1328                // Is device identifying itself?
   1329                if ( identifyTime > 0 )
   \                     ??zclGeneral_ProcessInIdentity_7:
   \   000097   7404         MOV     A,#0x4
   \   000099   12....       LCALL   ?XSTACK_DISP0_8
   \   00009C   E0           MOVX    A,@DPTR
   \   00009D   7002         JNZ     ??zclGeneral_ProcessInIdentity_8
   \   00009F   A3           INC     DPTR
   \   0000A0   E0           MOVX    A,@DPTR
   \                     ??zclGeneral_ProcessInIdentity_8:
   \   0000A1   6043         JZ      ??zclGeneral_ProcessInIdentity_9
   1330                {
   1331                  zclGeneral_SendIdentifyQueryResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   1332                                                        identifyTime, true, pInMsg->hdr.transSeqNum );
   \   0000A3   85..82       MOV     DPL,?V0 + 0
   \   0000A6   85..83       MOV     DPH,?V0 + 1
   \   0000A9   E0           MOVX    A,@DPTR
   \   0000AA   FE           MOV     R6,A
   \   0000AB   A3           INC     DPTR
   \   0000AC   E0           MOVX    A,@DPTR
   \   0000AD   FF           MOV     R7,A
   \   0000AE                ; Setup parameters for call to function zclGeneral_SendIdentifyQueryResponse
   \   0000AE   85..82       MOV     DPL,?V0 + 0
   \   0000B1   85..83       MOV     DPH,?V0 + 1
   \   0000B4   A3           INC     DPTR
   \   0000B5   A3           INC     DPTR
   \   0000B6   A3           INC     DPTR
   \   0000B7   A3           INC     DPTR
   \   0000B8   A3           INC     DPTR
   \   0000B9   A3           INC     DPTR
   \   0000BA   E0           MOVX    A,@DPTR
   \   0000BB   F5..         MOV     ?V0 + 0,A
   \   0000BD   78..         MOV     R0,#?V0 + 0
   \   0000BF   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000C2   75..01       MOV     ?V0 + 0,#0x1
   \   0000C5   78..         MOV     R0,#?V0 + 0
   \   0000C7   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000CA   7406         MOV     A,#0x6
   \   0000CC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CF   E0           MOVX    A,@DPTR
   \   0000D0   FC           MOV     R4,A
   \   0000D1   A3           INC     DPTR
   \   0000D2   E0           MOVX    A,@DPTR
   \   0000D3   FD           MOV     R5,A
   \   0000D4   EE           MOV     A,R6
   \   0000D5   2406         ADD     A,#0x6
   \   0000D7   FA           MOV     R2,A
   \   0000D8   EF           MOV     A,R7
   \   0000D9   3400         ADDC    A,#0x0
   \   0000DB   12....       LCALL   ?Subroutine3 & 0xFFFF
   1333                }
   \                     ??CrossCallReturnLabel_7:
   \   0000DE   12....       LCALL   ??zclGeneral_SendIdentifyQueryResponse?relay
   \   0000E1   7402         MOV     A,#0x2
   \   0000E3   12....       LCALL   ?DEALLOC_XSTACK8
   1334          
   1335                return ( ZCL_STATUS_CMD_HAS_RSP );
   \                     ??zclGeneral_ProcessInIdentity_9:
   \   0000E6   79FF         MOV     R1,#-0x1
   \   0000E8   8061         SJMP    ??zclGeneral_ProcessInIdentity_3
   1336              }
   1337            }
   1338            else // Client Command
   1339            {
   1340              if ( pInMsg->hdr.commandID > COMMAND_IDENTIFY_QUERY_RSP )
   \                     ??zclGeneral_ProcessInIdentity_0:
   \   0000EA   EA           MOV     A,R2
   \   0000EB   6003         JZ      $+5
   \   0000ED   02....       LJMP    ??zclGeneral_ProcessInIdentity_2 & 0xFFFF
   1341                return ( ZFailure );   // Error ignore the command
   1342          
   1343              if ( pCBs->pfnIdentifyQueryRsp )
   \   0000F0   8C82         MOV     DPL,R4
   \   0000F2   8D83         MOV     DPH,R5
   \   0000F4   A3           INC     DPTR
   \   0000F5   A3           INC     DPTR
   \   0000F6   12....       LCALL   ?Subroutine4 & 0xFFFF
   \                     ??CrossCallReturnLabel_9:
   \   0000F9   7001         JNZ     ??zclGeneral_ProcessInIdentity_6
   \   0000FB   ED           MOV     A,R5
   \                     ??zclGeneral_ProcessInIdentity_6:
   \   0000FC   604B         JZ      ??zclGeneral_ProcessInIdentity_10
   1344              {
   1345                zclIdentifyQueryRsp_t rsp;
   1346          
   1347                rsp.srcAddr = &(pInMsg->msg->srcAddr);
   \   0000FE   85..82       MOV     DPL,?V0 + 0
   \   000101   8B83         MOV     DPH,R3
   \   000103   E0           MOVX    A,@DPTR
   \   000104   2406         ADD     A,#0x6
   \   000106   F8           MOV     R0,A
   \   000107   A3           INC     DPTR
   \   000108   E0           MOVX    A,@DPTR
   \   000109   3400         ADDC    A,#0x0
   \   00010B   F9           MOV     R1,A
   \   00010C   85..82       MOV     DPL,?XSP + 0
   \   00010F   85..83       MOV     DPH,?XSP + 1
   \   000112   E8           MOV     A,R0
   \   000113   F0           MOVX    @DPTR,A
   \   000114   A3           INC     DPTR
   \   000115   E9           MOV     A,R1
   \   000116   F0           MOVX    @DPTR,A
   1348                rsp.timeout = BUILD_UINT16( pInMsg->pData[0], pInMsg->pData[1] );
   \   000117   85..82       MOV     DPL,?V0 + 0
   \   00011A   8B83         MOV     DPH,R3
   \   00011C   A3           INC     DPTR
   \   00011D   A3           INC     DPTR
   \   00011E   A3           INC     DPTR
   \   00011F   A3           INC     DPTR
   \   000120   A3           INC     DPTR
   \   000121   A3           INC     DPTR
   \   000122   A3           INC     DPTR
   \   000123   A3           INC     DPTR
   \   000124   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_17:
   \   000127   E0           MOVX    A,@DPTR
   \   000128   FA           MOV     R2,A
   \   000129   A3           INC     DPTR
   \   00012A   E0           MOVX    A,@DPTR
   \   00012B   F9           MOV     R1,A
   \   00012C   EA           MOV     A,R2
   \   00012D   F8           MOV     R0,A
   \   00012E   7402         MOV     A,#0x2
   \   000130   12....       LCALL   ?XSTACK_DISP0_8
   \   000133   E8           MOV     A,R0
   \   000134   F0           MOVX    @DPTR,A
   \   000135   A3           INC     DPTR
   \   000136   E9           MOV     A,R1
   \   000137   F0           MOVX    @DPTR,A
   1349          
   1350                pCBs->pfnIdentifyQueryRsp( &rsp );
   \   000138                ; Setup parameters for indirect call
   \   000138   85..82       MOV     DPL,?XSP + 0
   \   00013B   85..83       MOV     DPH,?XSP + 1
   \   00013E   AA82         MOV     R2,DPL
   \   000140   AB83         MOV     R3,DPH
   \   000142   8C82         MOV     DPL,R4
   \   000144   8D83         MOV     DPH,R5
   \   000146   12....       LCALL   ?CALL_IND
   1351              }
   1352            }
   1353          
   1354            return ( ZSuccess );
   \                     ??zclGeneral_ProcessInIdentity_10:
   \   000149   7900         MOV     R1,#0x0
   \                     ??zclGeneral_ProcessInIdentity_3:
   \   00014B   740E         MOV     A,#0xe
   \   00014D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000150   02....       LJMP    ?Subroutine9 & 0xFFFF
   1355          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_15:
   \   000005   FC           MOV     R4,A
   \   000006   E9           MOV     A,R1
   \   000007   FD           MOV     R5,A
   \   000008   EC           MOV     A,R4
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   FB           MOV     R3,A
   \   000001   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_13:
   \   000004   F9           MOV     R1,A
   \   000005   22           RET

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclGeneral_RegisterCmdCallbacks?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGeneral_RegisterCmdCallbacks

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclGeneral_SendIdentify?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGeneral_SendIdentify

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclGeneral_SendIdentifyQueryResponse?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGeneral_SendIdentifyQueryResponse

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclGeneral_HdlIncoming?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGeneral_HdlIncoming

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclGeneral_HdlInSpecificCommands?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGeneral_HdlInSpecificCommands

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclGeneral_ProcessInIdentity?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGeneral_ProcessInIdentity
   1356          #endif // ZCL_IDENTIFY
   1357          
   1358          #ifdef ZCL_GROUPS
   1359          
   1360          /*********************************************************************
   1361           * @fn      zclGeneral_AddGroup
   1362           *
   1363           * @brief   Add a Group.
   1364           *
   1365           * @param   endPoint - application endpoint
   1366           * @param   group - group to be added
   1367           * @param   pData - pointer to the group info
   1368           *
   1369           * @return  ZStatus_t
   1370           */
   1371          static ZStatus_t zclGeneral_AddGroup( uint8 endPoint, aps_Group_t *group, uint8 *pData )
   1372          {
   1373            zclAttrRec_t attrRec;
   1374            uint8 nameLen;
   1375            uint8 nameSupport = FALSE;
   1376          
   1377            pData += 2;   // Move past group ID
   1378            nameLen = *pData++;
   1379          
   1380            // Retrieve Name Support attribute
   1381            if ( zclFindAttrRec( endPoint, ZCL_CLUSTER_ID_GEN_GROUPS, ATTRID_GROUP_NAME_SUPPORT, &attrRec ) )
   1382               zclReadAttrData( &nameSupport, &attrRec );
   1383          
   1384            if ( nameSupport )
   1385            {
   1386              if ( nameLen > (APS_GROUP_NAME_LEN-1) )
   1387                 nameLen = (APS_GROUP_NAME_LEN-1);
   1388              group->name[0] = nameLen;
   1389              osal_memcpy( &(group->name[1]), pData, nameLen );
   1390            }
   1391          
   1392            return ( aps_AddGroup( endPoint, group ) );
   1393          }
   1394          
   1395          /*********************************************************************
   1396           * @fn      zclGeneral_ProcessInGroupsServer
   1397           *
   1398           * @brief   Process in the received Groups Command.
   1399           *
   1400           * @param   pInMsg - pointer to the incoming message
   1401           *
   1402           * @return  ZStatus_t
   1403           */
   1404          static ZStatus_t zclGeneral_ProcessInGroupsServer( zclIncoming_t *pInMsg )
   1405          {
   1406            zclAttrRec_t attrRec;
   1407            aps_Group_t group;
   1408            aps_Group_t *pGroup;
   1409            uint8 *pData;
   1410            uint8 status;
   1411            uint8 grpCnt;
   1412            uint8 grpRspCnt = 0;
   1413            uint16 *grpList;
   1414            uint16 identifyTime = 0;
   1415            uint8 i;
   1416            ZStatus_t stat = ZSuccess;
   1417          
   1418            osal_memset( (uint8*)&group, 0, sizeof( aps_Group_t ) );
   1419          
   1420            pData = pInMsg->pData;
   1421            group.ID = BUILD_UINT16( pData[0], pData[1] );
   1422            switch ( pInMsg->hdr.commandID )
   1423            {
   1424              case COMMAND_GROUP_ADD:
   1425                status = zclGeneral_AddGroup( pInMsg->msg->endPoint, &group, pData );
   1426                if ( status != ZSuccess )
   1427                {
   1428                  if ( status == ZApsDuplicateEntry )
   1429                    status = ZCL_STATUS_DUPLICATE_EXISTS;
   1430                  else
   1431                    status = ZCL_STATUS_INSUFFICIENT_SPACE;
   1432                }
   1433          
   1434                zclGeneral_SendGroupAddResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   1435                                                 status, group.ID, true, pInMsg->hdr.transSeqNum );
   1436                stat = ZCL_STATUS_CMD_HAS_RSP;
   1437                break;
   1438          
   1439              case COMMAND_GROUP_VIEW:
   1440                pGroup = aps_FindGroup( pInMsg->msg->endPoint, group.ID );
   1441                if ( pGroup )
   1442                {
   1443                  status = ZCL_STATUS_SUCCESS;
   1444                }
   1445                else
   1446                {
   1447                  // Group not found
   1448                  status = ZCL_STATUS_NOT_FOUND;
   1449                  pGroup = &group;
   1450                }
   1451                zclGeneral_SendGroupViewResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   1452                                                  status, pGroup, true, pInMsg->hdr.transSeqNum );
   1453                stat = ZCL_STATUS_CMD_HAS_RSP;
   1454                break;
   1455          
   1456              case COMMAND_GROUP_GET_MEMBERSHIP:
   1457                grpCnt = *pData++;
   1458                  
   1459                // Allocate space for the group list
   1460                grpList = osal_mem_alloc( sizeof( uint16 ) * APS_MAX_GROUPS );
   1461                if ( grpList != NULL )
   1462                {
   1463                  if ( grpCnt == 0 )
   1464                  {
   1465                    // Find out all the groups of which the endpoint is a member.
   1466                    grpRspCnt = aps_FindAllGroupsForEndpoint( pInMsg->msg->endPoint, grpList );
   1467                  }
   1468                  else
   1469                  {
   1470                    // Find out the groups (in the list) of which the endpoint is a member.
   1471                    for ( i = 0; i < grpCnt; i++ )
   1472                    {
   1473                      group.ID = BUILD_UINT16( pData[0], pData[1] );
   1474                      pData += 2;
   1475          
   1476                      if ( aps_FindGroup( pInMsg->msg->endPoint, group.ID ) )
   1477                        grpList[grpRspCnt++] = group.ID;
   1478                    }
   1479                  }
   1480                
   1481                  if ( grpCnt == 0 ||  grpRspCnt != 0 )
   1482                  {
   1483                    zclGeneral_SendGroupGetMembershipResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr, 
   1484                                                               aps_GroupsRemaingCapacity(), grpRspCnt, 
   1485                                                               grpList, true, pInMsg->hdr.transSeqNum );
   1486                  }
   1487          
   1488                  osal_mem_free( grpList );
   1489                }
   1490                else
   1491                {
   1492                  // Couldn't allocate space for the group list -- send a Default Response command back.
   1493                  zclDefaultRspCmd_t defaultRspCmd;
   1494                  
   1495                  defaultRspCmd.commandID = pInMsg->hdr.commandID;
   1496                  defaultRspCmd.statusCode = ZCL_STATUS_INSUFFICIENT_SPACE;
   1497                  zcl_SendDefaultRspCmd( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   1498                                         pInMsg->msg->clusterId, &defaultRspCmd,
   1499                                         ZCL_FRAME_SERVER_CLIENT_DIR, true, 0, pInMsg->hdr.transSeqNum );
   1500                }
   1501          
   1502                stat = ZCL_STATUS_CMD_HAS_RSP;
   1503                break;
   1504          
   1505              case COMMAND_GROUP_REMOVE:
   1506                if ( aps_RemoveGroup( pInMsg->msg->endPoint, group.ID ) )
   1507                  status = ZCL_STATUS_SUCCESS;
   1508                else
   1509                  status = ZCL_STATUS_NOT_FOUND;
   1510                zclGeneral_SendGroupRemoveResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   1511                                                    status, group.ID, true, pInMsg->hdr.transSeqNum );
   1512                stat = ZCL_STATUS_CMD_HAS_RSP;
   1513                break;
   1514          
   1515              case COMMAND_GROUP_REMOVE_ALL:
   1516                aps_RemoveAllGroup( pInMsg->msg->endPoint );
   1517                break;
   1518          
   1519              case COMMAND_GROUP_ADD_IF_IDENTIFYING:
   1520                // Retrieve Identify Time
   1521                if ( zclFindAttrRec( pInMsg->msg->endPoint, ZCL_CLUSTER_ID_GEN_IDENTIFY, ATTRID_IDENTIFY_TIME, &attrRec ) )
   1522                  zclReadAttrData( (uint8 *)&identifyTime, &attrRec );
   1523          
   1524                // Is device identifying itself?
   1525                if ( identifyTime > 0 )
   1526                  zclGeneral_AddGroup( pInMsg->msg->endPoint, &group, pData );
   1527                break;
   1528          
   1529              default:
   1530                stat = ZFailure;
   1531                break;
   1532            }
   1533          
   1534            return ( stat );
   1535          }
   1536          
   1537          /*********************************************************************
   1538           * @fn      zclGeneral_ProcessInGroupsClient
   1539           *
   1540           * @brief   Process in the received Groups Command.
   1541           *
   1542           * @param   pInMsg - pointer to the incoming message
   1543           *
   1544           * @return  ZStatus_t
   1545           */
   1546          static ZStatus_t zclGeneral_ProcessInGroupsClient( zclIncoming_t *pInMsg,
   1547                                                             zclGeneral_AppCallbacks_t *pCBs )
   1548          {
   1549            aps_Group_t group;
   1550            uint8 *pData = pInMsg->pData;
   1551            uint16 *grpList;
   1552            uint8 grpCnt;
   1553            uint8 nameLen;
   1554            zclGroupRsp_t rsp;
   1555            uint8 i;
   1556            ZStatus_t stat = ZSuccess;
   1557          
   1558            osal_memset( (uint8*)&group, 0, sizeof( aps_Group_t ) );
   1559            osal_memset( (uint8*)&rsp, 0, sizeof( zclGroupRsp_t ) );
   1560          
   1561            switch ( pInMsg->hdr.commandID )
   1562            {
   1563              case COMMAND_GROUP_ADD_RSP:
   1564              case COMMAND_GROUP_VIEW_RSP:
   1565              case COMMAND_GROUP_REMOVE_RSP:
   1566                rsp.status = *pData++;
   1567                group.ID = BUILD_UINT16( pData[0], pData[1] );
   1568          
   1569                if ( rsp.status == ZCL_STATUS_SUCCESS && pInMsg->hdr.commandID == COMMAND_GROUP_VIEW_RSP )
   1570                {
   1571                  pData += 2;   // Move past ID
   1572                  nameLen = *pData++;
   1573                  if ( nameLen > (APS_GROUP_NAME_LEN-1) )
   1574                    nameLen = (APS_GROUP_NAME_LEN-1);
   1575                  group.name[0] = nameLen;
   1576                  osal_memcpy( &(group.name[1]), pData, nameLen );
   1577                  rsp.grpName = group.name;
   1578                }
   1579          
   1580                if ( pCBs->pfnGroupRsp )
   1581                {
   1582                  rsp.srcAddr = &(pInMsg->msg->srcAddr);
   1583                  rsp.cmdID = pInMsg->hdr.commandID;
   1584                  rsp.grpCnt = 1;
   1585                  rsp.grpList = &group.ID;
   1586                  rsp.capacity = 0;
   1587          
   1588                  pCBs->pfnGroupRsp( &rsp );
   1589                }
   1590                break;
   1591          
   1592              case COMMAND_GROUP_GET_MEMBERSHIP_RSP:
   1593                rsp.capacity = *pData++;
   1594                grpCnt = *pData++;
   1595          
   1596                if ( grpCnt > 0 )
   1597                {
   1598                  // Allocate space for the group list
   1599                  grpList = osal_mem_alloc( sizeof( uint16 ) * grpCnt );
   1600                  if ( grpList != NULL )
   1601                  {
   1602                    rsp.grpCnt = grpCnt;
   1603                    for ( i = 0; i < grpCnt; i++ )
   1604                    {
   1605                      grpList[i] = BUILD_UINT16( pData[0], pData[1] );
   1606                      pData += 2;
   1607                    }
   1608                  }
   1609                }
   1610          
   1611                if ( pCBs->pfnGroupRsp )
   1612                {
   1613                  rsp.srcAddr = &(pInMsg->msg->srcAddr);
   1614                  rsp.cmdID = pInMsg->hdr.commandID;
   1615                  rsp.grpList = grpList;
   1616          
   1617                  pCBs->pfnGroupRsp( &rsp );
   1618                }
   1619                
   1620                if ( grpList != NULL )
   1621                  osal_mem_free( grpList );
   1622                break;
   1623          
   1624              default:
   1625                stat = ZFailure;
   1626                break;
   1627            }
   1628          
   1629            return ( stat );
   1630          }
   1631          #endif // ZCL_GROUPS
   1632          
   1633          #ifdef ZCL_SCENES
   1634          /*********************************************************************
   1635           * @fn      zclGeneral_AddScene
   1636           *
   1637           * @brief   Add a scene for an endpoint
   1638           *
   1639           * @param   endpoint -
   1640           * @param   scene - new scene item
   1641           *
   1642           * @return  ZStatus_t
   1643           */
   1644          ZStatus_t zclGeneral_AddScene( uint8 endpoint, zclGeneral_Scene_t *scene )
   1645          {
   1646            zclGenSceneItem_t *pNewItem;
   1647            zclGenSceneItem_t *pLoop;
   1648          
   1649            // Fill in the new profile list
   1650            pNewItem = osal_mem_alloc( sizeof( zclGenSceneItem_t ) );
   1651            if ( pNewItem == NULL )
   1652              return ( ZMemError );
   1653          
   1654            // Fill in the plugin record.
   1655            pNewItem->next = (zclGenSceneItem_t *)NULL;
   1656            pNewItem->endpoint = endpoint;
   1657            osal_memcpy( (uint8*)&(pNewItem->scene), (uint8*)scene, sizeof ( zclGeneral_Scene_t ));
   1658          
   1659            // Find spot in list
   1660            if (  zclGenSceneTable == NULL )
   1661            {
   1662              zclGenSceneTable = pNewItem;
   1663            }
   1664            else
   1665            {
   1666              // Look for end of list
   1667              pLoop = zclGenSceneTable;
   1668              while ( pLoop->next != NULL )
   1669                pLoop = pLoop->next;
   1670          
   1671              // Put new item at end of list
   1672              pLoop->next = pNewItem;
   1673            }
   1674          
   1675            // Update NV
   1676            zclGeneral_ScenesWriteNV();
   1677          
   1678            return ( ZSuccess );
   1679          }
   1680          
   1681          /*********************************************************************
   1682           * @fn      zclGeneral_FindScene
   1683           *
   1684           * @brief   Find a scene with endpoint and sceneID
   1685           *
   1686           * @param   endpoint -
   1687           * @param   groupID - what group the scene belongs to
   1688           * @param   sceneID - ID to look for scene
   1689           *
   1690           * @return  a pointer to the scene information, NULL if not found
   1691           */
   1692          zclGeneral_Scene_t *zclGeneral_FindScene( uint8 endpoint, uint16 groupID, uint8 sceneID )
   1693          {
   1694            zclGenSceneItem_t *pLoop;
   1695          
   1696            // Look for end of list
   1697            pLoop = zclGenSceneTable;
   1698            while ( pLoop )
   1699            {
   1700              if ( (pLoop->endpoint == endpoint || endpoint == 0xFF)
   1701                  && pLoop->scene.groupID == groupID && pLoop->scene.ID == sceneID )
   1702              {
   1703                return ( &(pLoop->scene) );
   1704              }
   1705              pLoop = pLoop->next;
   1706            }
   1707          
   1708            return ( (zclGeneral_Scene_t *)NULL );
   1709          }
   1710          
   1711          /*********************************************************************
   1712           * @fn      aps_FindAllScensForGroup
   1713           *
   1714           * @brief   Find all the scenes with groupID
   1715           *
   1716           * @param   endpoint - endpoint to look for
   1717           * @param   sceneList - List to hold scene IDs (should hold APS_MAX_SCENES entries)
   1718           *
   1719           * @return  number of scenes copied to sceneList
   1720           */
   1721          uint8 zclGeneral_FindAllScenesForGroup( uint8 endpoint, uint16 groupID, uint8 *sceneList )
   1722          {
   1723            zclGenSceneItem_t *pLoop;
   1724            uint8 cnt = 0;
   1725          
   1726            // Look for end of list
   1727            pLoop = zclGenSceneTable;
   1728            while ( pLoop )
   1729            {
   1730              if ( pLoop->endpoint == endpoint && pLoop->scene.groupID == groupID )
   1731                sceneList[cnt++] = pLoop->scene.ID;
   1732              pLoop = pLoop->next;
   1733            }
   1734            return ( cnt );
   1735          }
   1736          
   1737          /*********************************************************************
   1738           * @fn      zclGeneral_RemoveScene
   1739           *
   1740           * @brief   Remove a scene with endpoint and sceneID
   1741           *
   1742           * @param   endpoint -
   1743           * @param   groupID - what group the scene belongs to
   1744           * @param   sceneID - ID to look for scene
   1745           *
   1746           * @return  TRUE if removed, FALSE if not found
   1747           */
   1748          uint8 zclGeneral_RemoveScene( uint8 endpoint, uint16 groupID, uint8 sceneID )
   1749          {
   1750            zclGenSceneItem_t *pLoop;
   1751            zclGenSceneItem_t *pPrev;
   1752          
   1753            // Look for end of list
   1754            pLoop = zclGenSceneTable;
   1755            pPrev = NULL;
   1756            while ( pLoop )
   1757            {
   1758              if ( pLoop->endpoint == endpoint
   1759                  && pLoop->scene.groupID == groupID && pLoop->scene.ID == sceneID )
   1760              {
   1761                if ( pPrev == NULL )
   1762                  zclGenSceneTable = pLoop->next;
   1763                else
   1764                  pPrev->next = pLoop->next;
   1765          
   1766                // Free the memory
   1767                osal_mem_free( pLoop );
   1768          
   1769                // Update NV
   1770                zclGeneral_ScenesWriteNV();
   1771          
   1772                return ( TRUE );
   1773              }
   1774              pPrev = pLoop;
   1775              pLoop = pLoop->next;
   1776            }
   1777          
   1778            return ( FALSE );
   1779          }
   1780          
   1781          /*********************************************************************
   1782           * @fn      zclGeneral_RemoveAllScenes
   1783           *
   1784           * @brief   Remove all scenes with endpoint and group Id
   1785           *
   1786           * @param   endpoint -
   1787           * @param   groupID - ID to look for group
   1788           *
   1789           * @return  none
   1790           */
   1791          void zclGeneral_RemoveAllScenes( uint8 endpoint, uint16 groupID )
   1792          {
   1793            zclGenSceneItem_t *pLoop;
   1794            zclGenSceneItem_t *pPrev;
   1795            zclGenSceneItem_t *pNext;
   1796          
   1797            // Look for end of list
   1798            pLoop = zclGenSceneTable;
   1799            pPrev = NULL;
   1800            while ( pLoop )
   1801            {
   1802              if ( pLoop->endpoint == endpoint && pLoop->scene.groupID == groupID )
   1803              {
   1804                if ( pPrev == NULL )
   1805                  zclGenSceneTable = pLoop->next;
   1806                else
   1807                  pPrev->next = pLoop->next;
   1808                pNext = pLoop->next;
   1809          
   1810                // Free the memory
   1811                osal_mem_free( pLoop );
   1812                pLoop = pNext;
   1813              }
   1814              else
   1815              {
   1816                pPrev = pLoop;
   1817                pLoop = pLoop->next;
   1818              }
   1819            }
   1820          
   1821            // Update NV
   1822            zclGeneral_ScenesWriteNV();
   1823          }
   1824          
   1825          /*********************************************************************
   1826           * @fn      zclGeneral_CountScenes
   1827           *
   1828           * @brief   Count the number of scenes for an endpoint
   1829           *
   1830           * @param   endpoint -
   1831           *
   1832           * @return  number of scenes assigned to an endpoint
   1833           */
   1834          uint8 zclGeneral_CountScenes( uint8 endpoint )
   1835          {
   1836            zclGenSceneItem_t *pLoop;
   1837            uint8 cnt = 0;
   1838          
   1839            // Look for end of list
   1840            pLoop = zclGenSceneTable;
   1841            while ( pLoop )
   1842            {
   1843              if ( pLoop->endpoint == endpoint  )
   1844                cnt++;
   1845              pLoop = pLoop->next;
   1846            }
   1847            return ( cnt );
   1848          }
   1849          
   1850          /*********************************************************************
   1851           * @fn      zclGeneral_CountAllScenes
   1852           *
   1853           * @brief   Count the total number of scenes
   1854           *
   1855           * @param   none
   1856           *
   1857           * @return  number of scenes
   1858           */
   1859          uint8 zclGeneral_CountAllScenes( void )
   1860          {
   1861            zclGenSceneItem_t *pLoop;
   1862            uint8 cnt = 0;
   1863          
   1864            // Look for end of list
   1865            pLoop = zclGenSceneTable;
   1866            while ( pLoop )
   1867            {
   1868              cnt++;
   1869              pLoop = pLoop->next;
   1870            }
   1871            return ( cnt );
   1872          }
   1873          
   1874          /*********************************************************************
   1875           * @fn      zclGeneral_ProcessInScenesServer
   1876           *
   1877           * @brief   Process in the received Scenes Command.
   1878           *
   1879           * @param   pInMsg - pointer to the incoming message
   1880           *
   1881           * @return  ZStatus_t
   1882           */
   1883          static ZStatus_t zclGeneral_ProcessInScenesServer( zclIncoming_t *pInMsg,
   1884                                                             zclGeneral_AppCallbacks_t *pCBs )
   1885          {
   1886            zclAttrRec_t attrRec;
   1887            zclGeneral_Scene_t scene;
   1888            zclGeneral_Scene_t *pScene;
   1889            uint8 *pData = pInMsg->pData;
   1890            uint8 nameLen;
   1891            uint8 status;
   1892            uint8 sceneCnt = 0;
   1893            uint8 *sceneList = NULL;
   1894            uint8 sendRsp = FALSE;
   1895            uint8 nameSupport = FALSE;
   1896            ZStatus_t stat = ZSuccess;
   1897          
   1898            osal_memset( (uint8*)&scene, 0, sizeof( zclGeneral_Scene_t ) );
   1899          
   1900            scene.groupID = BUILD_UINT16( pData[0], pData[1] );
   1901            pData += 2;   // Move past group ID
   1902            scene.ID = *pData++;
   1903          
   1904            switch ( pInMsg->hdr.commandID )
   1905            {
   1906              case COMMAND_SCENE_ADD:
   1907                // Parse the rest of the incoming message
   1908                scene.transTime = BUILD_UINT16( pData[0], pData[1] );
   1909                pData += 2;
   1910                nameLen= *pData++; // Name length
   1911          
   1912                // Retrieve Name Support attribute
   1913                if ( zclFindAttrRec( pInMsg->msg->endPoint, ZCL_CLUSTER_ID_GEN_SCENES, ATTRID_SCENES_NAME_SUPPORT, &attrRec ) )
   1914                  zclReadAttrData( &nameSupport, &attrRec );
   1915          
   1916                if ( nameSupport )
   1917                {
   1918                  if ( nameLen > (ZCL_GEN_SCENE_NAME_LEN-1) )
   1919                    nameLen = (ZCL_GEN_SCENE_NAME_LEN-1);
   1920                  scene.name[0] = nameLen;
   1921                  osal_memcpy( &(scene.name[1]), pData, nameLen );
   1922                }
   1923          
   1924                pData += nameLen; // move pass name
   1925          
   1926                scene.extLen = pInMsg->pDataLen - ( (uint16)( pData - pInMsg->pData ) );
   1927                if ( scene.extLen > 0 )
   1928                {
   1929                  // Copy the extention field(s)
   1930                  if ( scene.extLen > ZCL_GEN_SCENE_EXT_LEN )
   1931                    scene.extLen = ZCL_GEN_SCENE_EXT_LEN;
   1932                  osal_memcpy( scene.extField, pData, scene.extLen );
   1933                }
   1934          
   1935                if ( scene.groupID == 0x0000 ||
   1936                     aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
   1937                {
   1938                  // Either the Scene doesn't belong to a Group (Group ID = 0x0000) or it
   1939                  // does and the corresponding Group exits
   1940                  pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
   1941                  if ( pScene || ( zclGeneral_CountAllScenes() < ZCL_GEN_MAX_SCENES ) )
   1942                  {
   1943                    status = ZCL_STATUS_SUCCESS;
   1944                    if ( pScene != NULL )
   1945                    {
   1946                      // The Scene already exists so update it
   1947                      pScene->transTime = scene.transTime;
   1948                      osal_memcpy( pScene->name, scene.name, ZCL_GEN_SCENE_NAME_LEN );
   1949          
   1950                      // Use the new extention field(s)
   1951                      osal_memcpy( pScene->extField, scene.extField, scene.extLen );
   1952                      pScene->extLen = scene.extLen;
   1953          
   1954                      // Update NV
   1955                      zclGeneral_ScenesWriteNV();
   1956                    }
   1957                    else
   1958                    {
   1959                      // The Scene doesn't exist so add it
   1960                      zclGeneral_AddScene( pInMsg->msg->endPoint, &scene );
   1961                    }
   1962                  }
   1963                  else
   1964                    status = ZCL_STATUS_INSUFFICIENT_SPACE; // The Scene Table is full
   1965                }
   1966                else
   1967                  status = ZCL_STATUS_INVALID_FIELD; // The Group is not in the Group Table
   1968          
   1969                zclGeneral_SendSceneAddResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   1970                                                 status, scene.groupID, scene.ID,
   1971                                                 true, pInMsg->hdr.transSeqNum );
   1972                stat = ZCL_STATUS_CMD_HAS_RSP;
   1973                break;
   1974          
   1975              case COMMAND_SCENE_VIEW:
   1976                pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
   1977                if ( pScene != NULL )
   1978                {
   1979                  status = ZCL_STATUS_SUCCESS;
   1980                }
   1981                else
   1982                {
   1983                  // Scene not found
   1984                  if ( scene.groupID != 0x0000 &&
   1985                       aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) == NULL )
   1986                  {
   1987                    status = ZCL_STATUS_INVALID_FIELD; // The Group is not in the Group Table
   1988                  }
   1989                  else
   1990                    status = ZCL_STATUS_NOT_FOUND;
   1991                  pScene = &scene;
   1992                }
   1993                zclGeneral_SendSceneViewResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   1994                                                  status, pScene, true, pInMsg->hdr.transSeqNum );
   1995                stat = ZCL_STATUS_CMD_HAS_RSP;
   1996                break;
   1997          
   1998              case COMMAND_SCENE_REMOVE:
   1999                if ( zclGeneral_RemoveScene( pInMsg->msg->endPoint, scene.groupID, scene.ID ) )
   2000                {
   2001                  status = ZCL_STATUS_SUCCESS;
   2002                }
   2003                else
   2004                {
   2005                  // Scene not found
   2006                  if ( aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) == NULL )
   2007                  {
   2008                    // The Group is not in the Group Table
   2009                    status = ZCL_STATUS_INVALID_FIELD;
   2010                  }
   2011                  else
   2012                    status = ZCL_STATUS_NOT_FOUND;
   2013                }
   2014          
   2015                if ( UNICAST_MSG( pInMsg->msg ) )
   2016                {
   2017                  // Addressed to this device (not to a group) - send a response back
   2018                  zclGeneral_SendSceneRemoveResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2019                                                      status, scene.groupID,
   2020                                                      scene.ID, true, pInMsg->hdr.transSeqNum );
   2021                }
   2022                stat = ZCL_STATUS_CMD_HAS_RSP;
   2023                break;
   2024          
   2025              case COMMAND_SCENE_REMOVE_ALL:
   2026                if ( scene.groupID == 0x0000 ||
   2027                     aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
   2028                {
   2029                  zclGeneral_RemoveAllScenes( pInMsg->msg->endPoint, scene.groupID );
   2030                  status = ZCL_STATUS_SUCCESS;
   2031                }
   2032                else
   2033                  status = ZCL_STATUS_INVALID_FIELD;
   2034          
   2035                if ( UNICAST_MSG( pInMsg->msg ) )
   2036                {
   2037                  // Addressed to this device (not to a group) - send a response back
   2038                  zclGeneral_SendSceneRemoveAllResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2039                                                         status, scene.groupID, true, pInMsg->hdr.transSeqNum );
   2040                }
   2041                stat = ZCL_STATUS_CMD_HAS_RSP;
   2042                break;
   2043          
   2044              case COMMAND_SCENE_STORE:
   2045                if ( scene.groupID == 0x0000 ||
   2046                     aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
   2047                {
   2048                  // Either the Scene doesn't belong to a Group (Group ID = 0x0000) or it
   2049                  // does and the corresponding Group exits
   2050                  pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
   2051                  if ( pScene || ( zclGeneral_CountAllScenes() < ZCL_GEN_MAX_SCENES ) )
   2052                  {
   2053                    uint8 sceneChanged = FALSE;
   2054          
   2055                    status = ZCL_STATUS_SUCCESS;
   2056                    if ( pScene == NULL )
   2057                    {
   2058                      // Haven't been added yet
   2059                      pScene = &scene;
   2060                    }
   2061          
   2062                    if ( pCBs->pfnSceneStoreReq )
   2063                    {
   2064                      zclSceneReq_t req;
   2065          
   2066                      req.srcAddr = &(pInMsg->msg->srcAddr);
   2067                      req.scene = pScene;
   2068          
   2069                      // Get the latest Scene info
   2070                      if ( pCBs->pfnSceneStoreReq( &req ) )
   2071                        sceneChanged = TRUE;
   2072                    }
   2073          
   2074                    if ( pScene == &scene )
   2075                    {
   2076                      // The Scene doesn't exist so add it
   2077                      zclGeneral_AddScene( pInMsg->msg->endPoint, &scene );
   2078                    }
   2079                    else if ( sceneChanged )
   2080                    {
   2081                      // The Scene already exists so update only NV
   2082                      zclGeneral_ScenesWriteNV();
   2083                    }
   2084                  }
   2085                  else
   2086                    status = ZCL_STATUS_INSUFFICIENT_SPACE; // The Scene Table is full
   2087                }
   2088                else
   2089                  status = ZCL_STATUS_INVALID_FIELD; // The Group is not in the Group Table
   2090          
   2091                if ( UNICAST_MSG( pInMsg->msg ) )
   2092                {
   2093                  // Addressed to this device (not to a group) - send a response back
   2094                  zclGeneral_SendSceneStoreResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2095                                                     status, scene.groupID, scene.ID,
   2096                                                     true, pInMsg->hdr.transSeqNum );
   2097                }
   2098                stat = ZCL_STATUS_CMD_HAS_RSP;
   2099                break;
   2100          
   2101              case COMMAND_SCENE_RECALL:
   2102                pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
   2103                if ( pScene && pCBs->pfnSceneRecallReq )
   2104                {
   2105                  zclSceneReq_t req;
   2106          
   2107                  req.srcAddr = &(pInMsg->msg->srcAddr);
   2108                  req.scene = pScene;
   2109          
   2110                  pCBs->pfnSceneRecallReq( &req );
   2111                }
   2112                // No response
   2113                break;
   2114          
   2115              case COMMAND_SCENE_GET_MEMBERSHIP:
   2116                // Find all the Scenes corresponding to the Group ID
   2117                if ( scene.groupID == 0x0000 ||
   2118                     aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
   2119                {
   2120                  // Allocate space for the scene list
   2121                  sceneList = osal_mem_alloc( ZCL_GEN_MAX_SCENES );
   2122                  if ( sceneList != NULL )
   2123                  {
   2124                    sceneCnt = zclGeneral_FindAllScenesForGroup( pInMsg->msg->endPoint, 
   2125                                                                 scene.groupID, sceneList ); 
   2126                    status = ZCL_STATUS_SUCCESS;
   2127                    if ( UNICAST_MSG( pInMsg->msg ) )
   2128                    {
   2129                      // Addressed only to this device - send a response back
   2130                      sendRsp = TRUE;
   2131                    }
   2132                    else
   2133                    {
   2134                      // Addressed to the Group - ONLY send a response if an entry within the 
   2135                      // Scene Table corresponds to the Group ID
   2136                      if ( sceneCnt != 0 )
   2137                        sendRsp = TRUE;
   2138                    }
   2139                  }
   2140                  else
   2141                  {
   2142                    // Couldn't allocate space for the scene list!
   2143                    status = ZCL_STATUS_INSUFFICIENT_SPACE;
   2144                    sendRsp = TRUE;
   2145                  }
   2146                }
   2147                else
   2148                {
   2149                  // The Group is not in the Group Table - send a response back
   2150                  status = ZCL_STATUS_INVALID_FIELD;
   2151                  sendRsp = TRUE;
   2152                }
   2153          
   2154                if ( sendRsp )
   2155                {
   2156                  zclGeneral_SendSceneGetMembershipResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2157                                              status, zclGeneral_ScenesRemaingCapacity(), sceneCnt, sceneList,
   2158                                              scene.groupID, true, pInMsg->hdr.transSeqNum );
   2159                }
   2160                
   2161                if ( sceneList != NULL )
   2162                  osal_mem_free( sceneList );
   2163                
   2164                stat = ZCL_STATUS_CMD_HAS_RSP;
   2165                break;
   2166          
   2167              default:
   2168                stat = ZFailure;
   2169              break;
   2170            }
   2171          
   2172            return ( stat );
   2173          }
   2174          
   2175          /*********************************************************************
   2176           * @fn      zclGeneral_ProcessInScenesClient
   2177           *
   2178           * @brief   Process in the received Scenes Command.
   2179           *
   2180           * @param   pInMsg - pointer to the incoming message
   2181           *
   2182           * @return  ZStatus_t
   2183           */
   2184          static ZStatus_t zclGeneral_ProcessInScenesClient( zclIncoming_t *pInMsg,
   2185                                                             zclGeneral_AppCallbacks_t *pCBs )
   2186          {
   2187            zclGeneral_Scene_t scene;
   2188            uint8 *pData = pInMsg->pData;
   2189            uint8 nameLen;
   2190            uint8 *sceneList = NULL;
   2191            zclSceneRsp_t rsp;
   2192            uint8 i;
   2193            ZStatus_t stat = ZSuccess;
   2194          
   2195            osal_memset( (uint8*)&scene, 0, sizeof( zclGeneral_Scene_t ) );
   2196            osal_memset( (uint8*)&rsp, 0, sizeof( zclSceneRsp_t ) );
   2197          
   2198            // Get the status field first
   2199            rsp.status = *pData++;
   2200          
   2201            if ( pInMsg->hdr.commandID == COMMAND_SCENE_GET_MEMBERSHIP_RSP )
   2202              rsp.capacity = *pData++;
   2203          
   2204            scene.groupID = BUILD_UINT16( pData[0], pData[1] );
   2205            pData += 2;   // Move past group ID
   2206          
   2207            switch ( pInMsg->hdr.commandID )
   2208            {
   2209              case COMMAND_SCENE_VIEW_RSP:
   2210                // Parse the rest of the incoming message
   2211                scene.ID = *pData++; // Not applicable to Remove All Response command
   2212                scene.transTime = BUILD_UINT16( pData[0], pData[1] );
   2213                pData += 2;
   2214                nameLen = *pData++; // Name length
   2215                if ( nameLen > (ZCL_GEN_SCENE_NAME_LEN-1) )
   2216                  nameLen = (ZCL_GEN_SCENE_NAME_LEN-1);
   2217                scene.name[0] = nameLen;
   2218                osal_memcpy( &(scene.name[1]), pData, nameLen );
   2219                pData += nameLen; // move pass name
   2220          
   2221                //*** Do something with the extension field(s)
   2222          
   2223                // Fall through to callback - break is left off intentionally
   2224          
   2225              case COMMAND_SCENE_ADD_RSP:
   2226              case COMMAND_SCENE_REMOVE_RSP:
   2227              case COMMAND_SCENE_REMOVE_ALL_RSP:
   2228              case COMMAND_SCENE_STORE_RSP:
   2229                if ( pCBs->pfnSceneRsp )
   2230                {
   2231                  rsp.srcAddr = &(pInMsg->msg->srcAddr);
   2232                  rsp.cmdID = pInMsg->hdr.commandID;
   2233                  rsp.scene = &scene;
   2234          
   2235                  pCBs->pfnSceneRsp( &rsp );
   2236                }
   2237                break;
   2238          
   2239              case COMMAND_SCENE_GET_MEMBERSHIP_RSP:
   2240                if ( rsp.status == ZCL_STATUS_SUCCESS )
   2241                {
   2242                  uint8 sceneCnt = *pData++;
   2243                  
   2244                  if ( sceneCnt > 0 )
   2245                  {
   2246                    // Allocate space for the scene list
   2247                    sceneList = osal_mem_alloc( sceneCnt );
   2248                    if ( sceneList != NULL )
   2249                    {
   2250                      rsp.sceneCnt = sceneCnt;
   2251                      for ( i = 0; i < sceneCnt; i++ )
   2252                        sceneList[i] = *pData++;
   2253                    }
   2254                  }
   2255                }
   2256          
   2257                if ( pCBs->pfnSceneRsp )
   2258                {
   2259                  rsp.srcAddr = &(pInMsg->msg->srcAddr);
   2260                  rsp.cmdID = pInMsg->hdr.commandID;
   2261                  rsp.sceneList = sceneList;
   2262                  rsp.scene = &scene;
   2263          
   2264                  pCBs->pfnSceneRsp( &rsp);
   2265                }
   2266                
   2267                if ( sceneList != NULL )
   2268                  osal_mem_free( sceneList );
   2269                break;
   2270          
   2271              default:
   2272                stat = ZFailure;
   2273                break;
   2274            }
   2275          
   2276            return ( stat );
   2277          }
   2278          #endif // ZCL_SCENES
   2279          
   2280          #ifdef ZCL_ON_OFF
   2281          /*********************************************************************
   2282           * @fn      zclGeneral_ProcessInCmdOnOff
   2283           *
   2284           * @brief   Process in the received On/Off Command.
   2285           *
   2286           * @param   pInMsg - pointer to the incoming message
   2287           *
   2288           * @return  ZStatus_t
   2289           */
   2290          static ZStatus_t zclGeneral_ProcessInOnOff( zclIncoming_t *pInMsg,
   2291                                                      zclGeneral_AppCallbacks_t *pCBs )
   2292          {
   2293            if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   2294            {
   2295              if ( pInMsg->hdr.commandID > COMMAND_TOGGLE )
   2296                return ( ZFailure );   // Error ignore the command
   2297          
   2298              if ( pCBs->pfnOnOff )
   2299                pCBs->pfnOnOff( pInMsg->hdr.commandID );
   2300            }
   2301            // no Client command
   2302          
   2303            return ( ZSuccess );
   2304          }
   2305          #endif // ZCL_ON_OFF
   2306          
   2307          #ifdef ZCL_LEVEL_CTRL
   2308          /*********************************************************************
   2309           * @fn      zclGeneral_ProcessInLevelControl
   2310           *
   2311           * @brief   Process in the received Level Control Command.
   2312           *
   2313           * @param   pInMsg - pointer to the incoming message
   2314           *
   2315           * @return  ZStatus_t
   2316           */
   2317          static ZStatus_t zclGeneral_ProcessInLevelControl( zclIncoming_t *pInMsg,
   2318                                                             zclGeneral_AppCallbacks_t *pCBs )
   2319          {
   2320            uint8 withOnOff = FALSE;
   2321            ZStatus_t stat = ZSuccess;
   2322          
   2323            if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   2324            {
   2325              switch ( pInMsg->hdr.commandID )
   2326              {
   2327                case COMMAND_LEVEL_MOVE_TO_LEVEL_WITH_ON_OFF:
   2328                  withOnOff = TRUE;
   2329                  // fall through
   2330                case COMMAND_LEVEL_MOVE_TO_LEVEL:
   2331                  if ( pCBs->pfnLevelControlMoveToLevel )
   2332                  {
   2333                    zclLCMoveToLevel_t cmd;
   2334          
   2335                    cmd.level = pInMsg->pData[0];
   2336                    cmd.transitionTime = BUILD_UINT16( pInMsg->pData[1], pInMsg->pData[2] );
   2337                    cmd.withOnOff = withOnOff;
   2338          
   2339                    pCBs->pfnLevelControlMoveToLevel( &cmd );
   2340                  }
   2341                  break;
   2342          
   2343                case COMMAND_LEVEL_MOVE_WITH_ON_OFF:
   2344                  withOnOff = TRUE;
   2345                  // fall through
   2346                case COMMAND_LEVEL_MOVE:
   2347                  if ( pCBs->pfnLevelControlMove )
   2348                  {
   2349                    zclLCMove_t cmd;
   2350          
   2351                    cmd.moveMode = pInMsg->pData[0];
   2352                    cmd.rate = pInMsg->pData[1];
   2353                    cmd.withOnOff = withOnOff;
   2354          
   2355                    pCBs->pfnLevelControlMove( &cmd );
   2356                  }
   2357                  break;
   2358          
   2359                case COMMAND_LEVEL_STEP_WITH_ON_OFF:
   2360                  withOnOff = TRUE;
   2361                  // fall through
   2362                case COMMAND_LEVEL_STEP:
   2363                  if ( pCBs->pfnLevelControlStep )
   2364                  {
   2365                    zclLCStep_t cmd;
   2366          
   2367                    cmd.stepMode = pInMsg->pData[0];
   2368                    cmd.amount =  pInMsg->pData[1];
   2369                    cmd.transitionTime = BUILD_UINT16( pInMsg->pData[2], pInMsg->pData[3] );
   2370                    cmd.withOnOff = withOnOff;
   2371          
   2372                    pCBs->pfnLevelControlStep( &cmd );
   2373                  }
   2374                  break;
   2375          
   2376                case COMMAND_LEVEL_STOP:
   2377                case COMMAND_LEVEL_STOP_WITH_ON_OFF:
   2378                  // Both Stop commands are identical
   2379                  if ( pCBs->pfnLevelControlStop )
   2380                  {
   2381                    pCBs->pfnLevelControlStop();
   2382                  }
   2383                  break;
   2384          
   2385                default:
   2386                  stat = ZFailure;
   2387                  break;
   2388              }
   2389            }
   2390            // no Client command
   2391          
   2392            return ( stat );
   2393          }
   2394          #endif // ZCL_LEVEL_CTRL
   2395          
   2396          #ifdef ZCL_ALARMS
   2397          /*********************************************************************
   2398           * @fn      zclGeneral_AddAlarm
   2399           *
   2400           * @brief   Add an alarm for a cluster
   2401           *
   2402           * @param   endpoint -
   2403           * @param   alarm - new alarm item
   2404           *
   2405           * @return  ZStatus_t
   2406           */
   2407          ZStatus_t zclGeneral_AddAlarm( uint8 endpoint, zclGeneral_Alarm_t *alarm )
   2408          {
   2409            zclGenAlarmItem_t *pNewItem;
   2410            zclGenAlarmItem_t *pLoop;
   2411          
   2412            // Fill in the new profile list
   2413            pNewItem = osal_mem_alloc( sizeof( zclGenAlarmItem_t ) );
   2414            if ( pNewItem == NULL )
   2415              return ( ZMemError );
   2416          
   2417            // Fill in the plugin record.
   2418            pNewItem->next = (zclGenAlarmItem_t *)NULL;
   2419            pNewItem->endpoint =  endpoint;
   2420            osal_memcpy( (uint8*)(&pNewItem->alarm), (uint8*)alarm, sizeof ( zclGeneral_Alarm_t ) );
   2421          
   2422            // Find spot in list
   2423            if (  zclGenAlarmTable == NULL )
   2424            {
   2425              zclGenAlarmTable = pNewItem;
   2426            }
   2427            else
   2428            {
   2429              // Look for end of list
   2430              pLoop = zclGenAlarmTable;
   2431              while ( pLoop->next != NULL )
   2432                pLoop = pLoop->next;
   2433          
   2434              // Put new item at end of list
   2435              pLoop->next = pNewItem;
   2436            }
   2437          
   2438            return ( ZSuccess );
   2439          }
   2440          
   2441          /*********************************************************************
   2442           * @fn      zclGeneral_FindAlarm
   2443           *
   2444           * @brief   Find an alarm with alarmCode and clusterID
   2445           *
   2446           * @param   endpoint -
   2447           * @param   groupID - what group the scene belongs to
   2448           * @param   sceneID - ID to look for scene
   2449           *
   2450           * @return  a pointer to the alarm information, NULL if not found
   2451           */
   2452          zclGeneral_Alarm_t *zclGeneral_FindAlarm( uint8 endpoint, uint8 alarmCode, uint16 clusterID )
   2453          {
   2454            zclGenAlarmItem_t *pLoop;
   2455          
   2456            // Look for the alarm
   2457            pLoop = zclGenAlarmTable;
   2458            while ( pLoop )
   2459            {
   2460              if ( pLoop->endpoint == endpoint &&
   2461                   pLoop->alarm.code == alarmCode && pLoop->alarm.clusterID == clusterID )
   2462              {
   2463                return ( &(pLoop->alarm) );
   2464              }
   2465              pLoop = pLoop->next;
   2466            }
   2467          
   2468            return ( (zclGeneral_Alarm_t *)NULL );
   2469          }
   2470          
   2471          /*********************************************************************
   2472           * @fn      zclGeneral_FindEarliestAlarm
   2473           *
   2474           * @brief   Find an alarm with the earliest timestamp
   2475           *
   2476           * @param   endpoint -
   2477           *
   2478           * @return  a pointer to the alarm information, NULL if not found
   2479           */
   2480          zclGeneral_Alarm_t *zclGeneral_FindEarliestAlarm( uint8 endpoint )
   2481          {
   2482            zclGenAlarmItem_t *pLoop;
   2483            zclGenAlarmItem_t earliestAlarm;
   2484            zclGenAlarmItem_t *pEarliestAlarm = &earliestAlarm;
   2485          
   2486            pEarliestAlarm->alarm.timeStamp = 0xFFFFFFFF;
   2487          
   2488            // Look for alarm with earliest time
   2489            pLoop = zclGenAlarmTable;
   2490            while ( pLoop )
   2491            {
   2492              if ( pLoop->endpoint == endpoint &&
   2493                   pLoop->alarm.timeStamp < pEarliestAlarm->alarm.timeStamp )
   2494              {
   2495                pEarliestAlarm = pLoop;
   2496              }
   2497              pLoop = pLoop->next;
   2498            }
   2499          
   2500            if ( pEarliestAlarm->alarm.timeStamp != 0xFFFFFFFF )
   2501              return ( &(pEarliestAlarm->alarm) );
   2502          
   2503            // No alarm
   2504            return ( (zclGeneral_Alarm_t *)NULL );
   2505          }
   2506          
   2507          /*********************************************************************
   2508           * @fn      zclGeneral_ResetAlarm
   2509           *
   2510           * @brief   Remove a scene with endpoint and sceneID
   2511           *
   2512           * @param   endpoint -
   2513           * @param   alarmCode -
   2514           * @param   clusterID -
   2515           *
   2516           * @return  TRUE if removed, FALSE if not found
   2517           */
   2518          void zclGeneral_ResetAlarm( uint8 endpoint, uint8 alarmCode, uint16 clusterID )
   2519          {
   2520            zclGenAlarmItem_t *pLoop;
   2521            zclGenAlarmItem_t *pPrev;
   2522          
   2523            // Look for end of list
   2524            pLoop = zclGenAlarmTable;
   2525            pPrev = NULL;
   2526            while ( pLoop )
   2527            {
   2528              if ( pLoop->endpoint == endpoint &&
   2529                   pLoop->alarm.code == alarmCode && pLoop->alarm.clusterID == clusterID )
   2530              {
   2531                if ( pPrev == NULL )
   2532                  zclGenAlarmTable = pLoop->next;
   2533                else
   2534                  pPrev->next = pLoop->next;
   2535          
   2536                // Free the memory
   2537                osal_mem_free( pLoop );
   2538          
   2539                // Notify the Application so that if the alarm condition still active then
   2540                // a new notification will be generated, and a new alarm record will be
   2541                // added to the alarm log
   2542                // zclGeneral_NotifyReset( alarmCode, clusterID ); // callback function?
   2543                return;
   2544              }
   2545              pPrev = pLoop;
   2546              pLoop = pLoop->next;
   2547            }
   2548          }
   2549          
   2550          /*********************************************************************
   2551           * @fn      zclGeneral_ResetAllAlarms
   2552           *
   2553           * @brief   Remove all alarms with endpoint
   2554           *
   2555           * @param   endpoint -
   2556           * @param   notifyApp -
   2557           *
   2558           * @return  none
   2559           */
   2560          void zclGeneral_ResetAllAlarms( uint8 endpoint, uint8 notifyApp )
   2561          {
   2562            zclGenAlarmItem_t *pLoop;
   2563            zclGenAlarmItem_t *pPrev;
   2564            zclGenAlarmItem_t *pNext;
   2565          
   2566            // Look for end of list
   2567            pLoop = zclGenAlarmTable;
   2568            pPrev = NULL;
   2569            while ( pLoop )
   2570            {
   2571              if (  pLoop->endpoint == endpoint )
   2572              {
   2573                if ( pPrev == NULL )
   2574                  zclGenAlarmTable = pLoop->next;
   2575                else
   2576                  pPrev->next = pLoop->next;
   2577          
   2578                pNext = pLoop->next;
   2579          
   2580                // Free the memory
   2581                osal_mem_free( pLoop );
   2582          
   2583                pLoop = pNext;
   2584              }
   2585              else
   2586              {
   2587                pPrev = pLoop;
   2588                pLoop = pLoop->next;
   2589              }
   2590            }
   2591          
   2592            if ( notifyApp )
   2593            {
   2594              // Notify the Application so that if any alarm conditions still active then
   2595              // a new notification will be generated, and a new alarm record will be
   2596              // added to the alarm log
   2597              // zclGeneral_NotifyResetAll(); // callback function?
   2598            }
   2599          }
   2600          
   2601          /*********************************************************************
   2602           * @fn      zclGeneral_ProcessInAlarmsServer
   2603           *
   2604           * @brief   Process in the received Alarms Command.
   2605           *
   2606           * @param   pInMsg - pointer to the incoming message
   2607           *
   2608           * @return  ZStatus_t
   2609           */
   2610          static ZStatus_t zclGeneral_ProcessInAlarmsServer( zclIncoming_t *pInMsg,
   2611                                                             zclGeneral_AppCallbacks_t *pCBs )
   2612          {
   2613            zclGeneral_Alarm_t *pAlarm;
   2614            uint8 *pData = pInMsg->pData;
   2615            ZStatus_t stat = ZSuccess;
   2616          
   2617            switch ( pInMsg->hdr.commandID )
   2618            {
   2619              case COMMAND_ALARMS_RESET:
   2620                zclGeneral_ResetAlarm( pInMsg->msg->endPoint, pData[0],
   2621                                       BUILD_UINT16( pData[1], pData[2] ) );
   2622                break;
   2623          
   2624              case COMMAND_ALARMS_RESET_ALL:
   2625                zclGeneral_ResetAllAlarms( pInMsg->msg->endPoint, TRUE );
   2626                break;
   2627          
   2628              case COMMAND_ALARMS_GET:
   2629                pAlarm = zclGeneral_FindEarliestAlarm( pInMsg->msg->endPoint );
   2630                if ( pAlarm )
   2631                {
   2632                  // Send a response back
   2633                  zclGeneral_SendAlarmGetRespnose( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2634                                                   ZCL_STATUS_SUCCESS, pAlarm->code,
   2635                                                   pAlarm->clusterID, pAlarm->timeStamp,
   2636                                                   true, pInMsg->hdr.transSeqNum );
   2637                  // Remove the entry from the Alarm table
   2638                  zclGeneral_ResetAlarm( pInMsg->msg->endPoint, pAlarm->code, pAlarm->clusterID );
   2639                }
   2640                else
   2641                {
   2642                  // Send a response back
   2643                  zclGeneral_SendAlarmGetRespnose( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2644                                                   ZCL_STATUS_NOT_FOUND, 0, 0, 0,
   2645                                                   true, pInMsg->hdr.transSeqNum );
   2646                }
   2647                stat = ZCL_STATUS_CMD_HAS_RSP;
   2648                break;
   2649          
   2650              case COMMAND_ALARMS_RESET_LOG:
   2651                zclGeneral_ResetAllAlarms( pInMsg->msg->endPoint, FALSE );
   2652                break;
   2653          
   2654              default:
   2655                stat = ZFailure;
   2656                break;
   2657            }
   2658          
   2659            return ( stat );
   2660          }
   2661          
   2662          /*********************************************************************
   2663           * @fn      zclGeneral_ProcessInAlarmsClient
   2664           *
   2665           * @brief   Process in the received Alarms Command.
   2666           *
   2667           * @param   pInMsg - pointer to the incoming message
   2668           *
   2669           * @return  ZStatus_t
   2670           */
   2671          static ZStatus_t zclGeneral_ProcessInAlarmsClient( zclIncoming_t *pInMsg,
   2672                                                             zclGeneral_AppCallbacks_t *pCBs )
   2673          {
   2674            uint8 *pData = pInMsg->pData;
   2675            zclAlarm_t alarm;
   2676            ZStatus_t stat = ZSuccess;
   2677          
   2678            osal_memset( (uint8*)&alarm, 0, sizeof( zclAlarm_t ) );
   2679          
   2680            switch ( pInMsg->hdr.commandID )
   2681            {
   2682              case COMMAND_ALARMS_ALARM:
   2683                if ( pCBs->pfnAlarm )
   2684                {
   2685                  alarm.srcAddr = &(pInMsg->msg->srcAddr);
   2686                  alarm.cmdID = pInMsg->hdr.commandID;
   2687                  alarm.status = *pData++;
   2688                  alarm.alarmCode = *pData++;
   2689                  alarm.clusterID = BUILD_UINT16( pData[0], pData[1] );
   2690                  pData += 2;
   2691                  alarm.timeStamp = osal_build_uint32( pData, 4 );
   2692          
   2693                  pCBs->pfnAlarm( &alarm );
   2694                }
   2695                break;
   2696          
   2697              case COMMAND_ALARMS_GET_RSP:
   2698                if ( pCBs->pfnAlarm )
   2699                {
   2700                  alarm.srcAddr = &(pInMsg->msg->srcAddr);
   2701                  alarm.cmdID = pInMsg->hdr.commandID;
   2702                  alarm.alarmCode = *pData++;
   2703                  alarm.clusterID = BUILD_UINT16( pData[0], pData[1] );
   2704          
   2705                  pCBs->pfnAlarm( &alarm );
   2706                }
   2707                break;
   2708          
   2709              default:
   2710                stat = ZFailure;
   2711                break;
   2712            }
   2713          
   2714            return ( stat );
   2715          }
   2716          #endif // ZCL_ALARMS
   2717          
   2718          #ifdef ZCL_LOCATION
   2719          /*********************************************************************
   2720           * @fn      zclGeneral_ProcessInLocationServer
   2721           *
   2722           * @brief   Process in the received Location Command.
   2723           *
   2724           * @param   pInMsg - pointer to the incoming message
   2725           *
   2726           * @return  ZStatus_t
   2727           */
   2728          static ZStatus_t zclGeneral_ProcessInLocationServer( zclIncoming_t *pInMsg,
   2729                                                               zclGeneral_AppCallbacks_t *pCBs )
   2730          {
   2731            uint8 *pData = pInMsg->pData;
   2732            zclLocation_t cmd;
   2733            ZStatus_t stat = ZSuccess;
   2734          
   2735            osal_memset( (uint8*)&cmd, 0, sizeof( zclLocation_t ) );
   2736          
   2737            switch ( pInMsg->hdr.commandID )
   2738            {
   2739              case COMMAND_LOCATION_SET_ABSOLUTE:
   2740                cmd.un.absLoc.coordinate1 = BUILD_UINT16( pData[0], pData[1] );
   2741                pData += 2;
   2742                cmd.un.absLoc.coordinate2 = BUILD_UINT16( pData[0], pData[1] );
   2743                pData += 2;
   2744                cmd.un.absLoc.coordinate3 = BUILD_UINT16( pData[0], pData[1] );
   2745                pData += 2;
   2746                cmd.un.absLoc.power = BUILD_UINT16( pData[0], pData[1] );
   2747                pData += 2;
   2748                cmd.un.absLoc.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
   2749          
   2750                if ( pCBs->pfnLocation )
   2751                {
   2752                  cmd.srcAddr = &(pInMsg->msg->srcAddr);
   2753                  cmd.cmdID = pInMsg->hdr.commandID;
   2754          
   2755                  // Update the absolute location info
   2756                  pCBs->pfnLocation( &cmd );
   2757                }
   2758                break;
   2759          
   2760              case COMMAND_LOCATION_SET_DEV_CFG:
   2761                cmd.un.devCfg.power = BUILD_UINT16( pData[0], pData[1] );
   2762                pData += 2;
   2763                cmd.un.devCfg.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
   2764                pData += 2;
   2765                cmd.un.devCfg.calcPeriod = BUILD_UINT16( pData[0], pData[1] );
   2766                pData += 2;
   2767                cmd.un.devCfg.numMeasurements = *pData++;
   2768                cmd.un.devCfg.reportPeriod = BUILD_UINT16( pData[0], pData[1] );
   2769          
   2770                if ( pCBs->pfnLocation )
   2771                {
   2772                  cmd.srcAddr = &(pInMsg->msg->srcAddr);
   2773                  cmd.cmdID = pInMsg->hdr.commandID;
   2774          
   2775                  // Update the device configuration info
   2776                  pCBs->pfnLocation( &cmd );
   2777                }
   2778                break;
   2779          
   2780              case COMMAND_LOCATION_GET_DEV_CFG:
   2781                cmd.un.ieeeAddr = pData;
   2782          
   2783                if ( pCBs->pfnLocation )
   2784                {
   2785                  cmd.srcAddr = &(pInMsg->msg->srcAddr);
   2786                  cmd.cmdID = pInMsg->hdr.commandID;
   2787                  cmd.seqNum = pInMsg->hdr.transSeqNum;
   2788          
   2789                  // Retreive the Device Configuration
   2790                  pCBs->pfnLocation( &cmd );
   2791                }
   2792                stat = ZCL_STATUS_CMD_HAS_RSP;
   2793                break;
   2794          
   2795              case COMMAND_LOCATION_GET_DATA:
   2796                cmd.un.loc.bitmap.locByte = *pData++;
   2797                cmd.un.loc.numResponses = *pData++;
   2798          
   2799                if ( cmd.un.loc.brdcastResponse == 0 ) // command is sent as a unicast
   2800                  osal_cpyExtAddr( cmd.un.loc.targetAddr, pData );
   2801          
   2802                if ( pCBs->pfnLocation )
   2803                {
   2804                  cmd.srcAddr = &(pInMsg->msg->srcAddr);
   2805                  cmd.cmdID = pInMsg->hdr.commandID;
   2806                  cmd.seqNum = pInMsg->hdr.transSeqNum;
   2807          
   2808                  // Retreive the Location Data
   2809                  pCBs->pfnLocation( &cmd );
   2810                }
   2811                stat = ZCL_STATUS_CMD_HAS_RSP;
   2812                break;
   2813          
   2814              default:
   2815                stat = ZFailure;
   2816                break;
   2817            }
   2818          
   2819            return ( stat );
   2820          }
   2821          
   2822          /*********************************************************************
   2823           * @fn      zclGeneral_ProcessInLocationDataRsp
   2824           *
   2825           * @brief   Process in the received Location Command.
   2826           *
   2827           * @param   pInMsg - pointer to the incoming message
   2828           *
   2829           * @return  ZStatus_t
   2830           */
   2831          static void zclGeneral_ProcessInLocationDataRsp( zclIncoming_t *pInMsg,
   2832                                                           zclGeneral_AppCallbacks_t *pCBs )
   2833          {
   2834            uint8 *pData = pInMsg->pData;
   2835            zclLocationRsp_t rsp;
   2836          
   2837            osal_memset( (uint8*)&rsp, 0, sizeof( zclLocationRsp_t ) );
   2838          
   2839            if ( pCBs->pfnLocationRsp )
   2840            {
   2841              if ( pInMsg->hdr.commandID == COMMAND_LOCATION_DATA_RSP )
   2842                rsp.un.loc.status = *pData++;
   2843          
   2844              if ( pInMsg->hdr.commandID != COMMAND_LOCATION_DATA_RSP ||
   2845                   rsp.un.loc.status == ZCL_STATUS_SUCCESS )
   2846              {
   2847                rsp.un.loc.data.type = *pData++;
   2848                rsp.un.loc.data.absLoc.coordinate1 = BUILD_UINT16( pData[0], pData[1] );
   2849                pData += 2;
   2850                rsp.un.loc.data.absLoc.coordinate2 = BUILD_UINT16( pData[0], pData[1] );
   2851                pData += 2;
   2852          
   2853                if ( locationType2D( rsp.un.loc.data.type ) == 0 )
   2854                {
   2855                  rsp.un.loc.data.absLoc.coordinate3 = BUILD_UINT16( pData[0], pData[1] );
   2856                  pData += 2;
   2857                }
   2858          
   2859                if ( pInMsg->hdr.commandID != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
   2860                {
   2861                  rsp.un.loc.data.absLoc.power = BUILD_UINT16( pData[0], pData[1] );
   2862                  pData += 2;
   2863                  rsp.un.loc.data.absLoc.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
   2864                  pData += 2;
   2865                }
   2866          
   2867                if ( locationTypeAbsolute( rsp.un.loc.data.type ) == 0 )
   2868                {
   2869                  if ( pInMsg->hdr.commandID != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
   2870                    rsp.un.loc.data.calcLoc.locationMethod = *pData++;
   2871          
   2872                  rsp.un.loc.data.calcLoc.qualityMeasure = *pData++;
   2873                  rsp.un.loc.data.calcLoc.locationAge = BUILD_UINT16( pData[0], pData[1] );
   2874                }
   2875              }
   2876          
   2877              rsp.srcAddr = &(pInMsg->msg->srcAddr);
   2878              rsp.cmdID = pInMsg->hdr.commandID;
   2879          
   2880              // Notify the Application
   2881              pCBs->pfnLocationRsp( &rsp );
   2882            }
   2883          }
   2884          
   2885          /*********************************************************************
   2886           * @fn      zclGeneral_ProcessInLocationClient
   2887           *
   2888           * @brief   Process in the received Location Command.
   2889           *
   2890           * @param   pInMsg - pointer to the incoming message
   2891           *
   2892           * @return  ZStatus_t
   2893           */
   2894          static ZStatus_t zclGeneral_ProcessInLocationClient( zclIncoming_t *pInMsg,
   2895                                                               zclGeneral_AppCallbacks_t *pCBs )
   2896          {
   2897            uint8 *pData = pInMsg->pData;
   2898            zclLocationRsp_t rsp;
   2899            ZStatus_t stat = ZSuccess;
   2900          
   2901            osal_memset( (uint8*)&rsp, 0, sizeof( zclLocationRsp_t ) );
   2902          
   2903            switch ( pInMsg->hdr.commandID )
   2904            {
   2905              case COMMAND_LOCATION_DEV_CFG_RSP:
   2906                if ( pCBs->pfnLocationRsp )
   2907                {
   2908                  rsp.un.devCfg.status = *pData++;
   2909                  if ( rsp.un.devCfg.status == ZCL_STATUS_SUCCESS )
   2910                  {
   2911                    rsp.un.devCfg.data.power = BUILD_UINT16( pData[0], pData[1] );
   2912                    pData += 2;
   2913                    rsp.un.devCfg.data.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
   2914                    pData += 2;
   2915                    rsp.un.devCfg.data.calcPeriod = BUILD_UINT16( pData[0], pData[1] );
   2916                    pData += 2;
   2917                    rsp.un.devCfg.data.numMeasurements = *pData++;
   2918                    rsp.un.devCfg.data.reportPeriod = BUILD_UINT16( pData[0], pData[1] );
   2919          
   2920                    rsp.srcAddr = &(pInMsg->msg->srcAddr);
   2921                    rsp.cmdID = pInMsg->hdr.commandID;
   2922          
   2923                    // Notify the Application
   2924                    pCBs->pfnLocationRsp( &rsp );
   2925                  }
   2926                }
   2927                break;
   2928          
   2929              case COMMAND_LOCATION_DATA_RSP:
   2930              case COMMAND_LOCATION_DATA_NOTIF:
   2931              case COMMAND_LOCATION_COMPACT_DATA_NOTIF:
   2932                zclGeneral_ProcessInLocationDataRsp( pInMsg, pCBs );
   2933                break;
   2934          
   2935              case COMMAND_LOCATION_RSSI_PING:
   2936                if ( pCBs->pfnLocationRsp )
   2937                {
   2938                  rsp.un.locationType = *pData;
   2939          
   2940                  rsp.srcAddr = &(pInMsg->msg->srcAddr);
   2941                  rsp.cmdID = pInMsg->hdr.commandID;
   2942          
   2943                  // Notify the Application
   2944                  pCBs->pfnLocationRsp( &rsp );
   2945                }
   2946                break;
   2947          
   2948              default:
   2949                stat = ZFailure;
   2950                break;
   2951            }
   2952          
   2953            return ( stat );
   2954          }
   2955          #endif // ZCL_LOCATION
   2956          
   2957          #ifdef ZCL_SCENES
   2958          /*********************************************************************
   2959           * @fn      zclGeneral_ScenesInitNV
   2960           *
   2961           * @brief   Initialize the NV Scene Table Items
   2962           *
   2963           * @param   none
   2964           *
   2965           * @return  number of scenes
   2966           */
   2967          static uint8 zclGeneral_ScenesInitNV( void )
   2968          {
   2969            uint8  status;
   2970            uint16 size;
   2971          
   2972            size = (uint16)((sizeof ( nvGenScenesHdr_t ))
   2973                            + ( sizeof( zclGenSceneNVItem_t ) * ZCL_GEN_MAX_SCENES ));
   2974          
   2975            status = osal_nv_item_init( ZCD_NV_SCENE_TABLE, size, NULL );
   2976          
   2977            if ( status != ZSUCCESS )
   2978            {
   2979              zclGeneral_ScenesSetDefaultNV();
   2980            }
   2981          
   2982            return status;
   2983          }
   2984          
   2985          /*********************************************************************
   2986           * @fn          zclGeneral_ScenesSetDefaultNV
   2987           *
   2988           * @brief       Write the defaults to NV
   2989           *
   2990           * @param       none
   2991           *
   2992           * @return      none
   2993           */
   2994          static void zclGeneral_ScenesSetDefaultNV( void )
   2995          {
   2996            nvGenScenesHdr_t hdr;
   2997          
   2998            // Initialize the header
   2999            hdr.numRecs = 0;
   3000          
   3001            // Save off the header
   3002            osal_nv_write( ZCD_NV_SCENE_TABLE, 0, sizeof( nvGenScenesHdr_t ), &hdr );
   3003          }
   3004          
   3005          /*********************************************************************
   3006           * @fn          zclGeneral_ScenesWriteNV
   3007           *
   3008           * @brief       Save the Scene Table in NV
   3009           *
   3010           * @param       none
   3011           *
   3012           * @return      none
   3013           */
   3014          static void zclGeneral_ScenesWriteNV( void )
   3015          {
   3016            nvGenScenesHdr_t hdr;
   3017            zclGenSceneItem_t *pLoop;
   3018            zclGenSceneNVItem_t item;
   3019          
   3020            hdr.numRecs = 0;
   3021          
   3022            // Look for end of list
   3023            pLoop = zclGenSceneTable;
   3024            while ( pLoop )
   3025            {
   3026              // Build the record
   3027              item.endpoint = pLoop->endpoint;
   3028              osal_memcpy( &(item.scene), &(pLoop->scene), sizeof ( zclGeneral_Scene_t ) );
   3029          
   3030              // Save the record to NV
   3031              osal_nv_write( ZCD_NV_SCENE_TABLE,
   3032                      (uint16)((sizeof( nvGenScenesHdr_t )) + (hdr.numRecs * sizeof ( zclGenSceneNVItem_t ))),
   3033                              sizeof ( zclGenSceneNVItem_t ), &item );
   3034          
   3035              hdr.numRecs++;
   3036          
   3037              pLoop = pLoop->next;
   3038            }
   3039          
   3040            // Save off the header
   3041            osal_nv_write( ZCD_NV_SCENE_TABLE, 0, sizeof( nvGenScenesHdr_t ), &hdr );
   3042          }
   3043          
   3044          /*********************************************************************
   3045           * @fn          zclGeneral_ScenesRestoreFromNV
   3046           *
   3047           * @brief       Restore the Scene table from NV
   3048           *
   3049           * @param       none
   3050           *
   3051           * @return      Number of entries restored
   3052           */
   3053          static uint16 zclGeneral_ScenesRestoreFromNV( void )
   3054          {
   3055            uint16 x;
   3056            nvGenScenesHdr_t hdr;
   3057          
   3058            zclGenSceneNVItem_t item;
   3059            uint16 numAdded = 0;
   3060          
   3061            if ( osal_nv_read( ZCD_NV_SCENE_TABLE, 0, sizeof(nvGenScenesHdr_t), &hdr ) == ZSuccess )
   3062            {
   3063              // Read in the device list
   3064              for ( x = 0; x < hdr.numRecs; x++ )
   3065              {
   3066                if ( osal_nv_read( ZCD_NV_SCENE_TABLE,
   3067                          (uint16)(sizeof(nvGenScenesHdr_t) + (x * sizeof ( zclGenSceneNVItem_t ))),
   3068                                            sizeof ( zclGenSceneNVItem_t ), &item ) == ZSUCCESS )
   3069                {
   3070                  // Add the scene
   3071                  if ( zclGeneral_AddScene( item.endpoint, &(item.scene) ) == ZSuccess )
   3072                  {
   3073                    numAdded++;
   3074                  }
   3075                }
   3076              }
   3077            }
   3078          
   3079            return ( numAdded );
   3080          }
   3081          #endif // ZCL_SCENES
   3082          
   3083          /***************************************************************************
   3084          ****************************************************************************/

   Maximum stack usage in bytes:

     Function                       ISTACK PSTACK XSTACK
     --------                       ------ ------ ------
     zclGeneral_HdlInSpecificCommands
                                        0      0     10
       -> zclGeneral_ProcessInIdentity
                                        0      0     20
     zclGeneral_HdlIncoming             2      0      0
       -> zclGeneral_HdlInSpecificCommands
                                        4      0      0
     zclGeneral_ProcessInIdentity       0      0     38
       -> zclFindAttrRec                0      0     56
       -> zclReadAttrData               0      0     52
       -> zclGeneral_SendIdentifyQueryResponse
                                        0      0     56
     zclGeneral_RegisterCmdCallbacks
                                        1      0     14
       -> zcl_registerPlugin            0      0     28
       -> osal_mem_alloc                0      0     24
     zclGeneral_SendIdentify            1      0     25
       -> zcl_SendCommand               0      0     46
     zclGeneral_SendIdentifyQueryResponse
                                        1      0     51
       -> zcl_SendCommand               0      0     46


   Segment part sizes:

     Function/Label                               Bytes
     --------------                               -----
     zclGenCBs                                       2
     zclGenPluginRegisted                            1
     zclGeneral_RegisterCmdCallbacks
                                                   153
     ?Subroutine9                                    5
     zclGeneral_SendIdentify                        80
     ?Subroutine10                                  30
     ??Subroutine11_0                                5
     ?Subroutine1                                   13
     ?Subroutine0                                   17
     zclGeneral_SendIdentifyQueryResponse
                                                    79
     zclGeneral_HdlIncoming                         37
     zclGeneral_HdlInSpecificCommands
                                                   195
     ?Subroutine2                                    6
     ?Subroutine8                                   10
     ?Subroutine5                                    9
     ?Subroutine7                                    7
     ?Subroutine6                                   12
     zclGeneral_ProcessInIdentity                  339
     ?Subroutine4                                   10
     ?Subroutine3                                    6
     ??zclGeneral_RegisterCmdCallbacks?relay         6
     ??zclGeneral_SendIdentify?relay                 6
     ??zclGeneral_SendIdentifyQueryResponse?relay    6
     ??zclGeneral_HdlIncoming?relay                  6
     ??zclGeneral_HdlInSpecificCommands?relay        6
     ??zclGeneral_ProcessInIdentity?relay            6

 
 1 013 bytes in segment BANKED_CODE
    36 bytes in segment BANK_RELAYS
     3 bytes in segment XDATA_Z
 
 1 049 bytes of CODE  memory
     3 bytes of XDATA memory

Errors: none
Warnings: none
