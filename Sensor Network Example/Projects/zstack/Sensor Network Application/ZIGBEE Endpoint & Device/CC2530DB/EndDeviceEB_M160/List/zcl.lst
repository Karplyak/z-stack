###############################################################################
#                                                                             #
# IAR C/C++ Compiler V7.51A/W32 for 8051                02/Sep/2013  22:54:28 #
# Copyright 2004-2009 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  D:\GitHub\z-stack\Sensor Network                   #
#                          Example\Components\stack\zcl\zcl.c                 #
#    Command line       =  -f "D:\GitHub\z-stack\Sensor Network               #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\Tools\CC2530DB\f8wEndev.c #
#                          fg" (-DCPU32MHZ -DROOT=__near_func -DBLINK_LEDS)   #
#                          -f "D:\GitHub\z-stack\Sensor Network               #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig. #
#                          cfg" (-DSECURE=0 -DZG_SECURE_DYNAMIC=0             #
#                          -DREFLECTOR -DDEFAULT_CHANLIST=0x00000800          #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116 "-DCONST=const __code"    #
#                          -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=TRUE      #
#                          -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100            #
#                          -DRESPONSE_POLL_RATE=100 -DREJOIN_POLL_RATE=440)   #
#                          -f "D:\GitHub\z-stack\Sensor Network               #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\Tools\CC2530DB\f8wZCL.cfg #
#                          " (-DZCL_READ -DZCL_WRITE -DZCL_BASIC              #
#                          -DZCL_IDENTIFY -DZCL_ON_OFF -DZCL_KEY_ESTABLISH    #
#                          -DZCL_LOAD_CONTROL -DZCL_SIMPLE_METERING           #
#                          -DZCL_PRICING) -DZCL_MESSAGE                       #
#                          "D:\GitHub\z-stack\Sensor Network                  #
#                          Example\Components\stack\zcl\zcl.c" -D             #
#                          NWK_AUTO_POLL -D ZTOOL_P1 -D MT_TASK -D            #
#                          MT_APP_FUNC -D MT_SYS_FUNC -D MT_ZDO_FUNC -D       #
#                          LCD_SUPPORTED=DEBUG -D xPOWER_SAVING -D            #
#                          End_Device -D HAL_KEYPAD -D xPA2591 -D HAL_TIMER   #
#                          -D M160 -lC "D:\GitHub\z-stack\Sensor Network      #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\EndDeviceEB_M160\List\" -lA        #
#                          "D:\GitHub\z-stack\Sensor Network                  #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\EndDeviceEB_M160\List\"            #
#                          --diag_suppress Pe001,Pa010 -o                     #
#                          "D:\GitHub\z-stack\Sensor Network                  #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\EndDeviceEB_M160\Obj\" -e          #
#                          --require_prototypes --debug --core=plain          #
#                          --dptr=16,1 --data_model=large                     #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data_rom                  #
#                          --nr_virtual_regs 16 -I "D:\GitHub\z-stack\Sensor  #
#                          Network Example\Projects\zstack\Sensor Network     #
#                          Application\ZIGBEE Endpoint & Device\CC2530DB\"    #
#                          -I "D:\GitHub\z-stack\Sensor Network               #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\SOURCE\" -I                     #
#                          "D:\GitHub\z-stack\Sensor Network                  #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\SOURCE\" -I                  #
#                          "D:\GitHub\z-stack\Sensor Network                  #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\ZMAIN\TI2530DB\" -I       #
#                          "D:\GitHub\z-stack\Sensor Network                  #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\MT\" -I  #
#                          "D:\GitHub\z-stack\Sensor Network                  #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\INCL #
#                          UDE\" -I "D:\GitHub\z-stack\Sensor Network         #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\MODU #
#                          LE\" -I "D:\GitHub\z-stack\Sensor Network          #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\TARG #
#                          ET\CC2530EB\" -I "D:\GitHub\z-stack\Sensor         #
#                          Network Example\Projects\zstack\Sensor Network     #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\OSAL\MCU #
#                          \CCSOC\" -I "D:\GitHub\z-stack\Sensor Network      #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\OSAL\INC #
#                          LUDE\" -I "D:\GitHub\z-stack\Sensor Network        #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\AF #
#                          \" -I "D:\GitHub\z-stack\Sensor Network            #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\NW #
#                          K\" -I "D:\GitHub\z-stack\Sensor Network           #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SE #
#                          C\" -I "D:\GitHub\z-stack\Sensor Network           #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SA #
#                          PI\" -I "D:\GitHub\z-stack\Sensor Network          #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SY #
#                          S\" -I "D:\GitHub\z-stack\Sensor Network           #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\ZC #
#                          L\" -I "D:\GitHub\z-stack\Sensor Network           #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\ZD #
#                          O\" -I "D:\GitHub\z-stack\Sensor Network           #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\ZMAC\F8W #
#                          \" -I "D:\GitHub\z-stack\Sensor Network            #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\ZMAC\"   #
#                          -I "D:\GitHub\z-stack\Sensor Network               #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\SERVICES #
#                          \SADDR\" -I "D:\GitHub\z-stack\Sensor Network      #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\SERVICES #
#                          \SDATA\" -I "D:\GitHub\z-stack\Sensor Network      #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\INCL #
#                          UDE\" -I "D:\GitHub\z-stack\Sensor Network         #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\HIGH #
#                          _LEVEL\" -I "D:\GitHub\z-stack\Sensor Network      #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\LOW_ #
#                          LEVEL\srf04\" -I "D:\GitHub\z-stack\Sensor         #
#                          Network Example\Projects\zstack\Sensor Network     #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\LOW_ #
#                          LEVEL\srf04\SINGLE_CHIP\" -I "C:\Program Files     #
#                          (x86)\IAR Systems\Embedded Workbench               #
#                          5.3\8051\INC\" -I "C:\Program Files (x86)\IAR      #
#                          Systems\Embedded Workbench 5.3\8051\INC\CLIB\"     #
#                          -Ohz                                               #
#    List file          =  D:\GitHub\z-stack\Sensor Network                   #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\EndDeviceEB_M160\List\zcl.lst      #
#    Object file        =  D:\GitHub\z-stack\Sensor Network                   #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\EndDeviceEB_M160\Obj\zcl.r51       #
#                                                                             #
#                                                                             #
###############################################################################

D:\GitHub\z-stack\Sensor Network Example\Components\stack\zcl\zcl.c
      1          #include "ZComDef.h"
      2          #include "OSAL.h"
      3          #include "OSAL_Tasks.h"
      4          #include "AF.h"
      5          #include "ZDConfig.h"
      6          #include "zcl.h"
      7          #include "zcl_general.h"
      8          #include <string.h>
      9          #include <stdio.h>
     10          
     11          #if defined ( INTER_PAN )
     12            #include "stub_aps.h"
     13          #endif
     14          
     15          #include "hal_uart.h"
     16          #include "hal_timer.h"
     17          #include "hal_led.h"
     18          #if defined (LCD_SUPPORTED)
     19            #include "hal_lcd.h"
     20          #endif
     21          
     22          #if defined(M160)
     23            #include "hal_sensor.h"
     24            #include "M160.h"
     25          #endif 
     26          
     27          /* MT */
     28          #include "MT_UART.h"
     29          #include "MT.h"
     30          
     31          /*** Frame Control ***/
     32          #define zcl_FCType( a )               ( (a) & ZCL_FRAME_CONTROL_TYPE )
     33          #define zcl_FCManuSpecific( a )       ( (a) & ZCL_FRAME_CONTROL_MANU_SPECIFIC )
     34          #define zcl_FCDirection( a )          ( (a) & ZCL_FRAME_CONTROL_DIRECTION )
     35          #define zcl_FCDisableDefaultRsp( a )  ( (a) & ZCL_FRAME_CONTROL_DISABLE_DEFAULT_RSP )
     36          
     37          /*** Attribute Access Control ***/
     38          #define zcl_AccessCtrlRead( a )       ( (a) & ACCESS_CONTROL_READ )
     39          #define zcl_AccessCtrlWrite( a )      ( (a) & ACCESS_CONTROL_WRITE )
     40          #define zcl_AccessCtrlCmd( a )        ( (a) & ACCESS_CONTROL_CMD )
     41          
     42          #define zclParseCmd( a, b )           zclCmdTable[(a)].pfnParseInProfile( (b) )
     43          #define zclProcessCmd( a, b )         zclCmdTable[(a)].pfnProcessInProfile( (b) )
     44          
     45          #define zcl_DefaultRspCmd( zclHdr )   ( zcl_ProfileCmd( (zclHdr).fc.type )     && \
     46                                                  (zclHdr).fc.manuSpecific == 0          && \
     47                                                  (zclHdr).commandID == ZCL_CMD_DEFAULT_RSP )
     48          
     49          // Commands that have corresponding responses
     50          #define CMD_HAS_RSP( cmd )            ( (cmd) == ZCL_CMD_READ            || \
     51                                                  (cmd) == ZCL_CMD_WRITE           || \
     52                                                  (cmd) == ZCL_CMD_WRITE_UNDIVIDED || \
     53                                                  (cmd) == ZCL_CMD_CONFIG_REPORT   || \
     54                                                  (cmd) == ZCL_CMD_READ_REPORT_CFG || \
     55                                                  (cmd) == ZCL_CMD_DISCOVER        || \
     56                                                  (cmd) == ZCL_CMD_DEFAULT_RSP ) // exception
     57          
     58          typedef struct zclLibPlugin
     59          {
     60            struct zclLibPlugin *next;
     61            uint16              startClusterID;    // starting cluster ID
     62            uint16              endClusterID;      // ending cluster ID
     63            zclInHdlr_t         pfnIncomingHdlr;    // function to handle incoming message
     64          } zclLibPlugin_t;
     65          
     66          // Attribute record list item
     67          typedef struct zclAttrRecsList
     68          {
     69            struct zclAttrRecsList *next;
     70            uint8                  endpoint;      // Used to link it into the endpoint descriptor
     71            uint8                  numAttributes; // Number of the following records
     72            CONST zclAttrRec_t     *attrs;        // attribute records
     73          } zclAttrRecsList;
     74          
     75          // Cluster option list item
     76          typedef struct zclClusterOptionList
     77          {
     78            struct zclClusterOptionList *next;
     79            uint8                       endpoint;   // Used to link it into the endpoint descriptor
     80            uint8                       numOptions; // Number of the following records
     81            zclOptionRec_t              *options;   // option records
     82          } zclClusterOptionList;
     83          
     84          typedef void *(*zclParseInProfileCmd_t)( zclParseCmd_t *pCmd );
     85          typedef uint8 (*zclProcessInProfileCmd_t)( zclIncoming_t *pInMsg );
     86          
     87          typedef struct
     88          {
     89            zclParseInProfileCmd_t   pfnParseInProfile;
     90            zclProcessInProfileCmd_t pfnProcessInProfile;
     91          } zclCmdItems_t;
     92          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     93          uint8 zcl_TaskID;
   \                     zcl_TaskID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
     94          
     95          // global entry

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     96          char global_entry[4];
   \                     global_entry:
   \   000000                DS 4
   \   000004                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     97          byte global_recv_data[30];
   \                     global_recv_data:
   \   000000                DS 30
   \   00001E                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     98          uint8 global_data_length;
   \                     global_data_length:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
     99          
    100          // The task Id of the Application where the unprocessed Foundation
    101          // Command/Response messages will be sent to.

   \                                 In  segment XDATA_I, align 1, keep-with-next
    102          uint8 zcl_RegisteredMsgTaskID = TASK_NO_TASK;
   \                     zcl_RegisteredMsgTaskID:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for zcl_RegisteredMsgTaskID>`
   \   000001                REQUIRE __INIT_XDATA_I
    103          
    104          // The Application should register its attribute data validation function

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    105          zclValidateAttrData_t zcl_ValidateAttrDataCB = NULL;
   \                     zcl_ValidateAttrDataCB:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    106          
    107          // ZCL Sequence number

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    108          uint8 zcl_SeqNum = 0x00;
   \                     zcl_SeqNum:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    109          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    110          static zclLibPlugin_t *plugins;
   \                     plugins:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    111          static zclAttrRecsList *attrList;
   \                     attrList:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    112          static zclClusterOptionList *clusterOptionList;
   \                     clusterOptionList:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    113          static uint8 zcl_TransID = 0;  // This is the unique message ID (counter)
   \                     zcl_TransID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    114          
    115          void zclProcessMessageMSG( afIncomingMSGPacket_t *pkt );  // Not static for ZNP build.
    116          void zclZigbeeReceiverMSG(afIncomingMSGPacket_t *msg);
    117          
    118          static uint8 *zclBuildHdr( zclFrameHdr_t *hdr, uint8 *pData );
    119          static uint8 zclCalcHdrSize( zclFrameHdr_t *hdr );
    120          static zclLibPlugin_t *zclFindPlugin( uint16 clusterID, uint16 profileID );
    121          static zclOptionRec_t *zclFindClusterOption( uint8 endpoint, uint16 clusterID );
    122          static uint8 zclGetClusterOption( uint8 endpoint, uint16 clusterID );
    123          static void zclSetSecurityOption( uint8 endpoint, uint16 clusterID, uint8 enable );
    124          
    125          static uint8 zcl_DeviceOperational( uint8 srcEP, uint16 clusterID, uint8 frameType, uint8 cmd, uint16 profileID );
    126          
    127          #if defined(ZCL_READ) || defined(ZCL_WRITE) || defined(ZCL_REPORT)
    128            static void zclSerializeData( uint8 dataType, void *attrData, uint8 *buf );
    129          #endif // ZCL_READ || ZCL_WRITE || ZCL_REPORT
    130          
    131          #ifdef ZCL_READ
    132            static void *zclParseInReadRspCmd( zclParseCmd_t *pCmd );
    133            static uint8 zclProcessInReadCmd( zclIncoming_t *pInMsg );
    134          #endif // ZCL_READ
    135          
    136          #ifdef ZCL_WRITE
    137            static uint8 zclWriteAttrData( zclAttrRec_t *pAttr, zclWriteRec_t *pWriteRec );
    138            static void *zclParseInWriteRspCmd( zclParseCmd_t *pCmd );
    139            static uint8 zclProcessInWriteCmd( zclIncoming_t *pInMsg );
    140            static uint8 zclProcessInWriteUndividedCmd( zclIncoming_t *pInMsg );
    141          #endif // ZCL_WRITE
    142          
    143          #ifdef ZCL_REPORT
    144            static void *zclParseInConfigReportRspCmd( zclParseCmd_t *pCmd );
    145            static void *zclParseInReadReportCfgRspCmd( zclParseCmd_t *pCmd );
    146          #endif // ZCL_REPORT
    147          
    148          static void *zclParseInDefaultRspCmd( zclParseCmd_t *pCmd );
    149          
    150          #ifdef ZCL_DISCOVER
    151            static uint8 zclFindNextAttrRec( uint8 endpoint, uint16 clusterID, uint16 *attrId, zclAttrRec_t *pAttr );
    152            static void *zclParseInDiscRspCmd( zclParseCmd_t *pCmd );
    153            static uint8 zclProcessInDiscCmd( zclIncoming_t *pInMsg );
    154          #endif // ZCL_DISCOVER
    155          
    156          static uint8 zclSendMsg( zclIncoming_t *pInMsg );
    157          

   \                                 In  segment CODE_C, align 1
   \   000000   ........     DW ??zclParseInReadCmd?relay, ??zclProcessInReadCmd?relay
   \   000004   ........     DW ??zclParseInReadRspCmd?relay, ??zclSendMsg?relay
   \   000008   ........     DW ??zclParseInWriteCmd?relay, ??zclProcessInWriteCmd?relay
   \   00000C   ........     DW ??zclParseInWriteCmd?relay, ??zclProcessInWriteUndividedCmd?relay
   \   000010   ........     DW ??zclParseInWriteRspCmd?relay, ??zclSendMsg?relay
   \   000014   ........     DW ??zclParseInWriteCmd?relay, ??zclProcessInWriteCmd?relay, 0H, 0H, 0H
   \            00000000
   \            0000    
   \   00001E   00000000     DW 0H, 0H, 0H, 0H, 0H, 0H, 0H, ??zclParseInDefaultRspCmd?relay
   \            00000000
   \            00000000
   \            0000....
   \   00002E   ....0000     DW ??zclSendMsg?relay, 0H, 0H, 0H, 0H
   \            00000000
   \            0000    
    158          static CONST zclCmdItems_t zclCmdTable[] =
    159          {
    160          #ifdef ZCL_READ
    161            /* ZCL_CMD_READ */                { zclParseInReadCmd,             zclProcessInReadCmd             },
    162            /* ZCL_CMD_READ_RSP */            { zclParseInReadRspCmd,          zclSendMsg                      },
    163          #else
    164            /* ZCL_CMD_READ */                { NULL,                          NULL                            },
    165            /* ZCL_CMD_READ_RSP */            { NULL,                          NULL                            },
    166          #endif // ZCL_READ
    167          
    168          #ifdef ZCL_WRITE
    169            /* ZCL_CMD_WRITE */               { zclParseInWriteCmd,            zclProcessInWriteCmd            },
    170            /* ZCL_CMD_WRITE_UNDIVIDED */     { zclParseInWriteCmd,            zclProcessInWriteUndividedCmd   },
    171            /* ZCL_CMD_WRITE_RSP */           { zclParseInWriteRspCmd,         zclSendMsg                      },
    172            /* ZCL_CMD_WRITE_NO_RSP */        { zclParseInWriteCmd,            zclProcessInWriteCmd            },
    173          #else
    174            /* ZCL_CMD_WRITE */               { NULL,                          NULL                            },
    175            /* ZCL_CMD_WRITE_UNDIVIDED */     { NULL,                          NULL                            },
    176            /* ZCL_CMD_WRITE_RSP */           { NULL,                          NULL                            },
    177            /* ZCL_CMD_WRITE_NO_RSP */        { NULL,                          NULL                            },
    178          #endif // ZCL_WRITE
    179          
    180          #ifdef ZCL_REPORT
    181            /* ZCL_CMD_CONFIG_REPORT */       { zclParseInConfigReportCmd,     zclSendMsg                      },
    182            /* ZCL_CMD_CONFIG_REPORT_RSP */   { zclParseInConfigReportRspCmd,  zclSendMsg                      },
    183            /* ZCL_CMD_READ_REPORT_CFG */     { zclParseInReadReportCfgCmd,    zclSendMsg                      },
    184            /* ZCL_CMD_READ_REPORT_CFG_RSP */ { zclParseInReadReportCfgRspCmd, zclSendMsg                      },
    185            /* ZCL_CMD_REPORT */              { zclParseInReportCmd,           zclSendMsg                      },
    186          #else
    187            /* ZCL_CMD_CONFIG_REPORT */       { NULL,                          NULL                            },
    188            /* ZCL_CMD_CONFIG_REPORT_RSP */   { NULL,                          NULL                            },
    189            /* ZCL_CMD_READ_REPORT_CFG */     { NULL,                          NULL                            },
    190            /* ZCL_CMD_READ_REPORT_CFG_RSP */ { NULL,                          NULL                            },
    191            /* ZCL_CMD_REPORT */              { NULL,                          NULL                            },
    192          #endif // ZCL_REPORT
    193          
    194            /* ZCL_CMD_DEFAULT_RSP */         { zclParseInDefaultRspCmd,       zclSendMsg                      },
    195            
    196          #ifdef ZCL_DISCOVER  
    197            /* ZCL_CMD_DISCOVER */            { zclParseInDiscCmd,             zclProcessInDiscCmd             },
    198            /* ZCL_CMD_DISCOVER_RSP */        { zclParseInDiscRspCmd,          zclSendMsg                      }
    199          #else
    200            /* ZCL_CMD_DISCOVER */            { NULL,                          NULL                            },
    201            /* ZCL_CMD_DISCOVER_RSP */        { NULL,                          NULL                            }
    202          #endif // ZCL_DISCOVER
    203          };
    204          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    205          void zcl_Init( uint8 task_id )
   \                     zcl_Init:
    206          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    207            zcl_TaskID = task_id;
   \   000004   E9           MOV     A,R1
   \   000005   90....       MOV     DPTR,#zcl_TaskID
   \   000008   F0           MOVX    @DPTR,A
    208          
    209            plugins = (zclLibPlugin_t  *)NULL;
   \   000009   90....       MOV     DPTR,#plugins
   \   00000C   E4           CLR     A
   \   00000D   F0           MOVX    @DPTR,A
   \   00000E   A3           INC     DPTR
   \   00000F   F0           MOVX    @DPTR,A
    210            attrList = (zclAttrRecsList *)NULL;
   \   000010   90....       MOV     DPTR,#attrList
   \   000013   F0           MOVX    @DPTR,A
   \   000014   A3           INC     DPTR
   \   000015   F0           MOVX    @DPTR,A
    211            clusterOptionList = (zclClusterOptionList *)NULL;
   \   000016   90....       MOV     DPTR,#clusterOptionList
   \   000019   F0           MOVX    @DPTR,A
   \   00001A   A3           INC     DPTR
   \   00001B   F0           MOVX    @DPTR,A
    212          }
   \   00001C   02....       LJMP    ?Subroutine84 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine84:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET
    213          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    214          uint16 zcl_event_loop( uint8 task_id, uint16 events )
   \                     zcl_event_loop:
    215          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
    216            uint8 *msgPtr;
    217            (void)task_id;  // Intentionally unreferenced parameter
    218            
    219            if ( events & SYS_EVENT_MSG )
   \   000009   7480         MOV     A,#-0x80
   \   00000B   55..         ANL     A,?V0 + 1
   \   00000D   F9           MOV     R1,A
   \   00000E   E4           CLR     A
   \   00000F   7001         JNZ     ??zcl_event_loop_0
   \   000011   E9           MOV     A,R1
   \                     ??zcl_event_loop_0:
   \   000012   604B         JZ      ??zcl_event_loop_1
    220            {
    221              msgPtr = osal_msg_receive( zcl_TaskID );
   \   000014                ; Setup parameters for call to function osal_msg_receive
   \   000014   800E         SJMP    ??zcl_event_loop_2
    222              while ( msgPtr != NULL )
    223              {
    224                uint8 dealloc = TRUE;
    225                
    226                if ( *msgPtr == AF_INCOMING_MSG_CMD )
    227                {
    228                  zclProcessMessageMSG( (afIncomingMSGPacket_t *)msgPtr );
   \                     ??zcl_event_loop_3:
   \   000016                ; Setup parameters for call to function zclProcessMessageMSG
   \   000016   EE           MOV     A,R6
   \   000017   FA           MOV     R2,A
   \   000018   EF           MOV     A,R7
   \   000019   FB           MOV     R3,A
   \   00001A   12....       LCALL   ??zclProcessMessageMSG?relay
    229                }
    230                else if ( zcl_RegisteredMsgTaskID != TASK_NO_TASK )
    231                {
    232                  osal_msg_send( zcl_RegisteredMsgTaskID, msgPtr ); // send it to another task to process.
    233                  dealloc = FALSE;
    234                }
    235                if ( dealloc ) // Release the memory
    236                {
    237                  osal_msg_deallocate( msgPtr );
   \                     ??zcl_event_loop_4:
   \   00001D                ; Setup parameters for call to function osal_msg_deallocate
   \   00001D   EE           MOV     A,R6
   \   00001E   FA           MOV     R2,A
   \   00001F   EF           MOV     A,R7
   \   000020   FB           MOV     R3,A
   \   000021   12....       LCALL   ??osal_msg_deallocate?relay
    238                }
    239                msgPtr = osal_msg_receive( zcl_TaskID ); // Next
   \                     ??zcl_event_loop_2:
   \   000024                ; Setup parameters for call to function osal_msg_receive
   \   000024   90....       MOV     DPTR,#zcl_TaskID
   \   000027   E0           MOVX    A,@DPTR
   \   000028   F9           MOV     R1,A
   \   000029   12....       LCALL   ??osal_msg_receive?relay
   \   00002C   8A..         MOV     ?V0 + 2,R2
   \   00002E   8B..         MOV     ?V0 + 3,R3
   \   000030   AE..         MOV     R6,?V0 + 2
   \   000032   AF..         MOV     R7,?V0 + 3
   \   000034   EE           MOV     A,R6
   \   000035   7001         JNZ     ??zcl_event_loop_5
   \   000037   EF           MOV     A,R7
   \                     ??zcl_event_loop_5:
   \   000038   601C         JZ      ??zcl_event_loop_6
   \   00003A   8E82         MOV     DPL,R6
   \   00003C   8F83         MOV     DPH,R7
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   641A         XRL     A,#0x1a
   \   000041   60D3         JZ      ??zcl_event_loop_3
   \   000043   90....       MOV     DPTR,#zcl_RegisteredMsgTaskID
   \   000046   E0           MOVX    A,@DPTR
   \   000047   64FF         XRL     A,#0xff
   \   000049   60D2         JZ      ??zcl_event_loop_4
   \   00004B                ; Setup parameters for call to function osal_msg_send
   \   00004B   EE           MOV     A,R6
   \   00004C   FA           MOV     R2,A
   \   00004D   EF           MOV     A,R7
   \   00004E   FB           MOV     R3,A
   \   00004F   E0           MOVX    A,@DPTR
   \   000050   F9           MOV     R1,A
   \   000051   12....       LCALL   ??osal_msg_send?relay
   \   000054   80CE         SJMP    ??zcl_event_loop_2
    240              } 
    241              return (events ^ SYS_EVENT_MSG);// return unprocessed events
   \                     ??zcl_event_loop_6:
   \   000056   AA..         MOV     R2,?V0 + 0
   \   000058   7480         MOV     A,#-0x80
   \   00005A   65..         XRL     A,?V0 + 1
   \   00005C   FB           MOV     R3,A
   \   00005D   8004         SJMP    ??zcl_event_loop_7
    242            }
    243            return 0; // Discard unknown events
   \                     ??zcl_event_loop_1:
   \   00005F   7A00         MOV     R2,#0x0
   \   000061   7B00         MOV     R3,#0x0
   \                     ??zcl_event_loop_7:
   \   000063   02....       LJMP    ?Subroutine85 & 0xFFFF
    244          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine85:
   \   000000   7F04         MOV     R7,#0x4
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    245          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    246          ZStatus_t zcl_registerPlugin( uint16 startClusterID,
   \                     zcl_registerPlugin:
    247                    uint16 endClusterID, zclInHdlr_t pfnIncomingHdlr )
    248          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
   \   000009   8C..         MOV     ?V0 + 2,R4
   \   00000B   8D..         MOV     ?V0 + 3,R5
   \   00000D   740E         MOV     A,#0xe
   \   00000F   12....       LCALL   ?XSTACK_DISP0_8
   \   000012   12....       LCALL   ?Subroutine35 & 0xFFFF
    249            zclLibPlugin_t *pNewItem;
    250            zclLibPlugin_t *pLoop;
    251          
    252            // Fill in the new profile list
    253            pNewItem = osal_mem_alloc( sizeof( zclLibPlugin_t ) );
   \                     ??CrossCallReturnLabel_47:
   \   000015                ; Setup parameters for call to function osal_mem_alloc
   \   000015   7A08         MOV     R2,#0x8
   \   000017   7B00         MOV     R3,#0x0
   \   000019   12....       LCALL   ??osal_mem_alloc?relay
   \   00001C   8A..         MOV     ?V0 + 4,R2
   \   00001E   8B..         MOV     ?V0 + 5,R3
   \   000020   A8..         MOV     R0,?V0 + 4
   \   000022   A9..         MOV     R1,?V0 + 5
    254            if ( pNewItem == NULL )
   \   000024   E8           MOV     A,R0
   \   000025   7001         JNZ     ??zcl_registerPlugin_0
   \   000027   E9           MOV     A,R1
   \                     ??zcl_registerPlugin_0:
   \   000028   7004         JNZ     ??zcl_registerPlugin_1
    255              return (ZMemError);
   \   00002A   7910         MOV     R1,#0x10
   \   00002C   8055         SJMP    ??CrossCallReturnLabel_14
    256          
    257            // Fill in the plugin record.
    258            pNewItem->next = (zclLibPlugin_t *)NULL;
   \                     ??zcl_registerPlugin_1:
   \   00002E   8882         MOV     DPL,R0
   \   000030   8983         MOV     DPH,R1
   \   000032   E4           CLR     A
   \   000033   F0           MOVX    @DPTR,A
   \   000034   A3           INC     DPTR
   \   000035   12....       LCALL   ?Subroutine14 & 0xFFFF
    259            pNewItem->startClusterID = startClusterID;
   \                     ??CrossCallReturnLabel_19:
   \   000038   A3           INC     DPTR
   \   000039   E5..         MOV     A,?V0 + 0
   \   00003B   F0           MOVX    @DPTR,A
   \   00003C   A3           INC     DPTR
   \   00003D   E5..         MOV     A,?V0 + 1
   \   00003F   12....       LCALL   ?Subroutine14 & 0xFFFF
    260            pNewItem->endClusterID = endClusterID;
   \                     ??CrossCallReturnLabel_20:
   \   000042   A3           INC     DPTR
   \   000043   A3           INC     DPTR
   \   000044   A3           INC     DPTR
   \   000045   E5..         MOV     A,?V0 + 2
   \   000047   F0           MOVX    @DPTR,A
   \   000048   A3           INC     DPTR
   \   000049   E5..         MOV     A,?V0 + 3
   \   00004B   F0           MOVX    @DPTR,A
    261            pNewItem->pfnIncomingHdlr = pfnIncomingHdlr;
   \   00004C   EE           MOV     A,R6
   \   00004D   FA           MOV     R2,A
   \   00004E   EF           MOV     A,R7
   \   00004F   FB           MOV     R3,A
   \   000050   8882         MOV     DPL,R0
   \   000052   8983         MOV     DPH,R1
   \   000054   A3           INC     DPTR
   \   000055   A3           INC     DPTR
   \   000056   A3           INC     DPTR
   \   000057   A3           INC     DPTR
   \   000058   A3           INC     DPTR
   \   000059   A3           INC     DPTR
   \   00005A   EA           MOV     A,R2
   \   00005B   F0           MOVX    @DPTR,A
   \   00005C   A3           INC     DPTR
   \   00005D   EB           MOV     A,R3
   \   00005E   F0           MOVX    @DPTR,A
    262          
    263            if (  plugins == NULL ) // Find spot in list
   \   00005F   90....       MOV     DPTR,#plugins
   \   000062   E0           MOVX    A,@DPTR
   \   000063   7002         JNZ     ??zcl_registerPlugin_2
   \   000065   A3           INC     DPTR
   \   000066   E0           MOVX    A,@DPTR
   \                     ??zcl_registerPlugin_2:
   \   000067   90....       MOV     DPTR,#plugins
   \   00006A   6014         JZ      ??zcl_registerPlugin_3
    264            {
    265              plugins = pNewItem;
    266            }
    267            else
    268            {
    269              // Look for end of list
    270              pLoop = plugins;
   \   00006C   12....       LCALL   ?Subroutine70 & 0xFFFF
   \                     ??CrossCallReturnLabel_209:
   \   00006F   8003         SJMP    ??zcl_registerPlugin_4
    271              while ( pLoop->next != NULL )
    272                pLoop = pLoop->next;
   \                     ??zcl_registerPlugin_5:
   \   000071   EA           MOV     A,R2
   \   000072   FC           MOV     R4,A
   \   000073   EB           MOV     A,R3
   \                     ??zcl_registerPlugin_4:
   \   000074   12....       LCALL   ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_133:
   \   000077   7001         JNZ     ??zcl_registerPlugin_6
   \   000079   EB           MOV     A,R3
   \                     ??zcl_registerPlugin_6:
   \   00007A   70F5         JNZ     ??zcl_registerPlugin_5
    273          
    274              pLoop->next = pNewItem; // Put new item at end of list
   \   00007C   8C82         MOV     DPL,R4
   \   00007E   8D83         MOV     DPH,R5
    275            }
   \                     ??zcl_registerPlugin_3:
   \   000080   12....       LCALL   ?Subroutine11 & 0xFFFF
    276            return ( ZSuccess );
   \                     ??CrossCallReturnLabel_14:
   \   000083                REQUIRE ?Subroutine86
   \   000083                ; // Fall through to label ?Subroutine86
    277          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine86:
   \   000000   7F06         MOV     R7,#0x6
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine30:
   \   000000   FD           MOV     R5,A
   \   000001   8C82         MOV     DPL,R4
   \   000003   8D83         MOV     DPH,R5
   \   000005                REQUIRE ??Subroutine101_0
   \   000005                ; // Fall through to label ??Subroutine101_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine101_0:
   \   000000   12....       LCALL   ?Subroutine66 & 0xFFFF
   \                     ??CrossCallReturnLabel_206:
   \   000003   EA           MOV     A,R2
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004   F0           MOVX    @DPTR,A
   \   000005   7900         MOV     R1,#0x0
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   12....       LCALL   ?Subroutine79 & 0xFFFF
   \                     ??CrossCallReturnLabel_104:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine79:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8882         MOV     DPL,R0
   \   000003   8983         MOV     DPH,R1
   \   000005   A3           INC     DPTR
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine70:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FC           MOV     R4,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine66:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine35:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FE           MOV     R6,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FF           MOV     R7,A
   \   000005   22           RET
    278          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    279          ZStatus_t zcl_registerAttrList( uint8 endpoint, uint8 numAttr, CONST zclAttrRec_t newAttrList[] )
   \                     zcl_registerAttrList:
    280          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   12....       LCALL   ?Subroutine50 & 0xFFFF
    281            zclAttrRecsList *pNewItem;
    282            zclAttrRecsList *pLoop;
    283          
    284            pNewItem = osal_mem_alloc( sizeof( zclAttrRecsList ) ); // Fill in the new profile list
    285            if ( pNewItem == NULL )
   \                     ??CrossCallReturnLabel_64:
   \   000008   7001         JNZ     ??zcl_registerAttrList_0
   \   00000A   E9           MOV     A,R1
   \                     ??zcl_registerAttrList_0:
   \   00000B   7004         JNZ     ??zcl_registerAttrList_1
    286              return (ZMemError);
   \   00000D   7910         MOV     R1,#0x10
   \   00000F   8027         SJMP    ??CrossCallReturnLabel_15
    287          
    288            pNewItem->next = (zclAttrRecsList *)NULL;
   \                     ??zcl_registerAttrList_1:
   \   000011   12....       LCALL   ?Subroutine0 & 0xFFFF
    289            pNewItem->endpoint = endpoint;
    290            pNewItem->numAttributes = numAttr;
    291            pNewItem->attrs = newAttrList;
    292          
    293            if ( attrList == NULL ) // Find spot in list
   \                     ??CrossCallReturnLabel_0:
   \   000014   90....       MOV     DPTR,#attrList
   \   000017   E0           MOVX    A,@DPTR
   \   000018   7002         JNZ     ??zcl_registerAttrList_2
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \                     ??zcl_registerAttrList_2:
   \   00001C   90....       MOV     DPTR,#attrList
   \   00001F   6014         JZ      ??zcl_registerAttrList_3
    294            {
    295              attrList = pNewItem;
    296            }
    297            else
    298            {
    299              pLoop = attrList; // Look for end of list
   \   000021   12....       LCALL   ?Subroutine70 & 0xFFFF
   \                     ??CrossCallReturnLabel_210:
   \   000024   8003         SJMP    ??zcl_registerAttrList_4
    300              while ( pLoop->next != NULL )
    301                pLoop = pLoop->next;
   \                     ??zcl_registerAttrList_5:
   \   000026   EA           MOV     A,R2
   \   000027   FC           MOV     R4,A
   \   000028   EB           MOV     A,R3
   \                     ??zcl_registerAttrList_4:
   \   000029   12....       LCALL   ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_134:
   \   00002C   7001         JNZ     ??zcl_registerAttrList_6
   \   00002E   EB           MOV     A,R3
   \                     ??zcl_registerAttrList_6:
   \   00002F   70F5         JNZ     ??zcl_registerAttrList_5
    302          
    303              pLoop->next = pNewItem; // Put new item at end of list
   \   000031   8C82         MOV     DPL,R4
   \   000033   8D83         MOV     DPH,R5
    304            }
   \                     ??zcl_registerAttrList_3:
   \   000035   12....       LCALL   ?Subroutine11 & 0xFFFF
    305            return ( ZSuccess );
   \                     ??CrossCallReturnLabel_15:
   \   000038   02....       LJMP    ?Subroutine85 & 0xFFFF
    306          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine50:
   \   000000   89..         MOV     ?V0 + 0,R1
   \   000002   8A..         MOV     ?V0 + 1,R2
   \   000004   EC           MOV     A,R4
   \   000005   FE           MOV     R6,A
   \   000006   ED           MOV     A,R5
   \   000007   FF           MOV     R7,A
   \   000008                ; Setup parameters for call to function osal_mem_alloc
   \   000008                ; Setup parameters for call to function osal_mem_alloc
   \   000008   7A06         MOV     R2,#0x6
   \   00000A   7B00         MOV     R3,#0x0
   \   00000C   12....       LCALL   ??osal_mem_alloc?relay
   \   00000F   8A..         MOV     ?V0 + 2,R2
   \   000011   8B..         MOV     ?V0 + 3,R3
   \   000013   A8..         MOV     R0,?V0 + 2
   \   000015   A9..         MOV     R1,?V0 + 3
   \   000017   E8           MOV     A,R0
   \   000018   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   8882         MOV     DPL,R0
   \   000002   8983         MOV     DPH,R1
   \   000004   E4           CLR     A
   \   000005   F0           MOVX    @DPTR,A
   \   000006   A3           INC     DPTR
   \   000007   12....       LCALL   ?Subroutine79 & 0xFFFF
   \                     ??CrossCallReturnLabel_102:
   \   00000A   A3           INC     DPTR
   \   00000B   E5..         MOV     A,?V0 + 0
   \   00000D   12....       LCALL   ?Subroutine63 & 0xFFFF
   \                     ??CrossCallReturnLabel_82:
   \   000010   E5..         MOV     A,?V0 + 1
   \   000012   12....       LCALL   ?Subroutine63 & 0xFFFF
   \                     ??CrossCallReturnLabel_83:
   \   000015   A3           INC     DPTR
   \   000016   EE           MOV     A,R6
   \   000017   F0           MOVX    @DPTR,A
   \   000018   A3           INC     DPTR
   \   000019   EF           MOV     A,R7
   \   00001A   F0           MOVX    @DPTR,A
   \   00001B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine63:
   \   000000   12....       LCALL   ?Subroutine79 & 0xFFFF
   \                     ??CrossCallReturnLabel_103:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   22           RET
    307          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    308          ZStatus_t zcl_registerClusterOptionList( uint8 endpoint, uint8 numOption, zclOptionRec_t optionList[] )
   \                     zcl_registerClusterOptionList:
    309          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   12....       LCALL   ?Subroutine50 & 0xFFFF
    310            zclClusterOptionList *pNewItem;
    311            zclClusterOptionList *pLoop;
    312          
    313            // Fill in the new profile list
    314            pNewItem = osal_mem_alloc( sizeof( zclClusterOptionList ) );
    315            if ( pNewItem == NULL )
   \                     ??CrossCallReturnLabel_65:
   \   000008   7001         JNZ     ??zcl_registerClusterOptionList_0
   \   00000A   E9           MOV     A,R1
   \                     ??zcl_registerClusterOptionList_0:
   \   00000B   7004         JNZ     ??zcl_registerClusterOptionList_1
    316              return (ZMemError);
   \   00000D   7910         MOV     R1,#0x10
   \   00000F   8027         SJMP    ??CrossCallReturnLabel_16
    317          
    318            pNewItem->next = (zclClusterOptionList *)NULL;
   \                     ??zcl_registerClusterOptionList_1:
   \   000011   12....       LCALL   ?Subroutine0 & 0xFFFF
    319            pNewItem->endpoint = endpoint;
    320            pNewItem->numOptions = numOption;
    321            pNewItem->options = optionList;
    322          
    323            // Find spot in list
    324            if ( clusterOptionList == NULL )
   \                     ??CrossCallReturnLabel_1:
   \   000014   90....       MOV     DPTR,#clusterOptionList
   \   000017   E0           MOVX    A,@DPTR
   \   000018   7002         JNZ     ??zcl_registerClusterOptionList_2
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \                     ??zcl_registerClusterOptionList_2:
   \   00001C   90....       MOV     DPTR,#clusterOptionList
   \   00001F   6014         JZ      ??zcl_registerClusterOptionList_3
    325            {
    326              clusterOptionList = pNewItem;
    327            }
    328            else
    329            {
    330              // Look for end of list
    331              pLoop = clusterOptionList;
   \   000021   12....       LCALL   ?Subroutine70 & 0xFFFF
   \                     ??CrossCallReturnLabel_211:
   \   000024   8003         SJMP    ??zcl_registerClusterOptionList_4
    332              while ( pLoop->next != NULL )
    333                pLoop = pLoop->next;
   \                     ??zcl_registerClusterOptionList_5:
   \   000026   EA           MOV     A,R2
   \   000027   FC           MOV     R4,A
   \   000028   EB           MOV     A,R3
   \                     ??zcl_registerClusterOptionList_4:
   \   000029   12....       LCALL   ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_135:
   \   00002C   7001         JNZ     ??zcl_registerClusterOptionList_6
   \   00002E   EB           MOV     A,R3
   \                     ??zcl_registerClusterOptionList_6:
   \   00002F   70F5         JNZ     ??zcl_registerClusterOptionList_5
    334          
    335              // Put new item at end of list
    336              pLoop->next = pNewItem;
   \   000031   8C82         MOV     DPL,R4
   \   000033   8D83         MOV     DPH,R5
    337            }
   \                     ??zcl_registerClusterOptionList_3:
   \   000035   12....       LCALL   ?Subroutine11 & 0xFFFF
    338            return ( ZSuccess );
   \                     ??CrossCallReturnLabel_16:
   \   000038   02....       LJMP    ?Subroutine85 & 0xFFFF
    339          }
    340          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    341          ZStatus_t zcl_registerValidateAttrData( zclValidateAttrData_t pfnValidateAttrData )
   \                     zcl_registerValidateAttrData:
    342          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    343            zcl_ValidateAttrDataCB = pfnValidateAttrData;
   \   000004   90....       MOV     DPTR,#zcl_ValidateAttrDataCB
   \   000007   EA           MOV     A,R2
   \   000008   F0           MOVX    @DPTR,A
   \   000009   A3           INC     DPTR
   \   00000A   EB           MOV     A,R3
   \   00000B   F0           MOVX    @DPTR,A
    344            
    345            return ( ZSuccess );
   \   00000C   7900         MOV     R1,#0x0
   \   00000E   80..         SJMP    ?Subroutine84
    346          }
    347          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    348          uint8 zcl_registerForMsg( uint8 taskId )
   \                     zcl_registerForMsg:
    349          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    350            // Allow only the first task
    351            if ( zcl_RegisteredMsgTaskID == TASK_NO_TASK )
   \   000004   90....       MOV     DPTR,#zcl_RegisteredMsgTaskID
   \   000007   E0           MOVX    A,@DPTR
   \   000008   64FF         XRL     A,#0xff
   \   00000A   7006         JNZ     ??zcl_registerForMsg_0
    352            {
    353              zcl_RegisteredMsgTaskID = taskId;  
   \   00000C   E9           MOV     A,R1
   \   00000D   F0           MOVX    @DPTR,A
    354              return ( true );
   \   00000E   7901         MOV     R1,#0x1
   \   000010   8002         SJMP    ??zcl_registerForMsg_1
    355            }
    356            return ( false );
   \                     ??zcl_registerForMsg_0:
   \   000012   7900         MOV     R1,#0x0
   \                     ??zcl_registerForMsg_1:
   \   000014                REQUIRE ?Subroutine84
   \   000014                ; // Fall through to label ?Subroutine84
    357          }
    358          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    359          static uint8 zcl_DeviceOperational( uint8 srcEP, uint16 clusterID, 
   \                     zcl_DeviceOperational:
    360                                              uint8 frameType, uint8 cmd, uint16 profileID )
    361          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 9
   \   000005   74F7         MOV     A,#-0x9
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    362            zclAttrRec_t attrRec;
    363            uint8 deviceEnabled = DEVICE_ENABLED; // default value
   \   00000A   7401         MOV     A,#0x1
   \   00000C   85..82       MOV     DPL,?XSP + 0
   \   00000F   85..83       MOV     DPH,?XSP + 1
   \   000012   F0           MOVX    @DPTR,A
    364            (void)profileID;  // Intentionally unreferenced parameter
    365            
    366            // If the device is Disabled (DeviceEnabled attribute is set to Disabled), it 
    367            // cannot send or respond to application level commands, other than commands
    368            // to read or write attributes. Note that the Identify cluster cannot be 
    369            // disabled, and remains functional regardless of this setting.
    370            if ( zcl_ProfileCmd( frameType ) && cmd <= ZCL_CMD_WRITE_NO_RSP )
   \   000013   EC           MOV     A,R4
   \   000014   700A         JNZ     ??zcl_DeviceOperational_0
   \   000016   ED           MOV     A,R5
   \   000017   C3           CLR     C
   \   000018   9406         SUBB    A,#0x6
   \   00001A   5004         JNC     ??zcl_DeviceOperational_0
    371              return ( TRUE );
   \                     ??zcl_DeviceOperational_1:
   \   00001C   7901         MOV     R1,#0x1
   \   00001E   804E         SJMP    ??zcl_DeviceOperational_2
    372            
    373            if ( clusterID == ZCL_CLUSTER_ID_GEN_IDENTIFY )
   \                     ??zcl_DeviceOperational_0:
   \   000020   7403         MOV     A,#0x3
   \   000022   6A           XRL     A,R2
   \   000023   7001         JNZ     ??zcl_DeviceOperational_3
   \   000025   EB           MOV     A,R3
   \                     ??zcl_DeviceOperational_3:
   \   000026   60F4         JZ      ??zcl_DeviceOperational_1
    374              return ( TRUE );
    375            
    376            // Is device enabled?
    377            if ( zclFindAttrRec( srcEP, ZCL_CLUSTER_ID_GEN_BASIC, ATTRID_BASIC_DEVICE_ENABLED, &attrRec ) )
   \   000028                ; Setup parameters for call to function zclFindAttrRec
   \   000028   7401         MOV     A,#0x1
   \   00002A   12....       LCALL   ?XSTACK_DISP0_8
   \   00002D   8582..       MOV     ?V0 + 0,DPL
   \   000030   8583..       MOV     ?V0 + 1,DPH
   \   000033   78..         MOV     R0,#?V0 + 0
   \   000035   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000038   7C12         MOV     R4,#0x12
   \   00003A   7D00         MOV     R5,#0x0
   \   00003C   7A00         MOV     R2,#0x0
   \   00003E   7B00         MOV     R3,#0x0
   \   000040   12....       LCALL   ??zclFindAttrRec?relay
   \   000043   7402         MOV     A,#0x2
   \   000045   12....       LCALL   ?DEALLOC_XSTACK8
   \   000048   E9           MOV     A,R1
   \   000049   6016         JZ      ??zcl_DeviceOperational_4
    378              zclReadAttrData( &deviceEnabled, &attrRec );
   \   00004B                ; Setup parameters for call to function zclReadAttrData
   \   00004B   7401         MOV     A,#0x1
   \   00004D   12....       LCALL   ?XSTACK_DISP0_8
   \   000050   AC82         MOV     R4,DPL
   \   000052   AD83         MOV     R5,DPH
   \   000054   85..82       MOV     DPL,?XSP + 0
   \   000057   85..83       MOV     DPH,?XSP + 1
   \   00005A   AA82         MOV     R2,DPL
   \   00005C   AB83         MOV     R3,DPH
   \   00005E   12....       LCALL   ??zclReadAttrData?relay
    379            
    380            return ( deviceEnabled == DEVICE_ENABLED ? TRUE : FALSE );
   \                     ??zcl_DeviceOperational_4:
   \   000061   85..82       MOV     DPL,?XSP + 0
   \   000064   85..83       MOV     DPH,?XSP + 1
   \   000067   E0           MOVX    A,@DPTR
   \   000068   6401         XRL     A,#0x1
   \   00006A   60B0         JZ      ??zcl_DeviceOperational_1
   \   00006C   7900         MOV     R1,#0x0
   \                     ??zcl_DeviceOperational_2:
   \   00006E   7409         MOV     A,#0x9
   \   000070   12....       LCALL   ?DEALLOC_XSTACK8
   \   000073   02....       LJMP    ?Subroutine94 & 0xFFFF
    381          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine94:
   \   000000   7F02         MOV     R7,#0x2
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    382          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    383          ZStatus_t zcl_SendCommand( uint8 srcEP, afAddrType_t *destAddr,
   \                     zcl_SendCommand:
    384                                     uint16 clusterID, uint8 cmd, uint8 specific, uint8 direction,
    385                                     uint8 disableDefaultRsp, uint16 manuCode, uint8 seqNum,
    386                                     uint16 cmdFormatLen, uint8 *cmdFormat )
    387          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 18
   \   000005   74EE         MOV     A,#-0x12
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FF           MOV     R7,A
   \   00000C   8C..         MOV     ?V0 + 0,R4
   \   00000E   8D..         MOV     ?V0 + 1,R5
   \   000010   742A         MOV     A,#0x2a
   \   000012   12....       LCALL   ?XSTACK_DISP0_8
   \   000015   E0           MOVX    A,@DPTR
   \   000016   FE           MOV     R6,A
   \   000017   742B         MOV     A,#0x2b
   \   000019   12....       LCALL   ?XSTACK_DISP0_8
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   F5..         MOV     ?V0 + 3,A
   \   00001F   742C         MOV     A,#0x2c
   \   000021   12....       LCALL   ?XSTACK_DISP0_8
   \   000024   E0           MOVX    A,@DPTR
   \   000025   F5..         MOV     ?V0 + 9,A
   \   000027   742D         MOV     A,#0x2d
   \   000029   12....       LCALL   ?XSTACK_DISP0_8
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   F5..         MOV     ?V0 + 8,A
   \   00002F   742E         MOV     A,#0x2e
   \   000031   12....       LCALL   ?XSTACK_DISP0_8
   \   000034   E0           MOVX    A,@DPTR
   \   000035   F5..         MOV     ?V0 + 12,A
   \   000037   A3           INC     DPTR
   \   000038   E0           MOVX    A,@DPTR
   \   000039   F5..         MOV     ?V0 + 13,A
   \   00003B   7430         MOV     A,#0x30
   \   00003D   12....       LCALL   ?XSTACK_DISP0_8
   \   000040   E0           MOVX    A,@DPTR
   \   000041   F5..         MOV     ?V0 + 7,A
   \   000043   7431         MOV     A,#0x31
   \   000045   12....       LCALL   ?XSTACK_DISP0_8
   \   000048   E0           MOVX    A,@DPTR
   \   000049   F5..         MOV     ?V0 + 14,A
   \   00004B   A3           INC     DPTR
   \   00004C   E0           MOVX    A,@DPTR
   \   00004D   F5..         MOV     ?V0 + 15,A
    388            endPointDesc_t *epDesc;
    389            zclFrameHdr_t hdr;
    390            uint8 *msgBuf;
    391            uint16 msgLen;
    392            uint8 *pBuf;
    393            afAddrType_t dstAddr;
    394            uint8 options;
    395            ZStatus_t status;
    396          
    397            osal_memcpy( &dstAddr, destAddr, sizeof ( afAddrType_t ) );
   \   00004F                ; Setup parameters for call to function osal_memcpy
   \   00004F   8A..         MOV     ?V0 + 4,R2
   \   000051   8B..         MOV     ?V0 + 5,R3
   \   000053   75..00       MOV     ?V0 + 6,#0x0
   \   000056   78..         MOV     R0,#?V0 + 4
   \   000058   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00005B   7C0C         MOV     R4,#0xc
   \   00005D   7D00         MOV     R5,#0x0
   \   00005F   7409         MOV     A,#0x9
   \   000061   12....       LCALL   ?XSTACK_DISP0_8
   \   000064   AA82         MOV     R2,DPL
   \   000066   AB83         MOV     R3,DPH
   \   000068   12....       LCALL   ?Subroutine88 & 0xFFFF
   \                     ??CrossCallReturnLabel_116:
   \   00006B   12....       LCALL   ?DEALLOC_XSTACK8
    398          
    399            epDesc = afFindEndPointDesc( srcEP );
   \   00006E                ; Setup parameters for call to function afFindEndPointDesc
   \   00006E   EF           MOV     A,R7
   \   00006F   F9           MOV     R1,A
   \   000070   12....       LCALL   ??afFindEndPointDesc?relay
   \   000073   8A..         MOV     ?V0 + 10,R2
   \   000075   8B..         MOV     ?V0 + 11,R3
    400            if ( epDesc == NULL )
   \   000077   EA           MOV     A,R2
   \   000078   7001         JNZ     ??zcl_SendCommand_0
   \   00007A   EB           MOV     A,R3
   \                     ??zcl_SendCommand_0:
   \   00007B   7005         JNZ     ??zcl_SendCommand_1
    401              return ( ZInvalidParameter ); // EMBEDDED RETURN
   \                     ??zcl_SendCommand_2:
   \   00007D   7902         MOV     R1,#0x2
   \   00007F   02....       LJMP    ??zcl_SendCommand_3 & 0xFFFF
    402          
    403            if ( clusterID == ZCL_INVALID_CLUSTER_ID )
   \                     ??zcl_SendCommand_1:
   \   000082   74FF         MOV     A,#-0x1
   \   000084   65..         XRL     A,?V0 + 0
   \   000086   7004         JNZ     ??zcl_SendCommand_4
   \   000088   74FF         MOV     A,#-0x1
   \   00008A   65..         XRL     A,?V0 + 1
   \                     ??zcl_SendCommand_4:
   \   00008C   60EF         JZ      ??zcl_SendCommand_2
    404              return ( ZInvalidParameter ); // EMBEDDED RETURN
    405          
    406          #if defined ( INTER_PAN )
    407            if ( StubAPS_InterPan( destAddr->panId, destAddr->endPoint ) )
    408              options = AF_TX_OPTIONS_NONE;
    409            else
    410          #endif
    411              options = zclGetClusterOption( srcEP, clusterID );
   \   00008E                ; Setup parameters for call to function zclGetClusterOption
   \   00008E   AA..         MOV     R2,?V0 + 0
   \   000090   AB..         MOV     R3,?V0 + 1
   \   000092   EF           MOV     A,R7
   \   000093   F9           MOV     R1,A
   \   000094   12....       LCALL   ??zclGetClusterOption?relay
   \   000097   E9           MOV     A,R1
   \   000098   F5..         MOV     ?V0 + 2,A
    412            
    413            osal_memset( &hdr, 0, sizeof( zclFrameHdr_t ) );
   \   00009A                ; Setup parameters for call to function osal_memset
   \   00009A   7C06         MOV     R4,#0x6
   \   00009C   7D00         MOV     R5,#0x0
   \   00009E   7900         MOV     R1,#0x0
   \   0000A0   85..82       MOV     DPL,?XSP + 0
   \   0000A3   85..83       MOV     DPH,?XSP + 1
   \   0000A6   AA82         MOV     R2,DPL
   \   0000A8   AB83         MOV     R3,DPH
   \   0000AA   12....       LCALL   ??osal_memset?relay
    414          
    415            // Not Profile wide command (like READ, WRITE)
    416            if ( specific )
   \   0000AD   E5..         MOV     A,?V0 + 3
   \   0000AF   85..82       MOV     DPL,?XSP + 0
   \   0000B2   85..83       MOV     DPH,?XSP + 1
   \   0000B5   6015         JZ      ??zcl_SendCommand_5
    417              hdr.fc.type = ZCL_FRAME_TYPE_SPECIFIC_CMD;
   \   0000B7   E0           MOVX    A,@DPTR
   \   0000B8   54FC         ANL     A,#0xfc
   \   0000BA   F8           MOV     R0,A
   \   0000BB   A3           INC     DPTR
   \   0000BC   E0           MOVX    A,@DPTR
   \   0000BD   F9           MOV     R1,A
   \   0000BE   7401         MOV     A,#0x1
   \   0000C0   48           ORL     A,R0
   \   0000C1   85..82       MOV     DPL,?XSP + 0
   \   0000C4   85..83       MOV     DPH,?XSP + 1
   \   0000C7   F0           MOVX    @DPTR,A
   \   0000C8   A3           INC     DPTR
   \   0000C9   E9           MOV     A,R1
   \   0000CA   8006         SJMP    ??zcl_SendCommand_6
    418            else
    419              hdr.fc.type = ZCL_FRAME_TYPE_PROFILE_CMD;
   \                     ??zcl_SendCommand_5:
   \   0000CC   E0           MOVX    A,@DPTR
   \   0000CD   54FC         ANL     A,#0xfc
   \   0000CF   F0           MOVX    @DPTR,A
   \   0000D0   A3           INC     DPTR
   \   0000D1   E0           MOVX    A,@DPTR
   \                     ??zcl_SendCommand_6:
   \   0000D2   F0           MOVX    @DPTR,A
    420          
    421            if ((epDesc->simpleDesc == NULL) ||
    422                (zcl_DeviceOperational(srcEP, clusterID, hdr.fc.type, cmd, epDesc->simpleDesc->AppProfId) == FALSE))
   \   0000D3   85..82       MOV     DPL,?V0 + 10
   \   0000D6   85..83       MOV     DPH,?V0 + 11
   \   0000D9   12....       LCALL   ?Subroutine45 & 0xFFFF
   \                     ??CrossCallReturnLabel_242:
   \   0000DC   8882         MOV     DPL,R0
   \   0000DE   8983         MOV     DPH,R1
   \   0000E0   E582         MOV     A,DPL
   \   0000E2   7002         JNZ     ??zcl_SendCommand_7
   \   0000E4   E583         MOV     A,DPH
   \                     ??zcl_SendCommand_7:
   \   0000E6   6020         JZ      ??zcl_SendCommand_8
   \   0000E8                ; Setup parameters for call to function zcl_DeviceOperational
   \   0000E8   A3           INC     DPTR
   \   0000E9   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0000EC   EE           MOV     A,R6
   \   0000ED   FD           MOV     R5,A
   \   0000EE   7402         MOV     A,#0x2
   \   0000F0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F3   E0           MOVX    A,@DPTR
   \   0000F4   5403         ANL     A,#0x3
   \   0000F6   FC           MOV     R4,A
   \   0000F7   AA..         MOV     R2,?V0 + 0
   \   0000F9   AB..         MOV     R3,?V0 + 1
   \   0000FB   EF           MOV     A,R7
   \   0000FC   F9           MOV     R1,A
   \   0000FD   12....       LCALL   ??zcl_DeviceOperational?relay
   \   000100   7402         MOV     A,#0x2
   \   000102   12....       LCALL   ?DEALLOC_XSTACK8
   \   000105   E9           MOV     A,R1
   \   000106   7005         JNZ     ??zcl_SendCommand_9
    423              return ( ZFailure ); // EMBEDDED RETURN
   \                     ??zcl_SendCommand_8:
   \   000108   7901         MOV     R1,#0x1
   \   00010A   02....       LJMP    ??zcl_SendCommand_3 & 0xFFFF
    424            
    425            if ( manuCode != 0 ) // Fill in the Maufacturer Code
   \                     ??zcl_SendCommand_9:
   \   00010D   E5..         MOV     A,?V0 + 12
   \   00010F   7002         JNZ     ??zcl_SendCommand_10
   \   000111   E5..         MOV     A,?V0 + 13
   \                     ??zcl_SendCommand_10:
   \   000113   6019         JZ      ??zcl_SendCommand_11
    426            {
    427              hdr.fc.manuSpecific = 1;
   \   000115   85..82       MOV     DPL,?XSP + 0
   \   000118   85..83       MOV     DPH,?XSP + 1
   \   00011B   E0           MOVX    A,@DPTR
   \   00011C   4404         ORL     A,#0x4
   \   00011E   F0           MOVX    @DPTR,A
   \   00011F   A3           INC     DPTR
   \   000120   E0           MOVX    A,@DPTR
   \   000121   F0           MOVX    @DPTR,A
    428              hdr.manuCode = manuCode;
   \   000122   7402         MOV     A,#0x2
   \   000124   12....       LCALL   ?XSTACK_DISP0_8
   \   000127   E5..         MOV     A,?V0 + 12
   \   000129   F0           MOVX    @DPTR,A
   \   00012A   A3           INC     DPTR
   \   00012B   E5..         MOV     A,?V0 + 13
   \   00012D   F0           MOVX    @DPTR,A
    429            }
    430            
    431            if ( direction ) // Set the Command Direction
   \                     ??zcl_SendCommand_11:
   \   00012E   E5..         MOV     A,?V0 + 9
   \   000130   85..82       MOV     DPL,?XSP + 0
   \   000133   85..83       MOV     DPH,?XSP + 1
   \   000136   6005         JZ      ??zcl_SendCommand_12
    432              hdr.fc.direction = ZCL_FRAME_SERVER_CLIENT_DIR;
   \   000138   E0           MOVX    A,@DPTR
   \   000139   4408         ORL     A,#0x8
   \   00013B   8003         SJMP    ??zcl_SendCommand_13
    433            else
    434              hdr.fc.direction = ZCL_FRAME_CLIENT_SERVER_DIR;
   \                     ??zcl_SendCommand_12:
   \   00013D   E0           MOVX    A,@DPTR
   \   00013E   54F7         ANL     A,#0xf7
   \                     ??zcl_SendCommand_13:
   \   000140   F0           MOVX    @DPTR,A
   \   000141   A3           INC     DPTR
   \   000142   E0           MOVX    A,@DPTR
   \   000143   F0           MOVX    @DPTR,A
    435          
    436            if ( disableDefaultRsp ) // Set the Disable Default Response field
   \   000144   E5..         MOV     A,?V0 + 8
   \   000146   85..82       MOV     DPL,?XSP + 0
   \   000149   85..83       MOV     DPH,?XSP + 1
   \   00014C   6005         JZ      ??zcl_SendCommand_14
    437              hdr.fc.disableDefaultRsp = 1;
   \   00014E   E0           MOVX    A,@DPTR
   \   00014F   4410         ORL     A,#0x10
   \   000151   8003         SJMP    ??zcl_SendCommand_15
    438            else
    439              hdr.fc.disableDefaultRsp = 0;
   \                     ??zcl_SendCommand_14:
   \   000153   E0           MOVX    A,@DPTR
   \   000154   54EF         ANL     A,#0xef
   \                     ??zcl_SendCommand_15:
   \   000156   F0           MOVX    @DPTR,A
   \   000157   A3           INC     DPTR
   \   000158   E0           MOVX    A,@DPTR
   \   000159   F0           MOVX    @DPTR,A
    440                               
    441            hdr.transSeqNum = seqNum; // Fill in the Transaction Sequence Number
   \   00015A   7404         MOV     A,#0x4
   \   00015C   12....       LCALL   ?XSTACK_DISP0_8
   \   00015F   E5..         MOV     A,?V0 + 7
   \   000161   F0           MOVX    @DPTR,A
    442            
    443            hdr.commandID = cmd; // Fill in the command
   \   000162   7405         MOV     A,#0x5
   \   000164   12....       LCALL   ?XSTACK_DISP0_8
   \   000167   EE           MOV     A,R6
   \   000168   F0           MOVX    @DPTR,A
    444            
    445            msgLen = zclCalcHdrSize( &hdr ); // calculate the needed buffer size
   \   000169   75..03       MOV     ?V0 + 4,#0x3
   \   00016C   85..82       MOV     DPL,?XSP + 0
   \   00016F   85..83       MOV     DPH,?XSP + 1
   \   000172   E0           MOVX    A,@DPTR
   \   000173   5404         ANL     A,#0x4
   \   000175   6003         JZ      ??zcl_SendCommand_16
   \   000177   75..05       MOV     ?V0 + 4,#0x5
    446            msgLen += cmdFormatLen;
   \                     ??zcl_SendCommand_16:
   \   00017A   E5..         MOV     A,?V0 + 14
   \   00017C   25..         ADD     A,?V0 + 4
   \   00017E   F5..         MOV     ?V0 + 12,A
   \   000180   E5..         MOV     A,?V0 + 15
   \   000182   3400         ADDC    A,#0x0
   \   000184   F5..         MOV     ?V0 + 13,A
    447          
    448            msgBuf = osal_mem_alloc( msgLen ); // Allocate the buffer needed
   \   000186                ; Setup parameters for call to function osal_mem_alloc
   \   000186   AA..         MOV     R2,?V0 + 12
   \   000188   FB           MOV     R3,A
   \   000189   12....       LCALL   ??osal_mem_alloc?relay
   \   00018C   8A..         MOV     ?V0 + 8,R2
   \   00018E   8B..         MOV     ?V0 + 9,R3
    449            if ( msgBuf != NULL )
   \   000190   EA           MOV     A,R2
   \   000191   7001         JNZ     ??zcl_SendCommand_17
   \   000193   EB           MOV     A,R3
   \                     ??zcl_SendCommand_17:
   \   000194   606B         JZ      ??zcl_SendCommand_18
    450            {
    451              pBuf = zclBuildHdr( &hdr, msgBuf ); // Fill in the ZCL Header
    452          
    453              osal_memcpy( pBuf, cmdFormat, cmdFormatLen ); // Fill in the command frame
   \   000196                ; Setup parameters for call to function osal_memcpy
   \   000196   7433         MOV     A,#0x33
   \   000198   12....       LCALL   ?XSTACK_DISP0_8
   \   00019B   12....       LCALL   ?Subroutine64 & 0xFFFF
   \                     ??CrossCallReturnLabel_84:
   \   00019E   78..         MOV     R0,#?V0 + 4
   \   0001A0   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0001A3                ; Setup parameters for call to function zclBuildHdr
   \   0001A3   AC..         MOV     R4,?V0 + 8
   \   0001A5   AD..         MOV     R5,?V0 + 9
   \   0001A7   7403         MOV     A,#0x3
   \   0001A9   12....       LCALL   ?XSTACK_DISP0_8
   \   0001AC   AA82         MOV     R2,DPL
   \   0001AE   AB83         MOV     R3,DPH
   \   0001B0   12....       LCALL   ??zclBuildHdr?relay
   \   0001B3   AC..         MOV     R4,?V0 + 14
   \   0001B5   AD..         MOV     R5,?V0 + 15
   \   0001B7   12....       LCALL   ?Subroutine88 & 0xFFFF
   \                     ??CrossCallReturnLabel_117:
   \   0001BA   12....       LCALL   ?DEALLOC_XSTACK8
    454          
    455              status = AF_DataRequest( &dstAddr, epDesc, clusterID, msgLen, msgBuf, 
    456                                       &zcl_TransID, options, AF_DEFAULT_RADIUS );  
   \   0001BD                ; Setup parameters for call to function AF_DataRequest
   \   0001BD   75..1E       MOV     ?V0 + 3,#0x1e
   \   0001C0   78..         MOV     R0,#?V0 + 3
   \   0001C2   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001C5   75....       MOV     ?V0 + 4,#(zcl_TransID & 0xff)
   \   0001C8   75....       MOV     ?V0 + 5,#((zcl_TransID >> 8) & 0xff)
   \   0001CB   78..         MOV     R0,#?V0 + 4
   \   0001CD   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001D0   78..         MOV     R0,#?V0 + 8
   \   0001D2   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001D5   78..         MOV     R0,#?V0 + 12
   \   0001D7   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001DA   78..         MOV     R0,#?V0 + 0
   \   0001DC   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001DF   A9..         MOV     R1,?V0 + 2
   \   0001E1   AC..         MOV     R4,?V0 + 10
   \   0001E3   AD..         MOV     R5,?V0 + 11
   \   0001E5   740F         MOV     A,#0xf
   \   0001E7   12....       LCALL   ?XSTACK_DISP0_8
   \   0001EA   AA82         MOV     R2,DPL
   \   0001EC   AB83         MOV     R3,DPH
   \   0001EE   12....       LCALL   ??AF_DataRequest?relay
   \   0001F1   7409         MOV     A,#0x9
   \   0001F3   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001F6   E9           MOV     A,R1
   \   0001F7   FE           MOV     R6,A
    457              osal_mem_free ( msgBuf );
   \   0001F8                ; Setup parameters for call to function osal_mem_free
   \   0001F8   AA..         MOV     R2,?V0 + 8
   \   0001FA   AB..         MOV     R3,?V0 + 9
   \   0001FC   12....       LCALL   ??osal_mem_free?relay
   \   0001FF   8002         SJMP    ??zcl_SendCommand_19
    458            }
    459            else
    460              status = ZMemError;
   \                     ??zcl_SendCommand_18:
   \   000201   7E10         MOV     R6,#0x10
    461          
    462            return ( status );
   \                     ??zcl_SendCommand_19:
   \   000203   EE           MOV     A,R6
   \   000204   F9           MOV     R1,A
   \                     ??zcl_SendCommand_3:
   \   000205                REQUIRE ?Subroutine100
   \   000205                ; // Fall through to label ?Subroutine100
    463          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine100:
   \   000000   7412         MOV     A,#0x12
   \   000002   80..         SJMP    ??Subroutine102_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine102_0:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003   7F10         MOV     R7,#0x10
   \   000005   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine88:
   \   000000   12....       LCALL   ??osal_memcpy?relay
   \   000003   7403         MOV     A,#0x3
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine64:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0 + 4,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V0 + 5,A
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine45:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine126_0
   \   000002                ; // Fall through to label ??Subroutine126_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine126_0:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine127_0
   \   000001                ; // Fall through to label ??Subroutine127_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine127_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   22           RET
    464          
    465          #ifdef ZCL_READ

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    466          ZStatus_t zcl_SendRead( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendRead:
    467                                  uint16 clusterID, zclReadCmd_t *readCmd,
    468                                  uint8 direction, uint8 disableDefaultRsp, uint8 seqNum)
    469          {
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 8,R1
   \   000007   EA           MOV     A,R2
   \   000008   FE           MOV     R6,A
   \   000009   EB           MOV     A,R3
   \   00000A   FF           MOV     R7,A
   \   00000B   8C..         MOV     ?V0 + 0,R4
   \   00000D   8D..         MOV     ?V0 + 1,R5
   \   00000F   7416         MOV     A,#0x16
   \   000011   12....       LCALL   ?XSTACK_DISP0_8
   \   000014   12....       LCALL   ?Subroutine46 & 0xFFFF
   \                     ??CrossCallReturnLabel_58:
   \   000017   12....       LCALL   ?XSTACK_DISP0_8
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   F5..         MOV     ?V0 + 9,A
   \   00001D   7419         MOV     A,#0x19
   \   00001F   12....       LCALL   ?XSTACK_DISP0_8
   \   000022   E0           MOVX    A,@DPTR
   \   000023   F5..         MOV     ?V0 + 12,A
   \   000025   741A         MOV     A,#0x1a
   \   000027   12....       LCALL   ?XSTACK_DISP0_8
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   F5..         MOV     ?V0 + 13,A
    470            uint8 dataLen;
    471            uint8 *buf;
    472            uint8 *pBuf;
    473            ZStatus_t status;
    474          
    475            dataLen = readCmd->numAttr * 2; // Attribute ID
   \   00002D   85..82       MOV     DPL,?V0 + 4
   \   000030   85..83       MOV     DPH,?V0 + 5
   \   000033   E0           MOVX    A,@DPTR
   \   000034   C3           CLR     C
   \   000035   33           RLC     A
   \   000036   FA           MOV     R2,A
    476          
    477            buf = osal_mem_alloc( dataLen );
   \   000037   8A82         MOV     DPL,R2
   \   000039   8582..       MOV     ?V0 + 6,DPL
   \   00003C   75..00       MOV     ?V0 + 7,#0x0
   \   00003F                ; Setup parameters for call to function osal_mem_alloc
   \   00003F   12....       LCALL   ?Subroutine53 & 0xFFFF
    478            if ( buf != NULL )
   \                     ??CrossCallReturnLabel_70:
   \   000042   7001         JNZ     ??zcl_SendRead_0
   \   000044   EB           MOV     A,R3
   \                     ??zcl_SendRead_0:
   \   000045   7003         JNZ     $+5
   \   000047   02....       LJMP    ??zcl_SendRead_1 & 0xFFFF
    479            {
    480              uint8 i;
    481          
    482              pBuf = buf; // Load the buffer - serially
   \   00004A   A8..         MOV     R0,?V0 + 2
   \   00004C   A9..         MOV     R1,?V0 + 3
    483              for (i = 0; i < readCmd->numAttr; i++)
   \   00004E   75..00       MOV     ?V0 + 10,#0x0
   \   000051   801F         SJMP    ??zcl_SendRead_2
    484              {
    485                *pBuf++ = LO_UINT16( readCmd->attrID[i] );
   \                     ??zcl_SendRead_3:
   \   000053   E5..         MOV     A,?V0 + 10
   \   000055   C3           CLR     C
   \   000056   33           RLC     A
   \   000057   FA           MOV     R2,A
   \   000058   E4           CLR     A
   \   000059   33           RLC     A
   \   00005A   FB           MOV     R3,A
   \   00005B   E5..         MOV     A,?V0 + 4
   \   00005D   2A           ADD     A,R2
   \   00005E   F582         MOV     DPL,A
   \   000060   E5..         MOV     A,?V0 + 5
   \   000062   3B           ADDC    A,R3
   \   000063   F583         MOV     DPH,A
   \   000065   A3           INC     DPTR
   \   000066   AA82         MOV     R2,DPL
   \   000068   AB83         MOV     R3,DPH
   \   00006A   12....       LCALL   ?Subroutine38 & 0xFFFF
    486                *pBuf++ = HI_UINT16( readCmd->attrID[i] );
   \                     ??CrossCallReturnLabel_129:
   \   00006D   12....       LCALL   ?Subroutine24 & 0xFFFF
    487              }
   \                     ??CrossCallReturnLabel_138:
   \   000070   05..         INC     ?V0 + 10
   \                     ??zcl_SendRead_2:
   \   000072   85..82       MOV     DPL,?V0 + 4
   \   000075   85..83       MOV     DPH,?V0 + 5
   \   000078   E0           MOVX    A,@DPTR
   \   000079   FA           MOV     R2,A
   \   00007A   E5..         MOV     A,?V0 + 10
   \   00007C   C3           CLR     C
   \   00007D   9A           SUBB    A,R2
   \   00007E   40D3         JC      ??zcl_SendRead_3
    488              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ, FALSE,
    489                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );  
   \   000080                ; Setup parameters for call to function zcl_SendCommand
   \   000080   78..         MOV     R0,#?V0 + 2
   \   000082   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000085   78..         MOV     R0,#?V0 + 6
   \   000087   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00008A   E5..         MOV     A,?V0 + 13
   \   00008C   F5..         MOV     ?V0 + 4,A
   \   00008E   78..         MOV     R0,#?V0 + 4
   \   000090   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000093   75..00       MOV     ?V0 + 4,#0x0
   \   000096   75..00       MOV     ?V0 + 5,#0x0
   \   000099   78..         MOV     R0,#?V0 + 4
   \   00009B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00009E   E5..         MOV     A,?V0 + 12
   \   0000A0   F5..         MOV     ?V0 + 4,A
   \   0000A2   78..         MOV     R0,#?V0 + 4
   \   0000A4   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000A7   E5..         MOV     A,?V0 + 9
   \   0000A9   F5..         MOV     ?V0 + 4,A
   \   0000AB   78..         MOV     R0,#?V0 + 4
   \   0000AD   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000B0   75..00       MOV     ?V0 + 4,#0x0
   \   0000B3   78..         MOV     R0,#?V0 + 4
   \   0000B5   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000B8   78..         MOV     R0,#?V0 + 4
   \   0000BA   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000BD   AC..         MOV     R4,?V0 + 0
   \   0000BF   AD..         MOV     R5,?V0 + 1
   \   0000C1   EE           MOV     A,R6
   \   0000C2   FA           MOV     R2,A
   \   0000C3   EF           MOV     A,R7
   \   0000C4   FB           MOV     R3,A
   \   0000C5   A9..         MOV     R1,?V0 + 8
   \   0000C7   12....       LCALL   ?Subroutine74 & 0xFFFF
   \                     ??CrossCallReturnLabel_94:
   \   0000CA   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000CD   E9           MOV     A,R1
   \   0000CE   FE           MOV     R6,A
    490              osal_mem_free( buf );
   \   0000CF                ; Setup parameters for call to function osal_mem_free
   \   0000CF   AA..         MOV     R2,?V0 + 2
   \   0000D1   AB..         MOV     R3,?V0 + 3
   \   0000D3   12....       LCALL   ??osal_mem_free?relay
   \   0000D6   8002         SJMP    ??zcl_SendRead_4
    491            }
    492            else
    493              status = ZMemError;
   \                     ??zcl_SendRead_1:
   \   0000D8   7E10         MOV     R6,#0x10
    494          
    495            return ( status );
   \                     ??zcl_SendRead_4:
   \   0000DA                REQUIRE ?Subroutine96
   \   0000DA                ; // Fall through to label ?Subroutine96
    496          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine96:
   \   000000   EE           MOV     A,R6
   \   000001   F9           MOV     R1,A
   \   000002                REQUIRE ??Subroutine103_0
   \   000002                ; // Fall through to label ??Subroutine103_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine103_0:
   \   000000   7F0E         MOV     R7,#0xe
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   8A82         MOV     DPL,R2
   \   000002   8B83         MOV     DPH,R3
   \   000004   A3           INC     DPTR
   \   000005                REQUIRE ??Subroutine104_0
   \   000005                ; // Fall through to label ??Subroutine104_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine104_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8882         MOV     DPL,R0
   \   000003   8983         MOV     DPH,R1
   \   000005   F0           MOVX    @DPTR,A
   \   000006   A3           INC     DPTR
   \   000007   08           INC     R0
   \   000008   A983         MOV     R1,DPH
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine91:
   \   000000   A882         MOV     R0,DPL
   \   000002   A983         MOV     R1,DPH
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine74:
   \   000000   12....       LCALL   ??zcl_SendCommand?relay
   \   000003   740B         MOV     A,#0xb
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine53:
   \   000000   7B00         MOV     R3,#0x0
   \   000002   12....       LCALL   ??osal_mem_alloc?relay
   \   000005   8A..         MOV     ?V0 + 2,R2
   \   000007   8B..         MOV     ?V0 + 3,R3
   \   000009   EA           MOV     A,R2
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine46:
   \   000000   12....       LCALL   ?Subroutine64 & 0xFFFF
   \                     ??CrossCallReturnLabel_87:
   \   000003   7418         MOV     A,#0x18
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine38:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8882         MOV     DPL,R0
   \   000003   8983         MOV     DPH,R1
   \   000005   F0           MOVX    @DPTR,A
   \   000006   A3           INC     DPTR
   \   000007   02....       LJMP    ?Subroutine91 & 0xFFFF
    497          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine95:
   \   000000   EE           MOV     A,R6
   \   000001   F9           MOV     R1,A
   \   000002   7404         MOV     A,#0x4
   \   000004                REQUIRE ??Subroutine102_0
   \   000004                ; // Fall through to label ??Subroutine102_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    498          ZStatus_t zcl_SendReadRsp( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendReadRsp:
    499                                     uint16 clusterID, zclReadRspCmd_t *readRspCmd,
    500                                     uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
    501          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   7402         MOV     A,#0x2
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   000012   12....       LCALL   ?XSTACK_DISP0_8
   \   000015   12....       LCALL   ?Subroutine47 & 0xFFFF
   \                     ??CrossCallReturnLabel_60:
   \   000018   12....       LCALL   ?XSTACK_DISP0_8
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F5..         MOV     ?V0 + 10,A
   \   00001E   741F         MOV     A,#0x1f
   \   000020   12....       LCALL   ?XSTACK_DISP0_8
   \   000023   E0           MOVX    A,@DPTR
   \   000024   F5..         MOV     ?V0 + 9,A
   \   000026   7420         MOV     A,#0x20
   \   000028   12....       LCALL   ?XSTACK_DISP0_8
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   F5..         MOV     ?V0 + 8,A
    502            uint8 *buf;
    503            uint8 *pBuf;
    504            zclReadRspStatus_t *statusRec;
    505            uint8 len = 0;
   \   00002E   7E00         MOV     R6,#0x0
    506            uint8 i;
    507            ZStatus_t status;
    508            
    509            // calculate the size of the command
    510            for ( i = 0; i < readRspCmd->numAttr; i++ )
   \   000030   8E..         MOV     ?V0 + 5,R6
   \   000032   8021         SJMP    ??zcl_SendReadRsp_0
    511            {
    512              statusRec = &(readRspCmd->attrList[i]);
   \                     ??zcl_SendReadRsp_1:
   \   000034   E5..         MOV     A,?V0 + 5
   \   000036   75F006       MOV     B,#0x6
   \   000039   12....       LCALL   ?Subroutine60 & 0xFFFF
    513              
    514              len += 2 + 1; // Attribute ID + Status
   \                     ??CrossCallReturnLabel_78:
   \   00003C   0E           INC     R6
   \   00003D   0E           INC     R6
   \   00003E   0E           INC     R6
    515          
    516              if ( statusRec->status == ZCL_STATUS_SUCCESS )
   \   00003F   A3           INC     DPTR
   \   000040   A3           INC     DPTR
   \   000041   E0           MOVX    A,@DPTR
   \   000042   700F         JNZ     ??zcl_SendReadRsp_2
    517              {
    518                len++; // Attribute Data Type
    519                len += zclGetAttrDataLength( statusRec->dataType, statusRec->data); // Attribute Data
   \   000044                ; Setup parameters for call to function zclGetAttrDataLength
   \   000044   8882         MOV     DPL,R0
   \   000046   8983         MOV     DPH,R1
   \   000048   A3           INC     DPTR
   \   000049   12....       LCALL   ?Subroutine28 & 0xFFFF
    520              }
    521            }
   \                     ??CrossCallReturnLabel_141:
   \   00004C   A3           INC     DPTR
   \   00004D   12....       LCALL   ?Subroutine69 & 0xFFFF
   \                     ??CrossCallReturnLabel_156:
   \   000050   04           INC     A
   \   000051   2E           ADD     A,R6
   \   000052   FE           MOV     R6,A
   \                     ??zcl_SendReadRsp_2:
   \   000053   05..         INC     ?V0 + 5
   \                     ??zcl_SendReadRsp_0:
   \   000055   12....       LCALL   ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_39:
   \   000058   40DA         JC      ??zcl_SendReadRsp_1
    522          
    523            buf = osal_mem_alloc( len );
   \   00005A   12....       LCALL   ?Subroutine54 & 0xFFFF
    524            if ( buf != NULL )
   \                     ??CrossCallReturnLabel_72:
   \   00005D   7001         JNZ     ??zcl_SendReadRsp_3
   \   00005F   EB           MOV     A,R3
   \                     ??zcl_SendReadRsp_3:
   \   000060   7003         JNZ     $+5
   \   000062   02....       LJMP    ??zcl_SendReadRsp_4 & 0xFFFF
    525            {
    526              // Load the buffer - serially
    527              pBuf = buf;
   \   000065   AE..         MOV     R6,?V0 + 6
   \   000067   AF..         MOV     R7,?V0 + 7
    528              for ( i = 0; i < readRspCmd->numAttr; i++ )
   \   000069   75..00       MOV     ?V0 + 5,#0x0
   \   00006C   8028         SJMP    ??zcl_SendReadRsp_5
    529              {
    530                statusRec = &(readRspCmd->attrList[i]);
   \                     ??zcl_SendReadRsp_6:
   \   00006E   E5..         MOV     A,?V0 + 5
   \   000070   75F006       MOV     B,#0x6
   \   000073   12....       LCALL   ?Subroutine1 & 0xFFFF
    531                
    532                *pBuf++ = LO_UINT16( statusRec->attrID );
    533                *pBuf++ = HI_UINT16( statusRec->attrID );
    534                *pBuf++ = statusRec->status;
   \                     ??CrossCallReturnLabel_2:
   \   000076   FA           MOV     R2,A
   \   000077   E9           MOV     A,R1
   \   000078   3400         ADDC    A,#0x0
   \   00007A   FB           MOV     R3,A
   \   00007B   8A82         MOV     DPL,R2
   \   00007D   8B83         MOV     DPH,R3
   \   00007F   12....       LCALL   ?Subroutine81 & 0xFFFF
    535          
    536                if ( statusRec->status == ZCL_STATUS_SUCCESS )
   \                     ??CrossCallReturnLabel_105:
   \   000082   8A82         MOV     DPL,R2
   \   000084   8B83         MOV     DPH,R3
   \   000086   E0           MOVX    A,@DPTR
   \   000087   700B         JNZ     ??CrossCallReturnLabel_125
    537                {
    538                  *pBuf++ = statusRec->dataType;
   \   000089   E8           MOV     A,R0
   \   00008A   2403         ADD     A,#0x3
   \   00008C   12....       LCALL   ?Subroutine39 & 0xFFFF
    539                  zclSerializeData( statusRec->dataType, statusRec->data, pBuf );
    540                  
    541                  // move pass attribute data
    542                  pBuf += zclGetAttrDataLength( statusRec->dataType, statusRec->data );
    543                }
    544              } // for loop
   \                     ??CrossCallReturnLabel_54:
   \   00008F   2404         ADD     A,#0x4
   \   000091   12....       LCALL   ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_125:
   \   000094   05..         INC     ?V0 + 5
   \                     ??zcl_SendReadRsp_5:
   \   000096   12....       LCALL   ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_40:
   \   000099   40D3         JC      ??zcl_SendReadRsp_6
    545          
    546              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ_RSP, FALSE, 
    547                                        direction, disableDefaultRsp, 0, seqNum, len, buf );
   \   00009B                ; Setup parameters for call to function zcl_SendCommand
   \   00009B   78..         MOV     R0,#?V0 + 6
   \   00009D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000A0   78..         MOV     R0,#?V0 + 0
   \   0000A2   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000A5   E5..         MOV     A,?V0 + 8
   \   0000A7   F5..         MOV     ?V0 + 0,A
   \   0000A9   78..         MOV     R0,#?V0 + 0
   \   0000AB   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000AE   75..00       MOV     ?V0 + 0,#0x0
   \   0000B1   78..         MOV     R0,#?V0 + 0
   \   0000B3   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000B6   E5..         MOV     A,?V0 + 9
   \   0000B8   F5..         MOV     ?V0 + 0,A
   \   0000BA   78..         MOV     R0,#?V0 + 0
   \   0000BC   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000BF   E5..         MOV     A,?V0 + 10
   \   0000C1   F5..         MOV     ?V0 + 0,A
   \   0000C3   78..         MOV     R0,#?V0 + 0
   \   0000C5   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000C8   75..00       MOV     ?V0 + 0,#0x0
   \   0000CB   78..         MOV     R0,#?V0 + 0
   \   0000CD   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000D0   75..01       MOV     ?V0 + 0,#0x1
   \   0000D3   78..         MOV     R0,#?V0 + 0
   \   0000D5   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000D8   740B         MOV     A,#0xb
   \   0000DA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DD   12....       LCALL   ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_30:
   \   0000E0   740D         MOV     A,#0xd
   \   0000E2   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E5   12....       LCALL   ?Subroutine33 & 0xFFFF
   \                     ??CrossCallReturnLabel_43:
   \   0000E8   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000EB   E9           MOV     A,R1
   \   0000EC   FE           MOV     R6,A
    548              osal_mem_free( buf );
   \   0000ED                ; Setup parameters for call to function osal_mem_free
   \   0000ED   AA..         MOV     R2,?V0 + 6
   \   0000EF   AB..         MOV     R3,?V0 + 7
   \   0000F1   12....       LCALL   ??osal_mem_free?relay
   \   0000F4   8002         SJMP    ??zcl_SendReadRsp_7
    549            }
    550            else
    551              status = ZMemError;
   \                     ??zcl_SendReadRsp_4:
   \   0000F6   7E10         MOV     R6,#0x10
    552          
    553            return ( status );
   \                     ??zcl_SendReadRsp_7:
   \   0000F8   02....       LJMP    ?Subroutine95 & 0xFFFF
    554          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine28:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004                REQUIRE ??Subroutine105_0
   \   000004                ; // Fall through to label ??Subroutine105_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine105_0:
   \   000000   FA           MOV     R2,A
   \   000001   A3           INC     DPTR
   \   000002   E0           MOVX    A,@DPTR
   \   000003   FB           MOV     R3,A
   \   000004   8882         MOV     DPL,R0
   \   000006   8983         MOV     DPH,R1
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine69:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F9           MOV     R1,A
   \   000002   12....       LCALL   ??zclGetAttrDataLength?relay
   \   000005   E9           MOV     A,R1
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine60:
   \   000000   12....       LCALL   ?Subroutine76 & 0xFFFF
   \                     ??CrossCallReturnLabel_132:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine76:
   \   000000   A4           MUL     AB
   \   000001   F8           MOV     R0,A
   \   000002   A9F0         MOV     R1,B
   \   000004   12....       LCALL   ?Subroutine82 & 0xFFFF
   \                     ??CrossCallReturnLabel_108:
   \   000007                REQUIRE ?Subroutine91
   \   000007                ; // Fall through to label ?Subroutine91

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine54:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8582..       MOV     ?V0 + 0,DPL
   \   000005   75..00       MOV     ?V0 + 1,#0x0
   \   000008                ; Setup parameters for call to function osal_mem_alloc
   \   000008                ; Setup parameters for call to function osal_mem_alloc
   \   000008   AA..         MOV     R2,?V0 + 0
   \   00000A   7B00         MOV     R3,#0x0
   \   00000C   12....       LCALL   ??osal_mem_alloc?relay
   \   00000F   8A..         MOV     ?V0 + 6,R2
   \   000011   8B..         MOV     ?V0 + 7,R3
   \   000013   EA           MOV     A,R2
   \   000014   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine47:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0 + 2,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V0 + 3,A
   \   000007   741E         MOV     A,#0x1e
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine39:
   \   000000   F5..         MOV     ?V0 + 12,A
   \   000002   E9           MOV     A,R1
   \   000003   3400         ADDC    A,#0x0
   \   000005   F5..         MOV     ?V0 + 13,A
   \   000007   85..82       MOV     DPL,?V0 + 12
   \   00000A   F583         MOV     DPH,A
   \   00000C   12....       LCALL   ?Subroutine68 & 0xFFFF
   \                     ??CrossCallReturnLabel_90:
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine68:
   \   000000   12....       LCALL   ?Subroutine81 & 0xFFFF
   \                     ??CrossCallReturnLabel_106:
   \   000003   E8           MOV     A,R0
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine81:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005   F0           MOVX    @DPTR,A
   \   000006   A3           INC     DPTR
   \   000007   0E           INC     R6
   \   000008   AF83         MOV     R7,DPH
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine33:
   \   000000   12....       LCALL   ?Subroutine66 & 0xFFFF
   \                     ??CrossCallReturnLabel_204:
   \   000003   A9..         MOV     R1,?V0 + 4
   \   000005   12....       LCALL   ?Subroutine74 & 0xFFFF
   \                     ??CrossCallReturnLabel_95:
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine32:
   \   000000   85..82       MOV     DPL,?V0 + 2
   \   000003   85..83       MOV     DPH,?V0 + 3
   \   000006   E0           MOVX    A,@DPTR
   \   000007   FA           MOV     R2,A
   \   000008   E5..         MOV     A,?V0 + 5
   \   00000A   C3           CLR     C
   \   00000B   9A           SUBB    A,R2
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   F5..         MOV     ?V0 + 14,A
   \   000002   E9           MOV     A,R1
   \   000003   3400         ADDC    A,#0x0
   \   000005   F5..         MOV     ?V0 + 15,A
   \   000007                ; Setup parameters for call to function zclSerializeData
   \   000007                ; Setup parameters for call to function zclSerializeData
   \   000007   EE           MOV     A,R6
   \   000008   FC           MOV     R4,A
   \   000009   EF           MOV     A,R7
   \   00000A   FD           MOV     R5,A
   \   00000B   12....       LCALL   ?Subroutine65 & 0xFFFF
   \                     ??CrossCallReturnLabel_88:
   \   00000E   12....       LCALL   ??zclSerializeData?relay
   \   000011                ; Setup parameters for call to function zclGetAttrDataLength
   \   000011                ; Setup parameters for call to function zclGetAttrDataLength
   \   000011   12....       LCALL   ?Subroutine65 & 0xFFFF
   \                     ??CrossCallReturnLabel_89:
   \   000014   12....       LCALL   ??zclGetAttrDataLength?relay
   \   000017   E9           MOV     A,R1
   \   000018   F8           MOV     R0,A
   \   000019   EE           MOV     A,R6
   \   00001A   28           ADD     A,R0
   \   00001B   FE           MOV     R6,A
   \   00001C                REQUIRE ?Subroutine90
   \   00001C                ; // Fall through to label ?Subroutine90

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine90:
   \   000000   EF           MOV     A,R7
   \   000001   3400         ADDC    A,#0x0
   \   000003   FF           MOV     R7,A
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine65:
   \   000000   85..82       MOV     DPL,?V0 + 14
   \   000003   85..83       MOV     DPH,?V0 + 15
   \   000006   E0           MOVX    A,@DPTR
   \   000007   FA           MOV     R2,A
   \   000008   A3           INC     DPTR
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   FB           MOV     R3,A
   \   00000B   85..82       MOV     DPL,?V0 + 12
   \   00000E   85..83       MOV     DPH,?V0 + 13
   \   000011   E0           MOVX    A,@DPTR
   \   000012   F9           MOV     R1,A
   \   000013   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   EA           MOV     A,R2
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   EB           MOV     A,R3
   \   000004   F0           MOVX    @DPTR,A
   \   000005   85..82       MOV     DPL,?XSP + 0
   \   000008   85..83       MOV     DPH,?XSP + 1
   \   00000B   EC           MOV     A,R4
   \   00000C   F0           MOVX    @DPTR,A
   \   00000D   A3           INC     DPTR
   \   00000E   ED           MOV     A,R5
   \   00000F   F0           MOVX    @DPTR,A
   \   000010   89..         MOV     ?V0 + 4,R1
   \   000012   741C         MOV     A,#0x1c
   \   000014   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   12....       LCALL   ?Subroutine76 & 0xFFFF
   \                     ??CrossCallReturnLabel_131:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   8E82         MOV     DPL,R6
   \   000006   8F83         MOV     DPH,R7
   \   000008   F0           MOVX    @DPTR,A
   \   000009   A3           INC     DPTR
   \   00000A   AE82         MOV     R6,DPL
   \   00000C   AF83         MOV     R7,DPH
   \   00000E   8882         MOV     DPL,R0
   \   000010   8983         MOV     DPH,R1
   \   000012   A3           INC     DPTR
   \   000013   12....       LCALL   ?Subroutine68 & 0xFFFF
   \                     ??CrossCallReturnLabel_91:
   \   000016   2402         ADD     A,#0x2
   \   000018   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine26:
   \   000000   12....       LCALL   ?Subroutine70 & 0xFFFF
   \                     ??CrossCallReturnLabel_214:
   \   000003   FD           MOV     R5,A
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine82:
   \   000000   E5..         MOV     A,?V0 + 2
   \   000002   28           ADD     A,R0
   \   000003   F582         MOV     DPL,A
   \   000005   E5..         MOV     A,?V0 + 3
   \   000007   39           ADDC    A,R1
   \   000008   F583         MOV     DPH,A
   \   00000A   A3           INC     DPTR
   \   00000B   22           RET
    555          #endif // ZCL_READ
    556          
    557          #ifdef ZCL_WRITE

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    558          ZStatus_t zcl_SendWriteRequest( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID, 
   \                     zcl_SendWriteRequest:
    559                                          zclWriteCmd_t *writeCmd, uint8 cmd, uint8 direction, 
    560                                          uint8 disableDefaultRsp, uint8 seqNum )
    561          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   7402         MOV     A,#0x2
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   000012   12....       LCALL   ?XSTACK_DISP0_8
   \   000015   12....       LCALL   ?Subroutine47 & 0xFFFF
   \                     ??CrossCallReturnLabel_61:
   \   000018   12....       LCALL   ?XSTACK_DISP0_8
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F5..         MOV     ?V0 + 11,A
   \   00001E   741F         MOV     A,#0x1f
   \   000020   12....       LCALL   ?XSTACK_DISP0_8
   \   000023   E0           MOVX    A,@DPTR
   \   000024   F5..         MOV     ?V0 + 10,A
   \   000026   7420         MOV     A,#0x20
   \   000028   12....       LCALL   ?XSTACK_DISP0_8
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   F5..         MOV     ?V0 + 9,A
   \   00002E   7421         MOV     A,#0x21
   \   000030   12....       LCALL   ?XSTACK_DISP0_8
   \   000033   E0           MOVX    A,@DPTR
   \   000034   F5..         MOV     ?V0 + 8,A
    562            uint8 *buf;
    563            uint8 *pBuf;
    564            zclWriteRec_t *statusRec;
    565            uint8 attrDataLen;
    566            uint8 dataLen = 0;
   \   000036   7E00         MOV     R6,#0x0
    567            uint8 i;
    568            ZStatus_t status;
    569            
    570            for ( i = 0; i < writeCmd->numAttr; i++ )
   \   000038   8E..         MOV     ?V0 + 5,R6
   \   00003A   8014         SJMP    ??zcl_SendWriteRequest_0
    571            {
    572              statusRec = &(writeCmd->attrList[i]);
   \                     ??zcl_SendWriteRequest_1:
   \   00003C   E5..         MOV     A,?V0 + 5
   \   00003E   75F005       MOV     B,#0x5
   \   000041   12....       LCALL   ?Subroutine60 & 0xFFFF
    573              
    574              attrDataLen = zclGetAttrDataLength( statusRec->dataType, statusRec->attrData );
    575              dataLen += 2 + 1 + attrDataLen; // Attribute ID + Attribute Type + Attribute Data
   \                     ??CrossCallReturnLabel_79:
   \   000044                ; Setup parameters for call to function zclGetAttrDataLength
   \   000044   12....       LCALL   ?Subroutine28 & 0xFFFF
    576            }
   \                     ??CrossCallReturnLabel_142:
   \   000047   12....       LCALL   ?Subroutine69 & 0xFFFF
   \                     ??CrossCallReturnLabel_157:
   \   00004A   2403         ADD     A,#0x3
   \   00004C   2E           ADD     A,R6
   \   00004D   FE           MOV     R6,A
   \   00004E   05..         INC     ?V0 + 5
   \                     ??zcl_SendWriteRequest_0:
   \   000050   12....       LCALL   ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_41:
   \   000053   40E7         JC      ??zcl_SendWriteRequest_1
    577          
    578            buf = osal_mem_alloc( dataLen );
   \   000055   12....       LCALL   ?Subroutine54 & 0xFFFF
    579            if ( buf != NULL )
   \                     ??CrossCallReturnLabel_73:
   \   000058   7001         JNZ     ??zcl_SendWriteRequest_2
   \   00005A   EB           MOV     A,R3
   \                     ??zcl_SendWriteRequest_2:
   \   00005B   607C         JZ      ??zcl_SendWriteRequest_3
    580            {
    581              // Load the buffer - serially
    582              pBuf = buf;
   \   00005D   AE..         MOV     R6,?V0 + 6
   \   00005F   AF..         MOV     R7,?V0 + 7
    583              for ( i = 0; i < writeCmd->numAttr; i++ )
   \   000061   75..00       MOV     ?V0 + 5,#0x0
   \   000064   8012         SJMP    ??zcl_SendWriteRequest_4
    584              { 
    585                statusRec = &(writeCmd->attrList[i]);
   \                     ??zcl_SendWriteRequest_5:
   \   000066   E5..         MOV     A,?V0 + 5
   \   000068   75F005       MOV     B,#0x5
   \   00006B   12....       LCALL   ?Subroutine1 & 0xFFFF
    586                
    587                *pBuf++ = LO_UINT16( statusRec->attrID );
    588                *pBuf++ = HI_UINT16( statusRec->attrID );
    589                *pBuf++ = statusRec->dataType;
    590                
    591                zclSerializeData( statusRec->dataType, statusRec->attrData, pBuf );
    592                
    593                attrDataLen = zclGetAttrDataLength( statusRec->dataType, statusRec->attrData );
    594                pBuf += attrDataLen; // move pass attribute data
    595              }
   \                     ??CrossCallReturnLabel_3:
   \   00006E   12....       LCALL   ?Subroutine39 & 0xFFFF
   \                     ??CrossCallReturnLabel_55:
   \   000071   2403         ADD     A,#0x3
   \   000073   12....       LCALL   ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_126:
   \   000076   05..         INC     ?V0 + 5
   \                     ??zcl_SendWriteRequest_4:
   \   000078   12....       LCALL   ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_42:
   \   00007B   40E9         JC      ??zcl_SendWriteRequest_5
    596          
    597              status = zcl_SendCommand( srcEP, dstAddr, clusterID, cmd, FALSE, 
    598                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \   00007D                ; Setup parameters for call to function zcl_SendCommand
   \   00007D   78..         MOV     R0,#?V0 + 6
   \   00007F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000082   78..         MOV     R0,#?V0 + 0
   \   000084   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000087   E5..         MOV     A,?V0 + 8
   \   000089   F5..         MOV     ?V0 + 0,A
   \   00008B   78..         MOV     R0,#?V0 + 0
   \   00008D   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000090   75..00       MOV     ?V0 + 0,#0x0
   \   000093   78..         MOV     R0,#?V0 + 0
   \   000095   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000098   E5..         MOV     A,?V0 + 9
   \   00009A   F5..         MOV     ?V0 + 0,A
   \   00009C   78..         MOV     R0,#?V0 + 0
   \   00009E   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000A1   E5..         MOV     A,?V0 + 10
   \   0000A3   F5..         MOV     ?V0 + 0,A
   \   0000A5   78..         MOV     R0,#?V0 + 0
   \   0000A7   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000AA   75..00       MOV     ?V0 + 0,#0x0
   \   0000AD   78..         MOV     R0,#?V0 + 0
   \   0000AF   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000B2   E5..         MOV     A,?V0 + 11
   \   0000B4   F5..         MOV     ?V0 + 0,A
   \   0000B6   78..         MOV     R0,#?V0 + 0
   \   0000B8   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000BB   740B         MOV     A,#0xb
   \   0000BD   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C0   12....       LCALL   ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_31:
   \   0000C3   740D         MOV     A,#0xd
   \   0000C5   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C8   12....       LCALL   ?Subroutine33 & 0xFFFF
   \                     ??CrossCallReturnLabel_44:
   \   0000CB   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000CE   E9           MOV     A,R1
   \   0000CF   FE           MOV     R6,A
    599              osal_mem_free( buf );
   \   0000D0                ; Setup parameters for call to function osal_mem_free
   \   0000D0   AA..         MOV     R2,?V0 + 6
   \   0000D2   AB..         MOV     R3,?V0 + 7
   \   0000D4   12....       LCALL   ??osal_mem_free?relay
   \   0000D7   8002         SJMP    ??zcl_SendWriteRequest_6
    600            }
    601            else
    602              status = ZMemError;
   \                     ??zcl_SendWriteRequest_3:
   \   0000D9   7E10         MOV     R6,#0x10
    603          
    604            return ( status);
   \                     ??zcl_SendWriteRequest_6:
   \   0000DB   02....       LJMP    ?Subroutine95 & 0xFFFF
    605          }
    606          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    607          ZStatus_t zcl_SendWriteRsp( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendWriteRsp:
    608                                      uint16 clusterID, zclWriteRspCmd_t *writeRspCmd,
    609                                      uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
    610          {
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 6,R1
   \   000007   EA           MOV     A,R2
   \   000008   FE           MOV     R6,A
   \   000009   EB           MOV     A,R3
   \   00000A   FF           MOV     R7,A
   \   00000B   8C..         MOV     ?V0 + 0,R4
   \   00000D   8D..         MOV     ?V0 + 1,R5
   \   00000F   7416         MOV     A,#0x16
   \   000011   12....       LCALL   ?XSTACK_DISP0_8
   \   000014   12....       LCALL   ?Subroutine46 & 0xFFFF
   \                     ??CrossCallReturnLabel_59:
   \   000017   12....       LCALL   ?XSTACK_DISP0_8
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   F5..         MOV     ?V0 + 7,A
   \   00001D   7419         MOV     A,#0x19
   \   00001F   12....       LCALL   ?XSTACK_DISP0_8
   \   000022   E0           MOVX    A,@DPTR
   \   000023   F5..         MOV     ?V0 + 10,A
   \   000025   741A         MOV     A,#0x1a
   \   000027   12....       LCALL   ?XSTACK_DISP0_8
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   F5..         MOV     ?V0 + 11,A
    611            uint8 dataLen;
    612            uint8 *buf;
    613            uint8 *pBuf;
    614            uint8 i;
    615            ZStatus_t status;
    616            
    617            dataLen = writeRspCmd->numAttr * ( 1 + 2 ); // status + attribute id
   \   00002D   75F003       MOV     B,#0x3
   \   000030   85..82       MOV     DPL,?V0 + 4
   \   000033   85..83       MOV     DPH,?V0 + 5
   \   000036   E0           MOVX    A,@DPTR
   \   000037   A4           MUL     AB
   \   000038   F5..         MOV     ?V0 + 12,A
    618          
    619            buf = osal_mem_alloc( dataLen );
   \   00003A                ; Setup parameters for call to function osal_mem_alloc
   \   00003A   FA           MOV     R2,A
   \   00003B   12....       LCALL   ?Subroutine53 & 0xFFFF
    620            if ( buf != NULL )
   \                     ??CrossCallReturnLabel_71:
   \   00003E   7001         JNZ     ??zcl_SendWriteRsp_0
   \   000040   EB           MOV     A,R3
   \                     ??zcl_SendWriteRsp_0:
   \   000041   7003         JNZ     $+5
   \   000043   02....       LJMP    ??zcl_SendWriteRsp_1 & 0xFFFF
    621            {
    622              // Load the buffer - serially
    623              pBuf = buf;
   \   000046   A8..         MOV     R0,?V0 + 2
   \   000048   A9..         MOV     R1,?V0 + 3
    624              for ( i = 0; i < writeRspCmd->numAttr; i++ )
   \   00004A   75..00       MOV     ?V0 + 8,#0x0
   \   00004D   802E         SJMP    ??zcl_SendWriteRsp_2
    625              { 
    626                *pBuf++ = writeRspCmd->attrList[i].status;
   \                     ??zcl_SendWriteRsp_3:
   \   00004F   E5..         MOV     A,?V0 + 8
   \   000051   75F003       MOV     B,#0x3
   \   000054   A4           MUL     AB
   \   000055   FA           MOV     R2,A
   \   000056   ABF0         MOV     R3,B
   \   000058   E5..         MOV     A,?V0 + 4
   \   00005A   2A           ADD     A,R2
   \   00005B   FA           MOV     R2,A
   \   00005C   E5..         MOV     A,?V0 + 5
   \   00005E   3B           ADDC    A,R3
   \   00005F   FB           MOV     R3,A
   \   000060   8A82         MOV     DPL,R2
   \   000062   8B83         MOV     DPH,R3
   \   000064   A3           INC     DPTR
   \   000065   12....       LCALL   ?Subroutine38 & 0xFFFF
    627                *pBuf++ = LO_UINT16( writeRspCmd->attrList[i].attrID );
   \                     ??CrossCallReturnLabel_130:
   \   000068   EA           MOV     A,R2
   \   000069   2402         ADD     A,#0x2
   \   00006B   0A           INC     R2
   \   00006C   0A           INC     R2
   \   00006D   EB           MOV     A,R3
   \   00006E   3400         ADDC    A,#0x0
   \   000070   FB           MOV     R3,A
   \   000071   8A82         MOV     DPL,R2
   \   000073   8B83         MOV     DPH,R3
   \   000075   12....       LCALL   ??Subroutine104_0 & 0xFFFF
    628                *pBuf++ = HI_UINT16( writeRspCmd->attrList[i].attrID );
   \                     ??CrossCallReturnLabel_137:
   \   000078   12....       LCALL   ?Subroutine24 & 0xFFFF
    629              }
   \                     ??CrossCallReturnLabel_139:
   \   00007B   05..         INC     ?V0 + 8
   \                     ??zcl_SendWriteRsp_2:
   \   00007D   85..82       MOV     DPL,?V0 + 4
   \   000080   85..83       MOV     DPH,?V0 + 5
   \   000083   E0           MOVX    A,@DPTR
   \   000084   FA           MOV     R2,A
   \   000085   E5..         MOV     A,?V0 + 8
   \   000087   C3           CLR     C
   \   000088   9A           SUBB    A,R2
   \   000089   40C4         JC      ??zcl_SendWriteRsp_3
    630              
    631              // If there's only a single status record and its status field is set to 
    632              // SUCCESS then omit the attribute ID field.
    633              if ( writeRspCmd->numAttr == 1 && writeRspCmd->attrList[0].status == ZCL_STATUS_SUCCESS )
   \   00008B   E0           MOVX    A,@DPTR
   \   00008C   6401         XRL     A,#0x1
   \   00008E   7007         JNZ     ??zcl_SendWriteRsp_4
   \   000090   A3           INC     DPTR
   \   000091   E0           MOVX    A,@DPTR
   \   000092   7003         JNZ     ??zcl_SendWriteRsp_4
    634                dataLen = 1;
   \   000094   75..01       MOV     ?V0 + 12,#0x1
    635                
    636              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_WRITE_RSP, FALSE,
    637                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \                     ??zcl_SendWriteRsp_4:
   \   000097                ; Setup parameters for call to function zcl_SendCommand
   \   000097   78..         MOV     R0,#?V0 + 2
   \   000099   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00009C   75..00       MOV     ?V0 + 13,#0x0
   \   00009F   78..         MOV     R0,#?V0 + 12
   \   0000A1   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000A4   E5..         MOV     A,?V0 + 11
   \   0000A6   F5..         MOV     ?V0 + 4,A
   \   0000A8   78..         MOV     R0,#?V0 + 4
   \   0000AA   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000AD   75..00       MOV     ?V0 + 4,#0x0
   \   0000B0   75..00       MOV     ?V0 + 5,#0x0
   \   0000B3   78..         MOV     R0,#?V0 + 4
   \   0000B5   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000B8   E5..         MOV     A,?V0 + 10
   \   0000BA   F5..         MOV     ?V0 + 4,A
   \   0000BC   78..         MOV     R0,#?V0 + 4
   \   0000BE   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000C1   E5..         MOV     A,?V0 + 7
   \   0000C3   F5..         MOV     ?V0 + 4,A
   \   0000C5   78..         MOV     R0,#?V0 + 4
   \   0000C7   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000CA   75..00       MOV     ?V0 + 4,#0x0
   \   0000CD   78..         MOV     R0,#?V0 + 4
   \   0000CF   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000D2   75..04       MOV     ?V0 + 4,#0x4
   \   0000D5   78..         MOV     R0,#?V0 + 4
   \   0000D7   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000DA   AC..         MOV     R4,?V0 + 0
   \   0000DC   AD..         MOV     R5,?V0 + 1
   \   0000DE   EE           MOV     A,R6
   \   0000DF   FA           MOV     R2,A
   \   0000E0   EF           MOV     A,R7
   \   0000E1   FB           MOV     R3,A
   \   0000E2   A9..         MOV     R1,?V0 + 6
   \   0000E4   12....       LCALL   ?Subroutine74 & 0xFFFF
   \                     ??CrossCallReturnLabel_96:
   \   0000E7   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000EA   E9           MOV     A,R1
   \   0000EB   FE           MOV     R6,A
    638              osal_mem_free( buf );
   \   0000EC                ; Setup parameters for call to function osal_mem_free
   \   0000EC   AA..         MOV     R2,?V0 + 2
   \   0000EE   AB..         MOV     R3,?V0 + 3
   \   0000F0   12....       LCALL   ??osal_mem_free?relay
   \   0000F3   8002         SJMP    ??zcl_SendWriteRsp_5
    639            }
    640            else
    641              status = ZMemError;
   \                     ??zcl_SendWriteRsp_1:
   \   0000F5   7E10         MOV     R6,#0x10
    642          
    643            return ( status );
   \                     ??zcl_SendWriteRsp_5:
   \   0000F7   02....       LJMP    ?Subroutine96 & 0xFFFF
    644          }
    645          #endif // ZCL_WRITE
    646          
    647          #ifdef ZCL_REPORT
    648          ZStatus_t zcl_SendConfigReportCmd( uint8 srcEP, afAddrType_t *dstAddr,
    649                                    uint16 clusterID, zclCfgReportCmd_t *cfgReportCmd,
    650                                    uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
    651          {
    652            uint8 *buf;
    653            uint8 *pBuf;
    654            uint8 dataLen = 0;
    655            zclCfgReportRec_t *reportRec;
    656            uint8 reportChangeLen; // length of Reportable Change field
    657            uint8 i;
    658            ZStatus_t status;
    659            
    660            // Find out the data length
    661            for ( i = 0; i < cfgReportCmd->numAttr; i++ )
    662            {
    663              reportRec = &(cfgReportCmd->attrList[i]);
    664              
    665              dataLen += 1 + 2; // Direction + Attribute ID
    666              reportChangeLen = 0;
    667              
    668              if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
    669              {
    670                dataLen += 1 + 2 + 2; // Data Type + Min + Max Reporting Intervals
    671                
    672                // Find out the size of the Reportable Change field (for Analog data types)
    673                if ( zclAnalogDataType( reportRec->dataType ) )
    674                {
    675                  reportChangeLen = zclGetDataTypeLength( reportRec->dataType );
    676                  dataLen += reportChangeLen;
    677                }
    678              }
    679              else
    680              {
    681                dataLen += 2; // Timeout Period
    682              }
    683            }
    684            
    685            buf = osal_mem_alloc( dataLen );
    686            if ( buf != NULL )
    687            {
    688              // Load the buffer - serially
    689              pBuf = buf;
    690              for ( i = 0; i < cfgReportCmd->numAttr; i++ )
    691              {
    692                reportRec = &(cfgReportCmd->attrList[i]);
    693                
    694                *pBuf++ = reportRec->direction;
    695                *pBuf++ = LO_UINT16( reportRec->attrID );
    696                *pBuf++ = HI_UINT16( reportRec->attrID );
    697                
    698                if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
    699                {
    700                  *pBuf++ = reportRec->dataType;
    701                  *pBuf++ = LO_UINT16( reportRec->minReportInt );
    702                  *pBuf++ = HI_UINT16( reportRec->minReportInt );
    703                  *pBuf++ = LO_UINT16( reportRec->maxReportInt );
    704                  *pBuf++ = HI_UINT16( reportRec->maxReportInt );
    705          
    706                  if ( zclAnalogDataType( reportRec->dataType ) )
    707                  {
    708                    zclSerializeData( reportRec->dataType, reportRec->reportableChange, pBuf );
    709                    reportChangeLen = zclGetDataTypeLength( reportRec->dataType );
    710                    pBuf += reportChangeLen;
    711                  }
    712                }
    713                else
    714                {
    715                  *pBuf++ = LO_UINT16( reportRec->timeoutPeriod );
    716                  *pBuf++ = HI_UINT16( reportRec->timeoutPeriod );
    717                } 
    718              } // for loop
    719              
    720              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_CONFIG_REPORT, FALSE, 
    721                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
    722              osal_mem_free( buf );
    723            }
    724            else
    725              status = ZMemError;
    726            
    727            return ( status );
    728          }
    729          
    730          ZStatus_t zcl_SendConfigReportRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
    731                              uint16 clusterID, zclCfgReportRspCmd_t *cfgReportRspCmd,
    732                              uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
    733          {
    734            uint8 dataLen;
    735            uint8 *buf;
    736            uint8 *pBuf;
    737            uint8 i;
    738            ZStatus_t status;
    739            
    740            // Atrribute list (Status, Direction and Attribute ID)
    741            dataLen = cfgReportRspCmd->numAttr * ( 1 + 1 + 2 ); 
    742            
    743            buf = osal_mem_alloc( dataLen );
    744            if ( buf != NULL )
    745            {
    746              // Load the buffer - serially
    747              pBuf = buf; 
    748              for ( i = 0; i < cfgReportRspCmd->numAttr; i++ )
    749              {
    750                *pBuf++ = cfgReportRspCmd->attrList[i].status;
    751                *pBuf++ = cfgReportRspCmd->attrList[i].direction;
    752                *pBuf++ = LO_UINT16( cfgReportRspCmd->attrList[i].attrID );
    753                *pBuf++ = HI_UINT16( cfgReportRspCmd->attrList[i].attrID );
    754              }
    755              
    756              // If there's only a single status record and its status field is set to 
    757              // SUCCESS then omit the attribute ID field.
    758              if ( cfgReportRspCmd->numAttr == 1 && cfgReportRspCmd->attrList[0].status == ZCL_STATUS_SUCCESS )
    759                dataLen = 1;
    760              
    761              status = zcl_SendCommand( srcEP, dstAddr, clusterID,
    762                                        ZCL_CMD_CONFIG_REPORT_RSP, FALSE, direction, 
    763                                        disableDefaultRsp, 0, seqNum, dataLen, buf );
    764              osal_mem_free( buf );
    765            }
    766            else
    767              status = ZMemError;
    768            
    769            return ( status );
    770          }
    771          
    772          ZStatus_t zcl_SendReadReportCfgCmd( uint8 srcEP, afAddrType_t *dstAddr,
    773                            uint16 clusterID, zclReadReportCfgCmd_t *readReportCfgCmd,
    774                            uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
    775          {
    776            uint8 dataLen;
    777            uint8 *buf;
    778            uint8 *pBuf;
    779            uint8 i;
    780            ZStatus_t status;
    781           
    782            dataLen = readReportCfgCmd->numAttr * ( 1 + 2 ); // Direction + Atrribute ID
    783            
    784            buf = osal_mem_alloc( dataLen );
    785            if ( buf != NULL )
    786            {
    787              // Load the buffer - serially
    788              pBuf = buf;
    789              for ( i = 0; i < readReportCfgCmd->numAttr; i++ )
    790              {
    791                *pBuf++ = readReportCfgCmd->attrList[i].direction;
    792                *pBuf++ = LO_UINT16( readReportCfgCmd->attrList[i].attrID );
    793                *pBuf++ = HI_UINT16( readReportCfgCmd->attrList[i].attrID );
    794              }
    795              
    796              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ_REPORT_CFG, FALSE, 
    797                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
    798              osal_mem_free( buf );
    799            }
    800            else
    801              status = ZMemError;
    802            
    803            return ( status );
    804          }
    805          
    806          ZStatus_t zcl_SendReadReportCfgRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
    807                       uint16 clusterID, zclReadReportCfgRspCmd_t *readReportCfgRspCmd,
    808                       uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
    809          {
    810            uint8 *buf;
    811            uint8 *pBuf;
    812            uint8 dataLen = 0;
    813            zclReportCfgRspRec_t *reportRspRec;
    814            uint8 reportChangeLen;
    815            uint8 i;
    816            ZStatus_t status;
    817          
    818            // Find out the data length
    819            for ( i = 0; i < readReportCfgRspCmd->numAttr; i++ )
    820            {
    821              reportRspRec = &(readReportCfgRspCmd->attrList[i]);
    822              
    823              dataLen += 1 + 1 + 2 ; // Status, Direction and Atrribute ID
    824              
    825              if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
    826              {
    827                if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
    828                {
    829                  dataLen += 1 + 2 + 2; // Data Type + Min + Max Reporting Intervals
    830                
    831                  if ( zclAnalogDataType( reportRspRec->dataType ) )
    832                  {
    833                    reportChangeLen = zclGetDataTypeLength( reportRspRec->dataType );
    834                    dataLen += reportChangeLen; // Reportable Change field
    835                  }
    836                }
    837                else
    838                {
    839                  dataLen += 2; // Timeout Period
    840                }
    841              }
    842            }
    843            
    844            buf = osal_mem_alloc( dataLen );
    845            if ( buf != NULL )
    846            {
    847              // Load the buffer - serially
    848              pBuf = buf;
    849          
    850              for ( i = 0; i < readReportCfgRspCmd->numAttr; i++ )
    851              {
    852                reportRspRec = &(readReportCfgRspCmd->attrList[i]);
    853          
    854                *pBuf++ = reportRspRec->status;
    855                *pBuf++ = reportRspRec->direction;
    856                *pBuf++ = LO_UINT16( reportRspRec->attrID );
    857                *pBuf++ = HI_UINT16( reportRspRec->attrID );
    858               
    859                if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
    860                {
    861                  if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
    862                  {
    863                    *pBuf++ = reportRspRec->dataType;
    864                    *pBuf++ = LO_UINT16( reportRspRec->minReportInt );
    865                    *pBuf++ = HI_UINT16( reportRspRec->minReportInt );
    866                    *pBuf++ = LO_UINT16( reportRspRec->maxReportInt );
    867                    *pBuf++ = HI_UINT16( reportRspRec->maxReportInt );
    868          
    869                    if ( zclAnalogDataType( reportRspRec->dataType ) )
    870                    {
    871                      zclSerializeData( reportRspRec->dataType, 
    872                                        reportRspRec->reportableChange, pBuf );
    873                      reportChangeLen = zclGetDataTypeLength( reportRspRec->dataType );
    874                      pBuf += reportChangeLen;
    875                    }
    876                  }
    877                  else
    878                  {
    879                    *pBuf++ = LO_UINT16( reportRspRec->timeoutPeriod );
    880                    *pBuf++ = HI_UINT16( reportRspRec->timeoutPeriod );
    881                  }
    882                }
    883              }
    884             
    885              status = zcl_SendCommand( srcEP, dstAddr, clusterID,
    886                                        ZCL_CMD_READ_REPORT_CFG_RSP, FALSE,
    887                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
    888              osal_mem_free( buf );
    889            }
    890            else
    891              status = ZMemError;
    892            
    893            return ( status );
    894          }
    895          
    896          ZStatus_t zcl_SendReportCmd( uint8 srcEP, afAddrType_t *dstAddr,
    897                                       uint16 clusterID, zclReportCmd_t *reportCmd,
    898                                       uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
    899          {
    900            zclReport_t *reportRec;
    901            uint8 attrDataLen;
    902            uint8 dataLen = 0;
    903            uint8 *buf;
    904            uint8 *pBuf;
    905            uint8 i;
    906            ZStatus_t status;
    907            
    908            // calculate the size of the command
    909            for ( i = 0; i < reportCmd->numAttr; i++ )
    910            {
    911              reportRec = &(reportCmd->attrList[i]);
    912              
    913              dataLen += 2 + 1; // Attribute ID + data type
    914          
    915              attrDataLen = zclGetAttrDataLength( reportRec->dataType, reportRec->attrData );
    916              dataLen += attrDataLen; // Attribute Data
    917            }
    918            
    919            buf = osal_mem_alloc( dataLen );
    920            if ( buf != NULL )
    921            {
    922              // Load the buffer - serially
    923              pBuf = buf;
    924              for ( i = 0; i < reportCmd->numAttr; i++ )
    925              {
    926                reportRec = &(reportCmd->attrList[i]);
    927                
    928                *pBuf++ = LO_UINT16( reportRec->attrID );
    929                *pBuf++ = HI_UINT16( reportRec->attrID );
    930                *pBuf++ = reportRec->dataType;
    931          
    932                zclSerializeData( reportRec->dataType, reportRec->attrData, pBuf );
    933                attrDataLen = zclGetAttrDataLength( reportRec->dataType, reportRec->attrData );
    934                pBuf += attrDataLen; // move pass attribute data
    935              }
    936           
    937              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_REPORT, FALSE, 
    938                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
    939              osal_mem_free( buf );
    940            }
    941            else
    942              status = ZMemError;
    943            
    944            return ( status );
    945          }
    946          #endif // ZCL_REPORT
    947          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    948          ZStatus_t zcl_SendDefaultRspCmd( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID,
   \                     zcl_SendDefaultRspCmd:
    949                                           zclDefaultRspCmd_t *defaultRspCmd, uint8 direction,
    950                                           uint8 disableDefaultRsp, uint16 manuCode, uint8 seqNum )
    951          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   \   00000C   7410         MOV     A,#0x10
   \   00000E   12....       LCALL   ?XSTACK_DISP0_8
   \   000011   12....       LCALL   ??Subroutine127_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_238:
   \   000014   7412         MOV     A,#0x12
   \   000016   12....       LCALL   ?XSTACK_DISP0_8
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   FF           MOV     R7,A
   \   00001B   7413         MOV     A,#0x13
   \   00001D   12....       LCALL   ?XSTACK_DISP0_8
   \   000020   E0           MOVX    A,@DPTR
   \   000021   F5..         MOV     ?V0 + 4,A
   \   000023   7414         MOV     A,#0x14
   \   000025   12....       LCALL   ?XSTACK_DISP0_8
   \   000028   E0           MOVX    A,@DPTR
   \   000029   F5..         MOV     ?V0 + 2,A
   \   00002B   A3           INC     DPTR
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   F5..         MOV     ?V0 + 3,A
   \   00002F   7416         MOV     A,#0x16
   \   000031   12....       LCALL   ?XSTACK_DISP0_8
   \   000034   E0           MOVX    A,@DPTR
   \   000035   F5..         MOV     ?V0 + 5,A
    952            uint8 buf[2]; // Command ID and Status;
    953          
    954            // Load the buffer - serially
    955            buf[0] = defaultRspCmd->commandID;
   \   000037   8882         MOV     DPL,R0
   \   000039   8983         MOV     DPH,R1
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   85..82       MOV     DPL,?XSP + 0
   \   00003F   85..83       MOV     DPH,?XSP + 1
   \   000042   12....       LCALL   ?Subroutine14 & 0xFFFF
    956            buf[1] = defaultRspCmd->statusCode;
   \                     ??CrossCallReturnLabel_21:
   \   000045   E0           MOVX    A,@DPTR
   \   000046   C0E0         PUSH    A
   \   000048   7401         MOV     A,#0x1
   \   00004A   12....       LCALL   ?XSTACK_DISP0_8
   \   00004D   D0E0         POP     A
   \   00004F   F0           MOVX    @DPTR,A
    957          
    958            return ( zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DEFAULT_RSP, FALSE,
    959                                      direction, disableDefaultRsp, manuCode, seqNum, 2, buf ) ); 
   \   000050                ; Setup parameters for call to function zcl_SendCommand
   \   000050   85..82       MOV     DPL,?XSP + 0
   \   000053   85..83       MOV     DPH,?XSP + 1
   \   000056   8582..       MOV     ?V0 + 0,DPL
   \   000059   8583..       MOV     ?V0 + 1,DPH
   \   00005C   78..         MOV     R0,#?V0 + 0
   \   00005E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000061   75..02       MOV     ?V0 + 0,#0x2
   \   000064   75..00       MOV     ?V0 + 1,#0x0
   \   000067   78..         MOV     R0,#?V0 + 0
   \   000069   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00006C   E5..         MOV     A,?V0 + 5
   \   00006E   F5..         MOV     ?V0 + 0,A
   \   000070   78..         MOV     R0,#?V0 + 0
   \   000072   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000075   78..         MOV     R0,#?V0 + 2
   \   000077   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00007A   E5..         MOV     A,?V0 + 4
   \   00007C   F5..         MOV     ?V0 + 0,A
   \   00007E   78..         MOV     R0,#?V0 + 0
   \   000080   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000083   EF           MOV     A,R7
   \   000084   F5..         MOV     ?V0 + 0,A
   \   000086   78..         MOV     R0,#?V0 + 0
   \   000088   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00008B   75..00       MOV     ?V0 + 0,#0x0
   \   00008E   78..         MOV     R0,#?V0 + 0
   \   000090   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000093   75..0B       MOV     ?V0 + 0,#0xb
   \   000096   78..         MOV     R0,#?V0 + 0
   \   000098   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00009B   EE           MOV     A,R6
   \   00009C   F9           MOV     R1,A
   \   00009D   12....       LCALL   ?Subroutine74 & 0xFFFF
   \                     ??CrossCallReturnLabel_97:
   \   0000A0   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000A3   7402         MOV     A,#0x2
   \   0000A5   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000A8   02....       LJMP    ?Subroutine86 & 0xFFFF
    960          }
    961          
    962          #ifdef ZCL_DISCOVER
    963          ZStatus_t zcl_SendDiscoverCmd( uint8 srcEP, afAddrType_t *dstAddr,
    964                                      uint16 clusterID, zclDiscoverCmd_t *discoverCmd,
    965                                      uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
    966          {
    967            uint8 dataLen = 2 + 1; // Start Attribute ID and Max Attribute IDs
    968            uint8 *buf;
    969            uint8 *pBuf;
    970            ZStatus_t status;
    971            
    972            buf = osal_mem_alloc( dataLen );
    973            if ( buf != NULL )
    974            {
    975              // Load the buffer - serially
    976              pBuf = buf;
    977              *pBuf++ = LO_UINT16(discoverCmd->startAttr);
    978              *pBuf++ = HI_UINT16(discoverCmd->startAttr);
    979              *pBuf++ = discoverCmd->maxAttrIDs;
    980              
    981              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER, FALSE, 
    982                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
    983              osal_mem_free( buf );
    984            }
    985            else
    986              status = ZMemError;
    987            
    988            return ( status );
    989          }
    990          
    991          ZStatus_t zcl_SendDiscoverRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
    992                                uint16 clusterID, zclDiscoverRspCmd_t *discoverRspCmd,
    993                                uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
    994          {
    995            uint8 dataLen = 1; // Discovery complete
    996            uint8 *buf;
    997            uint8 *pBuf;
    998            uint8 i;
    999            ZStatus_t status;
   1000            
   1001            // calculate the size of the command
   1002            dataLen += discoverRspCmd->numAttr * (2 + 1); // Attribute ID and Data Type
   1003            
   1004            buf = osal_mem_alloc( dataLen );
   1005            if ( buf != NULL )
   1006            {
   1007              // Load the buffer - serially
   1008              pBuf = buf;
   1009              *pBuf++ = discoverRspCmd->discComplete;    
   1010              for ( i = 0; i < discoverRspCmd->numAttr; i++ )
   1011              {
   1012                *pBuf++ = LO_UINT16(discoverRspCmd->attrList[i].attrID);
   1013                *pBuf++ = HI_UINT16(discoverRspCmd->attrList[i].attrID);
   1014                *pBuf++ = discoverRspCmd->attrList[i].dataType;
   1015              }
   1016              
   1017              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_RSP, FALSE,
   1018                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1019              osal_mem_free( buf );
   1020            }
   1021            else
   1022              status = ZMemError;
   1023            
   1024            return ( status );
   1025          }
   1026          #endif // ZCL_DISCOVER
   1027          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1028          void zclProcessMessageMSG( afIncomingMSGPacket_t *pkt )
   \                     zclProcessMessageMSG:
   1029          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 20
   \   000005   74EC         MOV     A,#-0x14
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   1030          #if defined(Coor_receiver) // The coordinator receive data
   1031            byte recv_data[30];  
   1032          #endif
   1033            byte receive[20]; 
   1034            uint16 len;
   1035            endPointDesc_t *epDesc;
   1036            zclIncoming_t inMsg;
   1037            zclLibPlugin_t *pInPlugin;
   1038            zclDefaultRspCmd_t defautlRspCmd;
   1039            uint8 options;
   1040            uint8 securityEnable;
   1041            uint8 interPanMsg;
   1042            ZStatus_t status = ZFailure;
   1043          
   1044            if ( pkt->cmd.DataLength == 0 ) return;   // Error, ignore the message
   \   00000A   EA           MOV     A,R2
   \   00000B   241F         ADD     A,#0x1f
   \   00000D   12....       LCALL   ?Subroutine75 & 0xFFFF
   \                     ??CrossCallReturnLabel_234:
   \   000010   12....       LCALL   ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_32:
   \   000013   EC           MOV     A,R4
   \   000014   7001         JNZ     ??zclProcessMessageMSG_0
   \   000016   ED           MOV     A,R5
   \                     ??zclProcessMessageMSG_0:
   \   000017   605C         JZ      ??zclProcessMessageMSG_1
   1045          
   1046          #if defined(Coor_receiver)
   1047            if (pkt->cmd.DataLength > 0)
   1048            {
   1049              for(len = 0; len < pkt->cmd.DataLength; len++) // Send the recv_data to UART
   1050              {
   1051                  recv_data[len] = pkt->cmd.Data[len+3]; // the cmd.Data[0~2] is cluster ID.
   1052              }
   1053              
   1054              #define HI_UINT16(a) (((a) >> 8) & 0xFF)
   1055              #define LO_UINT16(a) ((a) & 0xFF)
   1056              
   1057              char entry[4];
   1058              uint8 hi = HI_UINT16( pkt->srcAddr.addr.shortAddr );
   1059              uint8 lo = LO_UINT16( pkt->srcAddr.addr.shortAddr );
   1060          
   1061              entry[0] = hi/16 + 48;  /* Little Endian for the radio RAM */
   1062              entry[1] = hi%16 + 48;
   1063              entry[2] = lo/16 + 48;
   1064              entry[3] = lo%16 + 48;
   1065              for (int k=0;k<4;k++)
   1066              {
   1067                if(entry[k]>57)
   1068                  entry[k]+=7;
   1069              }
   1070          /*
   1071              HalUARTWrite(MT_UART_DEFAULT_PORT, "3", 1);//Cmd Type
   1072              HalUARTWrite(MT_UART_DEFAULT_PORT, ",", 1);//Comma   
   1073              HalUARTWrite(MT_UART_DEFAULT_PORT, entry, 4);//Device ID
   1074              HalUARTWrite(MT_UART_DEFAULT_PORT, ",", 1);//Comma
   1075              HalUARTWrite(MT_UART_DEFAULT_PORT, recv_data, pkt->cmd.DataLength-2);//Device Data
   1076              HalUARTWrite(MT_UART_DEFAULT_PORT, "$\r\n", 3);//$\n
   1077          */    
   1078              strcpy(global_entry, entry);
   1079              strcpy(global_recv_data, recv_data);
   1080              global_data_length = pkt->cmd.DataLength-2;
   1081            }
   1082          #endif
   1083          
   1084          // The device receive the uart command with RF
   1085          #if defined(End_Device) || defined(Router_Device)
   1086            if(pkt->cmd.DataLength > 0)
   1087            {
   1088              for(len = 0; len < pkt->cmd.DataLength; len++)
   \   000019   7800         MOV     R0,#0x0
   \   00001B   7900         MOV     R1,#0x0
   1089              {
   1090                receive[len] = pkt->cmd.Data[len+3];
   \                     ??zclProcessMessageMSG_2:
   \   00001D   EA           MOV     A,R2
   \   00001E   2421         ADD     A,#0x21
   \   000020   12....       LCALL   ??Subroutine106_0 & 0xFFFF
   1091              }
   \                     ??CrossCallReturnLabel_145:
   \   000023   28           ADD     A,R0
   \   000024   FE           MOV     R6,A
   \   000025   A3           INC     DPTR
   \   000026   E0           MOVX    A,@DPTR
   \   000027   39           ADDC    A,R1
   \   000028   8E82         MOV     DPL,R6
   \   00002A   F583         MOV     DPH,A
   \   00002C   A3           INC     DPTR
   \   00002D   A3           INC     DPTR
   \   00002E   A3           INC     DPTR
   \   00002F   E0           MOVX    A,@DPTR
   \   000030   C0E0         PUSH    A
   \   000032   85..82       MOV     DPL,?XSP + 0
   \   000035   85..83       MOV     DPH,?XSP + 1
   \   000038   E582         MOV     A,DPL
   \   00003A   28           ADD     A,R0
   \   00003B   F582         MOV     DPL,A
   \   00003D   E583         MOV     A,DPH
   \   00003F   39           ADDC    A,R1
   \   000040   F583         MOV     DPH,A
   \   000042   D0E0         POP     A
   \   000044   F0           MOVX    @DPTR,A
   \   000045   E8           MOV     A,R0
   \   000046   2401         ADD     A,#0x1
   \   000048   08           INC     R0
   \   000049   E9           MOV     A,R1
   \   00004A   3400         ADDC    A,#0x0
   \   00004C   F9           MOV     R1,A
   \   00004D   C3           CLR     C
   \   00004E   E8           MOV     A,R0
   \   00004F   9C           SUBB    A,R4
   \   000050   E9           MOV     A,R1
   \   000051   9D           SUBB    A,R5
   \   000052   40C9         JC      ??zclProcessMessageMSG_2
   1092              // Write receive coordinator command to UART, chrischris
   1093              // HalUARTWrite(MT_UART_DEFAULT_PORT, receive, pkt->cmd.DataLength-2);
   1094              // a - k 97=>107
   1095              // This part is addressing the level of the pwn(M160),
   1096              // and there are 11 levels which is from 97(a) to 107
   1097              #if defined(M160)
   1098                if((int)receive[0] >= 97 && (int)receive[0] <= 107 )
   \   000054   85..82       MOV     DPL,?XSP + 0
   \   000057   85..83       MOV     DPH,?XSP + 1
   \   00005A   E0           MOVX    A,@DPTR
   \   00005B   C3           CLR     C
   \   00005C   9461         SUBB    A,#0x61
   \   00005E   4015         JC      ??zclProcessMessageMSG_1
   \   000060   E0           MOVX    A,@DPTR
   \   000061   C3           CLR     C
   \   000062   946C         SUBB    A,#0x6c
   \   000064   500F         JNC     ??zclProcessMessageMSG_1
   1099                {
   1100                  int var = (int)receive[0];
   1101                  var = var + 3 - 100;
   1102                  duty_M160 = var * 10;
   \   000066   75F00A       MOV     B,#0xa
   \   000069   E0           MOVX    A,@DPTR
   \   00006A   249F         ADD     A,#-0x61
   \   00006C   A4           MUL     AB
   \   00006D   90....       MOV     DPTR,#duty_M160
   \   000070   F0           MOVX    @DPTR,A
   1103                  M160_On(duty_M160);
   \   000071                ; Setup parameters for call to function M160_On
   \   000071   F9           MOV     R1,A
   \   000072   12....       LCALL   ??M160_On?relay
   \                     ??zclProcessMessageMSG_1:
   \   000075   7414         MOV     A,#0x14
   \   000077   12....       LCALL   ?DEALLOC_XSTACK8
   1104                }
   1105              #endif  
   1106              return ;
   1107            }
   \   00007A                REQUIRE ?Subroutine97
   \   00007A                ; // Fall through to label ?Subroutine97
   1108          #endif  
   1109            
   1110            // Initialize
   1111            inMsg.msg = pkt;
   1112            inMsg.attrCmd = NULL;
   1113            inMsg.pData = NULL;
   1114            inMsg.pDataLen = 0;
   1115          
   1116            inMsg.pData = zclParseHdr( &(inMsg.hdr), pkt->cmd.Data );
   1117            inMsg.pDataLen = pkt->cmd.DataLength;
   1118            inMsg.pDataLen -= (uint16)(inMsg.pData - pkt->cmd.Data);
   1119          
   1120            // Find the wanted endpoint
   1121            epDesc = afFindEndPointDesc( pkt->endPoint );
   1122            if ( epDesc == NULL )
   1123              return;   // Error, ignore the message
   1124          
   1125            if ( pkt->clusterId == ZCL_INVALID_CLUSTER_ID )
   1126              return;   // Error, ignore the message
   1127            
   1128            if ((epDesc->simpleDesc == NULL) ||
   1129                (zcl_DeviceOperational(pkt->endPoint, pkt->clusterId, inMsg.hdr.fc.type, 
   1130                  inMsg.hdr.commandID, epDesc->simpleDesc->AppProfId) == FALSE))
   1131            {
   1132              return; // Error, ignore the message
   1133            }
   1134          
   1135          #if defined ( INTER_PAN )
   1136            if ( StubAPS_InterPan( pkt->srcAddr.panId, pkt->srcAddr.endPoint ) )
   1137            {
   1138              // No foundation command is supported thru Inter-PAN communication
   1139              if ( zcl_ProfileCmd( inMsg.hdr.fc.type ) )
   1140                return;
   1141          
   1142              interPanMsg = TRUE; 
   1143              options = AF_TX_OPTIONS_NONE;
   1144            }
   1145            else
   1146          #endif
   1147            {
   1148              interPanMsg = FALSE;
   1149              options = zclGetClusterOption( pkt->endPoint, pkt->clusterId );
   1150            }
   1151            
   1152            // Local and remote Security options must match except for Default Response command
   1153            if ( !zcl_DefaultRspCmd( inMsg.hdr ) )
   1154            {
   1155              securityEnable = ( options & AF_EN_SECURITY ) ? TRUE : FALSE;
   1156              if ( pkt->SecurityUse != securityEnable )
   1157              {
   1158                if ( UNICAST_MSG( inMsg.msg ) )
   1159                {
   1160                  // Send a Default Response command back with no Application Link Key security
   1161                  if ( securityEnable )
   1162                    zclSetSecurityOption( pkt->endPoint, pkt->clusterId, FALSE );
   1163                  
   1164                  defautlRspCmd.statusCode = status;
   1165                  defautlRspCmd.commandID = inMsg.hdr.commandID;
   1166                  zcl_SendDefaultRspCmd( inMsg.msg->endPoint, &(inMsg.msg->srcAddr),
   1167                                         inMsg.msg->clusterId, &defautlRspCmd, 
   1168                                         ZCL_FRAME_SERVER_CLIENT_DIR, true, 
   1169                                         inMsg.hdr.manuCode, inMsg.hdr.transSeqNum );
   1170                  if ( securityEnable )
   1171                    zclSetSecurityOption( pkt->endPoint, pkt->clusterId, TRUE );       
   1172                }
   1173                return;   // Error, ignore the message
   1174              }
   1175            }
   1176            
   1177            // Is this a foundation type message
   1178            if ( zcl_ProfileCmd( inMsg.hdr.fc.type ) )
   1179            { 
   1180              if ( inMsg.hdr.fc.manuSpecific )
   1181              {
   1182                // We don't support any manufacturer specific command
   1183                status = ZCL_STATUS_UNSUP_MANU_GENERAL_COMMAND;
   1184              }
   1185              else if ( ( inMsg.hdr.commandID <= ZCL_CMD_MAX ) && 
   1186                        ( zclCmdTable[inMsg.hdr.commandID].pfnParseInProfile != NULL ) )
   1187              {
   1188                zclParseCmd_t parseCmd;
   1189                
   1190                parseCmd.endpoint = pkt->endPoint;
   1191                parseCmd.dataLen = inMsg.pDataLen;
   1192                parseCmd.pData = inMsg.pData;
   1193                
   1194                // Parse the command, remember that the return value is a pointer to allocated memory
   1195                inMsg.attrCmd = zclParseCmd( inMsg.hdr.commandID, &parseCmd );
   1196                if ( (inMsg.attrCmd != NULL) && (zclCmdTable[inMsg.hdr.commandID].pfnProcessInProfile != NULL) )
   1197                { 
   1198                  // Process the command
   1199                  if ( zclProcessCmd( inMsg.hdr.commandID, &inMsg ) == FALSE )
   1200                  {
   1201                    // Couldn't find attribute in the table.
   1202                  }
   1203                }
   1204                 
   1205                // Free the buffer
   1206                if ( inMsg.attrCmd )
   1207                  osal_mem_free( inMsg.attrCmd );
   1208                
   1209                if ( CMD_HAS_RSP( inMsg.hdr.commandID ) )
   1210                  return; // We're done
   1211                
   1212                status = ZSuccess;
   1213              }
   1214              else
   1215              {
   1216                // Unsupported message
   1217                status = ZCL_STATUS_UNSUP_GENERAL_COMMAND;
   1218              }
   1219            }
   1220            else  // Not a foundation type message, so it must be specific to the cluster ID.
   1221            {
   1222              if (epDesc->simpleDesc == NULL)
   1223              {
   1224                pInPlugin = NULL;
   1225              }
   1226              else
   1227              {
   1228                // Find the appropriate plugin
   1229                pInPlugin = zclFindPlugin( pkt->clusterId, epDesc->simpleDesc->AppProfId );
   1230              }
   1231              if ( pInPlugin && pInPlugin->pfnIncomingHdlr )
   1232              { 
   1233                status = pInPlugin->pfnIncomingHdlr( &inMsg );
   1234                if ( status == ZCL_STATUS_CMD_HAS_RSP || ( interPanMsg && status == ZSuccess ) )
   1235                  return; // We're done      
   1236              }
   1237              
   1238              if ( status == ZFailure )
   1239              {
   1240                // Unsupported message
   1241                if ( inMsg.hdr.fc.manuSpecific )
   1242                  status = ZCL_STATUS_UNSUP_MANU_CLUSTER_COMMAND;
   1243                else
   1244                  status = ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
   1245              }
   1246            }
   1247            
   1248            if ( UNICAST_MSG( inMsg.msg ) && inMsg.hdr.fc.disableDefaultRsp == 0 )
   1249            {
   1250              // Send a Default Response command back
   1251              defautlRspCmd.statusCode = status;
   1252              defautlRspCmd.commandID = inMsg.hdr.commandID;
   1253              zcl_SendDefaultRspCmd( inMsg.msg->endPoint, &(inMsg.msg->srcAddr),
   1254                                     inMsg.msg->clusterId, &defautlRspCmd, 
   1255                                     ZCL_FRAME_SERVER_CLIENT_DIR, true, 
   1256                                     inMsg.hdr.manuCode, inMsg.hdr.transSeqNum );
   1257            }
   1258          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine97:
   \   000000   7F01         MOV     R7,#0x1
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine106_0:
   \   000000   F582         MOV     DPL,A
   \   000002   EB           MOV     A,R3
   \   000003                REQUIRE ??Subroutine107_0
   \   000003                ; // Fall through to label ??Subroutine107_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine107_0:
   \   000000   12....       LCALL   ??Subroutine125_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_236:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine75:
   \   000000   F582         MOV     DPL,A
   \   000002   EB           MOV     A,R3
   \   000003                REQUIRE ??Subroutine125_0
   \   000003                ; // Fall through to label ??Subroutine125_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine125_0:
   \   000000   3400         ADDC    A,#0x0
   \   000002   F583         MOV     DPH,A
   \   000004   22           RET
   1259          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1260          uint8 *zclParseHdr( zclFrameHdr_t *hdr, uint8 *pData )
   \                     zclParseHdr:
   1261          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
   1262            // Clear the header
   1263            osal_memset( (uint8 *)hdr, 0, sizeof ( zclFrameHdr_t ) );
   \   00000D                ; Setup parameters for call to function osal_memset
   \   00000D   7C06         MOV     R4,#0x6
   \   00000F   7D00         MOV     R5,#0x0
   \   000011   7900         MOV     R1,#0x0
   \   000013   12....       LCALL   ??osal_memset?relay
   1264          
   1265            // Parse the Frame Control
   1266            hdr->fc.type = zcl_FCType( *pData );
   \   000016   85..82       MOV     DPL,?V0 + 0
   \   000019   85..83       MOV     DPH,?V0 + 1
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   54FC         ANL     A,#0xfc
   \   00001F   12....       LCALL   ??Subroutine117_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_184:
   \   000022   E0           MOVX    A,@DPTR
   \   000023   FA           MOV     R2,A
   \   000024   7403         MOV     A,#0x3
   \   000026   5A           ANL     A,R2
   \   000027   48           ORL     A,R0
   \   000028   F8           MOV     R0,A
   \   000029   85..82       MOV     DPL,?V0 + 0
   \   00002C   85..83       MOV     DPH,?V0 + 1
   \   00002F   12....       LCALL   ??Subroutine122_0 & 0xFFFF
   1267            hdr->fc.manuSpecific = zcl_FCManuSpecific( *pData ) ? 1 : 0;
   \                     ??CrossCallReturnLabel_216:
   \   000032   74FB         MOV     A,#-0x5
   \   000034   58           ANL     A,R0
   \   000035   FA           MOV     R2,A
   \   000036   8E82         MOV     DPL,R6
   \   000038   8F83         MOV     DPH,R7
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   A2E2         MOV     C,0xE0 /* A   */.2
   \   00003D   E4           CLR     A
   \   00003E   92E0         MOV     0xE0 /* A   */.0,C
   \   000040   F5..         MOV     ?V0 + 2,A
   \   000042   75..00       MOV     ?V0 + 3,#0x0
   \   000045   7402         MOV     A,#0x2
   \   000047   78..         MOV     R0,#?V0 + 2
   \   000049   12....       LCALL   ?S_SHL
   \   00004C   7404         MOV     A,#0x4
   \   00004E   55..         ANL     A,?V0 + 2
   \   000050   4A           ORL     A,R2
   \   000051   85..82       MOV     DPL,?V0 + 0
   \   000054   85..83       MOV     DPH,?V0 + 1
   \   000057   12....       LCALL   ?Subroutine12 & 0xFFFF
   1268            if ( zcl_FCDirection( *pData ) )
   \                     ??CrossCallReturnLabel_17:
   \   00005A   A2E3         MOV     C,0xE0 /* A   */.3
   \   00005C   85..82       MOV     DPL,?V0 + 0
   \   00005F   85..83       MOV     DPH,?V0 + 1
   \   000062   E0           MOVX    A,@DPTR
   \   000063   5004         JNC     ??zclParseHdr_0
   1269              hdr->fc.direction = ZCL_FRAME_SERVER_CLIENT_DIR;
   \   000065   4408         ORL     A,#0x8
   \   000067   8002         SJMP    ??zclParseHdr_1
   1270            else
   1271              hdr->fc.direction = ZCL_FRAME_CLIENT_SERVER_DIR;
   \                     ??zclParseHdr_0:
   \   000069   54F7         ANL     A,#0xf7
   \                     ??zclParseHdr_1:
   \   00006B   F0           MOVX    @DPTR,A
   \   00006C   A3           INC     DPTR
   \   00006D   E0           MOVX    A,@DPTR
   \   00006E   F0           MOVX    @DPTR,A
   1272            
   1273            hdr->fc.disableDefaultRsp = zcl_FCDisableDefaultRsp( *pData ) ? 1 : 0;
   \   00006F   85..82       MOV     DPL,?V0 + 0
   \   000072   85..83       MOV     DPH,?V0 + 1
   \   000075   E0           MOVX    A,@DPTR
   \   000076   54EF         ANL     A,#0xef
   \   000078   FA           MOV     R2,A
   \   000079   A3           INC     DPTR
   \   00007A   E0           MOVX    A,@DPTR
   \   00007B   FB           MOV     R3,A
   \   00007C   8E82         MOV     DPL,R6
   \   00007E   8F83         MOV     DPH,R7
   \   000080   E0           MOVX    A,@DPTR
   \   000081   A2E4         MOV     C,0xE0 /* A   */.4
   \   000083   E4           CLR     A
   \   000084   92E0         MOV     0xE0 /* A   */.0,C
   \   000086   F5..         MOV     ?V0 + 2,A
   \   000088   7404         MOV     A,#0x4
   \   00008A   78..         MOV     R0,#?V0 + 2
   \   00008C   12....       LCALL   ?S_SHL
   \   00008F   7410         MOV     A,#0x10
   \   000091   55..         ANL     A,?V0 + 2
   \   000093   4A           ORL     A,R2
   \   000094   F8           MOV     R0,A
   \   000095   EB           MOV     A,R3
   \   000096   F9           MOV     R1,A
   \   000097   85..82       MOV     DPL,?V0 + 0
   \   00009A   85..83       MOV     DPH,?V0 + 1
   \   00009D   E8           MOV     A,R0
   \   00009E   F0           MOVX    @DPTR,A
   \   00009F   A3           INC     DPTR
   \   0000A0   E9           MOV     A,R1
   \   0000A1   12....       LCALL   ??Subroutine114_0 & 0xFFFF
   1274            pData++;  // move past the frame control field
   1275          
   1276            // parse the manfacturer code
   1277            if ( hdr->fc.manuSpecific )
   \                     ??CrossCallReturnLabel_169:
   \   0000A4   E8           MOV     A,R0
   \   0000A5   5404         ANL     A,#0x4
   \   0000A7   6014         JZ      ??CrossCallReturnLabel_10
   1278            {
   1279              hdr->manuCode = BUILD_UINT16( pData[0], pData[1] );
   \   0000A9   E0           MOVX    A,@DPTR
   \   0000AA   FA           MOV     R2,A
   \   0000AB   A3           INC     DPTR
   \   0000AC   E0           MOVX    A,@DPTR
   \   0000AD   F9           MOV     R1,A
   \   0000AE   EA           MOV     A,R2
   \   0000AF   85..82       MOV     DPL,?V0 + 0
   \   0000B2   85..83       MOV     DPH,?V0 + 1
   \   0000B5   A3           INC     DPTR
   \   0000B6   A3           INC     DPTR
   \   0000B7   F0           MOVX    @DPTR,A
   \   0000B8   A3           INC     DPTR
   \   0000B9   E9           MOV     A,R1
   \   0000BA   12....       LCALL   ?Subroutine9 & 0xFFFF
   1280              pData += 2;
   1281            }
   1282          
   1283            // parse the Transaction Sequence Number
   1284            hdr->transSeqNum = *pData++;
   \                     ??CrossCallReturnLabel_10:
   \   0000BD   8E82         MOV     DPL,R6
   \   0000BF   8F83         MOV     DPH,R7
   \   0000C1   E0           MOVX    A,@DPTR
   \   0000C2   85..82       MOV     DPL,?V0 + 0
   \   0000C5   85..83       MOV     DPH,?V0 + 1
   \   0000C8   A3           INC     DPTR
   \   0000C9   A3           INC     DPTR
   \   0000CA   A3           INC     DPTR
   \   0000CB   12....       LCALL   ?Subroutine5 & 0xFFFF
   1285          
   1286            // parse the Cluster's command ID
   1287            hdr->commandID = *pData++;
   \                     ??CrossCallReturnLabel_8:
   \   0000CE   85..82       MOV     DPL,?V0 + 0
   \   0000D1   85..83       MOV     DPH,?V0 + 1
   \   0000D4   A3           INC     DPTR
   \   0000D5   A3           INC     DPTR
   \   0000D6   A3           INC     DPTR
   \   0000D7   A3           INC     DPTR
   \   0000D8   A3           INC     DPTR
   \   0000D9   12....       LCALL   ??Subroutine115_0 & 0xFFFF
   1288          
   1289            // Should point to the frame payload
   1290            return ( pData );
   \                     ??CrossCallReturnLabel_175:
   \   0000DC   AA82         MOV     R2,DPL
   \   0000DE   AB83         MOV     R3,DPH
   \   0000E0                REQUIRE ?Subroutine85
   \   0000E0                ; // Fall through to label ?Subroutine85
   1291          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine93:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   12....       LCALL   ?Subroutine61 & 0xFFFF
   \                     ??CrossCallReturnLabel_80:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine61:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   12....       LCALL   ?Subroutine83 & 0xFFFF
   \                     ??CrossCallReturnLabel_127:
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine114_0:
   \   000000   12....       LCALL   ?Subroutine62 & 0xFFFF
   \                     ??CrossCallReturnLabel_172:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine62:
   \   000000   12....       LCALL   ?Subroutine80 & 0xFFFF
   \                     ??CrossCallReturnLabel_178:
   \   000003   A3           INC     DPTR
   \   000004   AE82         MOV     R6,DPL
   \   000006   AF83         MOV     R7,DPH
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine83:
   \   000000   EE           MOV     A,R6
   \   000001   2402         ADD     A,#0x2
   \   000003   0E           INC     R6
   \   000004   0E           INC     R6
   \   000005   02....       LJMP    ?Subroutine90 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   A3           INC     DPTR
   \   000001   12....       LCALL   ?Subroutine62 & 0xFFFF
   \                     ??CrossCallReturnLabel_173:
   \   000004   E0           MOVX    A,@DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine115_0:
   \   000000   12....       LCALL   ?Subroutine80 & 0xFFFF
   \                     ??CrossCallReturnLabel_179:
   \   000003   A3           INC     DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine117_0:
   \   000000   F8           MOV     R0,A
   \   000001   A3           INC     DPTR
   \   000002   E0           MOVX    A,@DPTR
   \   000003   F9           MOV     R1,A
   \   000004   02....       LJMP    ?Subroutine93 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine80:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   02....       LJMP    ?Subroutine93 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine122_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   E9           MOV     A,R1
   \   000003   F0           MOVX    @DPTR,A
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   E9           MOV     A,R1
   \   000003   12....       LCALL   ?Subroutine80 & 0xFFFF
   \                     ??CrossCallReturnLabel_181:
   \   000006   E0           MOVX    A,@DPTR
   \   000007   22           RET
   1292          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1293          static uint8 *zclBuildHdr( zclFrameHdr_t *hdr, uint8 *pData )
   \                     zclBuildHdr:
   1294          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   1295            // Build the Frame Control byte
   1296            *pData = hdr->fc.type;
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   5403         ANL     A,#0x3
   \   00000C   8C82         MOV     DPL,R4
   \   00000E   8D83         MOV     DPH,R5
   \   000010   12....       LCALL   ??Subroutine108_0 & 0xFFFF
   1297            *pData |= hdr->fc.manuSpecific << 2;
   \                     ??CrossCallReturnLabel_151:
   \   000013   5404         ANL     A,#0x4
   \   000015   12....       LCALL   ?Subroutine16 & 0xFFFF
   1298            *pData |= hdr->fc.direction << 3;
   \                     ??CrossCallReturnLabel_149:
   \   000018   5408         ANL     A,#0x8
   \   00001A   12....       LCALL   ?Subroutine16 & 0xFFFF
   1299            *pData |= hdr->fc.disableDefaultRsp << 4;
   \                     ??CrossCallReturnLabel_150:
   \   00001D   5410         ANL     A,#0x10
   \   00001F   FE           MOV     R6,A
   \   000020   8C82         MOV     DPL,R4
   \   000022   8D83         MOV     DPH,R5
   \   000024   E0           MOVX    A,@DPTR
   \   000025   4E           ORL     A,R6
   \   000026   12....       LCALL   ?Subroutine8 & 0xFFFF
   1300            pData++;  // move past the frame control field
   1301          
   1302            // Add the manfacturer code
   1303            if ( hdr->fc.manuSpecific )
   \                     ??CrossCallReturnLabel_187:
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   5404         ANL     A,#0x4
   \   00002C   6017         JZ      ??CrossCallReturnLabel_57
   1304            {
   1305              *pData++ = LO_UINT16( hdr->manuCode );
   \   00002E   EA           MOV     A,R2
   \   00002F   2402         ADD     A,#0x2
   \   000031   F8           MOV     R0,A
   \   000032   EB           MOV     A,R3
   \   000033   3400         ADDC    A,#0x0
   \   000035   F9           MOV     R1,A
   \   000036   8882         MOV     DPL,R0
   \   000038   8983         MOV     DPH,R1
   \   00003A   12....       LCALL   ?Subroutine43 & 0xFFFF
   1306              *pData++ = HI_UINT16( hdr->manuCode );
   \                     ??CrossCallReturnLabel_56:
   \   00003D   8882         MOV     DPL,R0
   \   00003F   8983         MOV     DPH,R1
   \   000041   A3           INC     DPTR
   \   000042   12....       LCALL   ?Subroutine43 & 0xFFFF
   1307            }
   1308          
   1309            // Add the Transaction Sequence Number
   1310            *pData++ = hdr->transSeqNum;
   \                     ??CrossCallReturnLabel_57:
   \   000045   8A82         MOV     DPL,R2
   \   000047   8B83         MOV     DPH,R3
   \   000049   A3           INC     DPTR
   \   00004A   A3           INC     DPTR
   \   00004B   A3           INC     DPTR
   \   00004C   A3           INC     DPTR
   \   00004D   E0           MOVX    A,@DPTR
   \   00004E   8C82         MOV     DPL,R4
   \   000050   8D83         MOV     DPH,R5
   \   000052   12....       LCALL   ?Subroutine8 & 0xFFFF
   1311            
   1312            // Add the Cluster's command ID
   1313            *pData++ = hdr->commandID;
   \                     ??CrossCallReturnLabel_188:
   \   000055   A3           INC     DPTR
   \   000056   A3           INC     DPTR
   \   000057   A3           INC     DPTR
   \   000058   A3           INC     DPTR
   \   000059   A3           INC     DPTR
   \   00005A   E0           MOVX    A,@DPTR
   \   00005B   8C82         MOV     DPL,R4
   \   00005D   8D83         MOV     DPH,R5
   \   00005F   F0           MOVX    @DPTR,A
   \   000060   A3           INC     DPTR
   1314          
   1315            // Should point to the frame payload
   1316            return ( pData );
   \   000061   AA82         MOV     R2,DPL
   \   000063   AB83         MOV     R3,DPH
   \   000065   02....       LJMP    ?Subroutine97 & 0xFFFF
   1317          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine43:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8C82         MOV     DPL,R4
   \   000003   8D83         MOV     DPH,R5
   \   000005   F0           MOVX    @DPTR,A
   \   000006   A3           INC     DPTR
   \   000007   0C           INC     R4
   \   000008   AD83         MOV     R5,DPH
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   FE           MOV     R6,A
   \   000001   8C82         MOV     DPL,R4
   \   000003   8D83         MOV     DPH,R5
   \   000005   E0           MOVX    A,@DPTR
   \   000006   4E           ORL     A,R6
   \   000007                REQUIRE ??Subroutine108_0
   \   000007                ; // Fall through to label ??Subroutine108_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine108_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8A82         MOV     DPL,R2
   \   000003   8B83         MOV     DPH,R3
   \   000005   E0           MOVX    A,@DPTR
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   AC82         MOV     R4,DPL
   \   000004   AD83         MOV     R5,DPH
   \   000006                REQUIRE ?Subroutine92
   \   000006                ; // Fall through to label ?Subroutine92

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine92:
   \   000000   8A82         MOV     DPL,R2
   \   000002   8B83         MOV     DPH,R3
   \   000004   22           RET
   1318          
   1319          static uint8 zclCalcHdrSize( zclFrameHdr_t *hdr )
   1320          {
   1321            uint8 needed = (1 + 1 + 1); // frame control + transaction seq num + cmd ID
   1322          
   1323            // Add the manfacturer code
   1324            if ( hdr->fc.manuSpecific )
   1325              needed += 2;
   1326          
   1327            return ( needed );
   1328          }
   1329          
   1330          static zclLibPlugin_t *zclFindPlugin( uint16 clusterID, uint16 profileID )
   1331          {
   1332            zclLibPlugin_t *pLoop;
   1333            
   1334            (void)profileID;  // Intentionally unreferenced parameter
   1335          
   1336            if ( clusterID != ZCL_INVALID_CLUSTER_ID )
   1337            {
   1338              pLoop = plugins;
   1339              while ( pLoop != NULL )
   1340              {
   1341                if ( clusterID >= pLoop->startClusterID && clusterID <= pLoop->endClusterID )
   1342                  return ( pLoop );
   1343                pLoop = pLoop->next;
   1344              }
   1345            }
   1346            return ( (zclLibPlugin_t *)NULL );
   1347          }
   1348          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1349          uint8 zclFindAttrRec( uint8 endpoint, uint16 clusterID, uint16 attrId, zclAttrRec_t *pAttr )
   \                     zclFindAttrRec:
   1350          {
   \   000000   74EE         MOV     A,#-0x12
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 18
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 2,R1
   \   000007   EA           MOV     A,R2
   \   000008   FE           MOV     R6,A
   \   000009   EB           MOV     A,R3
   \   00000A   FF           MOV     R7,A
   \   00000B   8C..         MOV     ?V0 + 0,R4
   \   00000D   8D..         MOV     ?V0 + 1,R5
   \   00000F   7412         MOV     A,#0x12
   \   000011   12....       LCALL   ?XSTACK_DISP0_8
   \   000014   12....       LCALL   ?Subroutine26 & 0xFFFF
   1351            uint8 x;
   1352            zclAttrRecsList *pLoop;
   1353          
   1354            pLoop = attrList;
   \                     ??CrossCallReturnLabel_33:
   \   000017   90....       MOV     DPTR,#attrList
   \   00001A   8004         SJMP    ??zclFindAttrRec_0
   1355          
   1356            while ( pLoop != NULL )
   1357            {
   1358              if ( pLoop->endpoint == endpoint )
   1359              {
   1360                for ( x = 0; x < pLoop->numAttributes; x++ )
   1361                {
   1362                  if ( pLoop->attrs[x].clusterID == clusterID && pLoop->attrs[x].attr.attrId == attrId )
   1363                  {
   1364                    *pAttr = pLoop->attrs[x];
   1365                    return ( TRUE ); // EMBEDDED RETURN
   1366                  }
   1367                }
   1368              }
   1369              pLoop = pLoop->next;
   \                     ??zclFindAttrRec_1:
   \   00001C   8A82         MOV     DPL,R2
   \   00001E   8B83         MOV     DPH,R3
   \                     ??zclFindAttrRec_0:
   \   000020   12....       LCALL   ??Subroutine101_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_136:
   \   000023   7001         JNZ     ??zclFindAttrRec_2
   \   000025   EB           MOV     A,R3
   \                     ??zclFindAttrRec_2:
   \   000026   7003         JNZ     $+5
   \   000028   02....       LJMP    ??zclFindAttrRec_3 & 0xFFFF
   \   00002B   8A82         MOV     DPL,R2
   \   00002D   8B83         MOV     DPH,R3
   \   00002F   A3           INC     DPTR
   \   000030   A3           INC     DPTR
   \   000031   E0           MOVX    A,@DPTR
   \   000032   65..         XRL     A,?V0 + 2
   \   000034   70E6         JNZ     ??zclFindAttrRec_1
   \   000036   75..00       MOV     ?V0 + 3,#0x0
   \   000039   EA           MOV     A,R2
   \   00003A   2404         ADD     A,#0x4
   \   00003C   F8           MOV     R0,A
   \   00003D   EB           MOV     A,R3
   \   00003E   3400         ADDC    A,#0x0
   \   000040   F9           MOV     R1,A
   \   000041   88..         MOV     ?V0 + 4,R0
   \   000043   89..         MOV     ?V0 + 5,R1
   \   000045   8002         SJMP    ??zclFindAttrRec_4
   \                     ??zclFindAttrRec_5:
   \   000047   05..         INC     ?V0 + 3
   \                     ??zclFindAttrRec_4:
   \   000049   8A82         MOV     DPL,R2
   \   00004B   8B83         MOV     DPH,R3
   \   00004D   A3           INC     DPTR
   \   00004E   A3           INC     DPTR
   \   00004F   A3           INC     DPTR
   \   000050   E0           MOVX    A,@DPTR
   \   000051   F8           MOV     R0,A
   \   000052   E5..         MOV     A,?V0 + 3
   \   000054   C3           CLR     C
   \   000055   98           SUBB    A,R0
   \   000056   50C4         JNC     ??zclFindAttrRec_1
   \   000058   85....       MOV     ?V0 + 8,?V0 + 3
   \   00005B   75..00       MOV     ?V0 + 9,#0x0
   \   00005E   7403         MOV     A,#0x3
   \   000060   78..         MOV     R0,#?V0 + 8
   \   000062   12....       LCALL   ?S_SHL
   \   000065   85....       MOV     ?V0 + 6,?V0 + 8
   \   000068   85....       MOV     ?V0 + 7,?V0 + 9
   \   00006B   85..82       MOV     DPL,?V0 + 4
   \   00006E   85..83       MOV     DPH,?V0 + 5
   \   000071   E0           MOVX    A,@DPTR
   \   000072   25..         ADD     A,?V0 + 6
   \   000074   F8           MOV     R0,A
   \   000075   A3           INC     DPTR
   \   000076   E0           MOVX    A,@DPTR
   \   000077   35..         ADDC    A,?V0 + 7
   \   000079   F9           MOV     R1,A
   \   00007A   8882         MOV     DPL,R0
   \   00007C   8983         MOV     DPH,R1
   \   00007E   E4           CLR     A
   \   00007F   93           MOVC    A,@A+DPTR
   \   000080   F8           MOV     R0,A
   \   000081   7401         MOV     A,#0x1
   \   000083   93           MOVC    A,@A+DPTR
   \   000084   F9           MOV     R1,A
   \   000085   EE           MOV     A,R6
   \   000086   68           XRL     A,R0
   \   000087   7002         JNZ     ??zclFindAttrRec_6
   \   000089   EF           MOV     A,R7
   \   00008A   69           XRL     A,R1
   \                     ??zclFindAttrRec_6:
   \   00008B   70BA         JNZ     ??zclFindAttrRec_5
   \   00008D   A3           INC     DPTR
   \   00008E   A3           INC     DPTR
   \   00008F   E4           CLR     A
   \   000090   93           MOVC    A,@A+DPTR
   \   000091   F8           MOV     R0,A
   \   000092   7401         MOV     A,#0x1
   \   000094   93           MOVC    A,@A+DPTR
   \   000095   F9           MOV     R1,A
   \   000096   E5..         MOV     A,?V0 + 0
   \   000098   68           XRL     A,R0
   \   000099   7003         JNZ     ??zclFindAttrRec_7
   \   00009B   E5..         MOV     A,?V0 + 1
   \   00009D   69           XRL     A,R1
   \                     ??zclFindAttrRec_7:
   \   00009E   70A7         JNZ     ??zclFindAttrRec_5
   \   0000A0   85..82       MOV     DPL,?V0 + 4
   \   0000A3   85..83       MOV     DPH,?V0 + 5
   \   0000A6   E0           MOVX    A,@DPTR
   \   0000A7   25..         ADD     A,?V0 + 6
   \   0000A9   FA           MOV     R2,A
   \   0000AA   A3           INC     DPTR
   \   0000AB   E0           MOVX    A,@DPTR
   \   0000AC   35..         ADDC    A,?V0 + 7
   \   0000AE   8A82         MOV     DPL,R2
   \   0000B0   F583         MOV     DPH,A
   \   0000B2   7408         MOV     A,#0x8
   \   0000B4   12....       LCALL   ?MOVE_LONG8_XDATA_CODE
   \   0000B7   7901         MOV     R1,#0x1
   \   0000B9   8002         SJMP    ??zclFindAttrRec_8
   1370            }
   1371            return ( FALSE );
   \                     ??zclFindAttrRec_3:
   \   0000BB   7900         MOV     R1,#0x0
   \                     ??zclFindAttrRec_8:
   \   0000BD   7F0A         MOV     R7,#0xa
   \   0000BF   02....       LJMP    ?BANKED_LEAVE_XDATA
   1372          }
   1373          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1374          static zclOptionRec_t *zclFindClusterOption( uint8 endpoint, uint16 clusterID )
   \                     zclFindClusterOption:
   1375          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 0,R1
   1376            uint8 x;
   1377            zclClusterOptionList *pLoop;
   1378          
   1379            pLoop = clusterOptionList;
   \   000007   90....       MOV     DPTR,#clusterOptionList
   \   00000A   8004         SJMP    ??zclFindClusterOption_0
   1380          
   1381            while ( pLoop != NULL )
   1382            {
   1383              if ( pLoop->endpoint == endpoint )
   1384              {
   1385                for ( x = 0; x < pLoop->numOptions; x++ )
   1386                {
   1387                  if ( pLoop->options[x].clusterID == clusterID )
   1388                    return ( &(pLoop->options[x]) ); // EMBEDDED RETURN
   1389                }
   1390              }
   1391              pLoop = pLoop->next;
   \                     ??zclFindClusterOption_1:
   \   00000C   8882         MOV     DPL,R0
   \   00000E   8983         MOV     DPH,R1
   \                     ??zclFindClusterOption_0:
   \   000010   12....       LCALL   ??Subroutine127_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_239:
   \   000013   E8           MOV     A,R0
   \   000014   7001         JNZ     ??zclFindClusterOption_2
   \   000016   E9           MOV     A,R1
   \                     ??zclFindClusterOption_2:
   \   000017   605F         JZ      ??zclFindClusterOption_3
   \   000019   8882         MOV     DPL,R0
   \   00001B   8983         MOV     DPH,R1
   \   00001D   A3           INC     DPTR
   \   00001E   A3           INC     DPTR
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   65..         XRL     A,?V0 + 0
   \   000022   70E8         JNZ     ??zclFindClusterOption_1
   \   000024   75..00       MOV     ?V0 + 2,#0x0
   \   000027   E8           MOV     A,R0
   \   000028   2404         ADD     A,#0x4
   \   00002A   FC           MOV     R4,A
   \   00002B   E9           MOV     A,R1
   \   00002C   3400         ADDC    A,#0x0
   \   00002E   FD           MOV     R5,A
   \   00002F   EC           MOV     A,R4
   \   000030   FE           MOV     R6,A
   \   000031   ED           MOV     A,R5
   \   000032   FF           MOV     R7,A
   \   000033   8002         SJMP    ??zclFindClusterOption_4
   \                     ??zclFindClusterOption_5:
   \   000035   05..         INC     ?V0 + 2
   \                     ??zclFindClusterOption_4:
   \   000037   8882         MOV     DPL,R0
   \   000039   8983         MOV     DPH,R1
   \   00003B   A3           INC     DPTR
   \   00003C   A3           INC     DPTR
   \   00003D   A3           INC     DPTR
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   FC           MOV     R4,A
   \   000040   E5..         MOV     A,?V0 + 2
   \   000042   C3           CLR     C
   \   000043   9C           SUBB    A,R4
   \   000044   50C6         JNC     ??zclFindClusterOption_1
   \   000046   E5..         MOV     A,?V0 + 2
   \   000048   75F003       MOV     B,#0x3
   \   00004B   A4           MUL     AB
   \   00004C   FC           MOV     R4,A
   \   00004D   85F0..       MOV     ?V0 + 1,B
   \   000050   AD..         MOV     R5,?V0 + 1
   \   000052   8E82         MOV     DPL,R6
   \   000054   8F83         MOV     DPH,R7
   \   000056   E0           MOVX    A,@DPTR
   \   000057   2C           ADD     A,R4
   \   000058   F5..         MOV     ?V0 + 1,A
   \   00005A   A3           INC     DPTR
   \   00005B   E0           MOVX    A,@DPTR
   \   00005C   3D           ADDC    A,R5
   \   00005D   85..82       MOV     DPL,?V0 + 1
   \   000060   F583         MOV     DPH,A
   \   000062   E0           MOVX    A,@DPTR
   \   000063   6A           XRL     A,R2
   \   000064   7003         JNZ     ??zclFindClusterOption_6
   \   000066   A3           INC     DPTR
   \   000067   E0           MOVX    A,@DPTR
   \   000068   6B           XRL     A,R3
   \                     ??zclFindClusterOption_6:
   \   000069   70CA         JNZ     ??zclFindClusterOption_5
   \   00006B   8E82         MOV     DPL,R6
   \   00006D   8F83         MOV     DPH,R7
   \   00006F   E0           MOVX    A,@DPTR
   \   000070   2C           ADD     A,R4
   \   000071   FA           MOV     R2,A
   \   000072   A3           INC     DPTR
   \   000073   E0           MOVX    A,@DPTR
   \   000074   3D           ADDC    A,R5
   \   000075   FB           MOV     R3,A
   \   000076   8004         SJMP    ??zclFindClusterOption_7
   1392            }
   1393            return ( NULL );
   \                     ??zclFindClusterOption_3:
   \   000078   7A00         MOV     R2,#0x0
   \   00007A   7B00         MOV     R3,#0x0
   \                     ??zclFindClusterOption_7:
   \   00007C                REQUIRE ?Subroutine98
   \   00007C                ; // Fall through to label ?Subroutine98
   1394          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine98:
   \   000000   7F03         MOV     R7,#0x3
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
   1395          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1396          static uint8 zclGetClusterOption( uint8 endpoint, uint16 clusterID )
   \                     zclGetClusterOption:
   1397          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   1398            uint8 option;
   1399            zclOptionRec_t *pOption;
   1400          
   1401             pOption = zclFindClusterOption( endpoint, clusterID );
   \   000005                ; Setup parameters for call to function zclFindClusterOption
   \   000005   12....       LCALL   ??zclFindClusterOption?relay
   \   000008   8A82         MOV     DPL,R2
   \   00000A   8B83         MOV     DPH,R3
   1402            if ( pOption != NULL )
   \   00000C   E582         MOV     A,DPL
   \   00000E   7002         JNZ     ??zclGetClusterOption_0
   \   000010   E583         MOV     A,DPH
   \                     ??zclGetClusterOption_0:
   \   000012   6008         JZ      ??zclGetClusterOption_1
   1403            {
   1404              option = pOption->option;
   1405              if ( !ZG_SECURE_ENABLED )
   1406                option &= (AF_EN_SECURITY ^ 0xFF); // make sure Application Link Key security is off
   1407          
   1408              return ( option ); // EMBEDDED RETURN
   \   000014   A3           INC     DPTR
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \   000017   54BF         ANL     A,#0xbf
   \   000019   F9           MOV     R1,A
   \   00001A   8002         SJMP    ??zclGetClusterOption_2
   1409            }
   1410          
   1411            return ( AF_TX_OPTIONS_NONE );
   \                     ??zclGetClusterOption_1:
   \   00001C   7900         MOV     R1,#0x0
   \                     ??zclGetClusterOption_2:
   \   00001E   80..         SJMP    ?Subroutine94
   1412          }
   1413          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1414          static void zclSetSecurityOption( uint8 endpoint, uint16 clusterID, uint8 enable )
   \                     zclSetSecurityOption:
   1415          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EC           MOV     A,R4
   \   000006   FE           MOV     R6,A
   1416            zclOptionRec_t *pOption;
   1417          
   1418            pOption = zclFindClusterOption( endpoint, clusterID );
   \   000007                ; Setup parameters for call to function zclFindClusterOption
   \   000007   12....       LCALL   ??zclFindClusterOption?relay
   \   00000A   8A..         MOV     ?V0 + 0,R2
   \   00000C   8B..         MOV     ?V0 + 1,R3
   \   00000E   A8..         MOV     R0,?V0 + 0
   \   000010   A9..         MOV     R1,?V0 + 1
   1419            if ( pOption != NULL )
   \   000012   E8           MOV     A,R0
   \   000013   7001         JNZ     ??zclSetSecurityOption_0
   \   000015   E9           MOV     A,R1
   \                     ??zclSetSecurityOption_0:
   \   000016   6015         JZ      ??zclSetSecurityOption_1
   1420            {
   1421              if ( enable )
   \   000018   E8           MOV     A,R0
   \   000019   2402         ADD     A,#0x2
   \   00001B   F582         MOV     DPL,A
   \   00001D   E9           MOV     A,R1
   \   00001E   12....       LCALL   ??Subroutine125_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_232:
   \   000021   EE           MOV     A,R6
   \   000022   6005         JZ      ??zclSetSecurityOption_2
   1422                pOption->option |= AF_EN_SECURITY;
   \   000024   E0           MOVX    A,@DPTR
   \   000025   D2E6         SETB    0xE0 /* A   */.6
   \   000027   8003         SJMP    ??zclSetSecurityOption_3
   1423              else
   1424                pOption->option &= (AF_EN_SECURITY ^ 0xFF);
   \                     ??zclSetSecurityOption_2:
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   C2E6         CLR     0xE0 /* A   */.6
   \                     ??zclSetSecurityOption_3:
   \   00002C   F0           MOVX    @DPTR,A
   1425            }
   1426          }
   \                     ??zclSetSecurityOption_1:
   \   00002D                REQUIRE ?Subroutine94
   \   00002D                ; // Fall through to label ?Subroutine94
   1427          
   1428          #ifdef ZCL_DISCOVER
   1429          
   1430          static uint8 zclFindNextAttrRec( uint8 endpoint, uint16 clusterID,
   1431                                           uint16 *attrId, zclAttrRec_t *pAttr )
   1432          {
   1433            uint16 x;
   1434            zclAttrRecsList *pLoop;
   1435          
   1436            pLoop = attrList;
   1437          
   1438            while ( pLoop != NULL )
   1439            {
   1440              if ( pLoop->endpoint == endpoint )
   1441              {
   1442                for ( x = 0; x < pLoop->numAttributes; x++ )
   1443                {
   1444                  if ( pLoop->attrs[x].clusterID == clusterID && pLoop->attrs[x].attr.attrId >= *attrId )
   1445                  {
   1446                    *pAttr = pLoop->attrs[x];
   1447                    
   1448                    // Update attribute ID
   1449                    *attrId = pAttr->attr.attrId; 
   1450                    return ( TRUE ); // EMBEDDED RETURN
   1451                  }
   1452                }
   1453              }
   1454              pLoop = pLoop->next;
   1455            }
   1456          
   1457            return ( FALSE );
   1458          }
   1459          #endif // ZCL_DISCOVER
   1460          
   1461          #if defined(ZCL_READ) || defined(ZCL_WRITE) || defined(ZCL_REPORT)

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1462          static void zclSerializeData( uint8 dataType, void *attrData, uint8 *buf )
   \                     zclSerializeData:
   1463          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   EC           MOV     A,R4
   \   00000A   FA           MOV     R2,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FB           MOV     R3,A
   1464            uint8 *pStr;
   1465            uint8 len;
   1466          
   1467            switch ( dataType )
   \   00000D   8E..         MOV     ?V0 + 0,R6
   \   00000F   8F..         MOV     ?V0 + 1,R7
   \   000011   75..00       MOV     ?V0 + 2,#0x0
   \   000014   8A82         MOV     DPL,R2
   \   000016   8B83         MOV     DPH,R3
   \   000018   A3           INC     DPTR
   \   000019   AC82         MOV     R4,DPL
   \   00001B   AD83         MOV     R5,DPH
   \   00001D   E9           MOV     A,R1
   \   00001E   12....       LCALL   ?UC_SWITCH_SPARSE
   \                     `?<Jumptable for zclSerializeData>_0`:
   \   000021   03           DB        3
   \   000022   41           DB        65
   \   000023   42           DB        66
   \   000024   ....         DW        ??zclSerializeData_0
   \   000026   E0           DB        224
   \   000027   E2           DB        226
   \   000028   ....         DW        ??zclSerializeData_1
   \   00002A   E8           DB        232
   \   00002B   E9           DB        233
   \   00002C   ....         DW        ??zclSerializeData_2
   \   00002E   19           DB        25
   \   00002F   08           DB        8
   \   000030   ....         DW        ??zclSerializeData_3
   \   000032   09           DB        9
   \   000033   ....         DW        ??zclSerializeData_2
   \   000035   0A           DB        10
   \   000036   ....         DW        ??zclSerializeData_4
   \   000038   0B           DB        11
   \   000039   ....         DW        ??zclSerializeData_1
   \   00003B   10           DB        16
   \   00003C   ....         DW        ??zclSerializeData_3
   \   00003E   18           DB        24
   \   00003F   ....         DW        ??zclSerializeData_3
   \   000041   19           DB        25
   \   000042   ....         DW        ??zclSerializeData_2
   \   000044   1A           DB        26
   \   000045   ....         DW        ??zclSerializeData_4
   \   000047   1B           DB        27
   \   000048   ....         DW        ??zclSerializeData_1
   \   00004A   20           DB        32
   \   00004B   ....         DW        ??zclSerializeData_3
   \   00004D   21           DB        33
   \   00004E   ....         DW        ??zclSerializeData_2
   \   000050   22           DB        34
   \   000051   ....         DW        ??zclSerializeData_4
   \   000053   23           DB        35
   \   000054   ....         DW        ??zclSerializeData_1
   \   000056   24           DB        36
   \   000057   ....         DW        ??zclSerializeData_5
   \   000059   25           DB        37
   \   00005A   ....         DW        ??zclSerializeData_6
   \   00005C   28           DB        40
   \   00005D   ....         DW        ??zclSerializeData_3
   \   00005F   29           DB        41
   \   000060   ....         DW        ??zclSerializeData_2
   \   000062   2A           DB        42
   \   000063   ....         DW        ??zclSerializeData_4
   \   000065   2B           DB        43
   \   000066   ....         DW        ??zclSerializeData_1
   \   000068   30           DB        48
   \   000069   ....         DW        ??zclSerializeData_3
   \   00006B   31           DB        49
   \   00006C   ....         DW        ??zclSerializeData_2
   \   00006E   38           DB        56
   \   00006F   ....         DW        ??zclSerializeData_2
   \   000071   39           DB        57
   \   000072   ....         DW        ??zclSerializeData_1
   \   000074   EA           DB        234
   \   000075   ....         DW        ??zclSerializeData_1
   \   000077   F0           DB        240
   \   000078   ....         DW        ??zclSerializeData_7
   \   00007A   ....         DW        ??zclSerializeData_8
   1468            {
   1469              case ZCL_DATATYPE_DATA8:
   1470              case ZCL_DATATYPE_BOOLEAN:
   1471              case ZCL_DATATYPE_BITMAP8:
   1472              case ZCL_DATATYPE_INT8:
   1473              case ZCL_DATATYPE_UINT8:
   1474              case ZCL_DATATYPE_ENUM8:
   1475                *buf = *((uint8 *)attrData);
   \                     ??zclSerializeData_3:
   \   00007C   8E82         MOV     DPL,R6
   \   00007E   8F83         MOV     DPH,R7
   \                     ??zclSerializeData_9:
   \   000080   12....       LCALL   ??Subroutine118_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_189:
   \   000083   F0           MOVX    @DPTR,A
   \   000084   02....       LJMP    ??zclSerializeData_8 & 0xFFFF
   1476                 break;
   1477          
   1478              case ZCL_DATATYPE_DATA16:
   1479              case ZCL_DATATYPE_BITMAP16:
   1480              case ZCL_DATATYPE_UINT16:
   1481              case ZCL_DATATYPE_INT16: 
   1482              case ZCL_DATATYPE_ENUM16:
   1483              case ZCL_DATATYPE_SEMI_PREC:
   1484              case ZCL_DATATYPE_CLUSTER_ID:
   1485              case ZCL_DATATYPE_ATTR_ID:
   1486                *buf++ = LO_UINT16( *((uint16*)attrData) );
   \                     ??zclSerializeData_2:
   \   000087   12....       LCALL   ?Subroutine40 & 0xFFFF
   \                     ??CrossCallReturnLabel_192:
   \   00008A   12....       LCALL   ?Subroutine15 & 0xFFFF
   1487                *buf++ = HI_UINT16( *((uint16*)attrData) );
   \                     ??CrossCallReturnLabel_182:
   \   00008D   A3           INC     DPTR
   \   00008E   80F0         SJMP    ??zclSerializeData_9
   1488                break;
   1489          
   1490              case ZCL_DATATYPE_DATA24:
   1491              case ZCL_DATATYPE_BITMAP24: 
   1492              case ZCL_DATATYPE_UINT24:
   1493              case ZCL_DATATYPE_INT24:
   1494                *buf++ = BREAK_UINT32( *((uint32*)attrData), 0 );
   \                     ??zclSerializeData_4:
   \   000090   8E82         MOV     DPL,R6
   \   000092   8F83         MOV     DPH,R7
   \   000094   78..         MOV     R0,#?V0 + 0
   \   000096   12....       LCALL   ?L_MOV_X
   \   000099   8A82         MOV     DPL,R2
   \   00009B   8B83         MOV     DPH,R3
   \   00009D   E5..         MOV     A,?V0 + 0
   \   00009F   12....       LCALL   ?Subroutine15 & 0xFFFF
   1495                *buf++ = BREAK_UINT32( *((uint32*)attrData), 1 );
   \                     ??CrossCallReturnLabel_183:
   \   0000A2   78..         MOV     R0,#?V0 + 0
   \   0000A4   12....       LCALL   ?L_MOV_X
   \   0000A7   E5..         MOV     A,?V0 + 1
   \   0000A9   8A82         MOV     DPL,R2
   \   0000AB   8B83         MOV     DPH,R3
   \   0000AD   F0           MOVX    @DPTR,A
   \   0000AE   A3           INC     DPTR
   \   0000AF   0A           INC     R2
   \   0000B0   AB83         MOV     R3,DPH
   1496                *buf++ = BREAK_UINT32( *((uint32*)attrData), 2 );
   \   0000B2   8E82         MOV     DPL,R6
   \   0000B4   8F83         MOV     DPH,R7
   \   0000B6   78..         MOV     R0,#?V0 + 0
   \   0000B8   12....       LCALL   ?L_MOV_X
   \   0000BB   7410         MOV     A,#0x10
   \   0000BD   78..         MOV     R0,#?V0 + 0
   \   0000BF   12....       LCALL   ?UL_SHR
   \   0000C2   8A82         MOV     DPL,R2
   \   0000C4   8B83         MOV     DPH,R3
   \   0000C6   E5..         MOV     A,?V0 + 0
   \   0000C8   80B9         SJMP    ??CrossCallReturnLabel_189
   1497                break;
   1498                
   1499              case ZCL_DATATYPE_DATA32:
   1500              case ZCL_DATATYPE_BITMAP32:
   1501              case ZCL_DATATYPE_UINT32:
   1502              case ZCL_DATATYPE_INT32:
   1503              case ZCL_DATATYPE_SINGLE_PREC:
   1504              case ZCL_DATATYPE_TOD:
   1505              case ZCL_DATATYPE_DATE:
   1506              case ZCL_DATATYPE_UTC:
   1507              case ZCL_DATATYPE_BAC_OID:
   1508                buf = osal_buffer_uint32( buf, *((uint32*)attrData) );
   \                     ??zclSerializeData_1:
   \   0000CA                ; Setup parameters for call to function osal_buffer_uint32
   \   0000CA   8E82         MOV     DPL,R6
   \   0000CC   8F83         MOV     DPH,R7
   \   0000CE   12....       LCALL   ?PUSH_XSTACK8_X_FOUR
   \   0000D1   12....       LCALL   ??osal_buffer_uint32?relay
   \   0000D4   7404         MOV     A,#0x4
   \   0000D6   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000D9   8043         SJMP    ??zclSerializeData_8
   1509                break;
   1510                
   1511              case ZCL_DATATYPE_UINT40:
   1512                pStr = (uint8*)attrData;
   1513                osal_memcpy( buf, pStr, 5 );
   \                     ??zclSerializeData_5:
   \   0000DB                ; Setup parameters for call to function osal_memcpy
   \   0000DB   78..         MOV     R0,#?V0 + 0
   \   0000DD   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000E0   7C05         MOV     R4,#0x5
   \   0000E2   8032         SJMP    ??zclSerializeData_10
   1514                break;
   1515                
   1516              case ZCL_DATATYPE_UINT48:
   1517                pStr = (uint8*)attrData;
   1518                osal_memcpy( buf, pStr, 6 );
   \                     ??zclSerializeData_6:
   \   0000E4                ; Setup parameters for call to function osal_memcpy
   \   0000E4   78..         MOV     R0,#?V0 + 0
   \   0000E6   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000E9   7C06         MOV     R4,#0x6
   \   0000EB   8029         SJMP    ??zclSerializeData_10
   1519                break;
   1520                
   1521              case ZCL_DATATYPE_IEEE_ADDR:
   1522                pStr = (uint8*)attrData;
   1523                osal_memcpy( buf, pStr, 8 );
   \                     ??zclSerializeData_7:
   \   0000ED                ; Setup parameters for call to function osal_memcpy
   \   0000ED   78..         MOV     R0,#?V0 + 0
   \   0000EF   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000F2   7C08         MOV     R4,#0x8
   \   0000F4   8020         SJMP    ??zclSerializeData_10
   1524                break;
   1525                
   1526              case ZCL_DATATYPE_CHAR_STR:
   1527              case ZCL_DATATYPE_OCTET_STR:
   1528                pStr = (uint8*)attrData;
   1529                len = *pStr++;
   \                     ??zclSerializeData_0:
   \   0000F6   8E82         MOV     DPL,R6
   \   0000F8   8F83         MOV     DPH,R7
   \   0000FA   E0           MOVX    A,@DPTR
   \   0000FB   F5..         MOV     ?V0 + 3,A
   \   0000FD   A3           INC     DPTR
   \   0000FE   AE82         MOV     R6,DPL
   \   000100   AF83         MOV     R7,DPH
   1530                *buf++ = len;
   \   000102   8A82         MOV     DPL,R2
   \   000104   8B83         MOV     DPH,R3
   \   000106   F0           MOVX    @DPTR,A
   \   000107   EC           MOV     A,R4
   \   000108   FA           MOV     R2,A
   \   000109   ED           MOV     A,R5
   \   00010A   FB           MOV     R3,A
   1531                osal_memcpy( buf, pStr, len );
   \   00010B                ; Setup parameters for call to function osal_memcpy
   \   00010B   8E..         MOV     ?V0 + 0,R6
   \   00010D   8F..         MOV     ?V0 + 1,R7
   \   00010F   78..         MOV     R0,#?V0 + 0
   \   000111   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000114   AC..         MOV     R4,?V0 + 3
   \                     ??zclSerializeData_10:
   \   000116   7D00         MOV     R5,#0x0
   1532                break;
   1533                
   1534              case ZCL_DATATYPE_NO_DATA:
   1535              case ZCL_DATATYPE_UNKNOWN:
   1536                // Fall through
   1537          
   1538              default:
   1539                break;
   1540            }
   \   000118   12....       LCALL   ?Subroutine88 & 0xFFFF
   \                     ??CrossCallReturnLabel_118:
   \   00011B   12....       LCALL   ?DEALLOC_XSTACK8
   1541          }
   \                     ??zclSerializeData_8:
   \   00011E   02....       LJMP    ?Subroutine85 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   EC           MOV     A,R4
   \   000002   FA           MOV     R2,A
   \   000003   ED           MOV     A,R5
   \   000004   FB           MOV     R3,A
   \   000005                REQUIRE ?Subroutine93
   \   000005                ; // Fall through to label ?Subroutine93

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine40:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004                REQUIRE ??Subroutine118_0
   \   000004                ; // Fall through to label ??Subroutine118_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine118_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   02....       LJMP    ?Subroutine92 & 0xFFFF
   1542          #endif // ZCL_READ || ZCL_WRITE || ZCL_REPORT
   1543          
   1544          #ifdef ZCL_REPORT
   1545          uint8 zclAnalogDataType( uint8 dataType )
   1546          {
   1547            uint8 analog;
   1548            
   1549            switch ( dataType )
   1550            {
   1551              case ZCL_DATATYPE_UINT8:
   1552              case ZCL_DATATYPE_UINT16:
   1553              case ZCL_DATATYPE_UINT24:
   1554              case ZCL_DATATYPE_UINT32:
   1555              case ZCL_DATATYPE_UINT40:
   1556              case ZCL_DATATYPE_UINT48:
   1557              case ZCL_DATATYPE_INT8:
   1558              case ZCL_DATATYPE_INT16:
   1559              case ZCL_DATATYPE_INT24:
   1560              case ZCL_DATATYPE_INT32:
   1561              case ZCL_DATATYPE_SEMI_PREC:
   1562              case ZCL_DATATYPE_SINGLE_PREC:
   1563              case ZCL_DATATYPE_DOUBLE_PREC:
   1564              case ZCL_DATATYPE_TOD:
   1565              case ZCL_DATATYPE_DATE:
   1566              case ZCL_DATATYPE_UTC:
   1567                analog = TRUE;
   1568                break;
   1569                
   1570              default:
   1571                analog = FALSE;
   1572                break;
   1573            }
   1574            return ( analog );
   1575          }
   1576          
   1577          static void zcl_BuildAnalogData( uint8 dataType, uint8 *pData, uint8 *pBuf)
   1578          {
   1579            switch ( dataType )
   1580            {
   1581              case ZCL_DATATYPE_UINT8:
   1582              case ZCL_DATATYPE_INT8:
   1583                *pData = *pBuf;
   1584                break;
   1585          
   1586              case ZCL_DATATYPE_UINT16:
   1587              case ZCL_DATATYPE_INT16:
   1588              case ZCL_DATATYPE_SEMI_PREC:
   1589                *((uint16*)pData) = BUILD_UINT16( pBuf[0], pBuf[1] ); 
   1590                break;
   1591           
   1592              case ZCL_DATATYPE_UINT24:
   1593              case ZCL_DATATYPE_INT24:
   1594                *((uint32*)pData) = osal_build_uint32( pBuf, 3 );
   1595                break;
   1596                
   1597              case ZCL_DATATYPE_UINT32:
   1598              case ZCL_DATATYPE_INT32:
   1599              case ZCL_DATATYPE_SINGLE_PREC:
   1600              case ZCL_DATATYPE_TOD:
   1601              case ZCL_DATATYPE_DATE:
   1602              case ZCL_DATATYPE_UTC:
   1603                *((uint32*)pData) = osal_build_uint32( pBuf, 4 );
   1604                break;
   1605                
   1606              case ZCL_DATATYPE_DOUBLE_PREC:
   1607                *pData = 0;
   1608                break;
   1609           
   1610              default:
   1611                break;
   1612            }
   1613          }
   1614          #endif // ZCL_REPORT
   1615          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1616          uint8 zclGetDataTypeLength( uint8 dataType )
   \                     zclGetDataTypeLength:
   1617          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1618            uint8 len;
   1619            
   1620            switch ( dataType )
   \   000004   E9           MOV     A,R1
   \   000005   12....       LCALL   ?UC_SWITCH_SPARSE
   \                     `?<Jumptable for zclGetDataTypeLength>_0`:
   \   000008   02           DB        2
   \   000009   E0           DB        224
   \   00000A   E2           DB        226
   \   00000B   ....         DW        ??zclGetDataTypeLength_0
   \   00000D   E8           DB        232
   \   00000E   E9           DB        233
   \   00000F   ....         DW        ??zclGetDataTypeLength_1
   \   000011   1A           DB        26
   \   000012   08           DB        8
   \   000013   ....         DW        ??zclGetDataTypeLength_2
   \   000015   09           DB        9
   \   000016   ....         DW        ??zclGetDataTypeLength_1
   \   000018   0A           DB        10
   \   000019   ....         DW        ??zclGetDataTypeLength_3
   \   00001B   0B           DB        11
   \   00001C   ....         DW        ??zclGetDataTypeLength_0
   \   00001E   10           DB        16
   \   00001F   ....         DW        ??zclGetDataTypeLength_2
   \   000021   18           DB        24
   \   000022   ....         DW        ??zclGetDataTypeLength_2
   \   000024   19           DB        25
   \   000025   ....         DW        ??zclGetDataTypeLength_1
   \   000027   1A           DB        26
   \   000028   ....         DW        ??zclGetDataTypeLength_3
   \   00002A   1B           DB        27
   \   00002B   ....         DW        ??zclGetDataTypeLength_0
   \   00002D   20           DB        32
   \   00002E   ....         DW        ??zclGetDataTypeLength_2
   \   000030   21           DB        33
   \   000031   ....         DW        ??zclGetDataTypeLength_1
   \   000033   22           DB        34
   \   000034   ....         DW        ??zclGetDataTypeLength_3
   \   000036   23           DB        35
   \   000037   ....         DW        ??zclGetDataTypeLength_0
   \   000039   24           DB        36
   \   00003A   ....         DW        ??zclGetDataTypeLength_4
   \   00003C   25           DB        37
   \   00003D   ....         DW        ??zclGetDataTypeLength_5
   \   00003F   28           DB        40
   \   000040   ....         DW        ??zclGetDataTypeLength_2
   \   000042   29           DB        41
   \   000043   ....         DW        ??zclGetDataTypeLength_1
   \   000045   2A           DB        42
   \   000046   ....         DW        ??zclGetDataTypeLength_3
   \   000048   2B           DB        43
   \   000049   ....         DW        ??zclGetDataTypeLength_0
   \   00004B   30           DB        48
   \   00004C   ....         DW        ??zclGetDataTypeLength_2
   \   00004E   31           DB        49
   \   00004F   ....         DW        ??zclGetDataTypeLength_1
   \   000051   38           DB        56
   \   000052   ....         DW        ??zclGetDataTypeLength_1
   \   000054   39           DB        57
   \   000055   ....         DW        ??zclGetDataTypeLength_0
   \   000057   3A           DB        58
   \   000058   ....         DW        ??zclGetDataTypeLength_6
   \   00005A   EA           DB        234
   \   00005B   ....         DW        ??zclGetDataTypeLength_0
   \   00005D   F0           DB        240
   \   00005E   ....         DW        ??zclGetDataTypeLength_6
   \   000060   ....         DW        ??zclGetDataTypeLength_7
   1621            {
   1622              case ZCL_DATATYPE_DATA8:
   1623              case ZCL_DATATYPE_BOOLEAN:
   1624              case ZCL_DATATYPE_BITMAP8:
   1625              case ZCL_DATATYPE_INT8:
   1626              case ZCL_DATATYPE_UINT8:
   1627              case ZCL_DATATYPE_ENUM8:
   1628                len = 1;
   \                     ??zclGetDataTypeLength_2:
   \   000062   7901         MOV     R1,#0x1
   \   000064   801A         SJMP    ??zclGetDataTypeLength_8
   1629                break;
   1630                
   1631              case ZCL_DATATYPE_DATA16:
   1632              case ZCL_DATATYPE_BITMAP16:
   1633              case ZCL_DATATYPE_UINT16:
   1634              case ZCL_DATATYPE_INT16: 
   1635              case ZCL_DATATYPE_ENUM16:
   1636              case ZCL_DATATYPE_SEMI_PREC:
   1637              case ZCL_DATATYPE_CLUSTER_ID:
   1638              case ZCL_DATATYPE_ATTR_ID:
   1639                len = 2;
   \                     ??zclGetDataTypeLength_1:
   \   000066   7902         MOV     R1,#0x2
   \   000068   8016         SJMP    ??zclGetDataTypeLength_8
   1640                break;
   1641                
   1642              case ZCL_DATATYPE_DATA24:
   1643              case ZCL_DATATYPE_BITMAP24: 
   1644              case ZCL_DATATYPE_UINT24:
   1645              case ZCL_DATATYPE_INT24:
   1646                len = 3;
   \                     ??zclGetDataTypeLength_3:
   \   00006A   7903         MOV     R1,#0x3
   \   00006C   8012         SJMP    ??zclGetDataTypeLength_8
   1647                break;
   1648                
   1649              case ZCL_DATATYPE_DATA32:
   1650              case ZCL_DATATYPE_BITMAP32:
   1651              case ZCL_DATATYPE_UINT32:
   1652              case ZCL_DATATYPE_INT32:
   1653              case ZCL_DATATYPE_SINGLE_PREC:
   1654              case ZCL_DATATYPE_TOD:
   1655              case ZCL_DATATYPE_DATE:
   1656              case ZCL_DATATYPE_UTC:
   1657              case ZCL_DATATYPE_BAC_OID:
   1658                len = 4;
   \                     ??zclGetDataTypeLength_0:
   \   00006E   7904         MOV     R1,#0x4
   \   000070   800E         SJMP    ??zclGetDataTypeLength_8
   1659                break;                       
   1660                          
   1661             case ZCL_DATATYPE_UINT40:
   1662                 len = 5;
   \                     ??zclGetDataTypeLength_4:
   \   000072   7905         MOV     R1,#0x5
   \   000074   800A         SJMP    ??zclGetDataTypeLength_8
   1663                 break;
   1664                 
   1665             case ZCL_DATATYPE_UINT48:
   1666                 len = 6;
   \                     ??zclGetDataTypeLength_5:
   \   000076   7906         MOV     R1,#0x6
   \   000078   8006         SJMP    ??zclGetDataTypeLength_8
   1667                 break;
   1668                 
   1669             case ZCL_DATATYPE_DOUBLE_PREC:
   1670             case ZCL_DATATYPE_IEEE_ADDR:
   1671               len = 8;
   \                     ??zclGetDataTypeLength_6:
   \   00007A   7908         MOV     R1,#0x8
   \   00007C   8002         SJMP    ??zclGetDataTypeLength_8
   1672               break;
   1673          
   1674              case ZCL_DATATYPE_NO_DATA:
   1675              case ZCL_DATATYPE_UNKNOWN:
   1676                // Fall through
   1677                
   1678              default:
   1679                len = 0;
   \                     ??zclGetDataTypeLength_7:
   \   00007E   7900         MOV     R1,#0x0
   1680                break;
   1681            }  
   1682            return ( len );
   \                     ??zclGetDataTypeLength_8:
   \   000080   02....       LJMP    ?Subroutine84 & 0xFFFF
   1683          }
   1684          
   1685          /*********************************************************************
   1686           * @fn      zclGetAttrDataLength
   1687           * @brief   Return the length of the attribute.
   1688           * @param   dataType - data type
   1689           *          pData - pointer to data
   1690           * @return  returns atrribute lentgh
   1691           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1692          uint8 zclGetAttrDataLength( uint8  dataType, uint8 *pData)
   \                     zclGetAttrDataLength:
   1693          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1694            uint8 dataLen = 0;
   1695            
   1696            if ( dataType  == ZCL_DATATYPE_CHAR_STR || dataType == ZCL_DATATYPE_OCTET_STR )
   \   000004   7442         MOV     A,#0x42
   \   000006   69           XRL     A,R1
   \   000007   6005         JZ      ??zclGetAttrDataLength_0
   \   000009   7441         MOV     A,#0x41
   \   00000B   69           XRL     A,R1
   \   00000C   7009         JNZ     ??zclGetAttrDataLength_1
   1697            {
   1698              dataLen = *pData + 1; // string length + 1 for length field
   \                     ??zclGetAttrDataLength_0:
   \   00000E   8A82         MOV     DPL,R2
   \   000010   8B83         MOV     DPH,R3
   \   000012   E0           MOVX    A,@DPTR
   \   000013   04           INC     A
   \   000014   F9           MOV     R1,A
   \   000015   8003         SJMP    ??zclGetAttrDataLength_2
   1699            }
   1700            else
   1701            {
   1702              dataLen = zclGetDataTypeLength( dataType );
   \                     ??zclGetAttrDataLength_1:
   \   000017                ; Setup parameters for call to function zclGetDataTypeLength
   \   000017   12....       LCALL   ??zclGetDataTypeLength?relay
   1703            }
   1704          
   1705            return ( dataLen );
   \                     ??zclGetAttrDataLength_2:
   \   00001A   02....       LJMP    ?Subroutine84 & 0xFFFF
   1706          }
   1707          
   1708          /*********************************************************************
   1709           * @fn      zclReadAttrData
   1710           * @brief   Read the attribute's current value into pAttrData.
   1711           * @param   pAttrData - where to put attribute data
   1712           *          pAttr - pointer to attribute
   1713           * @return Success
   1714           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1715          uint8 zclReadAttrData( uint8 *pAttrData, zclAttrRec_t *pAttr )
   \                     zclReadAttrData:
   1716          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   1717            uint8 dataLen;
   1718              
   1719            dataLen = zclGetAttrDataLength( pAttr->attr.dataType, (uint8*)(pAttr->attr.dataPtr) );
   \   000009   EC           MOV     A,R4
   \   00000A   2406         ADD     A,#0x6
   \   00000C   F8           MOV     R0,A
   \   00000D   ED           MOV     A,R5
   \   00000E   3400         ADDC    A,#0x0
   \   000010   F9           MOV     R1,A
   \   000011   88..         MOV     ?V0 + 0,R0
   \   000013   89..         MOV     ?V0 + 1,R1
   \   000015                ; Setup parameters for call to function zclGetAttrDataLength
   \   000015   8882         MOV     DPL,R0
   \   000017   F583         MOV     DPH,A
   \   000019   12....       LCALL   ??Subroutine112_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_159:
   \   00001C   8C82         MOV     DPL,R4
   \   00001E   8D83         MOV     DPH,R5
   \   000020   12....       LCALL   ?Subroutine25 & 0xFFFF
   1720            osal_memcpy( pAttrData, pAttr->attr.dataPtr, dataLen );
   \                     ??CrossCallReturnLabel_152:
   \   000023                ; Setup parameters for call to function osal_memcpy
   \   000023   85..82       MOV     DPL,?V0 + 0
   \   000026   85..83       MOV     DPH,?V0 + 1
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   F5..         MOV     ?V0 + 0,A
   \   00002C   A3           INC     DPTR
   \   00002D   E0           MOVX    A,@DPTR
   \   00002E   F5..         MOV     ?V0 + 1,A
   \   000030   75..00       MOV     ?V0 + 2,#0x0
   \   000033   78..         MOV     R0,#?V0 + 0
   \   000035   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000038   EA           MOV     A,R2
   \   000039   FC           MOV     R4,A
   \   00003A   7D00         MOV     R5,#0x0
   \   00003C   EE           MOV     A,R6
   \   00003D   FA           MOV     R2,A
   \   00003E   EF           MOV     A,R7
   \   00003F   FB           MOV     R3,A
   \   000040   12....       LCALL   ?Subroutine88 & 0xFFFF
   \                     ??CrossCallReturnLabel_119:
   \   000043   12....       LCALL   ?DEALLOC_XSTACK8
   1721            return ( ZCL_STATUS_SUCCESS );
   \   000046   7900         MOV     R1,#0x0
   \   000048   02....       LJMP    ?Subroutine98 & 0xFFFF
   1722          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine109_0
   \   000002                ; // Fall through to label ??Subroutine109_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine109_0:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine110_0
   \   000002                ; // Fall through to label ??Subroutine110_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine110_0:
   \   000000   12....       LCALL   ?Subroutine69 & 0xFFFF
   \                     ??CrossCallReturnLabel_158:
   \   000003   FA           MOV     R2,A
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine112_0:
   \   000000   12....       LCALL   ?Subroutine66 & 0xFFFF
   \                     ??CrossCallReturnLabel_207:
   \   000003   22           RET
   1723          
   1724          #ifdef ZCL_WRITE
   1725          /*********************************************************************
   1726           * @fn      zclWriteAttrData
   1727           * @brief   Write the received data.
   1728           * @param   pAttr - where to write data to
   1729           *          pWriteRec - data to be written
   1730           * @return  Successful if data was written
   1731           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1732          static uint8 zclWriteAttrData( zclAttrRec_t *pAttr, zclWriteRec_t *pWriteRec )
   \                     zclWriteAttrData:
   1733          {
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
   1734            uint8 len;
   1735          
   1736            if ( zcl_AccessCtrlWrite( pAttr->attr.accessControl ) )
   \   00000D   8A82         MOV     DPL,R2
   \   00000F   8B83         MOV     DPH,R3
   \   000011   A3           INC     DPTR
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   A3           INC     DPTR
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \   000017   A2E1         MOV     C,0xE0 /* A   */.1
   \   000019   5058         JNC     ??zclWriteAttrData_0
   1737            {
   1738              if ( zcl_ValidateAttrDataCB && !zcl_ValidateAttrDataCB( pAttr, pWriteRec ) )
   \   00001B   90....       MOV     DPTR,#zcl_ValidateAttrDataCB
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   7002         JNZ     ??zclWriteAttrData_1
   \   000021   A3           INC     DPTR
   \   000022   E0           MOVX    A,@DPTR
   \                     ??zclWriteAttrData_1:
   \   000023   6010         JZ      ??zclWriteAttrData_2
   \   000025                ; Setup parameters for indirect call
   \   000025   90....       MOV     DPTR,#zcl_ValidateAttrDataCB
   \   000028   12....       LCALL   ??Subroutine119_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_194:
   \   00002B   12....       LCALL   ?CALL_IND
   \   00002E   E9           MOV     A,R1
   \   00002F   7004         JNZ     ??zclWriteAttrData_2
   1739                return ( ZCL_STATUS_INVALID_VALUE );
   \   000031   7987         MOV     R1,#-0x79
   \   000033   8040         SJMP    ??zclWriteAttrData_3
   1740              
   1741              len = zclGetAttrDataLength( pAttr->attr.dataType, pWriteRec->attrData );
   \                     ??zclWriteAttrData_2:
   \   000035   EE           MOV     A,R6
   \   000036   2403         ADD     A,#0x3
   \   000038   EF           MOV     A,R7
   \   000039   3400         ADDC    A,#0x0
   \   00003B   0E           INC     R6
   \   00003C   0E           INC     R6
   \   00003D   0E           INC     R6
   \   00003E   FF           MOV     R7,A
   \   00003F                ; Setup parameters for call to function zclGetAttrDataLength
   \   00003F   8E82         MOV     DPL,R6
   \   000041   8F83         MOV     DPH,R7
   \   000043   12....       LCALL   ??Subroutine112_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_160:
   \   000046   85..82       MOV     DPL,?V0 + 0
   \   000049   85..83       MOV     DPH,?V0 + 1
   \   00004C   12....       LCALL   ?Subroutine25 & 0xFFFF
   1742              osal_memcpy( pAttr->attr.dataPtr, pWriteRec->attrData, len );
   \                     ??CrossCallReturnLabel_153:
   \   00004F                ; Setup parameters for call to function osal_memcpy
   \   00004F   8E82         MOV     DPL,R6
   \   000051   8F83         MOV     DPH,R7
   \   000053   12....       LCALL   ?Subroutine31 & 0xFFFF
   \                     ??CrossCallReturnLabel_123:
   \   000056   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000059   EA           MOV     A,R2
   \   00005A   FC           MOV     R4,A
   \   00005B   7D00         MOV     R5,#0x0
   \   00005D   85..82       MOV     DPL,?V0 + 0
   \   000060   85..83       MOV     DPH,?V0 + 1
   \   000063   A3           INC     DPTR
   \   000064   A3           INC     DPTR
   \   000065   A3           INC     DPTR
   \   000066   A3           INC     DPTR
   \   000067   A3           INC     DPTR
   \   000068   A3           INC     DPTR
   \   000069   12....       LCALL   ?Subroutine41 & 0xFFFF
   \                     ??CrossCallReturnLabel_113:
   \   00006C   12....       LCALL   ?DEALLOC_XSTACK8
   1743              return ( ZCL_STATUS_SUCCESS );
   \   00006F   7900         MOV     R1,#0x0
   \   000071   8002         SJMP    ??zclWriteAttrData_3
   1744            }
   1745            return ( ZCL_STATUS_READ_ONLY );
   \                     ??zclWriteAttrData_0:
   \   000073   7988         MOV     R1,#-0x78
   \                     ??zclWriteAttrData_3:
   \   000075   7F07         MOV     R7,#0x7
   \   000077   02....       LJMP    ?BANKED_LEAVE_XDATA
   1746          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine89:
   \   000000   75..00       MOV     ?V0 + 6,#0x0
   \   000003   78..         MOV     R0,#?V0 + 4
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine119_0:
   \   000000   12....       LCALL   ?Subroutine71 & 0xFFFF
   \                     ??CrossCallReturnLabel_199:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine71:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F583         MOV     DPH,A
   \   000006   8882         MOV     DPL,R0
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine41:
   \   000000   12....       LCALL   ?Subroutine66 & 0xFFFF
   \                     ??CrossCallReturnLabel_205:
   \   000003   02....       LJMP    ?Subroutine88 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine31:
   \   000000   12....       LCALL   ?Subroutine64 & 0xFFFF
   \                     ??CrossCallReturnLabel_86:
   \   000003   02....       LJMP    ?Subroutine89 & 0xFFFF
   1747          #endif // ZCL_WRITE
   1748          
   1749          #ifdef ZCL_READ
   1750          /*********************************************************************
   1751           * @fn      zclParseInReadCmd
   1752           * @brief   Parse the "Profile" Read Commands
   1753           *          NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   1754           *                FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   1755           * @param   pCmd - pointer to incoming data to parse
   1756           * @return  pointer to the parsed command structure
   1757           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1758          void *zclParseInReadCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReadCmd:
   1759          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   1760            zclReadCmd_t *readCmd;
   1761            uint8 *pBuf = pCmd->pData;
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   12....       LCALL   ?Subroutine45 & 0xFFFF
   \                     ??CrossCallReturnLabel_243:
   \   00000C   E8           MOV     A,R0
   \   00000D   FE           MOV     R6,A
   \   00000E   E9           MOV     A,R1
   \   00000F   FF           MOV     R7,A
   1762            
   1763            readCmd = (zclReadCmd_t *)osal_mem_alloc( sizeof ( zclReadCmd_t ) + pCmd->dataLen );
   \   000010   12....       LCALL   ?Subroutine29 & 0xFFFF
   1764            if ( readCmd != NULL )
   \                     ??CrossCallReturnLabel_37:
   \   000013   7001         JNZ     ??zclParseInReadCmd_0
   \   000015   EB           MOV     A,R3
   \                     ??zclParseInReadCmd_0:
   \   000016   6049         JZ      ??zclParseInReadCmd_1
   1765            {
   1766              uint8 i;
   1767              
   1768              readCmd->numAttr = pCmd->dataLen / 2; // Atrribute ID
   \   000018   85..82       MOV     DPL,?V0 + 0
   \   00001B   85..83       MOV     DPH,?V0 + 1
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   F8           MOV     R0,A
   \   000020   A3           INC     DPTR
   \   000021   E0           MOVX    A,@DPTR
   \   000022   C3           CLR     C
   \   000023   13           RRC     A
   \   000024   E8           MOV     A,R0
   \   000025   13           RRC     A
   \   000026   8A82         MOV     DPL,R2
   \   000028   8B83         MOV     DPH,R3
   \   00002A   F0           MOVX    @DPTR,A
   1769              for ( i = 0; i < readCmd->numAttr; i++ )
   \   00002B   75..00       MOV     ?V0 + 0,#0x0
   \   00002E   8025         SJMP    ??zclParseInReadCmd_2
   1770              {
   1771                readCmd->attrID[i] = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??zclParseInReadCmd_3:
   \   000030   8E82         MOV     DPL,R6
   \   000032   8F83         MOV     DPH,R7
   \   000034   12....       LCALL   ?Subroutine70 & 0xFFFF
   1772                pBuf += 2;
   1773              }
   \                     ??CrossCallReturnLabel_212:
   \   000037   F9           MOV     R1,A
   \   000038   E4           CLR     A
   \   000039   2C           ADD     A,R4
   \   00003A   E9           MOV     A,R1
   \   00003B   FD           MOV     R5,A
   \   00003C   E5..         MOV     A,?V0 + 0
   \   00003E   33           RLC     A
   \   00003F   F8           MOV     R0,A
   \   000040   E4           CLR     A
   \   000041   33           RLC     A
   \   000042   F9           MOV     R1,A
   \   000043   EA           MOV     A,R2
   \   000044   28           ADD     A,R0
   \   000045   F582         MOV     DPL,A
   \   000047   EB           MOV     A,R3
   \   000048   39           ADDC    A,R1
   \   000049   F583         MOV     DPH,A
   \   00004B   A3           INC     DPTR
   \   00004C   EC           MOV     A,R4
   \   00004D   F0           MOVX    @DPTR,A
   \   00004E   A3           INC     DPTR
   \   00004F   ED           MOV     A,R5
   \   000050   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_11:
   \   000053   05..         INC     ?V0 + 0
   \                     ??zclParseInReadCmd_2:
   \   000055   8A82         MOV     DPL,R2
   \   000057   8B83         MOV     DPH,R3
   \   000059   E0           MOVX    A,@DPTR
   \   00005A   FC           MOV     R4,A
   \   00005B   E5..         MOV     A,?V0 + 0
   \   00005D   C3           CLR     C
   \   00005E   9C           SUBB    A,R4
   \   00005F   40CF         JC      ??zclParseInReadCmd_3
   1774            }
   1775            return ( (void *)readCmd );
   \                     ??zclParseInReadCmd_1:
   \   000061   02....       LJMP    ?Subroutine85 & 0xFFFF
   1776          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine29:
   \   000000   8A82         MOV     DPL,R2
   \   000002   8B83         MOV     DPH,R3
   \   000004   A3           INC     DPTR
   \   000005   8582..       MOV     ?V0 + 0,DPL
   \   000008   8583..       MOV     ?V0 + 1,DPH
   \   00000B                ; Setup parameters for call to function osal_mem_alloc
   \   00000B                ; Setup parameters for call to function osal_mem_alloc
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   2401         ADD     A,#0x1
   \   00000E   FA           MOV     R2,A
   \   00000F   A3           INC     DPTR
   \   000010   E0           MOVX    A,@DPTR
   \   000011   3400         ADDC    A,#0x0
   \   000013   FB           MOV     R3,A
   \   000014   12....       LCALL   ??osal_mem_alloc?relay
   \   000017   EA           MOV     A,R2
   \   000018   22           RET
   1777          
   1778          /*********************************************************************
   1779           * @fn      zclParseInReadRspCmd
   1780           * @brief   Parse the "Profile" Read Response Commands
   1781           *          NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   1782           *                FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   1783           * @param   pCmd - pointer to incoming data to parse
   1784           * @return  pointer to the parsed command structure
   1785           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine49:
   \   000000   E9           MOV     A,R1
   \   000001   F5..         MOV     ?V0 + 4,A
   \   000003   FC           MOV     R4,A
   \   000004   7D00         MOV     R5,#0x0
   \   000006   AA..         MOV     R2,?V0 + 2
   \   000008   AB..         MOV     R3,?V0 + 3
   \   00000A                REQUIRE ?Subroutine88
   \   00000A                ; // Fall through to label ?Subroutine88

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1786          static void *zclParseInReadRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReadRspCmd:
   1787          {
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   12....       LCALL   ?Subroutine34 & 0xFFFF
   1788            zclReadRspCmd_t *readRspCmd;
   1789            zclReadRspStatus_t *statusRec;
   1790            uint8 *pBuf = pCmd->pData;
   1791            uint8 *dataPtr;
   1792            uint8 numAttr = 0;
   1793            uint8 hdrLen;
   1794            uint8 dataLen = 0;
   \                     ??CrossCallReturnLabel_45:
   \   000008   801B         SJMP    ??zclParseInReadRspCmd_0
   1795            uint8 attrDataLen;
   1796            uint8 dataType;
   1797            uint8 status;
   1798            uint8 i;
   1799            
   1800            // find out the number of attributes and the length of attribute data
   1801            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   1802            {
   1803              numAttr++;
   \                     ??zclParseInReadRspCmd_1:
   \   00000A   12....       LCALL   ?Subroutine57 & 0xFFFF
   1804          
   1805              pBuf += 2; // move pass attribute id
   1806              
   1807              status = *pBuf++;  
   \                     ??CrossCallReturnLabel_111:
   \   00000D   A3           INC     DPTR
   \   00000E   AE82         MOV     R6,DPL
   \   000010   AF83         MOV     R7,DPH
   1808              if ( status == ZCL_STATUS_SUCCESS )
   \   000012   7011         JNZ     ??zclParseInReadRspCmd_0
   1809              {
   1810                dataType = *pBuf++;
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F9           MOV     R1,A
   \   000016   A3           INC     DPTR
   \   000017   0E           INC     R6
   \   000018   12....       LCALL   ?Subroutine51 & 0xFFFF
   1811          
   1812                attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   1813                pBuf += attrDataLen; // move pass attribute data
   1814                
   1815                if ( PADDING_NEEDED( attrDataLen ) ) // add padding if needed
   \                     ??CrossCallReturnLabel_66:
   \   00001B   5002         JNC     ??zclParseInReadRspCmd_2
   1816                  attrDataLen++;
   \   00001D   05..         INC     ?V0 + 8
   1817                dataLen += attrDataLen;
   \                     ??zclParseInReadRspCmd_2:
   \   00001F   E5..         MOV     A,?V0 + 8
   \   000021   25..         ADD     A,?V0 + 6
   \   000023   F5..         MOV     ?V0 + 6,A
   1818              }
   1819            }
   \                     ??zclParseInReadRspCmd_0:
   \   000025   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_167:
   \   000028   40E0         JC      ??zclParseInReadRspCmd_1
   1820           
   1821            hdrLen = sizeof( zclReadRspCmd_t ) + ( numAttr * sizeof( zclReadRspStatus_t ) ); // calculate the length of the response header
   \   00002A   75F006       MOV     B,#0x6
   \   00002D   12....       LCALL   ?Subroutine48 & 0xFFFF
   1822            
   1823            readRspCmd = (zclReadRspCmd_t *)osal_mem_alloc( hdrLen + dataLen );
   1824            if ( readRspCmd != NULL )
   \                     ??CrossCallReturnLabel_62:
   \   000030   7001         JNZ     ??zclParseInReadRspCmd_3
   \   000032   EB           MOV     A,R3
   \                     ??zclParseInReadRspCmd_3:
   \   000033   6049         JZ      ??zclParseInReadRspCmd_4
   1825            {
   1826              pBuf = pCmd->pData;
   \   000035   12....       LCALL   ?Subroutine22 & 0xFFFF
   1827              dataPtr = (uint8 *)( (uint8 *)readRspCmd + hdrLen );
   1828                  
   1829              readRspCmd->numAttr = numAttr;
   1830              for ( i = 0; i < numAttr; i++ )
   \                     ??CrossCallReturnLabel_26:
   \   000038   803D         SJMP    ??zclParseInReadRspCmd_5
   1831              {
   1832                statusRec = &(readRspCmd->attrList[i]);
   \                     ??zclParseInReadRspCmd_6:
   \   00003A   E5..         MOV     A,?V0 + 9
   \   00003C   75F006       MOV     B,#0x6
   \   00003F   12....       LCALL   ?Subroutine3 & 0xFFFF
   1833                
   1834                statusRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   1835                pBuf += 2;
   1836                
   1837                statusRec->status = *pBuf++;
   \                     ??CrossCallReturnLabel_109:
   \   000042   12....       LCALL   ?Subroutine6 & 0xFFFF
   1838                if ( statusRec->status == ZCL_STATUS_SUCCESS )
   \                     ??CrossCallReturnLabel_170:
   \   000045   702E         JNZ     ??CrossCallReturnLabel_68
   1839                {
   1840                  statusRec->dataType = *pBuf++;
   \   000047   E0           MOVX    A,@DPTR
   \   000048   F9           MOV     R1,A
   \   000049   85..82       MOV     DPL,?V0 + 10
   \   00004C   85..83       MOV     DPH,?V0 + 11
   \   00004F   A3           INC     DPTR
   \   000050   A3           INC     DPTR
   \   000051   A3           INC     DPTR
   \   000052   12....       LCALL   ??Subroutine115_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_176:
   \   000055   0E           INC     R6
   \   000056   AF83         MOV     R7,DPH
   1841          
   1842                  attrDataLen = zclGetAttrDataLength( statusRec->dataType, pBuf );
   \   000058                ; Setup parameters for call to function zclGetAttrDataLength
   \   000058   12....       LCALL   ?Subroutine59 & 0xFFFF
   1843                  osal_memcpy( dataPtr, pBuf, attrDataLen);
   \                     ??CrossCallReturnLabel_121:
   \   00005B   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00005E   12....       LCALL   ?Subroutine49 & 0xFFFF
   \                     ??CrossCallReturnLabel_114:
   \   000061   12....       LCALL   ?DEALLOC_XSTACK8
   1844                  statusRec->data = dataPtr;
   \   000064   85..82       MOV     DPL,?V0 + 10
   \   000067   85..83       MOV     DPH,?V0 + 11
   \   00006A   A3           INC     DPTR
   \   00006B   12....       LCALL   ?Subroutine4 & 0xFFFF
   1845                  
   1846                  pBuf += attrDataLen; // move pass attribute data
   1847                 
   1848                  if ( PADDING_NEEDED( attrDataLen ) ) // advance attribute data pointer
   \                     ??CrossCallReturnLabel_6:
   \   00006E   5002         JNC     ??zclParseInReadRspCmd_7
   1849                    attrDataLen++;
   \   000070   05..         INC     ?V0 + 8
   1850                  dataPtr += attrDataLen;
   \                     ??zclParseInReadRspCmd_7:
   \   000072   12....       LCALL   ?Subroutine52 & 0xFFFF
   1851                }
   1852              }
   \                     ??CrossCallReturnLabel_68:
   \   000075   05..         INC     ?V0 + 9
   \                     ??zclParseInReadRspCmd_5:
   \   000077   E5..         MOV     A,?V0 + 9
   \   000079   C3           CLR     C
   \   00007A   95..         SUBB    A,?V0 + 7
   \   00007C   40BC         JC      ??zclParseInReadRspCmd_6
   1853            }
   1854            return ( (void *)readRspCmd );
   \                     ??zclParseInReadRspCmd_4:
   \   00007E                REQUIRE ?Subroutine99
   \   00007E                ; // Fall through to label ?Subroutine99
   1855          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine99:
   \   000000   AA..         MOV     R2,?V0 + 0
   \   000002   AB..         MOV     R3,?V0 + 1
   \   000004   7F0C         MOV     R7,#0xc
   \   000006   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   85..82       MOV     DPL,?V0 + 0
   \   000003   85..83       MOV     DPH,?V0 + 1
   \   000006   A3           INC     DPTR
   \   000007                REQUIRE ??Subroutine113_0
   \   000007                ; // Fall through to label ??Subroutine113_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine113_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   85..82       MOV     DPL,?V0 + 2
   \   000008   85..83       MOV     DPH,?V0 + 3
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   28           ADD     A,R0
   \   00000D   F8           MOV     R0,A
   \   00000E   A3           INC     DPTR
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   39           ADDC    A,R1
   \   000011   F9           MOV     R1,A
   \   000012   C3           CLR     C
   \   000013   EE           MOV     A,R6
   \   000014   98           SUBB    A,R0
   \   000015   EF           MOV     A,R7
   \   000016   99           SUBB    A,R1
   \   000017   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   85..82       MOV     DPL,?V0 + 10
   \   000003   85..83       MOV     DPH,?V0 + 11
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008                REQUIRE ??Subroutine114_0
   \   000008                ; // Fall through to label ??Subroutine114_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine59:
   \   000000   EE           MOV     A,R6
   \   000001   FA           MOV     R2,A
   \   000002   EF           MOV     A,R7
   \   000003   FB           MOV     R3,A
   \   000004   12....       LCALL   ??zclGetAttrDataLength?relay
   \   000007   E9           MOV     A,R1
   \   000008   F5..         MOV     ?V0 + 8,A
   \   00000A                ; Setup parameters for call to function osal_memcpy
   \   00000A                ; Setup parameters for call to function osal_memcpy
   \   00000A   8E..         MOV     ?V0 + 4,R6
   \   00000C   8F..         MOV     ?V0 + 5,R7
   \   00000E                REQUIRE ?Subroutine89
   \   00000E                ; // Fall through to label ?Subroutine89

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine57:
   \   000000   05..         INC     ?V0 + 7
   \   000002   12....       LCALL   ?Subroutine78 & 0xFFFF
   \                     ??CrossCallReturnLabel_101:
   \   000005                REQUIRE ?Subroutine87
   \   000005                ; // Fall through to label ?Subroutine87

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine87:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004   E0           MOVX    A,@DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine52:
   \   000000   85....       MOV     ?V0 + 4,?V0 + 8
   \   000003   E5..         MOV     A,?V0 + 2
   \   000005   25..         ADD     A,?V0 + 4
   \   000007   F5..         MOV     ?V0 + 2,A
   \   000009   E5..         MOV     A,?V0 + 3
   \   00000B   3400         ADDC    A,#0x0
   \   00000D   F5..         MOV     ?V0 + 3,A
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine51:
   \   000000   AF83         MOV     R7,DPH
   \   000002                ; Setup parameters for call to function zclGetAttrDataLength
   \   000002                ; Setup parameters for call to function zclGetAttrDataLength
   \   000002   EE           MOV     A,R6
   \   000003   FA           MOV     R2,A
   \   000004   EF           MOV     A,R7
   \   000005   FB           MOV     R3,A
   \   000006   12....       LCALL   ??zclGetAttrDataLength?relay
   \   000009   E9           MOV     A,R1
   \   00000A   F5..         MOV     ?V0 + 8,A
   \   00000C   F5..         MOV     ?V0 + 4,A
   \   00000E   EE           MOV     A,R6
   \   00000F   25..         ADD     A,?V0 + 4
   \   000011   FE           MOV     R6,A
   \   000012   EF           MOV     A,R7
   \   000013   3400         ADDC    A,#0x0
   \   000015   FF           MOV     R7,A
   \   000016   E9           MOV     A,R1
   \   000017   A2E0         MOV     C,0xE0 /* A   */.0
   \   000019   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine48:
   \   000000   E5..         MOV     A,?V0 + 7
   \   000002   A4           MUL     AB
   \   000003   04           INC     A
   \   000004   FA           MOV     R2,A
   \   000005   8A82         MOV     DPL,R2
   \   000007   8582..       MOV     ?V0 + 4,DPL
   \   00000A                ; Setup parameters for call to function osal_mem_alloc
   \   00000A                ; Setup parameters for call to function osal_mem_alloc
   \   00000A   85....       MOV     ?V0 + 0,?V0 + 6
   \   00000D   E5..         MOV     A,?V0 + 0
   \   00000F   25..         ADD     A,?V0 + 4
   \   000011   FA           MOV     R2,A
   \   000012   E4           CLR     A
   \   000013   3400         ADDC    A,#0x0
   \   000015   12....       LCALL   ?Subroutine72 & 0xFFFF
   \                     ??CrossCallReturnLabel_229:
   \   000018   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine34:
   \   000000   8A..         MOV     ?V0 + 0,R2
   \   000002   8B..         MOV     ?V0 + 1,R3
   \   000004   EA           MOV     A,R2
   \   000005   2403         ADD     A,#0x3
   \   000007   F5..         MOV     ?V0 + 2,A
   \   000009   EB           MOV     A,R3
   \   00000A   12....       LCALL   ?Subroutine73 & 0xFFFF
   \                     ??CrossCallReturnLabel_92:
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   FE           MOV     R6,A
   \   00000F   A3           INC     DPTR
   \   000010   E0           MOVX    A,@DPTR
   \   000011   FF           MOV     R7,A
   \   000012   75..00       MOV     ?V0 + 7,#0x0
   \   000015   75..00       MOV     ?V0 + 6,#0x0
   \   000018   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   85..82       MOV     DPL,?V0 + 2
   \   000003   85..83       MOV     DPH,?V0 + 3
   \   000006   E0           MOVX    A,@DPTR
   \   000007   FE           MOV     R6,A
   \   000008   A3           INC     DPTR
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   FF           MOV     R7,A
   \   00000B   EA           MOV     A,R2
   \   00000C   25..         ADD     A,?V0 + 4
   \   00000E   F5..         MOV     ?V0 + 2,A
   \   000010   EB           MOV     A,R3
   \   000011   3400         ADDC    A,#0x0
   \   000013   F5..         MOV     ?V0 + 3,A
   \   000015   8A82         MOV     DPL,R2
   \   000017   8B83         MOV     DPH,R3
   \   000019   E5..         MOV     A,?V0 + 7
   \   00001B   F0           MOVX    @DPTR,A
   \   00001C   75..00       MOV     ?V0 + 9,#0x0
   \   00001F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003   E5..         MOV     A,?V0 + 2
   \   000005   F0           MOVX    @DPTR,A
   \   000006   A3           INC     DPTR
   \   000007   E5..         MOV     A,?V0 + 3
   \   000009   F0           MOVX    @DPTR,A
   \   00000A   EE           MOV     A,R6
   \   00000B   25..         ADD     A,?V0 + 4
   \   00000D   FE           MOV     R6,A
   \   00000E   EF           MOV     A,R7
   \   00000F   3400         ADDC    A,#0x0
   \   000011   FF           MOV     R7,A
   \   000012   E5..         MOV     A,?V0 + 8
   \   000014   A2E0         MOV     C,0xE0 /* A   */.0
   \   000016   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   12....       LCALL   ?Subroutine77 & 0xFFFF
   \                     ??CrossCallReturnLabel_99:
   \   000003   A3           INC     DPTR
   \   000004   8582..       MOV     ?V0 + 10,DPL
   \   000007   8583..       MOV     ?V0 + 11,DPH
   \   00000A   8E82         MOV     DPL,R6
   \   00000C   8F83         MOV     DPH,R7
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   FA           MOV     R2,A
   \   000010   A3           INC     DPTR
   \   000011   E0           MOVX    A,@DPTR
   \   000012   F9           MOV     R1,A
   \   000013   EA           MOV     A,R2
   \   000014   85..82       MOV     DPL,?V0 + 10
   \   000017   85..83       MOV     DPH,?V0 + 11
   \   00001A   F0           MOVX    @DPTR,A
   \   00001B   A3           INC     DPTR
   \   00001C   E9           MOV     A,R1
   \   00001D   12....       LCALL   ?Subroutine61 & 0xFFFF
   \                     ??CrossCallReturnLabel_81:
   \   000020   02....       LJMP    ?Subroutine87 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine78:
   \   000000   12....       LCALL   ?Subroutine83 & 0xFFFF
   \                     ??CrossCallReturnLabel_128:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine77:
   \   000000   A4           MUL     AB
   \   000001   F8           MOV     R0,A
   \   000002   A9F0         MOV     R1,B
   \   000004   E5..         MOV     A,?V0 + 0
   \   000006   28           ADD     A,R0
   \   000007   F582         MOV     DPL,A
   \   000009   E5..         MOV     A,?V0 + 1
   \   00000B   39           ADDC    A,R1
   \   00000C   F583         MOV     DPH,A
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine73:
   \   000000   3400         ADDC    A,#0x0
   \   000002   F5..         MOV     ?V0 + 3,A
   \   000004                ; Setup parameters for call to function zclGetAttrDataLength
   \   000004   85..82       MOV     DPL,?V0 + 2
   \   000007   F583         MOV     DPH,A
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine72:
   \   000000   FB           MOV     R3,A
   \   000001                REQUIRE ??Subroutine124_0
   \   000001                ; // Fall through to label ??Subroutine124_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine124_0:
   \   000000   12....       LCALL   ??osal_mem_alloc?relay
   \   000003   8A..         MOV     ?V0 + 0,R2
   \   000005   8B..         MOV     ?V0 + 1,R3
   \   000007   EA           MOV     A,R2
   \   000008   22           RET
   1856          #endif // ZCL_READ
   1857          
   1858          #ifdef ZCL_WRITE
   1859          /*********************************************************************
   1860           * @fn      zclParseInWriteCmd
   1861           * @brief   Parse the "Profile" Write, Write Undivided and Write No
   1862           *          Response Commands
   1863           *          NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   1864           *                FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   1865           * @param   pCmd - pointer to incoming data to parse
   1866           * @return  pointer to the parsed command structure
   1867           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1868          void *zclParseInWriteCmd( zclParseCmd_t *pCmd )
   \                     zclParseInWriteCmd:
   1869          {
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   12....       LCALL   ?Subroutine34 & 0xFFFF
   1870            zclWriteCmd_t *writeCmd;
   1871            zclWriteRec_t *statusRec;
   1872            uint8 *pBuf = pCmd->pData;
   1873            uint8 attrDataLen;
   1874            uint8 *dataPtr;
   1875            uint8 numAttr = 0;
   1876            uint8 hdrLen;
   1877            uint8 dataLen = 0;
   \                     ??CrossCallReturnLabel_46:
   \   000008   8014         SJMP    ??zclParseInWriteCmd_0
   1878            uint8 dataType;
   1879            uint8 i;
   1880          
   1881            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) ) // find out the number of attributes and the length of attribute data
   1882            {
   1883              numAttr++;
   \                     ??zclParseInWriteCmd_1:
   \   00000A   12....       LCALL   ?Subroutine57 & 0xFFFF
   1884          
   1885              pBuf += 2; // move pass attribute id
   1886          
   1887              dataType = *pBuf++;
   \                     ??CrossCallReturnLabel_112:
   \   00000D   F9           MOV     R1,A
   \   00000E   A3           INC     DPTR
   \   00000F   AE82         MOV     R6,DPL
   \   000011   12....       LCALL   ?Subroutine51 & 0xFFFF
   1888          
   1889              attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   1890              pBuf += attrDataLen; // move pass attribute data
   1891              
   1892              if ( PADDING_NEEDED( attrDataLen ) ) // add padding if needed
   \                     ??CrossCallReturnLabel_67:
   \   000014   5002         JNC     ??zclParseInWriteCmd_2
   1893                attrDataLen++;
   \   000016   05..         INC     ?V0 + 8
   1894              dataLen += attrDataLen;
   \                     ??zclParseInWriteCmd_2:
   \   000018   E5..         MOV     A,?V0 + 8
   \   00001A   25..         ADD     A,?V0 + 6
   \   00001C   F5..         MOV     ?V0 + 6,A
   1895            }
   \                     ??zclParseInWriteCmd_0:
   \   00001E   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_168:
   \   000021   40E7         JC      ??zclParseInWriteCmd_1
   1896            
   1897            hdrLen = sizeof( zclWriteCmd_t ) + ( numAttr * sizeof( zclWriteRec_t ) ); // calculate the length of the response header
   \   000023   75F005       MOV     B,#0x5
   \   000026   12....       LCALL   ?Subroutine48 & 0xFFFF
   1898            
   1899            writeCmd = (zclWriteCmd_t *)osal_mem_alloc( hdrLen + dataLen );
   1900            if ( writeCmd != NULL )
   \                     ??CrossCallReturnLabel_63:
   \   000029   7001         JNZ     ??zclParseInWriteCmd_3
   \   00002B   EB           MOV     A,R3
   \                     ??zclParseInWriteCmd_3:
   \   00002C   6036         JZ      ??zclParseInWriteCmd_4
   1901            {
   1902              pBuf = pCmd->pData;
   \   00002E   12....       LCALL   ?Subroutine22 & 0xFFFF
   1903              dataPtr = (uint8 *)( (uint8 *)writeCmd + hdrLen );
   1904          
   1905              writeCmd->numAttr = numAttr;
   1906              for ( i = 0; i < numAttr; i++ )
   \                     ??CrossCallReturnLabel_27:
   \   000031   802A         SJMP    ??zclParseInWriteCmd_5
   1907              {
   1908                statusRec = &(writeCmd->attrList[i]);
   \                     ??zclParseInWriteCmd_6:
   \   000033   E5..         MOV     A,?V0 + 9
   \   000035   75F005       MOV     B,#0x5
   \   000038   12....       LCALL   ?Subroutine3 & 0xFFFF
   1909                
   1910                statusRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   1911                pBuf += 2;
   1912                statusRec->dataType = *pBuf++;
   \                     ??CrossCallReturnLabel_110:
   \   00003B   F9           MOV     R1,A
   \   00003C   12....       LCALL   ?Subroutine6 & 0xFFFF
   1913          
   1914                attrDataLen = zclGetAttrDataLength( statusRec->dataType, pBuf );
   \                     ??CrossCallReturnLabel_171:
   \   00003F                ; Setup parameters for call to function zclGetAttrDataLength
   \   00003F   12....       LCALL   ?Subroutine59 & 0xFFFF
   1915                osal_memcpy( dataPtr, pBuf, attrDataLen);
   \                     ??CrossCallReturnLabel_122:
   \   000042   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000045   12....       LCALL   ?Subroutine49 & 0xFFFF
   \                     ??CrossCallReturnLabel_115:
   \   000048   12....       LCALL   ?DEALLOC_XSTACK8
   1916                statusRec->attrData = dataPtr;
   \   00004B   85..82       MOV     DPL,?V0 + 10
   \   00004E   85..83       MOV     DPH,?V0 + 11
   \   000051   12....       LCALL   ?Subroutine4 & 0xFFFF
   1917                
   1918                pBuf += attrDataLen; // move pass attribute data
   1919          
   1920                if ( PADDING_NEEDED( attrDataLen ) ) // advance attribute data pointer
   \                     ??CrossCallReturnLabel_7:
   \   000054   5002         JNC     ??zclParseInWriteCmd_7
   1921                  attrDataLen++;
   \   000056   05..         INC     ?V0 + 8
   1922                dataPtr += attrDataLen;
   \                     ??zclParseInWriteCmd_7:
   \   000058   12....       LCALL   ?Subroutine52 & 0xFFFF
   1923              }
   \                     ??CrossCallReturnLabel_69:
   \   00005B   05..         INC     ?V0 + 9
   \                     ??zclParseInWriteCmd_5:
   \   00005D   E5..         MOV     A,?V0 + 9
   \   00005F   C3           CLR     C
   \   000060   95..         SUBB    A,?V0 + 7
   \   000062   40CF         JC      ??zclParseInWriteCmd_6
   1924            }
   1925            
   1926            return ( (void *)writeCmd );
   \                     ??zclParseInWriteCmd_4:
   \   000064   02....       LJMP    ?Subroutine99 & 0xFFFF
   1927          }
   1928          
   1929          /*********************************************************************
   1930           * @fn      zclParseInWriteRspCmd
   1931           * @brief   Parse the "Profile" Write Response Commands
   1932           *          NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   1933           *                FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   1934           * @param   pCmd - pointer to incoming data to parse
   1935           * @return  pointer to the parsed command structure
   1936           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1937          static void *zclParseInWriteRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInWriteRspCmd:
   1938          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   1939            zclWriteRspCmd_t *writeRspCmd;
   1940            uint8 *pBuf = pCmd->pData;
   \   000005   EA           MOV     A,R2
   \   000006   2403         ADD     A,#0x3
   \   000008   F5..         MOV     ?V0 + 2,A
   \   00000A   EB           MOV     A,R3
   \   00000B   12....       LCALL   ?Subroutine56 & 0xFFFF
   \                     ??CrossCallReturnLabel_74:
   \   00000E   12....       LCALL   ?Subroutine35 & 0xFFFF
   1941            uint8 i = 0;
   \                     ??CrossCallReturnLabel_48:
   \   000011   75..00       MOV     ?V0 + 4,#0x0
   1942          
   1943            writeRspCmd = (zclWriteRspCmd_t *)osal_mem_alloc( sizeof ( zclWriteRspCmd_t ) + pCmd->dataLen );
   \   000014   12....       LCALL   ?Subroutine29 & 0xFFFF
   1944            if ( writeRspCmd != NULL )
   \                     ??CrossCallReturnLabel_38:
   \   000017   7001         JNZ     ??zclParseInWriteRspCmd_0
   \   000019   EB           MOV     A,R3
   \                     ??zclParseInWriteRspCmd_0:
   \   00001A   605C         JZ      ??zclParseInWriteRspCmd_1
   1945            {
   1946              if ( pCmd->dataLen == 1 )
   \   00001C   85..82       MOV     DPL,?V0 + 0
   \   00001F   85..83       MOV     DPH,?V0 + 1
   \   000022   E0           MOVX    A,@DPTR
   \   000023   6401         XRL     A,#0x1
   \   000025   7002         JNZ     ??zclParseInWriteRspCmd_2
   \   000027   A3           INC     DPTR
   \   000028   E0           MOVX    A,@DPTR
   \                     ??zclParseInWriteRspCmd_2:
   \   000029   703B         JNZ     ??CrossCallReturnLabel_100
   1947              {
   1948                writeRspCmd->attrList[i++].status = *pBuf; // special case when all writes were successfull
   \   00002B   12....       LCALL   ?Subroutine40 & 0xFFFF
   1949              }
   \                     ??CrossCallReturnLabel_193:
   \   00002E   A3           INC     DPTR
   \   00002F   F0           MOVX    @DPTR,A
   \   000030   75..01       MOV     ?V0 + 4,#0x1
   \   000033   803C         SJMP    ??zclParseInWriteRspCmd_3
   1950              else
   1951              {
   1952                while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   1953                {
   1954                  writeRspCmd->attrList[i].status = *pBuf++;
   \                     ??zclParseInWriteRspCmd_4:
   \   000035   E5..         MOV     A,?V0 + 4
   \   000037   75F003       MOV     B,#0x3
   \   00003A   A4           MUL     AB
   \   00003B   F8           MOV     R0,A
   \   00003C   A9F0         MOV     R1,B
   \   00003E   EA           MOV     A,R2
   \   00003F   28           ADD     A,R0
   \   000040   F8           MOV     R0,A
   \   000041   EB           MOV     A,R3
   \   000042   39           ADDC    A,R1
   \   000043   F9           MOV     R1,A
   \   000044   8E82         MOV     DPL,R6
   \   000046   8F83         MOV     DPH,R7
   \   000048   E0           MOVX    A,@DPTR
   \   000049   8882         MOV     DPL,R0
   \   00004B   8983         MOV     DPH,R1
   \   00004D   12....       LCALL   ?Subroutine5 & 0xFFFF
   1955                  writeRspCmd->attrList[i++].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??CrossCallReturnLabel_9:
   \   000050   F5..         MOV     ?V0 + 6,A
   \   000052   A3           INC     DPTR
   \   000053   E0           MOVX    A,@DPTR
   \   000054   FD           MOV     R5,A
   \   000055   E5..         MOV     A,?V0 + 6
   \   000057   8882         MOV     DPL,R0
   \   000059   8983         MOV     DPH,R1
   \   00005B   A3           INC     DPTR
   \   00005C   A3           INC     DPTR
   \   00005D   F0           MOVX    @DPTR,A
   \   00005E   A3           INC     DPTR
   \   00005F   ED           MOV     A,R5
   \   000060   F0           MOVX    @DPTR,A
   \   000061   05..         INC     ?V0 + 4
   1956                  pBuf += 2;
   \   000063   12....       LCALL   ?Subroutine78 & 0xFFFF
   1957                }
   \                     ??CrossCallReturnLabel_100:
   \   000066   85..82       MOV     DPL,?V0 + 0
   \   000069   85..83       MOV     DPH,?V0 + 1
   \   00006C   12....       LCALL   ??Subroutine113_0 & 0xFFFF
   1958              }
   \                     ??CrossCallReturnLabel_166:
   \   00006F   40C4         JC      ??zclParseInWriteRspCmd_4
   1959              writeRspCmd->numAttr = i; 
   \                     ??zclParseInWriteRspCmd_3:
   \   000071   8A82         MOV     DPL,R2
   \   000073   8B83         MOV     DPH,R3
   \   000075   E5..         MOV     A,?V0 + 4
   \   000077   F0           MOVX    @DPTR,A
   1960            }
   1961            return ( (void *)writeRspCmd );
   \                     ??zclParseInWriteRspCmd_1:
   \   000078   7F08         MOV     R7,#0x8
   \   00007A   02....       LJMP    ?BANKED_LEAVE_XDATA
   1962          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine56:
   \   000000   12....       LCALL   ?Subroutine73 & 0xFFFF
   \                     ??CrossCallReturnLabel_93:
   \   000003   22           RET
   1963          #endif // ZCL_WRITE
   1964          
   1965          #ifdef ZCL_REPORT
   1966          /*********************************************************************
   1967           * @fn      zclParseInConfigReportCmd
   1968           * @brief   Parse the "Profile" Configure Reporting Command
   1969           *          NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   1970           *                FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   1971           * @param   pCmd - pointer to incoming data to parse
   1972           * @return  pointer to the parsed command structure
   1973           */
   1974          void *zclParseInConfigReportCmd( zclParseCmd_t *pCmd )
   1975          {
   1976            zclCfgReportCmd_t *cfgReportCmd;
   1977            zclCfgReportRec_t *reportRec;
   1978            uint8 *pBuf = pCmd->pData;
   1979            uint8 *dataPtr;
   1980            uint8 numAttr = 0;
   1981            uint8 direction;
   1982            uint8 dataType;
   1983            uint8 hdrLen;
   1984            uint8 dataLen = 0;
   1985            uint8 reportChangeLen; // length of Reportable Change field
   1986            uint8 i;
   1987           
   1988            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) ) // Calculate the length of the Request command
   1989            {
   1990              numAttr++;
   1991              
   1992              direction = *pBuf++;
   1993              pBuf += 2; // move pass the attribute ID
   1994              
   1995              if ( direction == ZCL_SEND_ATTR_REPORTS ) // Is there a Reportable Change field?
   1996              {
   1997                dataType = *pBuf++;
   1998                pBuf += 4; // move pass the Min and Max Reporting Intervals
   1999           
   2000                if ( zclAnalogDataType( dataType ) ) // For attributes of 'discrete' data types this field is omitted
   2001                {
   2002                  reportChangeLen = zclGetDataTypeLength( dataType );
   2003                  pBuf += reportChangeLen;
   2004                  
   2005                  if ( PADDING_NEEDED( reportChangeLen ) ) // add padding if needed
   2006                    reportChangeLen++;
   2007                  dataLen += reportChangeLen;
   2008                }
   2009              }
   2010              else
   2011              {
   2012                pBuf += 2; // move pass the Timeout Period
   2013              }
   2014            } // while loop
   2015          
   2016            hdrLen = sizeof( zclCfgReportCmd_t ) + ( numAttr * sizeof( zclCfgReportRec_t ) );
   2017            
   2018            cfgReportCmd = (zclCfgReportCmd_t *)osal_mem_alloc( hdrLen + dataLen );
   2019            if ( cfgReportCmd != NULL )
   2020            { 
   2021              pBuf = pCmd->pData;
   2022              dataPtr = (uint8 *)( (uint8 *)cfgReportCmd + hdrLen );
   2023              
   2024              cfgReportCmd->numAttr = numAttr;
   2025              for ( i = 0; i < numAttr; i++ )
   2026              {
   2027                reportRec = &(cfgReportCmd->attrList[i]);
   2028                
   2029                osal_memset( reportRec, 0, sizeof( zclCfgReportRec_t ) );
   2030                  
   2031                reportRec->direction = *pBuf++;
   2032                reportRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   2033                pBuf += 2;
   2034                if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
   2035                {
   2036                 
   2037                  reportRec->dataType = *pBuf++; // Attribute to be reported
   2038                  reportRec->minReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   2039                  pBuf += 2;
   2040                  reportRec->maxReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   2041                  pBuf += 2;
   2042                 
   2043                  if ( zclAnalogDataType( reportRec->dataType ) ) // For attributes of 'discrete' data types this field is omitted
   2044                  {
   2045                    zcl_BuildAnalogData( reportRec->dataType, dataPtr, pBuf);
   2046                    reportRec->reportableChange = dataPtr;
   2047                    
   2048                    reportChangeLen = zclGetDataTypeLength( reportRec->dataType );
   2049                    pBuf += reportChangeLen;
   2050                   
   2051                    if ( PADDING_NEEDED( reportChangeLen ) ) // advance attribute data pointer
   2052                      reportChangeLen++;
   2053                    dataPtr += reportChangeLen;
   2054                  }
   2055                }
   2056                else
   2057                {
   2058                  reportRec->timeoutPeriod = BUILD_UINT16( pBuf[0], pBuf[1] ); // Attribute reports to be received
   2059                  pBuf += 2;
   2060                }
   2061              } // while loop
   2062            }
   2063            return ( (void *)cfgReportCmd );
   2064          }
   2065          
   2066          /*********************************************************************
   2067           * @fn      zclParseInConfigReportRspCmd
   2068           * @brief   Parse the "Profile" Configure Reporting Response Command
   2069           *          NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2070           *                FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2071           * @param   pCmd - pointer to incoming data to parse
   2072           * @return  pointer to the parsed command structure
   2073           */
   2074          static void *zclParseInConfigReportRspCmd( zclParseCmd_t *pCmd )
   2075          {
   2076            zclCfgReportRspCmd_t *cfgReportRspCmd;
   2077            uint8 *pBuf = pCmd->pData;
   2078            uint8 numAttr;
   2079            uint8 i; 
   2080            
   2081            numAttr = pCmd->dataLen / ( 1 + 1 + 2 ); // Status + Direction + Attribute ID
   2082            
   2083            cfgReportRspCmd = (zclCfgReportRspCmd_t *)osal_mem_alloc( sizeof( zclCfgReportRspCmd_t ) 
   2084                                                      + ( numAttr * sizeof( zclCfgReportStatus_t ) ) );
   2085            if ( cfgReportRspCmd != NULL )
   2086            {
   2087              cfgReportRspCmd->numAttr = numAttr;
   2088              for ( i = 0; i < cfgReportRspCmd->numAttr; i++ )
   2089              {
   2090                cfgReportRspCmd->attrList[i].status = *pBuf++;
   2091                cfgReportRspCmd->attrList[i].direction = *pBuf++;
   2092                cfgReportRspCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   2093                pBuf += 2;
   2094              }
   2095            }
   2096            return ( (void *)cfgReportRspCmd );  
   2097          }
   2098          
   2099          /*********************************************************************
   2100           * @fn      zclParseInReadReportCfgCmd
   2101           * @brief   Parse the "Profile" Read Reporting Configuration Command
   2102           *          NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2103           *                FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2104           * @param   pCmd - pointer to incoming data to parse
   2105           * @return  pointer to the parsed command structure
   2106           */
   2107          void *zclParseInReadReportCfgCmd( zclParseCmd_t *pCmd )
   2108          {
   2109            zclReadReportCfgCmd_t *readReportCfgCmd;
   2110            uint8 *pBuf = pCmd->pData;
   2111            uint8 numAttr;
   2112            uint8 i;
   2113            
   2114            numAttr = pCmd->dataLen / ( 1 + 2 ); // Direction + Attribute ID
   2115            
   2116            readReportCfgCmd = (zclReadReportCfgCmd_t *)osal_mem_alloc( sizeof( zclReadReportCfgCmd_t ) 
   2117                                                            + ( numAttr * sizeof( zclReadReportCfgRec_t ) ) );
   2118            if ( readReportCfgCmd != NULL )
   2119            {
   2120              readReportCfgCmd->numAttr = numAttr;
   2121              for ( i = 0; i < readReportCfgCmd->numAttr; i++)
   2122              {
   2123                readReportCfgCmd->attrList[i].direction = *pBuf++;;
   2124                readReportCfgCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   2125                pBuf += 2;
   2126              }
   2127            }
   2128            return ( (void *)readReportCfgCmd );
   2129          }
   2130          
   2131          /*********************************************************************
   2132           * @fn      zclParseInReadReportCfgRspCmd
   2133           * @brief   Parse the "Profile" Read Reporting Configuration Response Command
   2134           *          NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2135           *                FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2136           * @param   pCmd - pointer to incoming data to parse
   2137           * @return  pointer to the parsed command structure
   2138           */
   2139          static void *zclParseInReadReportCfgRspCmd( zclParseCmd_t *pCmd )
   2140          {
   2141            zclReadReportCfgRspCmd_t *readReportCfgRspCmd;
   2142            zclReportCfgRspRec_t *reportRspRec;
   2143            uint8 reportChangeLen;
   2144            uint8 *pBuf = pCmd->pData;
   2145            uint8 *dataPtr;
   2146            uint8 numAttr = 0;
   2147            uint8 hdrLen;
   2148            uint8 dataLen = 0;
   2149            uint8 status;
   2150            uint8 direction;
   2151            uint8 dataType;
   2152            uint8 i;
   2153            
   2154            // Calculate the length of the response command
   2155            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   2156            { 
   2157              numAttr++;
   2158              
   2159              status = *pBuf++;
   2160              direction = *pBuf++; 
   2161              pBuf += 2; // move pass the attribute ID
   2162              
   2163              if ( status == ZCL_STATUS_SUCCESS )
   2164              {
   2165                if ( direction == ZCL_SEND_ATTR_REPORTS )
   2166                {
   2167                  dataType = *pBuf++;
   2168                  pBuf += 4; // move pass the Min and Max Reporting Intervals
   2169           
   2170                  // For attributes of 'discrete' data types this field is omitted
   2171                  if ( zclAnalogDataType( dataType ) )
   2172                  {
   2173                    reportChangeLen = zclGetDataTypeLength( dataType );
   2174                    pBuf += reportChangeLen;
   2175                    
   2176                    // add padding if needed
   2177                    if ( PADDING_NEEDED( reportChangeLen ) )
   2178                      reportChangeLen++;
   2179                    dataLen += reportChangeLen;
   2180                  }
   2181                }
   2182                else
   2183                {
   2184                  pBuf += 2; // move pass the Timeout field
   2185                }
   2186              }
   2187            } // while loop
   2188            
   2189            hdrLen = sizeof( zclReadReportCfgRspCmd_t ) + ( numAttr * sizeof( zclReportCfgRspRec_t ) );
   2190            
   2191            readReportCfgRspCmd = (zclReadReportCfgRspCmd_t *)osal_mem_alloc( hdrLen + dataLen );
   2192            if ( readReportCfgRspCmd != NULL )
   2193            {
   2194              pBuf = pCmd->pData;
   2195              dataPtr = (uint8 *)( (uint8 *)readReportCfgRspCmd + hdrLen );
   2196              
   2197              readReportCfgRspCmd->numAttr = numAttr;
   2198              for ( i = 0; i < numAttr; i++ )
   2199              {
   2200                reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   2201                
   2202                reportRspRec->status = *pBuf++;
   2203                reportRspRec->direction = *pBuf++;
   2204                reportRspRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   2205                pBuf += 2;
   2206           
   2207                if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   2208                {
   2209                  if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   2210                  {
   2211                    reportRspRec->dataType = *pBuf++;
   2212                    reportRspRec->minReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   2213                    pBuf += 2;
   2214                    reportRspRec->maxReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   2215                    pBuf += 2;
   2216          
   2217                    if ( zclAnalogDataType( reportRspRec->dataType ) )
   2218                    {
   2219                      zcl_BuildAnalogData( reportRspRec->dataType, dataPtr, pBuf);
   2220                      reportRspRec->reportableChange = dataPtr;
   2221                      
   2222                      reportChangeLen = zclGetDataTypeLength( reportRspRec->dataType ); 
   2223                      pBuf += reportChangeLen;
   2224                      
   2225                      // advance attribute data pointer
   2226                      if ( PADDING_NEEDED( reportChangeLen ) )
   2227                        reportChangeLen++;
   2228                      dataPtr += reportChangeLen;
   2229                    }
   2230                  }
   2231                  else
   2232                  {
   2233                    reportRspRec->timeoutPeriod = BUILD_UINT16( pBuf[0], pBuf[1] );
   2234                    pBuf += 2;
   2235                  }
   2236                }
   2237              } 
   2238            }
   2239            
   2240            return ( (void *)readReportCfgRspCmd );
   2241          }
   2242          
   2243          /*********************************************************************
   2244           * @fn      zclParseInReportCmd
   2245           * @brief   Parse the "Profile" Report Command
   2246           *          NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2247           *                FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2248           * @param   pCmd - pointer to incoming data to parse
   2249           * @return  pointer to the parsed command structure
   2250           */
   2251          void *zclParseInReportCmd( zclParseCmd_t *pCmd )
   2252          {
   2253            zclReportCmd_t *reportCmd;
   2254            zclReport_t *reportRec;
   2255            uint8 *pBuf = pCmd->pData;
   2256            uint8 attrDataLen;
   2257            uint8 *dataPtr;
   2258            uint8 numAttr = 0;
   2259            uint8 hdrLen;
   2260            uint8 dataLen = 0;
   2261            uint8 dataType;
   2262            uint8 i;
   2263          
   2264            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) ) // find out the number of attributes and the length of attribute data
   2265            {
   2266              numAttr++;
   2267          
   2268              pBuf += 2; // move pass attribute id
   2269              dataType = *pBuf++;
   2270              attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   2271              pBuf += attrDataLen; // move pass attribute data
   2272                
   2273              if ( PADDING_NEEDED( attrDataLen ) ) // add padding if needed
   2274                attrDataLen++;
   2275              dataLen += attrDataLen;
   2276            }
   2277            
   2278            hdrLen = sizeof( zclReportCmd_t ) + ( numAttr * sizeof( zclReport_t ) );
   2279            
   2280            reportCmd = (zclReportCmd_t *)osal_mem_alloc( hdrLen + dataLen );
   2281            if (reportCmd != NULL )
   2282            {
   2283              pBuf = pCmd->pData;
   2284              dataPtr = (uint8 *)( (uint8 *)reportCmd + hdrLen );
   2285              
   2286              reportCmd->numAttr = numAttr;
   2287              for ( i = 0; i < numAttr; i++ )
   2288              {
   2289                reportRec = &(reportCmd->attrList[i]);
   2290                
   2291                reportRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   2292                pBuf += 2;
   2293                reportRec->dataType = *pBuf++;
   2294          
   2295                attrDataLen = zclGetAttrDataLength( reportRec->dataType, pBuf );  
   2296                osal_memcpy( dataPtr, pBuf, attrDataLen );
   2297                reportRec->attrData = dataPtr;
   2298                
   2299                pBuf += attrDataLen; // move pass attribute data
   2300                
   2301                if ( PADDING_NEEDED( attrDataLen ) ) // advance attribute data pointer
   2302                  attrDataLen++;
   2303                dataPtr += attrDataLen;
   2304              }
   2305            }
   2306            return ( (void *)reportCmd );
   2307          }
   2308          #endif // ZCL_REPORT
   2309          
   2310          /*********************************************************************
   2311           * @fn      zclParseInDefaultRspCmd
   2312           * @brief   Parse the "Profile" Default Response Command
   2313           *          NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2314           *                FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2315           * @param   pCmd - pointer to incoming data to parse
   2316           * @return  pointer to the parsed command structure
   2317           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2318          static void *zclParseInDefaultRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInDefaultRspCmd:
   2319          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   2320            zclDefaultRspCmd_t *defaultRspCmd;
   2321            uint8 *pBuf = pCmd->pData;
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   12....       LCALL   ?Subroutine35 & 0xFFFF
   2322          
   2323            defaultRspCmd = (zclDefaultRspCmd_t *)osal_mem_alloc( sizeof ( zclDefaultRspCmd_t ) );
   \                     ??CrossCallReturnLabel_49:
   \   00000F                ; Setup parameters for call to function osal_mem_alloc
   \   00000F   7A02         MOV     R2,#0x2
   \   000011   7B00         MOV     R3,#0x0
   \   000013   12....       LCALL   ??osal_mem_alloc?relay
   2324            if ( defaultRspCmd != NULL )
   \   000016   EA           MOV     A,R2
   \   000017   7001         JNZ     ??zclParseInDefaultRspCmd_0
   \   000019   EB           MOV     A,R3
   \                     ??zclParseInDefaultRspCmd_0:
   \   00001A   600D         JZ      ??zclParseInDefaultRspCmd_1
   2325            {
   2326              defaultRspCmd->commandID = *pBuf++;
   \   00001C   8E82         MOV     DPL,R6
   \   00001E   8F83         MOV     DPH,R7
   \   000020   E0           MOVX    A,@DPTR
   \   000021   12....       LCALL   ?Subroutine7 & 0xFFFF
   2327              defaultRspCmd->statusCode = *pBuf;
   \                     ??CrossCallReturnLabel_177:
   \   000024   12....       LCALL   ??Subroutine118_0 & 0xFFFF
   2328            }
   \                     ??CrossCallReturnLabel_190:
   \   000027   A3           INC     DPTR
   \   000028   F0           MOVX    @DPTR,A
   2329            return ( (void *)defaultRspCmd );
   \                     ??zclParseInDefaultRspCmd_1:
   \   000029   02....       LJMP    ?Subroutine94 & 0xFFFF
   2330          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   8A82         MOV     DPL,R2
   \   000002   8B83         MOV     DPH,R3
   \   000004                REQUIRE ??Subroutine115_0
   \   000004                ; // Fall through to label ??Subroutine115_0
   2331          
   2332          #ifdef ZCL_DISCOVER
   2333          /*********************************************************************
   2334           * @fn      zclParseInDiscCmd
   2335           * @brief   Parse the "Profile" Discovery Commands
   2336           *          NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2337           *                FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2338           * @param   pCmd - pointer to incoming data to parse
   2339           * @return  pointer to the parsed command structure
   2340           */
   2341          void *zclParseInDiscCmd( zclParseCmd_t *pCmd )
   2342          {
   2343            zclDiscoverCmd_t *discoverCmd;
   2344            uint8 *pBuf = pCmd->pData;
   2345          
   2346            discoverCmd = (zclDiscoverCmd_t *)osal_mem_alloc( sizeof ( zclDiscoverCmd_t ) );
   2347            if ( discoverCmd != NULL )
   2348            {
   2349              discoverCmd->startAttr = BUILD_UINT16( pBuf[0], pBuf[1] );
   2350              pBuf += 2;
   2351              discoverCmd->maxAttrIDs = *pBuf;
   2352            }
   2353            return ( (void *)discoverCmd );
   2354          }
   2355          
   2356          /*********************************************************************
   2357           * @fn      zclParseInDiscRspCmd
   2358           * @brief   Parse the "Profile" Discovery Response Commands
   2359           *          NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2360           *                FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2361           * @param   pCmd - pointer to incoming data to parse
   2362           * @return  pointer to the parsed command structure
   2363           */
   2364          #define ZCLDISCRSPCMD_DATALEN(a)  ((a)-1) // data len - Discovery Complete
   2365          static void *zclParseInDiscRspCmd( zclParseCmd_t *pCmd )
   2366          {
   2367            zclDiscoverRspCmd_t *discoverRspCmd;
   2368            uint8 *pBuf = pCmd->pData;
   2369            uint8 numAttr = ZCLDISCRSPCMD_DATALEN(pCmd->dataLen) / ( 2 + 1 ); // Attr ID + Data Type
   2370            uint8 i;
   2371          
   2372            discoverRspCmd = (zclDiscoverRspCmd_t *)osal_mem_alloc( sizeof ( zclDiscoverRspCmd_t ) 
   2373                                                           + ( numAttr * sizeof(zclDiscoverInfo_t) ) );
   2374            if ( discoverRspCmd != NULL )
   2375            {
   2376              discoverRspCmd->discComplete = *pBuf++;
   2377              discoverRspCmd->numAttr = numAttr;
   2378              
   2379              for ( i = 0; i < numAttr; i++ )
   2380              {
   2381                discoverRspCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   2382                pBuf += 2;
   2383                discoverRspCmd->attrList[i].dataType = *pBuf++;;
   2384              }
   2385            }
   2386            return ( (void *)discoverRspCmd );
   2387          }
   2388          #endif // ZCL_DISCOVER
   2389          
   2390          #ifdef ZCL_READ
   2391          /*********************************************************************
   2392           * @fn      zclProcessInReadCmd
   2393           * @brief   Process the "Profile" Read Command
   2394           * @param   pInMsg - incoming message to process
   2395           * @return  TRUE if command processed. FALSE, otherwise.
   2396           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine55:
   \   000000   EA           MOV     A,R2
   \   000001   240C         ADD     A,#0xc
   \   000003                REQUIRE ??Subroutine106_0
   \   000003                ; // Fall through to label ??Subroutine106_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2397          static uint8 zclProcessInReadCmd( zclIncoming_t *pInMsg )
   \                     zclProcessInReadCmd:
   2398          {
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 4,R2
   \   00000C   8B..         MOV     ?V0 + 5,R3
   2399            zclReadCmd_t *readCmd;
   2400            zclReadRspCmd_t *readRspCmd;
   2401            zclReadRspStatus_t *statusRec;
   2402            zclAttrRec_t attrRec;
   2403            uint8 len;
   2404            uint8 i;
   2405            
   2406            readCmd = (zclReadCmd_t *)pInMsg->attrCmd;
   \   00000E   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_146:
   \   000011   F5..         MOV     ?V0 + 2,A
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F5..         MOV     ?V0 + 3,A
   2407            
   2408            // calculate the length of the response status record
   2409            len = sizeof( zclReadRspCmd_t ) + (readCmd->numAttr * sizeof( zclReadRspStatus_t ));
   2410            
   2411            readRspCmd = osal_mem_alloc( len );
   \   000017                ; Setup parameters for call to function osal_mem_alloc
   \   000017   75F006       MOV     B,#0x6
   \   00001A   85..82       MOV     DPL,?V0 + 2
   \   00001D   F583         MOV     DPH,A
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   A4           MUL     AB
   \   000021   04           INC     A
   \   000022   FA           MOV     R2,A
   \   000023   7B00         MOV     R3,#0x0
   \   000025   12....       LCALL   ??Subroutine124_0 & 0xFFFF
   2412            if ( readRspCmd == NULL )
   \                     ??CrossCallReturnLabel_231:
   \   000028   7001         JNZ     ??zclProcessInReadCmd_0
   \   00002A   EB           MOV     A,R3
   \                     ??zclProcessInReadCmd_0:
   \   00002B   7005         JNZ     ??zclProcessInReadCmd_1
   2413              return FALSE; // EMBEDDED RETURN
   \   00002D   7900         MOV     R1,#0x0
   \   00002F   02....       LJMP    ??zclProcessInReadCmd_2 & 0xFFFF
   2414          
   2415            readRspCmd->numAttr = readCmd->numAttr;
   \                     ??zclProcessInReadCmd_1:
   \   000032   85..82       MOV     DPL,?V0 + 2
   \   000035   85..83       MOV     DPH,?V0 + 3
   \   000038   12....       LCALL   ??Subroutine118_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_191:
   \   00003B   F0           MOVX    @DPTR,A
   2416            for (i = 0; i < readCmd->numAttr; i++)
   \   00003C   75..00       MOV     ?V0 + 6,#0x0
   \   00003F   800B         SJMP    ??zclProcessInReadCmd_3
   2417            {
   2418              statusRec = &(readRspCmd->attrList[i]);
   2419              statusRec->attrID = readCmd->attrID[i];
   2420              
   2421              if ( zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, readCmd->attrID[i], &attrRec ) )
   2422              {
   2423                statusRec->data = attrRec.attr.dataPtr;
   2424                statusRec->status = ZCL_STATUS_SUCCESS;
   2425                statusRec->dataType = attrRec.attr.dataType;
   2426              }
   2427              else
   2428              {
   2429                statusRec->status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   \                     ??zclProcessInReadCmd_4:
   \   000041   7486         MOV     A,#-0x7a
   \   000043   85..82       MOV     DPL,?V0 + 10
   \   000046   85..83       MOV     DPH,?V0 + 11
   \                     ??zclProcessInReadCmd_5:
   \   000049   F0           MOVX    @DPTR,A
   2430              }
   \   00004A   05..         INC     ?V0 + 6
   \                     ??zclProcessInReadCmd_3:
   \   00004C   85..82       MOV     DPL,?V0 + 2
   \   00004F   85..83       MOV     DPH,?V0 + 3
   \   000052   E0           MOVX    A,@DPTR
   \   000053   FA           MOV     R2,A
   \   000054   E5..         MOV     A,?V0 + 6
   \   000056   C3           CLR     C
   \   000057   9A           SUBB    A,R2
   \   000058   4003         JC      $+5
   \   00005A   02....       LJMP    ??zclProcessInReadCmd_6 & 0xFFFF
   \   00005D   85..82       MOV     DPL,?V0 + 6
   \   000060   A882         MOV     R0,DPL
   \   000062   E8           MOV     A,R0
   \   000063   75F006       MOV     B,#0x6
   \   000066   A4           MUL     AB
   \   000067   FA           MOV     R2,A
   \   000068   ABF0         MOV     R3,B
   \   00006A   E5..         MOV     A,?V0 + 0
   \   00006C   2A           ADD     A,R2
   \   00006D   F582         MOV     DPL,A
   \   00006F   E5..         MOV     A,?V0 + 1
   \   000071   3B           ADDC    A,R3
   \   000072   F583         MOV     DPH,A
   \   000074   A3           INC     DPTR
   \   000075   AE82         MOV     R6,DPL
   \   000077   AF83         MOV     R7,DPH
   \   000079   E8           MOV     A,R0
   \   00007A   C3           CLR     C
   \   00007B   33           RLC     A
   \   00007C   F8           MOV     R0,A
   \   00007D   E4           CLR     A
   \   00007E   33           RLC     A
   \   00007F   F9           MOV     R1,A
   \   000080   12....       LCALL   ?Subroutine82 & 0xFFFF
   \                     ??CrossCallReturnLabel_107:
   \   000083   AA82         MOV     R2,DPL
   \   000085   AB83         MOV     R3,DPH
   \   000087   12....       LCALL   ?Subroutine44 & 0xFFFF
   \                     ??CrossCallReturnLabel_185:
   \   00008A   12....       LCALL   ??Subroutine121_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_217:
   \   00008D   EE           MOV     A,R6
   \   00008E   2402         ADD     A,#0x2
   \   000090   F5..         MOV     ?V0 + 10,A
   \   000092   EF           MOV     A,R7
   \   000093   3400         ADDC    A,#0x0
   \   000095   F5..         MOV     ?V0 + 11,A
   \   000097   12....       LCALL   ?Subroutine67 & 0xFFFF
   \                     ??CrossCallReturnLabel_226:
   \   00009A                ; Setup parameters for call to function zclFindAttrRec
   \   00009A   85..82       MOV     DPL,?XSP + 0
   \   00009D   85..83       MOV     DPH,?XSP + 1
   \   0000A0   8582..       MOV     ?V0 + 12,DPL
   \   0000A3   8583..       MOV     ?V0 + 13,DPH
   \   0000A6   78..         MOV     R0,#?V0 + 12
   \   0000A8   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000AB   8A82         MOV     DPL,R2
   \   0000AD   8B83         MOV     DPH,R3
   \   0000AF   12....       LCALL   ??Subroutine120_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_202:
   \   0000B2   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000B5   E9           MOV     A,R1
   \   0000B6   6089         JZ      ??zclProcessInReadCmd_4
   \   0000B8   7406         MOV     A,#0x6
   \   0000BA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BD   12....       LCALL   ?Subroutine44 & 0xFFFF
   \                     ??CrossCallReturnLabel_186:
   \   0000C0   A3           INC     DPTR
   \   0000C1   A3           INC     DPTR
   \   0000C2   A3           INC     DPTR
   \   0000C3   A3           INC     DPTR
   \   0000C4   12....       LCALL   ??Subroutine121_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_218:
   \   0000C7   E4           CLR     A
   \   0000C8   85..82       MOV     DPL,?V0 + 10
   \   0000CB   85..83       MOV     DPH,?V0 + 11
   \   0000CE   F0           MOVX    @DPTR,A
   \   0000CF   7404         MOV     A,#0x4
   \   0000D1   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D4   E0           MOVX    A,@DPTR
   \   0000D5   8E82         MOV     DPL,R6
   \   0000D7   8F83         MOV     DPH,R7
   \   0000D9   A3           INC     DPTR
   \   0000DA   A3           INC     DPTR
   \   0000DB   A3           INC     DPTR
   \   0000DC   02....       LJMP    ??zclProcessInReadCmd_5 & 0xFFFF
   2431            }
   2432            
   2433            // Build and send Read Response command
   2434            zcl_SendReadRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr), pInMsg->msg->clusterId,
   2435                             readRspCmd, ZCL_FRAME_SERVER_CLIENT_DIR,
   2436                             true, pInMsg->hdr.transSeqNum );
   \                     ??zclProcessInReadCmd_6:
   \   0000DF   12....       LCALL   ?Subroutine67 & 0xFFFF
   \                     ??CrossCallReturnLabel_227:
   \   0000E2                ; Setup parameters for call to function zcl_SendReadRsp
   \   0000E2   85..82       MOV     DPL,?V0 + 4
   \   0000E5   85..83       MOV     DPH,?V0 + 5
   \   0000E8   A3           INC     DPTR
   \   0000E9   A3           INC     DPTR
   \   0000EA   A3           INC     DPTR
   \   0000EB   A3           INC     DPTR
   \   0000EC   A3           INC     DPTR
   \   0000ED   A3           INC     DPTR
   \   0000EE   E0           MOVX    A,@DPTR
   \   0000EF   F5..         MOV     ?V0 + 2,A
   \   0000F1   78..         MOV     R0,#?V0 + 2
   \   0000F3   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000F6   75..01       MOV     ?V0 + 2,#0x1
   \   0000F9   78..         MOV     R0,#?V0 + 2
   \   0000FB   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000FE   78..         MOV     R0,#?V0 + 2
   \   000100   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000103   78..         MOV     R0,#?V0 + 0
   \   000105   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000108   85..82       MOV     DPL,?V0 + 8
   \   00010B   85..83       MOV     DPH,?V0 + 9
   \   00010E   A3           INC     DPTR
   \   00010F   A3           INC     DPTR
   \   000110   A3           INC     DPTR
   \   000111   A3           INC     DPTR
   \   000112   12....       LCALL   ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_34:
   \   000115   E5..         MOV     A,?V0 + 8
   \   000117   2406         ADD     A,#0x6
   \   000119   FA           MOV     R2,A
   \   00011A   E5..         MOV     A,?V0 + 9
   \   00011C   3400         ADDC    A,#0x0
   \   00011E   FB           MOV     R3,A
   \   00011F   E5..         MOV     A,?V0 + 8
   \   000121   2414         ADD     A,#0x14
   \   000123   F582         MOV     DPL,A
   \   000125   E5..         MOV     A,?V0 + 9
   \   000127   12....       LCALL   ??Subroutine107_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_143:
   \   00012A   F9           MOV     R1,A
   \   00012B   12....       LCALL   ??zcl_SendReadRsp?relay
   \   00012E   7405         MOV     A,#0x5
   \   000130   12....       LCALL   ?DEALLOC_XSTACK8
   2437            osal_mem_free( readRspCmd );
   \   000133                ; Setup parameters for call to function osal_mem_free
   \   000133   AA..         MOV     R2,?V0 + 0
   \   000135   AB..         MOV     R3,?V0 + 1
   \   000137   12....       LCALL   ??osal_mem_free?relay
   2438              
   2439            return TRUE;
   \   00013A   7901         MOV     R1,#0x1
   \                     ??zclProcessInReadCmd_2:
   \   00013C   7408         MOV     A,#0x8
   \   00013E   12....       LCALL   ?DEALLOC_XSTACK8
   \   000141   02....       LJMP    ??Subroutine103_0 & 0xFFFF
   2440          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine67:
   \   000000   85..82       MOV     DPL,?V0 + 4
   \   000003   85..83       MOV     DPH,?V0 + 5
   \   000006                REQUIRE ??Subroutine116_0
   \   000006                ; // Fall through to label ??Subroutine116_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine116_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0 + 8,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V0 + 9,A
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine44:
   \   000000   E0           MOVX    A,@DPTR
   \   000001                REQUIRE ??Subroutine117_0
   \   000001                ; // Fall through to label ??Subroutine117_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine120_0:
   \   000000   12....       LCALL   ?Subroutine70 & 0xFFFF
   \                     ??CrossCallReturnLabel_215:
   \   000003   FD           MOV     R5,A
   \   000004   85..82       MOV     DPL,?V0 + 8
   \   000007   85..83       MOV     DPH,?V0 + 9
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   A3           INC     DPTR
   \   00000D   A3           INC     DPTR
   \   00000E   12....       LCALL   ?Subroutine66 & 0xFFFF
   \                     ??CrossCallReturnLabel_208:
   \   000011   E5..         MOV     A,?V0 + 8
   \   000013   2414         ADD     A,#0x14
   \   000015   F582         MOV     DPL,A
   \   000017   E5..         MOV     A,?V0 + 9
   \   000019   12....       LCALL   ??Subroutine125_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_237:
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   F9           MOV     R1,A
   \   00001E   12....       LCALL   ??zclFindAttrRec?relay
   \   000021   7402         MOV     A,#0x2
   \   000023   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine121_0:
   \   000000   E8           MOV     A,R0
   \   000001                REQUIRE ??Subroutine122_0
   \   000001                ; // Fall through to label ??Subroutine122_0
   2441          #endif // ZCL_READ
   2442          
   2443          #ifdef ZCL_WRITE
   2444          /*********************************************************************
   2445           * @fn      processInWriteCmd
   2446           * @brief   Process the "Profile" Write and Write No Response Commands
   2447           * @param   pInMsg - incoming message to process
   2448           * @return  TRUE if command processed. FALSE, otherwise.
   2449           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2450          static uint8 zclProcessInWriteCmd( zclIncoming_t *pInMsg )
   \                     zclProcessInWriteCmd:
   2451          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 10
   \   000005   74F6         MOV     A,#-0xa
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 6,R2
   \   00000C   8B..         MOV     ?V0 + 7,R3
   2452            zclWriteCmd_t *writeCmd;
   2453            zclWriteRec_t *statusRec;
   2454            zclWriteRspCmd_t *writeRspCmd;
   2455            zclAttrRec_t attrRec;
   2456            uint8 sendRsp = FALSE;
   \   00000E   75..00       MOV     ?V0 + 4,#0x0
   2457            uint8 status;
   2458            uint8 i, j = 0;
   \   000011   75..00       MOV     ?V0 + 2,#0x0
   2459          
   2460            writeCmd = (zclWriteCmd_t *)pInMsg->attrCmd;
   \   000014   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_147:
   \   000017   F8           MOV     R0,A
   \   000018   A3           INC     DPTR
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   12....       LCALL   ?Subroutine13 & 0xFFFF
   2461            if ( pInMsg->hdr.commandID == ZCL_CMD_WRITE )
   \                     ??CrossCallReturnLabel_221:
   \   00001D   8A82         MOV     DPL,R2
   \   00001F   8B83         MOV     DPH,R3
   \   000021   A3           INC     DPTR
   \   000022   A3           INC     DPTR
   \   000023   A3           INC     DPTR
   \   000024   A3           INC     DPTR
   \   000025   A3           INC     DPTR
   \   000026   A3           INC     DPTR
   \   000027   A3           INC     DPTR
   \   000028   E0           MOVX    A,@DPTR
   \   000029   6402         XRL     A,#0x2
   \   00002B   7013         JNZ     ??zclProcessInWriteCmd_0
   2462            {
   2463              // We need to send a response back - allocate space for it
   2464              writeRspCmd = (zclWriteRspCmd_t *)osal_mem_alloc( sizeof( zclWriteRspCmd_t ) 
   2465                      + sizeof( zclWriteRspStatus_t ) * writeCmd->numAttr );
   \   00002D                ; Setup parameters for call to function osal_mem_alloc
   \   00002D   12....       LCALL   ?Subroutine37 & 0xFFFF
   \                     ??CrossCallReturnLabel_195:
   \   000030   12....       LCALL   ?Subroutine23 & 0xFFFF
   2466              if ( writeRspCmd == NULL )
   \                     ??CrossCallReturnLabel_28:
   \   000033   7001         JNZ     ??zclProcessInWriteCmd_1
   \   000035   EB           MOV     A,R3
   \                     ??zclProcessInWriteCmd_1:
   \   000036   7005         JNZ     ??zclProcessInWriteCmd_2
   2467                return FALSE; // EMBEDDED RETURN
   \   000038   7900         MOV     R1,#0x0
   \   00003A   02....       LJMP    ??zclProcessInWriteCmd_3 & 0xFFFF
   2468              sendRsp = TRUE;
   \                     ??zclProcessInWriteCmd_2:
   \   00003D   75..01       MOV     ?V0 + 4,#0x1
   2469            }
   2470            
   2471            for (i = 0; i < writeCmd->numAttr; i++)
   \                     ??zclProcessInWriteCmd_0:
   \   000040   75..00       MOV     ?V0 + 3,#0x0
   \   000043   801F         SJMP    ??zclProcessInWriteCmd_4
   2472            {
   2473              statusRec = &(writeCmd->attrList[i]);
   2474              if ( zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, statusRec->attrID, &attrRec ) )
   2475              {
   2476                if ( statusRec->dataType == attrRec.attr.dataType )
   2477                {
   2478                  status = zclWriteAttrData( &attrRec, statusRec );
   2479          
   2480                  if ( sendRsp && status != ZCL_STATUS_SUCCESS ) // If successful, a write attribute status record shall NOT be generated
   2481                  {
   2482                    writeRspCmd->attrList[j].status = status; // Attribute is read only - move on to the next write attribute record
   2483                    writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   2484                  }
   2485                }
   2486                else
   2487                {
   2488                  if ( sendRsp ) // Attribute data type is incorrect - move on to the next write attribute record
   2489                  {
   2490                    writeRspCmd->attrList[j].status = ZCL_STATUS_INVALID_DATA_TYPE;
   2491                    writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   2492                  }
   2493                }
   2494              }
   2495              else
   2496              {
   2497                if ( sendRsp ) // Attribute is not supported - move on to the next write attribute record
   \                     ??zclProcessInWriteCmd_5:
   \   000045   E5..         MOV     A,?V0 + 4
   \   000047   6019         JZ      ??zclProcessInWriteCmd_6
   2498                {
   2499                  writeRspCmd->attrList[j].status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   \   000049   7486         MOV     A,#-0x7a
   \                     ??zclProcessInWriteCmd_7:
   \   00004B   85..82       MOV     DPL,?V0 + 14
   \   00004E   85..83       MOV     DPH,?V0 + 15
   2500                  writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   2501                }
   2502              }
   \   000051   12....       LCALL   ?Subroutine80 & 0xFFFF
   \                     ??CrossCallReturnLabel_180:
   \   000054   12....       LCALL   ??Subroutine127_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_240:
   \   000057   85..82       MOV     DPL,?V0 + 12
   \   00005A   85..83       MOV     DPH,?V0 + 13
   \   00005D   12....       LCALL   ??Subroutine121_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_219:
   \   000060   05..         INC     ?V0 + 2
   \                     ??zclProcessInWriteCmd_6:
   \   000062   05..         INC     ?V0 + 3
   \                     ??zclProcessInWriteCmd_4:
   \   000064   12....       LCALL   ?Subroutine37 & 0xFFFF
   \                     ??CrossCallReturnLabel_196:
   \   000067   E0           MOVX    A,@DPTR
   \   000068   FA           MOV     R2,A
   \   000069   E5..         MOV     A,?V0 + 3
   \   00006B   C3           CLR     C
   \   00006C   9A           SUBB    A,R2
   \   00006D   4003         JC      $+5
   \   00006F   02....       LJMP    ??zclProcessInWriteCmd_8 & 0xFFFF
   \   000072   E5..         MOV     A,?V0 + 3
   \   000074   75F005       MOV     B,#0x5
   \   000077   A4           MUL     AB
   \   000078   F8           MOV     R0,A
   \   000079   A9F0         MOV     R1,B
   \   00007B   85..82       MOV     DPL,?XSP + 0
   \   00007E   85..83       MOV     DPH,?XSP + 1
   \   000081   E0           MOVX    A,@DPTR
   \   000082   28           ADD     A,R0
   \   000083   FA           MOV     R2,A
   \   000084   A3           INC     DPTR
   \   000085   E0           MOVX    A,@DPTR
   \   000086   39           ADDC    A,R1
   \   000087   8A82         MOV     DPL,R2
   \   000089   F583         MOV     DPH,A
   \   00008B   A3           INC     DPTR
   \   00008C   AE82         MOV     R6,DPL
   \   00008E   AF83         MOV     R7,DPH
   \   000090   E5..         MOV     A,?V0 + 2
   \   000092   75F003       MOV     B,#0x3
   \   000095   12....       LCALL   ?Subroutine77 & 0xFFFF
   \                     ??CrossCallReturnLabel_98:
   \   000098   E582         MOV     A,DPL
   \   00009A   2402         ADD     A,#0x2
   \   00009C   F5..         MOV     ?V0 + 12,A
   \   00009E   E583         MOV     A,DPH
   \   0000A0   3400         ADDC    A,#0x0
   \   0000A2   F5..         MOV     ?V0 + 13,A
   \   0000A4   A3           INC     DPTR
   \   0000A5   8582..       MOV     ?V0 + 14,DPL
   \   0000A8   8583..       MOV     ?V0 + 15,DPH
   \   0000AB   85..82       MOV     DPL,?V0 + 6
   \   0000AE   85..83       MOV     DPH,?V0 + 7
   \   0000B1   12....       LCALL   ??Subroutine123_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_223:
   \   0000B4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B7   8582..       MOV     ?V0 + 10,DPL
   \   0000BA   8583..       MOV     ?V0 + 11,DPH
   \   0000BD   78..         MOV     R0,#?V0 + 10
   \   0000BF   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000C2   8E82         MOV     DPL,R6
   \   0000C4   8F83         MOV     DPH,R7
   \   0000C6   12....       LCALL   ??Subroutine120_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_203:
   \   0000C9   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000CC   E9           MOV     A,R1
   \   0000CD   7003         JNZ     $+5
   \   0000CF   02....       LJMP    ??zclProcessInWriteCmd_5 & 0xFFFF
   \   0000D2   8E82         MOV     DPL,R6
   \   0000D4   8F83         MOV     DPH,R7
   \   0000D6   A3           INC     DPTR
   \   0000D7   A3           INC     DPTR
   \   0000D8   E0           MOVX    A,@DPTR
   \   0000D9   FA           MOV     R2,A
   \   0000DA   7406         MOV     A,#0x6
   \   0000DC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DF   E0           MOVX    A,@DPTR
   \   0000E0   6A           XRL     A,R2
   \   0000E1   7022         JNZ     ??zclProcessInWriteCmd_9
   \   0000E3                ; Setup parameters for call to function zclWriteAttrData
   \   0000E3   EE           MOV     A,R6
   \   0000E4   FC           MOV     R4,A
   \   0000E5   EF           MOV     A,R7
   \   0000E6   FD           MOV     R5,A
   \   0000E7   7402         MOV     A,#0x2
   \   0000E9   12....       LCALL   ?XSTACK_DISP0_8
   \   0000EC   AA82         MOV     R2,DPL
   \   0000EE   AB83         MOV     R3,DPH
   \   0000F0   12....       LCALL   ??zclWriteAttrData?relay
   \   0000F3   E9           MOV     A,R1
   \   0000F4   FA           MOV     R2,A
   \   0000F5   E5..         MOV     A,?V0 + 4
   \   0000F7   7003         JNZ     $+5
   \   0000F9   02....       LJMP    ??zclProcessInWriteCmd_6 & 0xFFFF
   \   0000FC   EA           MOV     A,R2
   \   0000FD   7003         JNZ     $+5
   \   0000FF   02....       LJMP    ??zclProcessInWriteCmd_6 & 0xFFFF
   \   000102   02....       LJMP    ??zclProcessInWriteCmd_7 & 0xFFFF
   \                     ??zclProcessInWriteCmd_9:
   \   000105   E5..         MOV     A,?V0 + 4
   \   000107   7003         JNZ     $+5
   \   000109   02....       LJMP    ??zclProcessInWriteCmd_6 & 0xFFFF
   \   00010C   748D         MOV     A,#-0x73
   \   00010E   02....       LJMP    ??zclProcessInWriteCmd_7 & 0xFFFF
   2503            } // for loop
   2504          
   2505            if ( sendRsp )
   \                     ??zclProcessInWriteCmd_8:
   \   000111   E5..         MOV     A,?V0 + 4
   \   000113   604A         JZ      ??zclProcessInWriteCmd_10
   2506            {
   2507              writeRspCmd->numAttr = j;
   \   000115   85..82       MOV     DPL,?V0 + 0
   \   000118   85..83       MOV     DPH,?V0 + 1
   \   00011B   E5..         MOV     A,?V0 + 2
   \   00011D   F0           MOVX    @DPTR,A
   2508              if ( writeRspCmd->numAttr == 0 )
   \   00011E   7003         JNZ     ??CrossCallReturnLabel_12
   2509              {
   2510                // Since all records were written successful, include a single status record in the resonse command 
   2511                // with the status field set to SUCCESS and the attribute ID field omitted.
   2512                writeRspCmd->attrList[0].status = ZCL_STATUS_SUCCESS;
   \   000120   12....       LCALL   ?Subroutine10 & 0xFFFF
   2513                writeRspCmd->numAttr = 1;
   2514              }
   2515              zcl_SendWriteRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   2516                                pInMsg->msg->clusterId, writeRspCmd, ZCL_FRAME_SERVER_CLIENT_DIR, 
   2517                                true, pInMsg->hdr.transSeqNum );
   \                     ??CrossCallReturnLabel_12:
   \   000123   85..82       MOV     DPL,?V0 + 6
   \   000126   85..83       MOV     DPH,?V0 + 7
   \   000129   12....       LCALL   ?Subroutine35 & 0xFFFF
   \                     ??CrossCallReturnLabel_50:
   \   00012C                ; Setup parameters for call to function zcl_SendWriteRsp
   \   00012C   85..82       MOV     DPL,?V0 + 6
   \   00012F   85..83       MOV     DPH,?V0 + 7
   \   000132   A3           INC     DPTR
   \   000133   A3           INC     DPTR
   \   000134   A3           INC     DPTR
   \   000135   A3           INC     DPTR
   \   000136   A3           INC     DPTR
   \   000137   A3           INC     DPTR
   \   000138   E0           MOVX    A,@DPTR
   \   000139   F5..         MOV     ?V0 + 2,A
   \   00013B   78..         MOV     R0,#?V0 + 2
   \   00013D   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000140   75..01       MOV     ?V0 + 2,#0x1
   \   000143   78..         MOV     R0,#?V0 + 2
   \   000145   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000148   78..         MOV     R0,#?V0 + 2
   \   00014A   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00014D   78..         MOV     R0,#?V0 + 0
   \   00014F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000152   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_24:
   \   000155   12....       LCALL   ?DEALLOC_XSTACK8
   2518              osal_mem_free( writeRspCmd );
   \   000158                ; Setup parameters for call to function osal_mem_free
   \   000158   AA..         MOV     R2,?V0 + 0
   \   00015A   AB..         MOV     R3,?V0 + 1
   \   00015C   12....       LCALL   ??osal_mem_free?relay
   2519            }
   2520            return TRUE; 
   \                     ??zclProcessInWriteCmd_10:
   \   00015F   7901         MOV     R1,#0x1
   \                     ??zclProcessInWriteCmd_3:
   \   000161   740A         MOV     A,#0xa
   \   000163   02....       LJMP    ??Subroutine102_0 & 0xFFFF
   2521          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine37:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine119_0
   \   000006                ; // Fall through to label ??Subroutine119_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   F9           MOV     R1,A
   \   000001   85..82       MOV     DPL,?XSP + 0
   \   000004   85..83       MOV     DPH,?XSP + 1
   \   000007                REQUIRE ??Subroutine121_0
   \   000007                ; // Fall through to label ??Subroutine121_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine123_0:
   \   000000   12....       LCALL   ??Subroutine116_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_228:
   \   000003                ; Setup parameters for call to function zclFindAttrRec
   \   000003                ; Setup parameters for call to function zclFindAttrRec
   \   000003                ; Setup parameters for call to function zclFindAttrRec
   \   000003   7402         MOV     A,#0x2
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   75F003       MOV     B,#0x3
   \   000004   A4           MUL     AB
   \   000005   F8           MOV     R0,A
   \   000006   A9F0         MOV     R1,B
   \   000008   7401         MOV     A,#0x1
   \   00000A   28           ADD     A,R0
   \   00000B   FA           MOV     R2,A
   \   00000C   E4           CLR     A
   \   00000D   39           ADDC    A,R1
   \   00000E   12....       LCALL   ?Subroutine72 & 0xFFFF
   \                     ??CrossCallReturnLabel_230:
   \   000011   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   12....       LCALL   ?Subroutine70 & 0xFFFF
   \                     ??CrossCallReturnLabel_213:
   \   00000B   FD           MOV     R5,A
   \   00000C   EE           MOV     A,R6
   \   00000D   2406         ADD     A,#0x6
   \   00000F   FA           MOV     R2,A
   \   000010   EF           MOV     A,R7
   \   000011   3400         ADDC    A,#0x0
   \   000013   FB           MOV     R3,A
   \   000014   EE           MOV     A,R6
   \   000015   2414         ADD     A,#0x14
   \   000017   F582         MOV     DPL,A
   \   000019   EF           MOV     A,R7
   \   00001A   12....       LCALL   ??Subroutine125_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_233:
   \   00001D   E0           MOVX    A,@DPTR
   \   00001E   F9           MOV     R1,A
   \   00001F   12....       LCALL   ??zcl_SendWriteRsp?relay
   \   000022   7405         MOV     A,#0x5
   \   000024   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   E4           CLR     A
   \   000001   A3           INC     DPTR
   \   000002   F0           MOVX    @DPTR,A
   \   000003   7401         MOV     A,#0x1
   \   000005   85..82       MOV     DPL,?V0 + 0
   \   000008   85..83       MOV     DPH,?V0 + 1
   \   00000B   F0           MOVX    @DPTR,A
   \   00000C   22           RET
   2522          
   2523          /*********************************************************************
   2524           * @fn      zclRevertWriteUndividedCmd
   2525           * @brief   Revert the "Profile" Write Undevided Command
   2526           * @param   pInMsg - incoming message to process
   2527           *          curWriteRec - old data
   2528           *          numAttr - number of attributes to be reverted
   2529           */
   2530          static void zclRevertWriteUndividedCmd( zclIncoming_t *pInMsg, zclWriteRec_t *curWriteRec, uint16 numAttr )
   2531          {
   2532            zclWriteRec_t *statusRec;
   2533            zclAttrRec_t attrRec;
   2534            uint8 dataLen;
   2535            uint8 i;
   2536          
   2537            statusRec = curWriteRec;
   2538            for (i = 0; i < numAttr; i++)
   2539            {
   2540              statusRec = &(curWriteRec[i]);
   2541              
   2542              if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, statusRec->attrID, &attrRec ) )
   2543                break; // should never happen
   2544           
   2545              // Just copy the old data back - no need to validate the data
   2546              dataLen = zclGetAttrDataLength( attrRec.attr.dataType, statusRec->attrData );
   2547              osal_memcpy( attrRec.attr.dataPtr, statusRec->attrData, dataLen );
   2548            } // for loop
   2549          }
   2550          
   2551          /*********************************************************************
   2552           * @fn      zclProcessInWriteUndividedCmd
   2553           * @brief   Process the "Profile" Write Undivided Command
   2554           * @param   pInMsg - incoming message to process
   2555           * @return  TRUE if command processed. FALSE, otherwise.
   2556           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine42:
   \   000000   85..82       MOV     DPL,?V0 + 2
   \   000003   85..83       MOV     DPH,?V0 + 3
   \   000006                REQUIRE ??Subroutine111_0
   \   000006                ; // Fall through to label ??Subroutine111_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine111_0:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003                REQUIRE ??Subroutine112_0
   \   000003                ; // Fall through to label ??Subroutine112_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   85..82       MOV     DPL,?V0 + 2
   \   000003   85..83       MOV     DPH,?V0 + 3
   \   000006                REQUIRE ??Subroutine120_0
   \   000006                ; // Fall through to label ??Subroutine120_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2557          static uint8 zclProcessInWriteUndividedCmd( zclIncoming_t *pInMsg )
   \                     zclProcessInWriteUndividedCmd:
   2558          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 18
   \   000005   74EE         MOV     A,#-0x12
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 14,R2
   \   00000C   8B..         MOV     ?V0 + 15,R3
   2559            zclWriteCmd_t *writeCmd;
   2560            zclWriteRec_t *statusRec;
   2561            zclWriteRec_t *curWriteRec;
   2562            zclWriteRec_t *curStatusRec;
   2563            zclWriteRspCmd_t *writeRspCmd;
   2564            zclAttrRec_t attrRec;
   2565            uint8 *curDataPtr;
   2566            uint8 hdrLen;
   2567            uint8 dataLen;
   2568            uint8 curLen = 0;
   \   00000E   75..00       MOV     ?V0 + 4,#0x0
   2569            uint8 status;
   2570            uint8 i, j = 0;
   \   000011   7F00         MOV     R7,#0x0
   2571          
   2572            writeCmd = (zclWriteCmd_t *)pInMsg->attrCmd;
   \   000013   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_148:
   \   000016   F5..         MOV     ?V0 + 6,A
   \   000018   A3           INC     DPTR
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   F5..         MOV     ?V0 + 7,A
   2573            
   2574            // Allocate space for Write Response Command
   2575            writeRspCmd = (zclWriteRspCmd_t *)osal_mem_alloc( sizeof( zclWriteRspCmd_t ) + sizeof( zclWriteRspStatus_t )* writeCmd->numAttr );
   \   00001C                ; Setup parameters for call to function osal_mem_alloc
   \   00001C   85..82       MOV     DPL,?V0 + 6
   \   00001F   F583         MOV     DPH,A
   \   000021   12....       LCALL   ?Subroutine23 & 0xFFFF
   2576            
   2577            if ( writeRspCmd == NULL )
   \                     ??CrossCallReturnLabel_29:
   \   000024   7001         JNZ     ??zclProcessInWriteUndividedCmd_0
   \   000026   EB           MOV     A,R3
   \                     ??zclProcessInWriteUndividedCmd_0:
   \   000027   7005         JNZ     ??zclProcessInWriteUndividedCmd_1
   2578              return FALSE; // EMBEDDED RETURN
   \                     ??zclProcessInWriteUndividedCmd_2:
   \   000029   7900         MOV     R1,#0x0
   \   00002B   02....       LJMP    ??zclProcessInWriteUndividedCmd_3 & 0xFFFF
   2579            
   2580            // If any attribute cannot be written, no attribute values are changed. Hence,
   2581            // make sure all the attributes are supported and writable
   2582            for (i = 0; i < writeCmd->numAttr; i++)
   \                     ??zclProcessInWriteUndividedCmd_1:
   \   00002E   7E00         MOV     R6,#0x0
   \   000030   8013         SJMP    ??zclProcessInWriteUndividedCmd_4
   2583            {
   2584              statusRec = &(writeCmd->attrList[i]);
   2585              
   2586              if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, statusRec->attrID, &attrRec ) )
   2587              {
   2588                // Attribute is not supported - stop here
   2589                writeRspCmd->attrList[j].status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   2590                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   2591                break;
   2592              }
   2593              
   2594              if ( statusRec->dataType != attrRec.attr.dataType )
   2595              {
   2596                // Attribute data type is incorrect - stope here
   2597                writeRspCmd->attrList[j].status = ZCL_STATUS_INVALID_DATA_TYPE;
   2598                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   2599                break;
   2600              }
   2601              
   2602              if ( !zcl_AccessCtrlWrite( attrRec.attr.accessControl ) )
   2603              {
   2604                // Attribute is not writable - stop here
   2605                writeRspCmd->attrList[j].status = ZCL_STATUS_READ_ONLY;
   2606                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   2607                break;
   2608              }  
   2609              dataLen = zclGetAttrDataLength( statusRec->dataType, statusRec->attrData );
   \                     ??zclProcessInWriteUndividedCmd_5:
   \   000032                ; Setup parameters for call to function zclGetAttrDataLength
   \   000032   12....       LCALL   ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_164:
   \   000035   12....       LCALL   ??zclGetAttrDataLength?relay
   \   000038   E9           MOV     A,R1
   \   000039   FA           MOV     R2,A
   2610              
   2611              // add padding if needed
   2612              if ( PADDING_NEEDED( dataLen ) )
   \   00003A   A2E0         MOV     C,0xE0 /* A   */.0
   \   00003C   5001         JNC     ??zclProcessInWriteUndividedCmd_6
   2613                dataLen++;
   \   00003E   0A           INC     R2
   2614              curLen += dataLen;
   \                     ??zclProcessInWriteUndividedCmd_6:
   \   00003F   EA           MOV     A,R2
   \   000040   25..         ADD     A,?V0 + 4
   \   000042   F5..         MOV     ?V0 + 4,A
   \   000044   0E           INC     R6
   \                     ??zclProcessInWriteUndividedCmd_4:
   \   000045   85..82       MOV     DPL,?V0 + 6
   \   000048   85..83       MOV     DPH,?V0 + 7
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   FA           MOV     R2,A
   \   00004D   EE           MOV     A,R6
   \   00004E   C3           CLR     C
   \   00004F   9A           SUBB    A,R2
   \   000050   505D         JNC     ??zclProcessInWriteUndividedCmd_7
   \   000052   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_76:
   \   000055   12....       LCALL   ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_224:
   \   000058   12....       LCALL   ?XSTACK_DISP0_8
   \   00005B   8582..       MOV     ?V0 + 10,DPL
   \   00005E   8583..       MOV     ?V0 + 11,DPH
   \   000061   78..         MOV     R0,#?V0 + 10
   \   000063   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000066   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_200:
   \   000069   12....       LCALL   ?DEALLOC_XSTACK8
   \   00006C   E9           MOV     A,R1
   \   00006D   7004         JNZ     ??zclProcessInWriteUndividedCmd_8
   \   00006F   7486         MOV     A,#-0x7a
   \   000071   8023         SJMP    ??zclProcessInWriteUndividedCmd_9
   \                     ??zclProcessInWriteUndividedCmd_8:
   \   000073   85..82       MOV     DPL,?V0 + 2
   \   000076   85..83       MOV     DPH,?V0 + 3
   \   000079   A3           INC     DPTR
   \   00007A   A3           INC     DPTR
   \   00007B   E0           MOVX    A,@DPTR
   \   00007C   F9           MOV     R1,A
   \   00007D   7406         MOV     A,#0x6
   \   00007F   12....       LCALL   ?XSTACK_DISP0_8
   \   000082   E0           MOVX    A,@DPTR
   \   000083   69           XRL     A,R1
   \   000084   6004         JZ      ??zclProcessInWriteUndividedCmd_10
   \   000086   748D         MOV     A,#-0x73
   \   000088   800C         SJMP    ??zclProcessInWriteUndividedCmd_9
   \                     ??zclProcessInWriteUndividedCmd_10:
   \   00008A   7407         MOV     A,#0x7
   \   00008C   12....       LCALL   ?XSTACK_DISP0_8
   \   00008F   E0           MOVX    A,@DPTR
   \   000090   A2E1         MOV     C,0xE0 /* A   */.1
   \   000092   409E         JC      ??zclProcessInWriteUndividedCmd_5
   \   000094   7488         MOV     A,#-0x78
   \                     ??zclProcessInWriteUndividedCmd_9:
   \   000096   85..82       MOV     DPL,?V0 + 0
   \   000099   85..83       MOV     DPH,?V0 + 1
   \   00009C   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_22:
   \   00009F   F8           MOV     R0,A
   \   0000A0   A3           INC     DPTR
   \   0000A1   E0           MOVX    A,@DPTR
   \   0000A2   F9           MOV     R1,A
   \   0000A3   85..82       MOV     DPL,?V0 + 0
   \   0000A6   85..83       MOV     DPH,?V0 + 1
   \   0000A9   A3           INC     DPTR
   \   0000AA   A3           INC     DPTR
   \   0000AB   12....       LCALL   ??Subroutine121_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_220:
   \   0000AE   0F           INC     R7
   2615            } // for loop
   2616            
   2617            writeRspCmd->numAttr = j;
   \                     ??zclProcessInWriteUndividedCmd_7:
   \   0000AF   EF           MOV     A,R7
   \   0000B0   85..82       MOV     DPL,?V0 + 0
   \   0000B3   85..83       MOV     DPH,?V0 + 1
   \   0000B6   F0           MOVX    @DPTR,A
   2618            if ( writeRspCmd->numAttr == 0 ) // All attributes can be written
   \   0000B7   6003         JZ      $+5
   \   0000B9   02....       LJMP    ??zclProcessInWriteUndividedCmd_11 & 0xFFFF
   2619            {
   2620              // calculate the length of the current data header
   2621              hdrLen = j * sizeof( zclWriteRec_t );
   \   0000BC   75F005       MOV     B,#0x5
   \   0000BF   A4           MUL     AB
   \   0000C0   FA           MOV     R2,A
   2622            
   2623              // Allocate space to keep a copy of the current data
   2624              curWriteRec = (zclWriteRec_t *) osal_mem_alloc( hdrLen + curLen ); 
   \   0000C1   8A82         MOV     DPL,R2
   \   0000C3   8582..       MOV     ?V0 + 2,DPL
   \   0000C6                ; Setup parameters for call to function osal_mem_alloc
   \   0000C6   E5..         MOV     A,?V0 + 4
   \   0000C8   25..         ADD     A,?V0 + 2
   \   0000CA   FA           MOV     R2,A
   \   0000CB   E4           CLR     A
   \   0000CC   3400         ADDC    A,#0x0
   \   0000CE   FB           MOV     R3,A
   \   0000CF   12....       LCALL   ??osal_mem_alloc?relay
   \   0000D2   8A..         MOV     ?V0 + 12,R2
   \   0000D4   8B..         MOV     ?V0 + 13,R3
   2625              if ( curWriteRec == NULL )
   \   0000D6   EA           MOV     A,R2
   \   0000D7   7001         JNZ     ??zclProcessInWriteUndividedCmd_12
   \   0000D9   EB           MOV     A,R3
   \                     ??zclProcessInWriteUndividedCmd_12:
   \   0000DA   700A         JNZ     ??zclProcessInWriteUndividedCmd_13
   2626              {
   2627                osal_mem_free(writeRspCmd );
   \   0000DC                ; Setup parameters for call to function osal_mem_free
   \   0000DC   AA..         MOV     R2,?V0 + 0
   \   0000DE   AB..         MOV     R3,?V0 + 1
   \   0000E0   12....       LCALL   ??osal_mem_free?relay
   2628                return FALSE; // EMBEDDED RETURN
   \   0000E3   02....       LJMP    ??zclProcessInWriteUndividedCmd_2 & 0xFFFF
   2629              }
   2630          
   2631              curDataPtr = (uint8 *)((uint8 *)curWriteRec + hdrLen);
   \                     ??zclProcessInWriteUndividedCmd_13:
   \   0000E6   EA           MOV     A,R2
   \   0000E7   25..         ADD     A,?V0 + 2
   \   0000E9   F5..         MOV     ?V0 + 4,A
   \   0000EB   EB           MOV     A,R3
   \   0000EC   3400         ADDC    A,#0x0
   \   0000EE   F5..         MOV     ?V0 + 5,A
   2632              
   2633              // Write the new data over
   2634              for (i = 0; i < writeCmd->numAttr; i++)
   \   0000F0   7E00         MOV     R6,#0x0
   \   0000F2   8020         SJMP    ??zclProcessInWriteUndividedCmd_14
   2635              {
   2636                statusRec = &(writeCmd->attrList[i]);
   2637                curStatusRec = &(curWriteRec[i]);
   2638              
   2639                if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, statusRec->attrID, &attrRec ) )
   2640                  break; // should never happen
   2641          
   2642                // Keep a copy of the current data before before writing the new data over
   2643                curStatusRec->attrID = statusRec->attrID;
   2644                zclReadAttrData( curDataPtr, &attrRec );
   2645                curStatusRec->attrData = curDataPtr;
   2646                
   2647                status = zclWriteAttrData( &attrRec, statusRec );
   2648                   
   2649                // If successful, a write attribute status record shall NOT be generated
   2650                if ( status != ZCL_STATUS_SUCCESS )
   2651                {
   2652                  writeRspCmd->attrList[j].status = status;
   2653                  writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   2654                    
   2655                  // Since this write failed, we need to revert all the pervious writes
   2656                  zclRevertWriteUndividedCmd( pInMsg, curWriteRec, i);
   2657                  break;
   2658                }
   2659                
   2660                dataLen = zclGetAttrDataLength( statusRec->dataType, statusRec->attrData );
   \                     ??zclProcessInWriteUndividedCmd_15:
   \   0000F4                ; Setup parameters for call to function zclGetAttrDataLength
   \   0000F4   12....       LCALL   ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_165:
   \   0000F7   85..82       MOV     DPL,?V0 + 2
   \   0000FA   85..83       MOV     DPH,?V0 + 3
   \   0000FD   12....       LCALL   ??Subroutine109_0 & 0xFFFF
   2661                
   2662                // add padding if needed
   2663                if ( PADDING_NEEDED( dataLen ) )
   \                     ??CrossCallReturnLabel_154:
   \   000100   A2E0         MOV     C,0xE0 /* A   */.0
   \   000102   5001         JNC     ??zclProcessInWriteUndividedCmd_16
   2664                  dataLen++;
   \   000104   0A           INC     R2
   2665                curDataPtr += dataLen;
   \                     ??zclProcessInWriteUndividedCmd_16:
   \   000105   8A..         MOV     ?V0 + 2,R2
   \   000107   E5..         MOV     A,?V0 + 4
   \   000109   25..         ADD     A,?V0 + 2
   \   00010B   F5..         MOV     ?V0 + 4,A
   \   00010D   E5..         MOV     A,?V0 + 5
   \   00010F   3400         ADDC    A,#0x0
   \   000111   F5..         MOV     ?V0 + 5,A
   \   000113   0E           INC     R6
   \                     ??zclProcessInWriteUndividedCmd_14:
   \   000114   85..82       MOV     DPL,?V0 + 6
   \   000117   85..83       MOV     DPH,?V0 + 7
   \   00011A   E0           MOVX    A,@DPTR
   \   00011B   FA           MOV     R2,A
   \   00011C   EE           MOV     A,R6
   \   00011D   C3           CLR     C
   \   00011E   9A           SUBB    A,R2
   \   00011F   4003         JC      $+5
   \   000121   02....       LJMP    ??zclProcessInWriteUndividedCmd_17 & 0xFFFF
   \   000124   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_77:
   \   000127   E5..         MOV     A,?V0 + 12
   \   000129   28           ADD     A,R0
   \   00012A   F8           MOV     R0,A
   \   00012B   E5..         MOV     A,?V0 + 13
   \   00012D   39           ADDC    A,R1
   \   00012E   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_222:
   \   000131   12....       LCALL   ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_225:
   \   000134   12....       LCALL   ?XSTACK_DISP0_8
   \   000137   8582..       MOV     ?V0 + 10,DPL
   \   00013A   8583..       MOV     ?V0 + 11,DPH
   \   00013D   78..         MOV     R0,#?V0 + 10
   \   00013F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000142   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_201:
   \   000145   12....       LCALL   ?DEALLOC_XSTACK8
   \   000148   E9           MOV     A,R1
   \   000149   7003         JNZ     $+5
   \   00014B   02....       LJMP    ??zclProcessInWriteUndividedCmd_17 & 0xFFFF
   \   00014E   85..82       MOV     DPL,?V0 + 2
   \   000151   85..83       MOV     DPH,?V0 + 3
   \   000154   12....       LCALL   ??Subroutine112_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_161:
   \   000157   12....       LCALL   ?Subroutine37 & 0xFFFF
   \                     ??CrossCallReturnLabel_197:
   \   00015A   EA           MOV     A,R2
   \   00015B   F0           MOVX    @DPTR,A
   \   00015C   A3           INC     DPTR
   \   00015D   EB           MOV     A,R3
   \   00015E   F0           MOVX    @DPTR,A
   \   00015F                ; Setup parameters for call to function zclReadAttrData
   \   00015F   7402         MOV     A,#0x2
   \   000161   12....       LCALL   ?XSTACK_DISP0_8
   \   000164   AC82         MOV     R4,DPL
   \   000166   AD83         MOV     R5,DPH
   \   000168   AA..         MOV     R2,?V0 + 4
   \   00016A   AB..         MOV     R3,?V0 + 5
   \   00016C   12....       LCALL   ??zclReadAttrData?relay
   \   00016F   85..82       MOV     DPL,?XSP + 0
   \   000172   85..83       MOV     DPH,?XSP + 1
   \   000175   12....       LCALL   ?Subroutine36 & 0xFFFF
   \                     ??CrossCallReturnLabel_52:
   \   000178   E5..         MOV     A,?V0 + 4
   \   00017A   F0           MOVX    @DPTR,A
   \   00017B   A3           INC     DPTR
   \   00017C   E5..         MOV     A,?V0 + 5
   \   00017E   F0           MOVX    @DPTR,A
   \   00017F                ; Setup parameters for call to function zclWriteAttrData
   \   00017F   AC..         MOV     R4,?V0 + 2
   \   000181   AD..         MOV     R5,?V0 + 3
   \   000183   7402         MOV     A,#0x2
   \   000185   12....       LCALL   ?XSTACK_DISP0_8
   \   000188   AA82         MOV     R2,DPL
   \   00018A   AB83         MOV     R3,DPH
   \   00018C   12....       LCALL   ??zclWriteAttrData?relay
   \   00018F   E9           MOV     A,R1
   \   000190   FB           MOV     R3,A
   \   000191   7003         JNZ     $+5
   \   000193   02....       LJMP    ??zclProcessInWriteUndividedCmd_15 & 0xFFFF
   \   000196   EF           MOV     A,R7
   \   000197   75F003       MOV     B,#0x3
   \   00019A   A4           MUL     AB
   \   00019B   F8           MOV     R0,A
   \   00019C   A9F0         MOV     R1,B
   \   00019E   E5..         MOV     A,?V0 + 0
   \   0001A0   28           ADD     A,R0
   \   0001A1   F8           MOV     R0,A
   \   0001A2   E5..         MOV     A,?V0 + 1
   \   0001A4   39           ADDC    A,R1
   \   0001A5   F9           MOV     R1,A
   \   0001A6   EB           MOV     A,R3
   \   0001A7   8882         MOV     DPL,R0
   \   0001A9   8983         MOV     DPH,R1
   \   0001AB   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_23:
   \   0001AE   12....       LCALL   ??Subroutine105_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_140:
   \   0001B1   EA           MOV     A,R2
   \   0001B2   F0           MOVX    @DPTR,A
   \   0001B3   A3           INC     DPTR
   \   0001B4   EB           MOV     A,R3
   \   0001B5   F0           MOVX    @DPTR,A
   \   0001B6   0F           INC     R7
   \   0001B7   8E82         MOV     DPL,R6
   \   0001B9   8582..       MOV     ?V0 + 8,DPL
   \   0001BC   7E00         MOV     R6,#0x0
   \   0001BE   8032         SJMP    ??zclProcessInWriteUndividedCmd_18
   2666              } // for loop
   \                     ??zclProcessInWriteUndividedCmd_19:
   \   0001C0   E5..         MOV     A,?V0 + 2
   \   0001C2   2403         ADD     A,#0x3
   \   0001C4   F5..         MOV     ?V0 + 2,A
   \   0001C6   E5..         MOV     A,?V0 + 3
   \   0001C8   12....       LCALL   ?Subroutine56 & 0xFFFF
   \                     ??CrossCallReturnLabel_75:
   \   0001CB   12....       LCALL   ??Subroutine112_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_162:
   \   0001CE   740E         MOV     A,#0xe
   \   0001D0   12....       LCALL   ?XSTACK_DISP0_8
   \   0001D3   12....       LCALL   ??Subroutine110_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_155:
   \   0001D6                ; Setup parameters for call to function osal_memcpy
   \   0001D6   85..82       MOV     DPL,?V0 + 2
   \   0001D9   85..83       MOV     DPH,?V0 + 3
   \   0001DC   12....       LCALL   ?Subroutine31 & 0xFFFF
   \                     ??CrossCallReturnLabel_124:
   \   0001DF   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0001E2   EA           MOV     A,R2
   \   0001E3   FC           MOV     R4,A
   \   0001E4   7D00         MOV     R5,#0x0
   \   0001E6   7413         MOV     A,#0x13
   \   0001E8   12....       LCALL   ?XSTACK_DISP0_8
   \   0001EB   12....       LCALL   ?Subroutine41 & 0xFFFF
   \                     ??CrossCallReturnLabel_120:
   \   0001EE   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001F1   0E           INC     R6
   \                     ??zclProcessInWriteUndividedCmd_18:
   \   0001F2   8E..         MOV     ?V0 + 2,R6
   \   0001F4   C3           CLR     C
   \   0001F5   E5..         MOV     A,?V0 + 2
   \   0001F7   95..         SUBB    A,?V0 + 8
   \   0001F9   E4           CLR     A
   \   0001FA   9400         SUBB    A,#0x0
   \   0001FC   5058         JNC     ??zclProcessInWriteUndividedCmd_17
   \   0001FE   EE           MOV     A,R6
   \   0001FF   75F005       MOV     B,#0x5
   \   000202   A4           MUL     AB
   \   000203   F8           MOV     R0,A
   \   000204   A9F0         MOV     R1,B
   \   000206   E5..         MOV     A,?V0 + 12
   \   000208   28           ADD     A,R0
   \   000209   F5..         MOV     ?V0 + 2,A
   \   00020B   E5..         MOV     A,?V0 + 13
   \   00020D   39           ADDC    A,R1
   \   00020E   F5..         MOV     ?V0 + 3,A
   \   000210   85..82       MOV     DPL,?V0 + 14
   \   000213   85..83       MOV     DPH,?V0 + 15
   \   000216   12....       LCALL   ?Subroutine64 & 0xFFFF
   \                     ??CrossCallReturnLabel_85:
   \   000219                ; Setup parameters for call to function zclFindAttrRec
   \   000219   740A         MOV     A,#0xa
   \   00021B   12....       LCALL   ?XSTACK_DISP0_8
   \   00021E   8582..       MOV     ?V0 + 6,DPL
   \   000221   8583..       MOV     ?V0 + 7,DPH
   \   000224   78..         MOV     R0,#?V0 + 6
   \   000226   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000229   85..82       MOV     DPL,?V0 + 2
   \   00022C   85..83       MOV     DPH,?V0 + 3
   \   00022F   12....       LCALL   ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_35:
   \   000232   85..82       MOV     DPL,?V0 + 4
   \   000235   85..83       MOV     DPH,?V0 + 5
   \   000238   A3           INC     DPTR
   \   000239   12....       LCALL   ??Subroutine111_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_163:
   \   00023C   E5..         MOV     A,?V0 + 4
   \   00023E   2414         ADD     A,#0x14
   \   000240   F582         MOV     DPL,A
   \   000242   E5..         MOV     A,?V0 + 5
   \   000244   12....       LCALL   ??Subroutine107_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_144:
   \   000247   F9           MOV     R1,A
   \   000248   12....       LCALL   ??zclFindAttrRec?relay
   \   00024B   7402         MOV     A,#0x2
   \   00024D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000250   E9           MOV     A,R1
   \   000251   6003         JZ      $+5
   \   000253   02....       LJMP    ??zclProcessInWriteUndividedCmd_19 & 0xFFFF
   2667            
   2668              writeRspCmd->numAttr = j;
   \                     ??zclProcessInWriteUndividedCmd_17:
   \   000256   EF           MOV     A,R7
   \   000257   85..82       MOV     DPL,?V0 + 0
   \   00025A   85..83       MOV     DPH,?V0 + 1
   \   00025D   F0           MOVX    @DPTR,A
   2669              if ( writeRspCmd->numAttr  == 0 )
   \   00025E   7003         JNZ     ??CrossCallReturnLabel_13
   2670              {
   2671                // Since all records were written successful, include a single status record in the resonse command
   2672                // with the status field set to SUCCESS and the attribute ID field omitted.
   2673                writeRspCmd->attrList[0].status = ZCL_STATUS_SUCCESS;
   \   000260   12....       LCALL   ?Subroutine10 & 0xFFFF
   2674                writeRspCmd->numAttr = 1;
   2675              }
   2676          
   2677              osal_mem_free( curWriteRec );
   \                     ??CrossCallReturnLabel_13:
   \   000263                ; Setup parameters for call to function osal_mem_free
   \   000263   AA..         MOV     R2,?V0 + 12
   \   000265   AB..         MOV     R3,?V0 + 13
   \   000267   12....       LCALL   ??osal_mem_free?relay
   2678            }
   2679            
   2680            zcl_SendWriteRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   2681                              pInMsg->msg->clusterId, writeRspCmd, ZCL_FRAME_SERVER_CLIENT_DIR, 
   2682                              true, pInMsg->hdr.transSeqNum );  
   \                     ??zclProcessInWriteUndividedCmd_11:
   \   00026A   85..82       MOV     DPL,?V0 + 14
   \   00026D   85..83       MOV     DPH,?V0 + 15
   \   000270   12....       LCALL   ?Subroutine35 & 0xFFFF
   \                     ??CrossCallReturnLabel_51:
   \   000273                ; Setup parameters for call to function zcl_SendWriteRsp
   \   000273   85..82       MOV     DPL,?V0 + 14
   \   000276   85..83       MOV     DPH,?V0 + 15
   \   000279   A3           INC     DPTR
   \   00027A   A3           INC     DPTR
   \   00027B   A3           INC     DPTR
   \   00027C   A3           INC     DPTR
   \   00027D   A3           INC     DPTR
   \   00027E   A3           INC     DPTR
   \   00027F   E0           MOVX    A,@DPTR
   \   000280   F5..         MOV     ?V0 + 2,A
   \   000282   78..         MOV     R0,#?V0 + 2
   \   000284   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000287   75..01       MOV     ?V0 + 2,#0x1
   \   00028A   78..         MOV     R0,#?V0 + 2
   \   00028C   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00028F   78..         MOV     R0,#?V0 + 2
   \   000291   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000294   78..         MOV     R0,#?V0 + 0
   \   000296   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000299   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_25:
   \   00029C   12....       LCALL   ?DEALLOC_XSTACK8
   2683            osal_mem_free( writeRspCmd );
   \   00029F                ; Setup parameters for call to function osal_mem_free
   \   00029F   AA..         MOV     R2,?V0 + 0
   \   0002A1   AB..         MOV     R3,?V0 + 1
   \   0002A3   12....       LCALL   ??osal_mem_free?relay
   2684           
   2685            return TRUE; 
   \   0002A6   7901         MOV     R1,#0x1
   \                     ??zclProcessInWriteUndividedCmd_3:
   \   0002A8   02....       LJMP    ?Subroutine100 & 0xFFFF
   2686          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine58:
   \   000000   EE           MOV     A,R6
   \   000001   75F005       MOV     B,#0x5
   \   000004   A4           MUL     AB
   \   000005   F8           MOV     R0,A
   \   000006   A9F0         MOV     R1,B
   \   000008   E5..         MOV     A,?V0 + 6
   \   00000A   28           ADD     A,R0
   \   00000B   F582         MOV     DPL,A
   \   00000D   E5..         MOV     A,?V0 + 7
   \   00000F   39           ADDC    A,R1
   \   000010   F583         MOV     DPH,A
   \   000012   A3           INC     DPTR
   \   000013   8582..       MOV     ?V0 + 2,DPL
   \   000016   8583..       MOV     ?V0 + 3,DPH
   \   000019   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine27:
   \   000000   85..82       MOV     DPL,?V0 + 14
   \   000003   85..83       MOV     DPH,?V0 + 15
   \   000006                REQUIRE ??Subroutine123_0
   \   000006                ; // Fall through to label ??Subroutine123_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   A3           INC     DPTR
   \   000001   F0           MOVX    @DPTR,A
   \   000002   85..82       MOV     DPL,?V0 + 2
   \   000005   85..83       MOV     DPH,?V0 + 3
   \   000008   E0           MOVX    A,@DPTR
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine36:
   \   000000   12....       LCALL   ?Subroutine71 & 0xFFFF
   \                     ??CrossCallReturnLabel_198:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   22           RET
   2687          #endif // ZCL_WRITE
   2688          
   2689          #ifdef ZCL_DISCOVER
   2690          /*********************************************************************
   2691           * @fn      zclProcessInDiscCmd
   2692           * @brief   Process the "Profile" Discover Command
   2693           * @param   pInMsg - incoming message to process
   2694           * @return  TRUE if command processed. FALSE, otherwise.
   2695           */
   2696          static uint8 zclProcessInDiscCmd( zclIncoming_t *pInMsg )
   2697          {
   2698            zclDiscoverCmd_t *discoverCmd;
   2699            zclDiscoverRspCmd_t *discoverRspCmd;
   2700            uint8 discComplete = TRUE;
   2701            zclAttrRec_t attrRec;
   2702            uint16 attrID;
   2703            uint8 i;
   2704            
   2705            discoverCmd = (zclDiscoverCmd_t *)pInMsg->attrCmd;
   2706            
   2707            // Find out the number of attributes supported within the specified range
   2708            for ( i = 0, attrID = discoverCmd->startAttr; i < discoverCmd->maxAttrIDs; i++, attrID++ )
   2709            {
   2710              if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, &attrID, &attrRec ) )
   2711                break;
   2712            }
   2713            
   2714            // Allocate space for the response command
   2715            discoverRspCmd = (zclDiscoverRspCmd_t *)osal_mem_alloc( sizeof (zclDiscoverRspCmd_t) 
   2716                                                                   + sizeof ( zclDiscoverInfo_t ) * i );
   2717            if ( discoverRspCmd == NULL )
   2718              return FALSE; // EMEDDED RETURN
   2719            
   2720            discoverRspCmd->numAttr = i;
   2721            if ( discoverRspCmd->numAttr != 0 )
   2722            {
   2723              for ( i = 0, attrID = discoverCmd->startAttr; i < discoverRspCmd->numAttr; i++, attrID++ )
   2724              {
   2725                if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, &attrID, &attrRec ) )
   2726                  break; // Attribute not supported
   2727                
   2728                discoverRspCmd->attrList[i].attrID = attrRec.attr.attrId;
   2729                discoverRspCmd->attrList[i].dataType = attrRec.attr.dataType;
   2730              }
   2731              
   2732              // Are there more attributes to be discovered?
   2733              if ( zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, &attrID, &attrRec ) )
   2734                discComplete = FALSE;
   2735            }
   2736            
   2737            discoverRspCmd->discComplete = discComplete;
   2738            zcl_SendDiscoverRspCmd( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr, 
   2739                                    pInMsg->msg->clusterId, discoverRspCmd, ZCL_FRAME_SERVER_CLIENT_DIR, 
   2740                                    true, pInMsg->hdr.transSeqNum );
   2741            osal_mem_free( discoverRspCmd );
   2742            
   2743            return TRUE;
   2744          }
   2745          #endif // ZCL_DISCOVER
   2746          
   2747          /*********************************************************************
   2748           * @fn      zclSendMsg
   2749           * @brief   Send an incoming message to the Application
   2750           * @param   pInMsg - incoming message to process
   2751           * @return  TRUE
   2752           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2753          static uint8 zclSendMsg( zclIncoming_t *pInMsg )
   \                     zclSendMsg:
   2754          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   2755            zclIncomingMsg_t *pCmd;
   2756              
   2757            if ( zcl_RegisteredMsgTaskID == TASK_NO_TASK )
   \   000009   90....       MOV     DPTR,#zcl_RegisteredMsgTaskID
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   64FF         XRL     A,#0xff
   \   00000F   7005         JNZ     ??zclSendMsg_0
   2758              return ( TRUE );
   \                     ??zclSendMsg_1:
   \   000011   7901         MOV     R1,#0x1
   \   000013   02....       LJMP    ?Subroutine94 & 0xFFFF
   2759            
   2760            pCmd = (zclIncomingMsg_t *)osal_msg_allocate( sizeof ( zclIncomingMsg_t ) );
   \                     ??zclSendMsg_0:
   \   000016                ; Setup parameters for call to function osal_msg_allocate
   \   000016   7A18         MOV     R2,#0x18
   \   000018   7B00         MOV     R3,#0x0
   \   00001A   12....       LCALL   ??osal_msg_allocate?relay
   2761            if ( pCmd != NULL )
   \   00001D   EA           MOV     A,R2
   \   00001E   7001         JNZ     ??zclSendMsg_2
   \   000020   EB           MOV     A,R3
   \                     ??zclSendMsg_2:
   \   000021   60EE         JZ      ??zclSendMsg_1
   2762            {
   2763              // fill in the message
   2764              pCmd->hdr.event = ZCL_INCOMING_MSG;
   \   000023   7434         MOV     A,#0x34
   \   000025   12....       LCALL   ?Subroutine7 & 0xFFFF
   2765              pCmd->zclHdr    = pInMsg->hdr;
   \                     ??CrossCallReturnLabel_174:
   \   000028   A3           INC     DPTR
   \   000029   EA           MOV     A,R2
   \   00002A   2402         ADD     A,#0x2
   \   00002C   FC           MOV     R4,A
   \   00002D   EB           MOV     A,R3
   \   00002E   3400         ADDC    A,#0x0
   \   000030   FD           MOV     R5,A
   \   000031   7406         MOV     A,#0x6
   \   000033   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
   2766              pCmd->clusterId = pInMsg->msg->clusterId;
   \   000036   8E82         MOV     DPL,R6
   \   000038   8F83         MOV     DPH,R7
   \   00003A   12....       LCALL   ?Subroutine36 & 0xFFFF
   \                     ??CrossCallReturnLabel_53:
   \   00003D   12....       LCALL   ??Subroutine126_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_241:
   \   000040   8A82         MOV     DPL,R2
   \   000042   8B83         MOV     DPH,R3
   \   000044   A3           INC     DPTR
   \   000045   A3           INC     DPTR
   \   000046   A3           INC     DPTR
   \   000047   A3           INC     DPTR
   \   000048   A3           INC     DPTR
   \   000049   A3           INC     DPTR
   \   00004A   A3           INC     DPTR
   \   00004B   A3           INC     DPTR
   \   00004C   E8           MOV     A,R0
   \   00004D   12....       LCALL   ?Subroutine12 & 0xFFFF
   2767              pCmd->srcAddr   = pInMsg->msg->srcAddr;
   \                     ??CrossCallReturnLabel_18:
   \   000050   F8           MOV     R0,A
   \   000051   A3           INC     DPTR
   \   000052   E0           MOVX    A,@DPTR
   \   000053   F583         MOV     DPH,A
   \   000055   8882         MOV     DPL,R0
   \   000057   A3           INC     DPTR
   \   000058   A3           INC     DPTR
   \   000059   A3           INC     DPTR
   \   00005A   A3           INC     DPTR
   \   00005B   A3           INC     DPTR
   \   00005C   A3           INC     DPTR
   \   00005D   EA           MOV     A,R2
   \   00005E   240A         ADD     A,#0xa
   \   000060   FC           MOV     R4,A
   \   000061   EB           MOV     A,R3
   \   000062   3400         ADDC    A,#0x0
   \   000064   FD           MOV     R5,A
   \   000065   740C         MOV     A,#0xc
   \   000067   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
   2768              pCmd->attrCmd   = pInMsg->attrCmd;
   \   00006A   EE           MOV     A,R6
   \   00006B   240C         ADD     A,#0xc
   \   00006D   F8           MOV     R0,A
   \   00006E   EF           MOV     A,R7
   \   00006F   3400         ADDC    A,#0x0
   \   000071   F9           MOV     R1,A
   \   000072   8882         MOV     DPL,R0
   \   000074   8983         MOV     DPH,R1
   \   000076   12....       LCALL   ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_36:
   \   000079   EA           MOV     A,R2
   \   00007A   2416         ADD     A,#0x16
   \   00007C   12....       LCALL   ?Subroutine75 & 0xFFFF
   \                     ??CrossCallReturnLabel_235:
   \   00007F   EC           MOV     A,R4
   \   000080   F0           MOVX    @DPTR,A
   \   000081   A3           INC     DPTR
   \   000082   ED           MOV     A,R5
   \   000083   F0           MOVX    @DPTR,A
   2769              
   2770              // Application will free the attrCmd buffer
   2771              pInMsg->attrCmd = NULL;
   \   000084   8882         MOV     DPL,R0
   \   000086   8983         MOV     DPH,R1
   \   000088   E4           CLR     A
   \   000089   F0           MOVX    @DPTR,A
   \   00008A   A3           INC     DPTR
   \   00008B   F0           MOVX    @DPTR,A
   2772              
   2773              /* send message through task message */
   2774              osal_msg_send( zcl_RegisteredMsgTaskID, (uint8 *)pCmd );
   \   00008C                ; Setup parameters for call to function osal_msg_send
   \   00008C   90....       MOV     DPTR,#zcl_RegisteredMsgTaskID
   \   00008F   E0           MOVX    A,@DPTR
   \   000090   F9           MOV     R1,A
   \   000091   12....       LCALL   ??osal_msg_send?relay
   \   000094   02....       LJMP    ??zclSendMsg_1 & 0xFFFF
   2775            }
   2776            return ( TRUE );
   2777          }

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for zcl_RegisteredMsgTaskID>`:
   \   000000   FF           DB 255

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_Init?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_Init

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_event_loop?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_event_loop

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_registerPlugin?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerPlugin

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_registerAttrList?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerAttrList

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_registerClusterOptionList?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerClusterOptionList

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_registerValidateAttrData?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerValidateAttrData

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_registerForMsg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerForMsg

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_DeviceOperational?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_DeviceOperational

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendCommand?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendCommand

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendRead?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendRead

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendReadRsp?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendReadRsp

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendWriteRequest?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendWriteRequest

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendWriteRsp?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendWriteRsp

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendDefaultRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendDefaultRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclProcessMessageMSG?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclProcessMessageMSG

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseHdr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseHdr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclBuildHdr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclBuildHdr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclFindAttrRec?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclFindAttrRec

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclFindClusterOption?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclFindClusterOption

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclGetClusterOption?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetClusterOption

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclSetSecurityOption?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclSetSecurityOption

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclSerializeData?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclSerializeData

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclGetDataTypeLength?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetDataTypeLength

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclGetAttrDataLength?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetAttrDataLength

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclReadAttrData?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclReadAttrData

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclWriteAttrData?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclWriteAttrData

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInReadCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInReadCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInReadRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInReadRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInWriteCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInWriteCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInWriteRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInWriteRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInDefaultRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInDefaultRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclProcessInReadCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclProcessInReadCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclProcessInWriteCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclProcessInWriteCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclProcessInWriteUndividedCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclProcessInWriteUndividedCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclSendMsg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclSendMsg
   2778          
   2779          /*********************************************************************
   2780          *********************************************************************/

   Maximum stack usage in bytes:

     Function                      ISTACK PSTACK XSTACK
     --------                      ------ ------ ------
     zclBuildHdr                       1      0     54
     zclFindAttrRec                    1      0     62
     zclFindClusterOption              1      0     21
     zclGetAttrDataLength              2      0     42
       -> zclGetDataTypeLength         4      0      0
     zclGetClusterOption               0      0     52
       -> zclFindClusterOption         0      0     20
     zclGetDataTypeLength              2      0      0
     zclParseHdr                       1      0     12
       -> osal_memset                  0      0     24
     zclParseInDefaultRspCmd           1      0     10
       -> osal_mem_alloc               0      0     20
     zclParseInReadCmd                 1      0     12
       -> osal_mem_alloc               0      0     24
     zclParseInReadRspCmd              1      0     23
       -> zclGetAttrDataLength         0      0     40
       -> osal_mem_alloc               0      0     40
       -> zclGetAttrDataLength         0      0     40
       -> osal_memcpy                  0      0     46
     zclParseInWriteCmd                1      0     23
       -> zclGetAttrDataLength         0      0     40
       -> osal_mem_alloc               0      0     40
       -> zclGetAttrDataLength         0      0     40
       -> osal_memcpy                  0      0     46
     zclParseInWriteRspCmd             1      0     16
       -> osal_mem_alloc               0      0     32
     zclProcessInReadCmd               1      0     35
       -> osal_mem_alloc               0      0     60
       -> zclFindAttrRec               0      0     64
       -> zcl_SendReadRsp              0      0     70
       -> osal_mem_free                0      0     60
     zclProcessInWriteCmd              1      0     39
       -> osal_mem_alloc               0      0     68
       -> zclFindAttrRec               0      0     72
       -> zclWriteAttrData             0      0     68
       -> zcl_SendWriteRsp             0      0     78
       -> osal_mem_free                0      0     68
     zclProcessInWriteUndividedCmd     1      0     47
       -> osal_mem_alloc               0      0     84
       -> zclGetAttrDataLength         0      0     84
       -> zclFindAttrRec               0      0     88
       -> osal_mem_alloc               0      0     84
       -> osal_mem_free                0      0     84
       -> zclGetAttrDataLength         0      0     84
       -> zclFindAttrRec               0      0     88
       -> zclReadAttrData              0      0     84
       -> zclWriteAttrData             0      0     84
       -> zclGetAttrDataLength         0      0     84
       -> osal_memcpy                  0      0     90
       -> zclFindAttrRec               0      0     88
       -> osal_mem_free                0      0     84
       -> zcl_SendWriteRsp             0      0     94
       -> osal_mem_free                0      0     84
     zclProcessMessageMSG              1      0     41
       -> M160_On                      0      0     58
     zclReadAttrData                   0      0     56
       -> zclGetAttrDataLength         0      0     22
       -> osal_memcpy                  0      0     28
     zclSendMsg                        1      0     10
       -> osal_msg_allocate            0      0     20
       -> osal_msg_send                0      0     20
     zclSerializeData                  1      0     44
       -> osal_buffer_uint32           0      0     32
       -> osal_memcpy                  0      0     30
       -> osal_memcpy                  0      0     30
       -> osal_memcpy                  0      0     30
       -> osal_memcpy                  0      0     30
     zclSetSecurityOption              0      0     10
       -> zclFindClusterOption         0      0     20
     zclWriteAttrData                  0      0     60
       -> zclGetAttrDataLength         0      0     30
       -> osal_memcpy                  0      0     36
     zcl_DeviceOperational             1      0     65
       -> zclFindAttrRec               0      0     42
       -> zclReadAttrData              0      0     38
     zcl_Init                          2      0      0
     zcl_SendCommand                   1      0     90
       -> osal_memcpy                  0      0     90
       -> afFindEndPointDesc           0      0     84
       -> zclGetClusterOption          0      0     84
       -> osal_memset                  0      0     84
       -> zcl_DeviceOperational        0      0     88
       -> osal_mem_alloc               0      0     84
       -> zclBuildHdr                  0      0     90
       -> osal_memcpy                  0      0     90
       -> AF_DataRequest               0      0    102
       -> osal_mem_free                0      0     84
     zcl_SendDefaultRspCmd             1      0     34
       -> zcl_SendCommand              0      0     54
     zcl_SendRead                      1      0     38
       -> osal_mem_alloc               0      0     44
       -> zcl_SendCommand              0      0     66
       -> osal_mem_free                0      0     44
     zcl_SendReadRsp                   1      0     74
       -> zclGetAttrDataLength         0      0     56
       -> osal_mem_alloc               0      0     56
       -> zclSerializeData             0      0     56
       -> zclGetAttrDataLength         0      0     56
       -> zcl_SendCommand              0      0     78
       -> osal_mem_free                0      0     56
     zcl_SendWriteRequest              1      0     45
       -> zclGetAttrDataLength         0      0     56
       -> osal_mem_alloc               0      0     56
       -> zclSerializeData             0      0     56
       -> zclGetAttrDataLength         0      0     56
       -> zcl_SendCommand              0      0     78
       -> osal_mem_free                0      0     56
     zcl_SendWriteRsp                  1      0     80
       -> osal_mem_alloc               0      0     44
       -> zcl_SendCommand              0      0     66
       -> osal_mem_free                0      0     44
     zcl_event_loop                    0      0     12
       -> osal_msg_receive             0      0     24
       -> zclProcessMessageMSG         0      0     24
       -> osal_msg_deallocate          0      0     24
       -> osal_msg_receive             0      0     24
       -> osal_msg_send                0      0     24
     zcl_registerAttrList              1      0     12
       -> osal_mem_alloc               0      0     24
     zcl_registerClusterOptionList     1      0     12
       -> osal_mem_alloc               0      0     24
     zcl_registerForMsg                2      0      0
     zcl_registerPlugin                0      0     16
       -> osal_mem_alloc               0      0     28
     zcl_registerValidateAttrData      2      0      0


   Segment part sizes:

     Function/Label                             Bytes
     --------------                             -----
     zcl_TaskID                                    1
     global_entry                                  4
     global_recv_data                             30
     global_data_length                            1
     zcl_RegisteredMsgTaskID                       1
     zcl_ValidateAttrDataCB                        2
     zcl_SeqNum                                    1
     plugins                                       2
     attrList                                      2
     clusterOptionList                             2
     zcl_TransID                                   1
     zclCmdTable                                  56
     zcl_Init                                     31
     ?Subroutine84                                 7
     zcl_event_loop                              102
     ?Subroutine85                                 5
     zcl_registerPlugin                          131
     ?Subroutine86                                 5
     ?Subroutine30                                 5
     ??Subroutine101_0                             5
     ?Subroutine11                                 8
     ?Subroutine14                                 4
     ?Subroutine79                                 7
     ?Subroutine70                                 5
     ?Subroutine66                                 6
     ?Subroutine35                                 6
     zcl_registerAttrList                         59
     ?Subroutine50                                25
     ?Subroutine0                                 28
     ?Subroutine63                                 6
     zcl_registerClusterOptionList                59
     zcl_registerValidateAttrData                 16
     zcl_registerForMsg                           20
     zcl_DeviceOperational                       118
     ?Subroutine94                                 5
     zcl_SendCommand                             517
     ?Subroutine100                                4
     ??Subroutine102_0                             8
     ?Subroutine88                                 6
     ?Subroutine64                                 8
     ?Subroutine45                                 2
     ??Subroutine126_0                             1
     ??Subroutine127_0                             6
     zcl_SendRead                                218
     ?Subroutine96                                 2
     ??Subroutine103_0                             5
     ?Subroutine24                                 5
     ??Subroutine104_0                            11
     ?Subroutine91                                 5
     ?Subroutine74                                 6
     ?Subroutine53                                11
     ?Subroutine46                                 6
     ?Subroutine38                                10
     ?Subroutine95                                 4
     zcl_SendReadRsp                             251
     ?Subroutine28                                 4
     ??Subroutine105_0                            11
     ?Subroutine69                                 7
     ?Subroutine60                                 4
     ?Subroutine76                                 7
     ?Subroutine54                                21
     ?Subroutine47                                10
     ?Subroutine39                                16
     ?Subroutine68                                 5
     ?Subroutine81                                11
     ?Subroutine33                                 9
     ?Subroutine32                                13
     ?Subroutine19                                28
     ?Subroutine90                                 5
     ?Subroutine65                                20
     ?Subroutine2                                 21
     ?Subroutine1                                 25
     ?Subroutine26                                 5
     ?Subroutine82                                12
     zcl_SendWriteRequest                        222
     zcl_SendWriteRsp                            250
     zcl_SendDefaultRspCmd                       171
     zclProcessMessageMSG                        122
     ?Subroutine97                                 5
     ??Subroutine106_0                             3
     ??Subroutine107_0                             5
     ?Subroutine75                                 3
     ??Subroutine125_0                             5
     zclParseHdr                                 224
     ?Subroutine93                                 5
     ?Subroutine9                                  4
     ?Subroutine61                                 5
     ??Subroutine114_0                             4
     ?Subroutine62                                 9
     ?Subroutine83                                 8
     ?Subroutine5                                  6
     ??Subroutine115_0                             5
     ??Subroutine117_0                             7
     ?Subroutine80                                 4
     ??Subroutine122_0                             5
     ?Subroutine12                                 8
     zclBuildHdr                                 104
     ?Subroutine43                                11
     ?Subroutine16                                 7
     ??Subroutine108_0                             7
     ?Subroutine8                                  6
     ?Subroutine92                                 5
     zclFindAttrRec                              194
     zclFindClusterOption                        124
     ?Subroutine98                                 5
     zclGetClusterOption                          32
     zclSetSecurityOption                         45
     zclSerializeData                            289
     ?Subroutine15                                 5
     ?Subroutine40                                 4
     ??Subroutine118_0                             4
     zclGetDataTypeLength                        131
     zclGetAttrDataLength                         29
     zclReadAttrData                              75
     ?Subroutine25                                 2
     ??Subroutine109_0                             2
     ??Subroutine110_0                             5
     ??Subroutine112_0                             4
     zclWriteAttrData                            122
     ?Subroutine89                                 6
     ??Subroutine119_0                             4
     ?Subroutine71                                 9
     ?Subroutine41                                 6
     ?Subroutine31                                 6
     zclParseInReadCmd                           100
     ?Subroutine29                                25
     ?Subroutine49                                10
     zclParseInReadRspCmd                        126
     ?Subroutine99                                 9
     ?Subroutine20                                 7
     ??Subroutine113_0                            24
     ?Subroutine6                                  8
     ?Subroutine59                                14
     ?Subroutine57                                 5
     ?Subroutine87                                 6
     ?Subroutine52                                16
     ?Subroutine51                                26
     ?Subroutine48                                25
     ?Subroutine34                                25
     ?Subroutine22                                32
     ?Subroutine4                                 23
     ?Subroutine3                                 35
     ?Subroutine78                                 4
     ?Subroutine77                                15
     ?Subroutine73                                10
     ?Subroutine72                                 1
     ??Subroutine124_0                             9
     zclParseInWriteCmd                          103
     zclParseInWriteRspCmd                       125
     ?Subroutine56                                 4
     zclParseInDefaultRspCmd                      44
     ?Subroutine7                                  4
     ?Subroutine55                                 3
     zclProcessInReadCmd                         324
     ?Subroutine67                                 6
     ??Subroutine116_0                             8
     ?Subroutine44                                 1
     ??Subroutine120_0                            36
     ??Subroutine121_0                             1
     zclProcessInWriteCmd                        358
     ?Subroutine37                                 6
     ?Subroutine13                                 7
     ??Subroutine123_0                             6
     ?Subroutine23                                18
     ?Subroutine21                                37
     ?Subroutine10                                13
     ?Subroutine42                                 6
     ??Subroutine111_0                             3
     ?Subroutine18                                 6
     zclProcessInWriteUndividedCmd               683
     ?Subroutine58                                26
     ?Subroutine27                                 6
     ?Subroutine17                                10
     ?Subroutine36                                 7
     zclSendMsg                                  151
     ?<Initializer for zcl_RegisteredMsgTaskID>    1
     ??zcl_Init?relay                              6
     ??zcl_event_loop?relay                        6
     ??zcl_registerPlugin?relay                    6
     ??zcl_registerAttrList?relay                  6
     ??zcl_registerClusterOptionList?relay         6
     ??zcl_registerValidateAttrData?relay          6
     ??zcl_registerForMsg?relay                    6
     ??zcl_DeviceOperational?relay                 6
     ??zcl_SendCommand?relay                       6
     ??zcl_SendRead?relay                          6
     ??zcl_SendReadRsp?relay                       6
     ??zcl_SendWriteRequest?relay                  6
     ??zcl_SendWriteRsp?relay                      6
     ??zcl_SendDefaultRspCmd?relay                 6
     ??zclProcessMessageMSG?relay                  6
     ??zclParseHdr?relay                           6
     ??zclBuildHdr?relay                           6
     ??zclFindAttrRec?relay                        6
     ??zclFindClusterOption?relay                  6
     ??zclGetClusterOption?relay                   6
     ??zclSetSecurityOption?relay                  6
     ??zclSerializeData?relay                      6
     ??zclGetDataTypeLength?relay                  6
     ??zclGetAttrDataLength?relay                  6
     ??zclReadAttrData?relay                       6
     ??zclWriteAttrData?relay                      6
     ??zclParseInReadCmd?relay                     6
     ??zclParseInReadRspCmd?relay                  6
     ??zclParseInWriteCmd?relay                    6
     ??zclParseInWriteRspCmd?relay                 6
     ??zclParseInDefaultRspCmd?relay               6
     ??zclProcessInReadCmd?relay                   6
     ??zclProcessInWriteCmd?relay                  6
     ??zclProcessInWriteUndividedCmd?relay         6
     ??zclSendMsg?relay                            6

 
 6 863 bytes in segment BANKED_CODE
   210 bytes in segment BANK_RELAYS
    56 bytes in segment CODE_C
     1 byte  in segment XDATA_I
     1 byte  in segment XDATA_ID
    46 bytes in segment XDATA_Z
 
 7 130 bytes of CODE  memory
    47 bytes of XDATA memory

Errors: none
Warnings: none
