###############################################################################
#                                                                             #
# IAR C/C++ Compiler V7.51A/W32 for 8051                02/Sep/2013  17:24:50 #
# Copyright 2004-2009 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  D:\GitHub\z-stack\Sensor Network                   #
#                          Example\Components\stack\zcl\zcl.c                 #
#    Command line       =  -f "D:\GitHub\z-stack\Sensor Network               #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\Tools\CC2530DB\f8wEndev.c #
#                          fg" (-DCPU32MHZ -DROOT=__near_func -DBLINK_LEDS)   #
#                          -f "D:\GitHub\z-stack\Sensor Network               #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig. #
#                          cfg" (-DSECURE=0 -DZG_SECURE_DYNAMIC=0             #
#                          -DREFLECTOR -DDEFAULT_CHANLIST=0x00000800          #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116 "-DCONST=const __code"    #
#                          -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=TRUE      #
#                          -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100            #
#                          -DRESPONSE_POLL_RATE=100 -DREJOIN_POLL_RATE=440)   #
#                          -f "D:\GitHub\z-stack\Sensor Network               #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\Tools\CC2530DB\f8wZCL.cfg #
#                          " (-DZCL_READ -DZCL_WRITE -DZCL_BASIC              #
#                          -DZCL_IDENTIFY -DZCL_ON_OFF -DZCL_KEY_ESTABLISH    #
#                          -DZCL_LOAD_CONTROL -DZCL_SIMPLE_METERING           #
#                          -DZCL_PRICING) -DZCL_MESSAGE                       #
#                          "D:\GitHub\z-stack\Sensor Network                  #
#                          Example\Components\stack\zcl\zcl.c" -D             #
#                          NWK_AUTO_POLL -D ZTOOL_P1 -D MT_TASK -D            #
#                          MT_APP_FUNC -D MT_SYS_FUNC -D MT_ZDO_FUNC -D       #
#                          LCD_SUPPORTED=DEBUG -D xPOWER_SAVING -D            #
#                          End_Device -D HAL_KEYPAD -D xPA2591 -D MMN_UART    #
#                          -lC "D:\GitHub\z-stack\Sensor Network              #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\EndDeviceEB_M160\List\" -lA        #
#                          "D:\GitHub\z-stack\Sensor Network                  #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\EndDeviceEB_M160\List\"            #
#                          --diag_suppress Pe001,Pa010 -o                     #
#                          "D:\GitHub\z-stack\Sensor Network                  #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\EndDeviceEB_M160\Obj\" -e          #
#                          --require_prototypes --debug --core=plain          #
#                          --dptr=16,1 --data_model=large                     #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data_rom                  #
#                          --nr_virtual_regs 16 -I "D:\GitHub\z-stack\Sensor  #
#                          Network Example\Projects\zstack\Sensor Network     #
#                          Application\ZIGBEE Endpoint & Device\CC2530DB\"    #
#                          -I "D:\GitHub\z-stack\Sensor Network               #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\SOURCE\" -I                     #
#                          "D:\GitHub\z-stack\Sensor Network                  #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\SOURCE\" -I                  #
#                          "D:\GitHub\z-stack\Sensor Network                  #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\ZMAIN\TI2530DB\" -I       #
#                          "D:\GitHub\z-stack\Sensor Network                  #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\MT\" -I  #
#                          "D:\GitHub\z-stack\Sensor Network                  #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\INCL #
#                          UDE\" -I "D:\GitHub\z-stack\Sensor Network         #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\MODU #
#                          LE\" -I "D:\GitHub\z-stack\Sensor Network          #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\TARG #
#                          ET\CC2530EB\" -I "D:\GitHub\z-stack\Sensor         #
#                          Network Example\Projects\zstack\Sensor Network     #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\OSAL\MCU #
#                          \CCSOC\" -I "D:\GitHub\z-stack\Sensor Network      #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\OSAL\INC #
#                          LUDE\" -I "D:\GitHub\z-stack\Sensor Network        #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\AF #
#                          \" -I "D:\GitHub\z-stack\Sensor Network            #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\NW #
#                          K\" -I "D:\GitHub\z-stack\Sensor Network           #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SE #
#                          C\" -I "D:\GitHub\z-stack\Sensor Network           #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SA #
#                          PI\" -I "D:\GitHub\z-stack\Sensor Network          #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SY #
#                          S\" -I "D:\GitHub\z-stack\Sensor Network           #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\ZC #
#                          L\" -I "D:\GitHub\z-stack\Sensor Network           #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\ZD #
#                          O\" -I "D:\GitHub\z-stack\Sensor Network           #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\ZMAC\F8W #
#                          \" -I "D:\GitHub\z-stack\Sensor Network            #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\ZMAC\"   #
#                          -I "D:\GitHub\z-stack\Sensor Network               #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\SERVICES #
#                          \SADDR\" -I "D:\GitHub\z-stack\Sensor Network      #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\SERVICES #
#                          \SDATA\" -I "D:\GitHub\z-stack\Sensor Network      #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\INCL #
#                          UDE\" -I "D:\GitHub\z-stack\Sensor Network         #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\HIGH #
#                          _LEVEL\" -I "D:\GitHub\z-stack\Sensor Network      #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\LOW_ #
#                          LEVEL\srf04\" -I "D:\GitHub\z-stack\Sensor         #
#                          Network Example\Projects\zstack\Sensor Network     #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\LOW_ #
#                          LEVEL\srf04\SINGLE_CHIP\" -I "C:\Program Files     #
#                          (x86)\IAR Systems\Embedded Workbench               #
#                          5.3\8051\INC\" -I "C:\Program Files (x86)\IAR      #
#                          Systems\Embedded Workbench 5.3\8051\INC\CLIB\"     #
#                          -Ohz                                               #
#    List file          =  D:\GitHub\z-stack\Sensor Network                   #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\EndDeviceEB_M160\List\zcl.lst      #
#    Object file        =  D:\GitHub\z-stack\Sensor Network                   #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\EndDeviceEB_M160\Obj\zcl.r51       #
#                                                                             #
#                                                                             #
###############################################################################

D:\GitHub\z-stack\Sensor Network Example\Components\stack\zcl\zcl.c
      1          #include "ZComDef.h"
      2          #include "OSAL.h"
      3          #include "OSAL_Tasks.h"
      4          #include "AF.h"
      5          #include "ZDConfig.h"
      6          #include "zcl.h"
      7          #include "zcl_general.h"
      8          #include <string.h>
      9          #include <stdio.h>
     10          
     11          #if defined ( INTER_PAN )
     12            #include "stub_aps.h"
     13          #endif
     14          
     15          #include "hal_uart.h"
     16          #include "hal_timer.h"
     17          #include "hal_led.h"
     18          #if defined (LCD_SUPPORTED)
     19            #include "hal_lcd.h"
     20          #endif
     21          
     22          #if defined(M160)
     23            #include "hal_sensor.h"
     24          #endif 
     25          
     26          /* MT */
     27          #include "MT_UART.h"
     28          #include "MT.h"
     29          
     30          /*** Frame Control ***/
     31          #define zcl_FCType( a )               ( (a) & ZCL_FRAME_CONTROL_TYPE )
     32          #define zcl_FCManuSpecific( a )       ( (a) & ZCL_FRAME_CONTROL_MANU_SPECIFIC )
     33          #define zcl_FCDirection( a )          ( (a) & ZCL_FRAME_CONTROL_DIRECTION )
     34          #define zcl_FCDisableDefaultRsp( a )  ( (a) & ZCL_FRAME_CONTROL_DISABLE_DEFAULT_RSP )
     35          
     36          /*** Attribute Access Control ***/
     37          #define zcl_AccessCtrlRead( a )       ( (a) & ACCESS_CONTROL_READ )
     38          #define zcl_AccessCtrlWrite( a )      ( (a) & ACCESS_CONTROL_WRITE )
     39          #define zcl_AccessCtrlCmd( a )        ( (a) & ACCESS_CONTROL_CMD )
     40          
     41          #define zclParseCmd( a, b )           zclCmdTable[(a)].pfnParseInProfile( (b) )
     42          #define zclProcessCmd( a, b )         zclCmdTable[(a)].pfnProcessInProfile( (b) )
     43          
     44          #define zcl_DefaultRspCmd( zclHdr )   ( zcl_ProfileCmd( (zclHdr).fc.type )     && \
     45                                                  (zclHdr).fc.manuSpecific == 0          && \
     46                                                  (zclHdr).commandID == ZCL_CMD_DEFAULT_RSP )
     47          
     48          // Commands that have corresponding responses
     49          #define CMD_HAS_RSP( cmd )            ( (cmd) == ZCL_CMD_READ            || \
     50                                                  (cmd) == ZCL_CMD_WRITE           || \
     51                                                  (cmd) == ZCL_CMD_WRITE_UNDIVIDED || \
     52                                                  (cmd) == ZCL_CMD_CONFIG_REPORT   || \
     53                                                  (cmd) == ZCL_CMD_READ_REPORT_CFG || \
     54                                                  (cmd) == ZCL_CMD_DISCOVER        || \
     55                                                  (cmd) == ZCL_CMD_DEFAULT_RSP ) // exception
     56          
     57          typedef struct zclLibPlugin
     58          {
     59            struct zclLibPlugin *next;
     60            uint16              startClusterID;    // starting cluster ID
     61            uint16              endClusterID;      // ending cluster ID
     62            zclInHdlr_t         pfnIncomingHdlr;    // function to handle incoming message
     63          } zclLibPlugin_t;
     64          
     65          // Attribute record list item
     66          typedef struct zclAttrRecsList
     67          {
     68            struct zclAttrRecsList *next;
     69            uint8                  endpoint;      // Used to link it into the endpoint descriptor
     70            uint8                  numAttributes; // Number of the following records
     71            CONST zclAttrRec_t     *attrs;        // attribute records
     72          } zclAttrRecsList;
     73          
     74          // Cluster option list item
     75          typedef struct zclClusterOptionList
     76          {
     77            struct zclClusterOptionList *next;
     78            uint8                       endpoint;   // Used to link it into the endpoint descriptor
     79            uint8                       numOptions; // Number of the following records
     80            zclOptionRec_t              *options;   // option records
     81          } zclClusterOptionList;
     82          
     83          typedef void *(*zclParseInProfileCmd_t)( zclParseCmd_t *pCmd );
     84          typedef uint8 (*zclProcessInProfileCmd_t)( zclIncoming_t *pInMsg );
     85          
     86          typedef struct
     87          {
     88            zclParseInProfileCmd_t   pfnParseInProfile;
     89            zclProcessInProfileCmd_t pfnProcessInProfile;
     90          } zclCmdItems_t;
     91          
     92          uint8 zcl_TaskID;
     93          
     94          // The task Id of the Application where the unprocessed Foundation
     95          // Command/Response messages will be sent to.
     96          uint8 zcl_RegisteredMsgTaskID = TASK_NO_TASK;
     97          
     98          // The Application should register its attribute data validation function
     99          zclValidateAttrData_t zcl_ValidateAttrDataCB = NULL;
    100          
    101          // ZCL Sequence number
    102          uint8 zcl_SeqNum = 0x00;
    103          
    104          static zclLibPlugin_t *plugins;
    105          static zclAttrRecsList *attrList;
    106          static zclClusterOptionList *clusterOptionList;
    107          static uint8 zcl_TransID = 0;  // This is the unique message ID (counter)
    108          
    109          void zclProcessMessageMSG( afIncomingMSGPacket_t *pkt );  // Not static for ZNP build.
    110          void zclZigbeeReceiverMSG(afIncomingMSGPacket_t *msg);
    111          
    112          static uint8 *zclBuildHdr( zclFrameHdr_t *hdr, uint8 *pData );
    113          static uint8 zclCalcHdrSize( zclFrameHdr_t *hdr );
    114          static zclLibPlugin_t *zclFindPlugin( uint16 clusterID, uint16 profileID );
    115          static zclOptionRec_t *zclFindClusterOption( uint8 endpoint, uint16 clusterID );
    116          static uint8 zclGetClusterOption( uint8 endpoint, uint16 clusterID );
    117          static void zclSetSecurityOption( uint8 endpoint, uint16 clusterID, uint8 enable );
    118          
    119          static uint8 zcl_DeviceOperational( uint8 srcEP, uint16 clusterID, uint8 frameType, uint8 cmd, uint16 profileID );
    120          
    121          #if defined(ZCL_READ) || defined(ZCL_WRITE) || defined(ZCL_REPORT)
    122            static void zclSerializeData( uint8 dataType, void *attrData, uint8 *buf );
    123          #endif // ZCL_READ || ZCL_WRITE || ZCL_REPORT
    124          
    125          #ifdef ZCL_READ
    126            static void *zclParseInReadRspCmd( zclParseCmd_t *pCmd );
    127            static uint8 zclProcessInReadCmd( zclIncoming_t *pInMsg );
    128          #endif // ZCL_READ
    129          
    130          #ifdef ZCL_WRITE
    131            static uint8 zclWriteAttrData( zclAttrRec_t *pAttr, zclWriteRec_t *pWriteRec );
    132            static void *zclParseInWriteRspCmd( zclParseCmd_t *pCmd );
    133            static uint8 zclProcessInWriteCmd( zclIncoming_t *pInMsg );
    134            static uint8 zclProcessInWriteUndividedCmd( zclIncoming_t *pInMsg );
    135          #endif // ZCL_WRITE
    136          
    137          #ifdef ZCL_REPORT
    138            static void *zclParseInConfigReportRspCmd( zclParseCmd_t *pCmd );
    139            static void *zclParseInReadReportCfgRspCmd( zclParseCmd_t *pCmd );
    140          #endif // ZCL_REPORT
    141          
    142          static void *zclParseInDefaultRspCmd( zclParseCmd_t *pCmd );
    143          
    144          #ifdef ZCL_DISCOVER
    145            static uint8 zclFindNextAttrRec( uint8 endpoint, uint16 clusterID, uint16 *attrId, zclAttrRec_t *pAttr );
    146            static void *zclParseInDiscRspCmd( zclParseCmd_t *pCmd );
    147            static uint8 zclProcessInDiscCmd( zclIncoming_t *pInMsg );
    148          #endif // ZCL_DISCOVER
    149          
    150          static uint8 zclSendMsg( zclIncoming_t *pInMsg );
    151          
    152          /*********************************************************************
    153           * Parse Profile Command Function Table
    154           */
    155          static CONST zclCmdItems_t zclCmdTable[] =
    156          {
    157          #ifdef ZCL_READ
    158            /* ZCL_CMD_READ */                { zclParseInReadCmd,             zclProcessInReadCmd             },
    159            /* ZCL_CMD_READ_RSP */            { zclParseInReadRspCmd,          zclSendMsg                      },
    160          #else
    161            /* ZCL_CMD_READ */                { NULL,                          NULL                            },
    162            /* ZCL_CMD_READ_RSP */            { NULL,                          NULL                            },
    163          #endif // ZCL_READ
    164          
    165          #ifdef ZCL_WRITE
    166            /* ZCL_CMD_WRITE */               { zclParseInWriteCmd,            zclProcessInWriteCmd            },
    167            /* ZCL_CMD_WRITE_UNDIVIDED */     { zclParseInWriteCmd,            zclProcessInWriteUndividedCmd   },
    168            /* ZCL_CMD_WRITE_RSP */           { zclParseInWriteRspCmd,         zclSendMsg                      },
    169            /* ZCL_CMD_WRITE_NO_RSP */        { zclParseInWriteCmd,            zclProcessInWriteCmd            },
    170          #else
    171            /* ZCL_CMD_WRITE */               { NULL,                          NULL                            },
    172            /* ZCL_CMD_WRITE_UNDIVIDED */     { NULL,                          NULL                            },
    173            /* ZCL_CMD_WRITE_RSP */           { NULL,                          NULL                            },
    174            /* ZCL_CMD_WRITE_NO_RSP */        { NULL,                          NULL                            },
    175          #endif // ZCL_WRITE
    176          
    177          #ifdef ZCL_REPORT
    178            /* ZCL_CMD_CONFIG_REPORT */       { zclParseInConfigReportCmd,     zclSendMsg                      },
    179            /* ZCL_CMD_CONFIG_REPORT_RSP */   { zclParseInConfigReportRspCmd,  zclSendMsg                      },
    180            /* ZCL_CMD_READ_REPORT_CFG */     { zclParseInReadReportCfgCmd,    zclSendMsg                      },
    181            /* ZCL_CMD_READ_REPORT_CFG_RSP */ { zclParseInReadReportCfgRspCmd, zclSendMsg                      },
    182            /* ZCL_CMD_REPORT */              { zclParseInReportCmd,           zclSendMsg                      },
    183          #else
    184            /* ZCL_CMD_CONFIG_REPORT */       { NULL,                          NULL                            },
    185            /* ZCL_CMD_CONFIG_REPORT_RSP */   { NULL,                          NULL                            },
    186            /* ZCL_CMD_READ_REPORT_CFG */     { NULL,                          NULL                            },
    187            /* ZCL_CMD_READ_REPORT_CFG_RSP */ { NULL,                          NULL                            },
    188            /* ZCL_CMD_REPORT */              { NULL,                          NULL                            },
    189          #endif // ZCL_REPORT
    190          
    191            /* ZCL_CMD_DEFAULT_RSP */         { zclParseInDefaultRspCmd,       zclSendMsg                      },
    192            
    193          #ifdef ZCL_DISCOVER  
    194            /* ZCL_CMD_DISCOVER */            { zclParseInDiscCmd,             zclProcessInDiscCmd             },
    195            /* ZCL_CMD_DISCOVER_RSP */        { zclParseInDiscRspCmd,          zclSendMsg                      }
    196          #else
    197            /* ZCL_CMD_DISCOVER */            { NULL,                          NULL                            },
    198            /* ZCL_CMD_DISCOVER_RSP */        { NULL,                          NULL                            }
    199          #endif // ZCL_DISCOVER
    200          };
    201          
    202          void zcl_Init( uint8 task_id )
    203          {
    204            zcl_TaskID = task_id;
    205          
    206            plugins = (zclLibPlugin_t  *)NULL;
    207            attrList = (zclAttrRecsList *)NULL;
    208            clusterOptionList = (zclClusterOptionList *)NULL;
    209          }
    210          
    211          uint16 zcl_event_loop( uint8 task_id, uint16 events )
    212          {
    213            uint8 *msgPtr;
    214            (void)task_id;  // Intentionally unreferenced parameter
    215            
    216            if ( events & SYS_EVENT_MSG )
    217            {
    218              msgPtr = osal_msg_receive( zcl_TaskID );
    219              while ( msgPtr != NULL )
    220              {
    221                uint8 dealloc = TRUE;
    222                
    223                if ( *msgPtr == AF_INCOMING_MSG_CMD )
    224                {
    225                  zclProcessMessageMSG( (afIncomingMSGPacket_t *)msgPtr );
    226                }
    227                else if ( zcl_RegisteredMsgTaskID != TASK_NO_TASK )
    228                {
    229                  osal_msg_send( zcl_RegisteredMsgTaskID, msgPtr ); // send it to another task to process.
    230                  dealloc = FALSE;
    231                }
    232                if ( dealloc ) // Release the memory
    233                {
    234                  osal_msg_deallocate( msgPtr );
    235                }
    236                msgPtr = osal_msg_receive( zcl_TaskID ); // Next
    237              } 
    238              return (events ^ SYS_EVENT_MSG);// return unprocessed events
    239            }
    240            return 0; // Discard unknown events
    241          }
    242          
    243          ZStatus_t zcl_registerPlugin( uint16 startClusterID,
    244                    uint16 endClusterID, zclInHdlr_t pfnIncomingHdlr )
    245          {
    246            zclLibPlugin_t *pNewItem;
    247            zclLibPlugin_t *pLoop;
    248          
    249            // Fill in the new profile list
    250            pNewItem = osal_mem_alloc( sizeof( zclLibPlugin_t ) );
    251            if ( pNewItem == NULL )
    252              return (ZMemError);
    253          
    254            // Fill in the plugin record.
    255            pNewItem->next = (zclLibPlugin_t *)NULL;
    256            pNewItem->startClusterID = startClusterID;
    257            pNewItem->endClusterID = endClusterID;
    258            pNewItem->pfnIncomingHdlr = pfnIncomingHdlr;
    259          
    260            if (  plugins == NULL ) // Find spot in list
    261            {
    262              plugins = pNewItem;
    263            }
    264            else
    265            {
    266              // Look for end of list
    267              pLoop = plugins;
    268              while ( pLoop->next != NULL )
    269                pLoop = pLoop->next;
    270          
    271              pLoop->next = pNewItem; // Put new item at end of list
    272            }
    273            return ( ZSuccess );
    274          }
    275          
    276          ZStatus_t zcl_registerAttrList( uint8 endpoint, uint8 numAttr, CONST zclAttrRec_t newAttrList[] )
    277          {
    278            zclAttrRecsList *pNewItem;
    279            zclAttrRecsList *pLoop;
    280          
    281            pNewItem = osal_mem_alloc( sizeof( zclAttrRecsList ) ); // Fill in the new profile list
    282            if ( pNewItem == NULL )
    283              return (ZMemError);
    284          
    285            pNewItem->next = (zclAttrRecsList *)NULL;
    286            pNewItem->endpoint = endpoint;
    287            pNewItem->numAttributes = numAttr;
    288            pNewItem->attrs = newAttrList;
    289          
    290            if ( attrList == NULL ) // Find spot in list
    291            {
    292              attrList = pNewItem;
    293            }
    294            else
    295            {
    296              pLoop = attrList; // Look for end of list
    297              while ( pLoop->next != NULL )
    298                pLoop = pLoop->next;
    299          
    300              pLoop->next = pNewItem; // Put new item at end of list
    301            }
    302            return ( ZSuccess );
    303          }
    304          
    305          ZStatus_t zcl_registerClusterOptionList( uint8 endpoint, uint8 numOption, zclOptionRec_t optionList[] )
    306          {
    307            zclClusterOptionList *pNewItem;
    308            zclClusterOptionList *pLoop;
    309          
    310            // Fill in the new profile list
    311            pNewItem = osal_mem_alloc( sizeof( zclClusterOptionList ) );
    312            if ( pNewItem == NULL )
    313              return (ZMemError);
    314          
    315            pNewItem->next = (zclClusterOptionList *)NULL;
    316            pNewItem->endpoint = endpoint;
    317            pNewItem->numOptions = numOption;
    318            pNewItem->options = optionList;
    319          
    320            // Find spot in list
    321            if ( clusterOptionList == NULL )
    322            {
    323              clusterOptionList = pNewItem;
    324            }
    325            else
    326            {
    327              // Look for end of list
    328              pLoop = clusterOptionList;
    329              while ( pLoop->next != NULL )
    330                pLoop = pLoop->next;
    331          
    332              // Put new item at end of list
    333              pLoop->next = pNewItem;
    334            }
    335          
    336            return ( ZSuccess );
    337          }
    338          
    339          ZStatus_t zcl_registerValidateAttrData( zclValidateAttrData_t pfnValidateAttrData )
    340          {
    341            zcl_ValidateAttrDataCB = pfnValidateAttrData;
    342            
    343            return ( ZSuccess );
    344          }
    345          
    346          uint8 zcl_registerForMsg( uint8 taskId )
    347          {
    348            // Allow only the first task
    349            if ( zcl_RegisteredMsgTaskID == TASK_NO_TASK )
    350            {
    351              zcl_RegisteredMsgTaskID = taskId;  
    352              return ( true );
    353            }
    354            return ( false );
    355          }
    356          
    357          static uint8 zcl_DeviceOperational( uint8 srcEP, uint16 clusterID, 
    358                                              uint8 frameType, uint8 cmd, uint16 profileID )
    359          {
    360            zclAttrRec_t attrRec;
    361            uint8 deviceEnabled = DEVICE_ENABLED; // default value
    362            
    363            (void)profileID;  // Intentionally unreferenced parameter
    364            
    365            // If the device is Disabled (DeviceEnabled attribute is set to Disabled), it 
    366            // cannot send or respond to application level commands, other than commands
    367            // to read or write attributes. Note that the Identify cluster cannot be 
    368            // disabled, and remains functional regardless of this setting.
    369            if ( zcl_ProfileCmd( frameType ) && cmd <= ZCL_CMD_WRITE_NO_RSP )
    370              return ( TRUE );
    371            
    372            if ( clusterID == ZCL_CLUSTER_ID_GEN_IDENTIFY )
    373              return ( TRUE );
    374            
    375            // Is device enabled?
    376            if ( zclFindAttrRec( srcEP, ZCL_CLUSTER_ID_GEN_BASIC, ATTRID_BASIC_DEVICE_ENABLED, &attrRec ) )
    377              zclReadAttrData( &deviceEnabled, &attrRec );
    378            
    379            return ( deviceEnabled == DEVICE_ENABLED ? TRUE : FALSE );
    380          }
    381          
    382          ZStatus_t zcl_SendCommand( uint8 srcEP, afAddrType_t *destAddr,
    383                                     uint16 clusterID, uint8 cmd, uint8 specific, uint8 direction,
    384                                     uint8 disableDefaultRsp, uint16 manuCode, uint8 seqNum,
    385                                     uint16 cmdFormatLen, uint8 *cmdFormat )
    386          {
    387            endPointDesc_t *epDesc;
    388            zclFrameHdr_t hdr;
    389            uint8 *msgBuf;
    390            uint16 msgLen;
    391            uint8 *pBuf;
    392            afAddrType_t dstAddr;
    393            uint8 options;
    394            ZStatus_t status;
    395          
    396            osal_memcpy( &dstAddr, destAddr, sizeof ( afAddrType_t ) );
    397          
    398            epDesc = afFindEndPointDesc( srcEP );
    399            if ( epDesc == NULL )
    400              return ( ZInvalidParameter ); // EMBEDDED RETURN
    401          
    402            if ( clusterID == ZCL_INVALID_CLUSTER_ID )
    403              return ( ZInvalidParameter ); // EMBEDDED RETURN
    404          
    405          #if defined ( INTER_PAN )
    406            if ( StubAPS_InterPan( destAddr->panId, destAddr->endPoint ) )
    407              options = AF_TX_OPTIONS_NONE;
    408            else
    409          #endif
    410              options = zclGetClusterOption( srcEP, clusterID );
    411            
    412            osal_memset( &hdr, 0, sizeof( zclFrameHdr_t ) );
    413          
    414            // Not Profile wide command (like READ, WRITE)
    415            if ( specific )
    416              hdr.fc.type = ZCL_FRAME_TYPE_SPECIFIC_CMD;
    417            else
    418              hdr.fc.type = ZCL_FRAME_TYPE_PROFILE_CMD;
    419          
    420            if ((epDesc->simpleDesc == NULL) ||
    421                (zcl_DeviceOperational(srcEP, clusterID, hdr.fc.type, cmd, epDesc->simpleDesc->AppProfId) == FALSE))
    422              return ( ZFailure ); // EMBEDDED RETURN
    423            
    424            if ( manuCode != 0 ) // Fill in the Maufacturer Code
    425            {
    426              hdr.fc.manuSpecific = 1;
    427              hdr.manuCode = manuCode;
    428            }
    429            
    430            if ( direction ) // Set the Command Direction
    431              hdr.fc.direction = ZCL_FRAME_SERVER_CLIENT_DIR;
    432            else
    433              hdr.fc.direction = ZCL_FRAME_CLIENT_SERVER_DIR;
    434          
    435            if ( disableDefaultRsp ) // Set the Disable Default Response field
    436              hdr.fc.disableDefaultRsp = 1;
    437            else
    438              hdr.fc.disableDefaultRsp = 0;
    439                               
    440            hdr.transSeqNum = seqNum; // Fill in the Transaction Sequence Number
    441            
    442            hdr.commandID = cmd; // Fill in the command
    443            
    444            msgLen = zclCalcHdrSize( &hdr ); // calculate the needed buffer size
    445            msgLen += cmdFormatLen;
    446          
    447            msgBuf = osal_mem_alloc( msgLen ); // Allocate the buffer needed
    448            if ( msgBuf != NULL )
    449            {
    450              pBuf = zclBuildHdr( &hdr, msgBuf ); // Fill in the ZCL Header
    451          
    452              osal_memcpy( pBuf, cmdFormat, cmdFormatLen ); // Fill in the command frame
    453          
    454              status = AF_DataRequest( &dstAddr, epDesc, clusterID, msgLen, msgBuf, 
    455                                       &zcl_TransID, options, AF_DEFAULT_RADIUS );  
    456              osal_mem_free ( msgBuf );
    457            }
    458            else
    459              status = ZMemError;
    460          
    461            return ( status );
    462          }
    463          
    464          #ifdef ZCL_READ
    465          ZStatus_t zcl_SendRead( uint8 srcEP, afAddrType_t *dstAddr,
    466                                  uint16 clusterID, zclReadCmd_t *readCmd,
    467                                  uint8 direction, uint8 disableDefaultRsp, uint8 seqNum)
    468          {
    469            uint8 dataLen;
    470            uint8 *buf;
    471            uint8 *pBuf;
    472            ZStatus_t status;
    473          
    474            dataLen = readCmd->numAttr * 2; // Attribute ID
    475          
    476            buf = osal_mem_alloc( dataLen );
    477            if ( buf != NULL )
    478            {
    479              uint8 i;
    480          
    481              pBuf = buf; // Load the buffer - serially
    482              for (i = 0; i < readCmd->numAttr; i++)
    483              {
    484                *pBuf++ = LO_UINT16( readCmd->attrID[i] );
    485                *pBuf++ = HI_UINT16( readCmd->attrID[i] );
    486              }
    487              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ, FALSE,
    488                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );  
    489              osal_mem_free( buf );
    490            }
    491            else
    492              status = ZMemError;
    493          
    494            return ( status );
    495          }
    496          
    497          ZStatus_t zcl_SendReadRsp( uint8 srcEP, afAddrType_t *dstAddr,
    498                                     uint16 clusterID, zclReadRspCmd_t *readRspCmd,
    499                                     uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
    500          {
    501            uint8 *buf;
    502            uint8 *pBuf;
    503            zclReadRspStatus_t *statusRec;
    504            uint8 len = 0;
    505            uint8 i;
    506            ZStatus_t status;
    507            
    508            // calculate the size of the command
    509            for ( i = 0; i < readRspCmd->numAttr; i++ )
    510            {
    511              statusRec = &(readRspCmd->attrList[i]);
    512              
    513              len += 2 + 1; // Attribute ID + Status
    514          
    515              if ( statusRec->status == ZCL_STATUS_SUCCESS )
    516              {
    517                len++; // Attribute Data Type
    518                len += zclGetAttrDataLength( statusRec->dataType, statusRec->data); // Attribute Data
    519              }
    520            }
    521          
    522            buf = osal_mem_alloc( len );
    523            if ( buf != NULL )
    524            {
    525              // Load the buffer - serially
    526              pBuf = buf;
    527              for ( i = 0; i < readRspCmd->numAttr; i++ )
    528              {
    529                statusRec = &(readRspCmd->attrList[i]);
    530                
    531                *pBuf++ = LO_UINT16( statusRec->attrID );
    532                *pBuf++ = HI_UINT16( statusRec->attrID );
    533                *pBuf++ = statusRec->status;
    534          
    535                if ( statusRec->status == ZCL_STATUS_SUCCESS )
    536                {
    537                  *pBuf++ = statusRec->dataType;
    538                  zclSerializeData( statusRec->dataType, statusRec->data, pBuf );
    539                  
    540                  // move pass attribute data
    541                  pBuf += zclGetAttrDataLength( statusRec->dataType, statusRec->data );
    542                }
    543              } // for loop
    544          
    545              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ_RSP, FALSE, 
    546                                        direction, disableDefaultRsp, 0, seqNum, len, buf );
    547              osal_mem_free( buf );
    548            }
    549            else
    550              status = ZMemError;
    551          
    552            return ( status );
    553          }
    554          #endif // ZCL_READ
    555          
    556          #ifdef ZCL_WRITE
    557          ZStatus_t zcl_SendWriteRequest( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID, 
    558                                          zclWriteCmd_t *writeCmd, uint8 cmd, uint8 direction, 
    559                                          uint8 disableDefaultRsp, uint8 seqNum )
    560          {
    561            uint8 *buf;
    562            uint8 *pBuf;
    563            zclWriteRec_t *statusRec;
    564            uint8 attrDataLen;
    565            uint8 dataLen = 0;
    566            uint8 i;
    567            ZStatus_t status;
    568            
    569            for ( i = 0; i < writeCmd->numAttr; i++ )
    570            {
    571              statusRec = &(writeCmd->attrList[i]);
    572              
    573              attrDataLen = zclGetAttrDataLength( statusRec->dataType, statusRec->attrData );
    574              dataLen += 2 + 1 + attrDataLen; // Attribute ID + Attribute Type + Attribute Data
    575            }
    576          
    577            buf = osal_mem_alloc( dataLen );
    578            if ( buf != NULL )
    579            {
    580              // Load the buffer - serially
    581              pBuf = buf;
    582              for ( i = 0; i < writeCmd->numAttr; i++ )
    583              { 
    584                statusRec = &(writeCmd->attrList[i]);
    585                
    586                *pBuf++ = LO_UINT16( statusRec->attrID );
    587                *pBuf++ = HI_UINT16( statusRec->attrID );
    588                *pBuf++ = statusRec->dataType;
    589                
    590                zclSerializeData( statusRec->dataType, statusRec->attrData, pBuf );
    591                
    592                attrDataLen = zclGetAttrDataLength( statusRec->dataType, statusRec->attrData );
    593                pBuf += attrDataLen; // move pass attribute data
    594              }
    595          
    596              status = zcl_SendCommand( srcEP, dstAddr, clusterID, cmd, FALSE, 
    597                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
    598              osal_mem_free( buf );
    599            }
    600            else
    601              status = ZMemError;
    602          
    603            return ( status);
    604          }
    605          
    606          ZStatus_t zcl_SendWriteRsp( uint8 srcEP, afAddrType_t *dstAddr,
    607                                      uint16 clusterID, zclWriteRspCmd_t *writeRspCmd,
    608                                      uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
    609          {
    610            uint8 dataLen;
    611            uint8 *buf;
    612            uint8 *pBuf;
    613            uint8 i;
    614            ZStatus_t status;
    615            
    616            dataLen = writeRspCmd->numAttr * ( 1 + 2 ); // status + attribute id
    617          
    618            buf = osal_mem_alloc( dataLen );
    619            if ( buf != NULL )
    620            {
    621              // Load the buffer - serially
    622              pBuf = buf;
    623              for ( i = 0; i < writeRspCmd->numAttr; i++ )
    624              { 
    625                *pBuf++ = writeRspCmd->attrList[i].status;
    626                *pBuf++ = LO_UINT16( writeRspCmd->attrList[i].attrID );
    627                *pBuf++ = HI_UINT16( writeRspCmd->attrList[i].attrID );
    628              }
    629              
    630              // If there's only a single status record and its status field is set to 
    631              // SUCCESS then omit the attribute ID field.
    632              if ( writeRspCmd->numAttr == 1 && writeRspCmd->attrList[0].status == ZCL_STATUS_SUCCESS )
    633                dataLen = 1;
    634                
    635              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_WRITE_RSP, FALSE,
    636                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
    637              osal_mem_free( buf );
    638            }
    639            else
    640              status = ZMemError;
    641          
    642            return ( status );
    643          }
    644          #endif // ZCL_WRITE
    645          
    646          #ifdef ZCL_REPORT
    647          ZStatus_t zcl_SendConfigReportCmd( uint8 srcEP, afAddrType_t *dstAddr,
    648                                    uint16 clusterID, zclCfgReportCmd_t *cfgReportCmd,
    649                                    uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
    650          {
    651            uint8 *buf;
    652            uint8 *pBuf;
    653            uint8 dataLen = 0;
    654            zclCfgReportRec_t *reportRec;
    655            uint8 reportChangeLen; // length of Reportable Change field
    656            uint8 i;
    657            ZStatus_t status;
    658            
    659            // Find out the data length
    660            for ( i = 0; i < cfgReportCmd->numAttr; i++ )
    661            {
    662              reportRec = &(cfgReportCmd->attrList[i]);
    663              
    664              dataLen += 1 + 2; // Direction + Attribute ID
    665              reportChangeLen = 0;
    666              
    667              if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
    668              {
    669                dataLen += 1 + 2 + 2; // Data Type + Min + Max Reporting Intervals
    670                
    671                // Find out the size of the Reportable Change field (for Analog data types)
    672                if ( zclAnalogDataType( reportRec->dataType ) )
    673                {
    674                  reportChangeLen = zclGetDataTypeLength( reportRec->dataType );
    675                  dataLen += reportChangeLen;
    676                }
    677              }
    678              else
    679              {
    680                dataLen += 2; // Timeout Period
    681              }
    682            }
    683            
    684            buf = osal_mem_alloc( dataLen );
    685            if ( buf != NULL )
    686            {
    687              // Load the buffer - serially
    688              pBuf = buf;
    689              for ( i = 0; i < cfgReportCmd->numAttr; i++ )
    690              {
    691                reportRec = &(cfgReportCmd->attrList[i]);
    692                
    693                *pBuf++ = reportRec->direction;
    694                *pBuf++ = LO_UINT16( reportRec->attrID );
    695                *pBuf++ = HI_UINT16( reportRec->attrID );
    696                
    697                if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
    698                {
    699                  *pBuf++ = reportRec->dataType;
    700                  *pBuf++ = LO_UINT16( reportRec->minReportInt );
    701                  *pBuf++ = HI_UINT16( reportRec->minReportInt );
    702                  *pBuf++ = LO_UINT16( reportRec->maxReportInt );
    703                  *pBuf++ = HI_UINT16( reportRec->maxReportInt );
    704          
    705                  if ( zclAnalogDataType( reportRec->dataType ) )
    706                  {
    707                    zclSerializeData( reportRec->dataType, reportRec->reportableChange, pBuf );
    708                    reportChangeLen = zclGetDataTypeLength( reportRec->dataType );
    709                    pBuf += reportChangeLen;
    710                  }
    711                }
    712                else
    713                {
    714                  *pBuf++ = LO_UINT16( reportRec->timeoutPeriod );
    715                  *pBuf++ = HI_UINT16( reportRec->timeoutPeriod );
    716                } 
    717              } // for loop
    718              
    719              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_CONFIG_REPORT, FALSE, 
    720                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
    721              osal_mem_free( buf );
    722            }
    723            else
    724              status = ZMemError;
    725            
    726            return ( status );
    727          }
    728          
    729          ZStatus_t zcl_SendConfigReportRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
    730                              uint16 clusterID, zclCfgReportRspCmd_t *cfgReportRspCmd,
    731                              uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
    732          {
    733            uint8 dataLen;
    734            uint8 *buf;
    735            uint8 *pBuf;
    736            uint8 i;
    737            ZStatus_t status;
    738            
    739            // Atrribute list (Status, Direction and Attribute ID)
    740            dataLen = cfgReportRspCmd->numAttr * ( 1 + 1 + 2 ); 
    741            
    742            buf = osal_mem_alloc( dataLen );
    743            if ( buf != NULL )
    744            {
    745              // Load the buffer - serially
    746              pBuf = buf; 
    747              for ( i = 0; i < cfgReportRspCmd->numAttr; i++ )
    748              {
    749                *pBuf++ = cfgReportRspCmd->attrList[i].status;
    750                *pBuf++ = cfgReportRspCmd->attrList[i].direction;
    751                *pBuf++ = LO_UINT16( cfgReportRspCmd->attrList[i].attrID );
    752                *pBuf++ = HI_UINT16( cfgReportRspCmd->attrList[i].attrID );
    753              }
    754              
    755              // If there's only a single status record and its status field is set to 
    756              // SUCCESS then omit the attribute ID field.
    757              if ( cfgReportRspCmd->numAttr == 1 && cfgReportRspCmd->attrList[0].status == ZCL_STATUS_SUCCESS )
    758                dataLen = 1;
    759              
    760              status = zcl_SendCommand( srcEP, dstAddr, clusterID,
    761                                        ZCL_CMD_CONFIG_REPORT_RSP, FALSE, direction, 
    762                                        disableDefaultRsp, 0, seqNum, dataLen, buf );
    763              osal_mem_free( buf );
    764            }
    765            else
    766              status = ZMemError;
    767            
    768            return ( status );
    769          }
    770          
    771          ZStatus_t zcl_SendReadReportCfgCmd( uint8 srcEP, afAddrType_t *dstAddr,
    772                            uint16 clusterID, zclReadReportCfgCmd_t *readReportCfgCmd,
    773                            uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
    774          {
    775            uint8 dataLen;
    776            uint8 *buf;
    777            uint8 *pBuf;
    778            uint8 i;
    779            ZStatus_t status;
    780           
    781            dataLen = readReportCfgCmd->numAttr * ( 1 + 2 ); // Direction + Atrribute ID
    782            
    783            buf = osal_mem_alloc( dataLen );
    784            if ( buf != NULL )
    785            {
    786              // Load the buffer - serially
    787              pBuf = buf;
    788              for ( i = 0; i < readReportCfgCmd->numAttr; i++ )
    789              {
    790                *pBuf++ = readReportCfgCmd->attrList[i].direction;
    791                *pBuf++ = LO_UINT16( readReportCfgCmd->attrList[i].attrID );
    792                *pBuf++ = HI_UINT16( readReportCfgCmd->attrList[i].attrID );
    793              }
    794              
    795              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ_REPORT_CFG, FALSE, 
    796                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
    797              osal_mem_free( buf );
    798            }
    799            else
    800              status = ZMemError;
    801            
    802            return ( status );
    803          }
    804          
    805          ZStatus_t zcl_SendReadReportCfgRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
    806                       uint16 clusterID, zclReadReportCfgRspCmd_t *readReportCfgRspCmd,
    807                       uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
    808          {
    809            uint8 *buf;
    810            uint8 *pBuf;
    811            uint8 dataLen = 0;
    812            zclReportCfgRspRec_t *reportRspRec;
    813            uint8 reportChangeLen;
    814            uint8 i;
    815            ZStatus_t status;
    816          
    817            // Find out the data length
    818            for ( i = 0; i < readReportCfgRspCmd->numAttr; i++ )
    819            {
    820              reportRspRec = &(readReportCfgRspCmd->attrList[i]);
    821              
    822              dataLen += 1 + 1 + 2 ; // Status, Direction and Atrribute ID
    823              
    824              if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
    825              {
    826                if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
    827                {
    828                  dataLen += 1 + 2 + 2; // Data Type + Min + Max Reporting Intervals
    829                
    830                  if ( zclAnalogDataType( reportRspRec->dataType ) )
    831                  {
    832                    reportChangeLen = zclGetDataTypeLength( reportRspRec->dataType );
    833                    dataLen += reportChangeLen; // Reportable Change field
    834                  }
    835                }
    836                else
    837                {
    838                  dataLen += 2; // Timeout Period
    839                }
    840              }
    841            }
    842            
    843            buf = osal_mem_alloc( dataLen );
    844            if ( buf != NULL )
    845            {
    846              // Load the buffer - serially
    847              pBuf = buf;
    848          
    849              for ( i = 0; i < readReportCfgRspCmd->numAttr; i++ )
    850              {
    851                reportRspRec = &(readReportCfgRspCmd->attrList[i]);
    852          
    853                *pBuf++ = reportRspRec->status;
    854                *pBuf++ = reportRspRec->direction;
    855                *pBuf++ = LO_UINT16( reportRspRec->attrID );
    856                *pBuf++ = HI_UINT16( reportRspRec->attrID );
    857               
    858                if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
    859                {
    860                  if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
    861                  {
    862                    *pBuf++ = reportRspRec->dataType;
    863                    *pBuf++ = LO_UINT16( reportRspRec->minReportInt );
    864                    *pBuf++ = HI_UINT16( reportRspRec->minReportInt );
    865                    *pBuf++ = LO_UINT16( reportRspRec->maxReportInt );
    866                    *pBuf++ = HI_UINT16( reportRspRec->maxReportInt );
    867          
    868                    if ( zclAnalogDataType( reportRspRec->dataType ) )
    869                    {
    870                      zclSerializeData( reportRspRec->dataType, 
    871                                        reportRspRec->reportableChange, pBuf );
    872                      reportChangeLen = zclGetDataTypeLength( reportRspRec->dataType );
    873                      pBuf += reportChangeLen;
    874                    }
    875                  }
    876                  else
    877                  {
    878                    *pBuf++ = LO_UINT16( reportRspRec->timeoutPeriod );
    879                    *pBuf++ = HI_UINT16( reportRspRec->timeoutPeriod );
    880                  }
    881                }
    882              }
    883             
    884              status = zcl_SendCommand( srcEP, dstAddr, clusterID,
    885                                        ZCL_CMD_READ_REPORT_CFG_RSP, FALSE,
    886                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
    887              osal_mem_free( buf );
    888            }
    889            else
    890              status = ZMemError;
    891            
    892            return ( status );
    893          }
    894          
    895          ZStatus_t zcl_SendReportCmd( uint8 srcEP, afAddrType_t *dstAddr,
    896                                       uint16 clusterID, zclReportCmd_t *reportCmd,
    897                                       uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
    898          {
    899            zclReport_t *reportRec;
    900            uint8 attrDataLen;
    901            uint8 dataLen = 0;
    902            uint8 *buf;
    903            uint8 *pBuf;
    904            uint8 i;
    905            ZStatus_t status;
    906            
    907            // calculate the size of the command
    908            for ( i = 0; i < reportCmd->numAttr; i++ )
    909            {
    910              reportRec = &(reportCmd->attrList[i]);
    911              
    912              dataLen += 2 + 1; // Attribute ID + data type
    913          
    914              attrDataLen = zclGetAttrDataLength( reportRec->dataType, reportRec->attrData );
    915              dataLen += attrDataLen; // Attribute Data
    916            }
    917            
    918            buf = osal_mem_alloc( dataLen );
    919            if ( buf != NULL )
    920            {
    921              // Load the buffer - serially
    922              pBuf = buf;
    923              for ( i = 0; i < reportCmd->numAttr; i++ )
    924              {
    925                reportRec = &(reportCmd->attrList[i]);
    926                
    927                *pBuf++ = LO_UINT16( reportRec->attrID );
    928                *pBuf++ = HI_UINT16( reportRec->attrID );
    929                *pBuf++ = reportRec->dataType;
    930          
    931                zclSerializeData( reportRec->dataType, reportRec->attrData, pBuf );
    932                attrDataLen = zclGetAttrDataLength( reportRec->dataType, reportRec->attrData );
    933                pBuf += attrDataLen; // move pass attribute data
    934              }
    935           
    936              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_REPORT, FALSE, 
    937                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
    938              osal_mem_free( buf );
    939            }
    940            else
    941              status = ZMemError;
    942            
    943            return ( status );
    944          }
    945          #endif // ZCL_REPORT
    946          
    947          ZStatus_t zcl_SendDefaultRspCmd( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID,
    948                                           zclDefaultRspCmd_t *defaultRspCmd, uint8 direction,
    949                                           uint8 disableDefaultRsp, uint16 manuCode, uint8 seqNum )
    950          {
    951            uint8 buf[2]; // Command ID and Status;
    952          
    953            // Load the buffer - serially
    954            buf[0] = defaultRspCmd->commandID;
    955            buf[1] = defaultRspCmd->statusCode;
    956          
    957            return ( zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DEFAULT_RSP, FALSE,
    958                                      direction, disableDefaultRsp, manuCode, seqNum, 2, buf ) ); 
    959          }
    960          
    961          #ifdef ZCL_DISCOVER
    962          ZStatus_t zcl_SendDiscoverCmd( uint8 srcEP, afAddrType_t *dstAddr,
    963                                      uint16 clusterID, zclDiscoverCmd_t *discoverCmd,
    964                                      uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
    965          {
    966            uint8 dataLen = 2 + 1; // Start Attribute ID and Max Attribute IDs
    967            uint8 *buf;
    968            uint8 *pBuf;
    969            ZStatus_t status;
    970            
    971            buf = osal_mem_alloc( dataLen );
    972            if ( buf != NULL )
    973            {
    974              // Load the buffer - serially
    975              pBuf = buf;
    976              *pBuf++ = LO_UINT16(discoverCmd->startAttr);
    977              *pBuf++ = HI_UINT16(discoverCmd->startAttr);
    978              *pBuf++ = discoverCmd->maxAttrIDs;
    979              
    980              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER, FALSE, 
    981                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
    982              osal_mem_free( buf );
    983            }
    984            else
    985              status = ZMemError;
    986            
    987            return ( status );
    988          }
    989          
    990          ZStatus_t zcl_SendDiscoverRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
    991                                uint16 clusterID, zclDiscoverRspCmd_t *discoverRspCmd,
    992                                uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
    993          {
    994            uint8 dataLen = 1; // Discovery complete
    995            uint8 *buf;
    996            uint8 *pBuf;
    997            uint8 i;
    998            ZStatus_t status;
    999            
   1000            // calculate the size of the command
   1001            dataLen += discoverRspCmd->numAttr * (2 + 1); // Attribute ID and Data Type
   1002            
   1003            buf = osal_mem_alloc( dataLen );
   1004            if ( buf != NULL )
   1005            {
   1006              // Load the buffer - serially
   1007              pBuf = buf;
   1008              *pBuf++ = discoverRspCmd->discComplete;    
   1009              for ( i = 0; i < discoverRspCmd->numAttr; i++ )
   1010              {
   1011                *pBuf++ = LO_UINT16(discoverRspCmd->attrList[i].attrID);
   1012                *pBuf++ = HI_UINT16(discoverRspCmd->attrList[i].attrID);
   1013                *pBuf++ = discoverRspCmd->attrList[i].dataType;
   1014              }
   1015              
   1016              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_RSP, FALSE,
   1017                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1018              osal_mem_free( buf );
   1019            }
   1020            else
   1021              status = ZMemError;
   1022            
   1023            return ( status );
   1024          }
   1025          #endif // ZCL_DISCOVER
   1026          
   1027          void zclProcessMessageMSG( afIncomingMSGPacket_t *pkt )
   1028          {
   1029          #if defined(Coor_receiver) // The coordinator receive data
   1030            byte recv_data[30];  
   1031          #endif
   1032            uint16 len;
   1033            endPointDesc_t *epDesc;
   1034            zclIncoming_t inMsg;
   1035            zclLibPlugin_t *pInPlugin;
   1036            zclDefaultRspCmd_t defautlRspCmd;
   1037            uint8 options;
   1038            uint8 securityEnable;
   1039            uint8 interPanMsg;
   1040            ZStatus_t status = ZFailure;
   1041          
   1042            if ( pkt->cmd.DataLength == 0 ) return;   // Error, ignore the message
   1043          
   1044          #if defined(Coor_receiver)
   1045            if (pkt->cmd.DataLength > 0)
   1046            {
   1047              for(len = 0; len < pkt->cmd.DataLength; len++) // Send the recv_data to UART
   1048              {
   1049                  recv_data[len] = pkt->cmd.Data[len+3]; // the cmd.Data[0~2] is cluster ID.
   1050              }
   1051              
   1052              #define HI_UINT16(a) (((a) >> 8) & 0xFF)
   1053              #define LO_UINT16(a) ((a) & 0xFF)
   1054              
   1055              char entry[4];
   1056              uint8 hi = HI_UINT16( pkt->srcAddr.addr.shortAddr );
   1057              uint8 lo = LO_UINT16( pkt->srcAddr.addr.shortAddr );
   1058          
   1059              entry[0] = hi/16 + 48;  /* Little Endian for the radio RAM */
   1060              entry[1] = hi%16 + 48;
   1061              entry[2] = lo/16 + 48;
   1062              entry[3] = lo%16 + 48;
   1063              for (int k=0;k<4;k++)
   1064              {
   1065                if(entry[k]>57)
   1066                  entry[k]+=7;
   1067              }
   1068          
   1069              HalUARTWrite(MT_UART_DEFAULT_PORT, "3", 1);//Cmd Type
   1070              HalUARTWrite(MT_UART_DEFAULT_PORT, ",", 1);//Comma   
   1071              HalUARTWrite(MT_UART_DEFAULT_PORT, entry, 4);//Device ID
   1072              HalUARTWrite(MT_UART_DEFAULT_PORT, ",", 1);//Comma
   1073              HalUARTWrite(MT_UART_DEFAULT_PORT, recv_data, pkt->cmd.DataLength-2);//Device Data
   1074              HalUARTWrite(MT_UART_DEFAULT_PORT, "$\r\n", 3);//$\n
   1075            }
   1076          #endif
   1077          
   1078          // The device receive the uart command with RF
   1079          #if defined(End_Device) || defined(Router_Device)
   1080            if(pkt->cmd.DataLength > 0)
   1081            {
   1082              for(len = 0; len < pkt->cmd.DataLength; len++)
   1083              {
   1084                receive[len] = pkt->cmd.Data[len+3];
                       ^
Error[Pe020]: identifier "receive" is undefined
   1085              }
   1086              // Write receive coordinator command to UART, chrischris
   1087              // HalUARTWrite(MT_UART_DEFAULT_PORT, receive, pkt->cmd.DataLength-2);
   1088              // a - k 97=>107
   1089              // This part is addressing the level of the pwn(M160),
   1090              // and there are 11 levels which is from 97(a) to 107
   1091              #if defined(M160)
   1092                if((int)receive[0] > 97 && (int)receive[0]< 107 ){
   1093                  int var = (int)receive[0];
   1094                  var = var + 3 - 100;
   1095                  duty_M160 = var * 5;
   1096                }
   1097              #endif  
   1098              return ;
   1099            }
   1100          #endif  
   1101            
   1102            // Initialize
   1103            inMsg.msg = pkt;
   1104            inMsg.attrCmd = NULL;
   1105            inMsg.pData = NULL;
   1106            inMsg.pDataLen = 0;
   1107          
   1108            inMsg.pData = zclParseHdr( &(inMsg.hdr), pkt->cmd.Data );
   1109            inMsg.pDataLen = pkt->cmd.DataLength;
   1110            inMsg.pDataLen -= (uint16)(inMsg.pData - pkt->cmd.Data);
   1111          
   1112            // Find the wanted endpoint
   1113            epDesc = afFindEndPointDesc( pkt->endPoint );
   1114            if ( epDesc == NULL )
   1115              return;   // Error, ignore the message
   1116          
   1117            if ( pkt->clusterId == ZCL_INVALID_CLUSTER_ID )
   1118              return;   // Error, ignore the message
   1119            
   1120            if ((epDesc->simpleDesc == NULL) ||
   1121                (zcl_DeviceOperational(pkt->endPoint, pkt->clusterId, inMsg.hdr.fc.type, inMsg.hdr.commandID,
   1122                                             epDesc->simpleDesc->AppProfId) == FALSE))
   1123            {
   1124              return; // Error, ignore the message
   1125            }
   1126          
   1127          #if defined ( INTER_PAN )
   1128            if ( StubAPS_InterPan( pkt->srcAddr.panId, pkt->srcAddr.endPoint ) )
   1129            {
   1130              // No foundation command is supported thru Inter-PAN communication
   1131              if ( zcl_ProfileCmd( inMsg.hdr.fc.type ) )
   1132                return;
   1133          
   1134              interPanMsg = TRUE; 
   1135              options = AF_TX_OPTIONS_NONE;
   1136            }
   1137            else
   1138          #endif
   1139            {
   1140              interPanMsg = FALSE;
   1141              options = zclGetClusterOption( pkt->endPoint, pkt->clusterId );
   1142            }
   1143            
   1144            // Local and remote Security options must match except for Default Response command
   1145            if ( !zcl_DefaultRspCmd( inMsg.hdr ) )
   1146            {
   1147              securityEnable = ( options & AF_EN_SECURITY ) ? TRUE : FALSE;
   1148              if ( pkt->SecurityUse != securityEnable )
   1149              {
   1150                if ( UNICAST_MSG( inMsg.msg ) )
   1151                {
   1152                  // Send a Default Response command back with no Application Link Key security
   1153                  if ( securityEnable )
   1154                    zclSetSecurityOption( pkt->endPoint, pkt->clusterId, FALSE );
   1155                  
   1156                  defautlRspCmd.statusCode = status;
   1157                  defautlRspCmd.commandID = inMsg.hdr.commandID;
   1158                  zcl_SendDefaultRspCmd( inMsg.msg->endPoint, &(inMsg.msg->srcAddr),
   1159                                         inMsg.msg->clusterId, &defautlRspCmd, 
   1160                                         ZCL_FRAME_SERVER_CLIENT_DIR, true, 
   1161                                         inMsg.hdr.manuCode, inMsg.hdr.transSeqNum );
   1162                  if ( securityEnable )
   1163                    zclSetSecurityOption( pkt->endPoint, pkt->clusterId, TRUE );       
   1164                }
   1165                return;   // Error, ignore the message
   1166              }
   1167            }
   1168            
   1169            // Is this a foundation type message
   1170            if ( zcl_ProfileCmd( inMsg.hdr.fc.type ) )
   1171            { 
   1172              if ( inMsg.hdr.fc.manuSpecific )
   1173              {
   1174                // We don't support any manufacturer specific command
   1175                status = ZCL_STATUS_UNSUP_MANU_GENERAL_COMMAND;
   1176              }
   1177              else if ( ( inMsg.hdr.commandID <= ZCL_CMD_MAX ) && 
   1178                        ( zclCmdTable[inMsg.hdr.commandID].pfnParseInProfile != NULL ) )
   1179              {
   1180                zclParseCmd_t parseCmd;
   1181                
   1182                parseCmd.endpoint = pkt->endPoint;
   1183                parseCmd.dataLen = inMsg.pDataLen;
   1184                parseCmd.pData = inMsg.pData;
   1185                
   1186                // Parse the command, remember that the return value is a pointer to allocated memory
   1187                inMsg.attrCmd = zclParseCmd( inMsg.hdr.commandID, &parseCmd );
   1188                if ( (inMsg.attrCmd != NULL) && (zclCmdTable[inMsg.hdr.commandID].pfnProcessInProfile != NULL) )
   1189                { 
   1190                  // Process the command
   1191                  if ( zclProcessCmd( inMsg.hdr.commandID, &inMsg ) == FALSE )
   1192                  {
   1193                    // Couldn't find attribute in the table.
   1194                  }
   1195                }
   1196                 
   1197                // Free the buffer
   1198                if ( inMsg.attrCmd )
   1199                  osal_mem_free( inMsg.attrCmd );
   1200                
   1201                if ( CMD_HAS_RSP( inMsg.hdr.commandID ) )
   1202                  return; // We're done
   1203                
   1204                status = ZSuccess;
   1205              }
   1206              else
   1207              {
   1208                // Unsupported message
   1209                status = ZCL_STATUS_UNSUP_GENERAL_COMMAND;
   1210              }
   1211            }
   1212            else  // Not a foundation type message, so it must be specific to the cluster ID.
   1213            {
   1214              if (epDesc->simpleDesc == NULL)
   1215              {
   1216                pInPlugin = NULL;
   1217              }
   1218              else
   1219              {
   1220                // Find the appropriate plugin
   1221                pInPlugin = zclFindPlugin( pkt->clusterId, epDesc->simpleDesc->AppProfId );
   1222              }
   1223              if ( pInPlugin && pInPlugin->pfnIncomingHdlr )
   1224              { 
   1225                status = pInPlugin->pfnIncomingHdlr( &inMsg );
   1226                if ( status == ZCL_STATUS_CMD_HAS_RSP || ( interPanMsg && status == ZSuccess ) )
   1227                  return; // We're done      
   1228              }
   1229              
   1230              if ( status == ZFailure )
   1231              {
   1232                // Unsupported message
   1233                if ( inMsg.hdr.fc.manuSpecific )
   1234                  status = ZCL_STATUS_UNSUP_MANU_CLUSTER_COMMAND;
   1235                else
   1236                  status = ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
   1237              }
   1238            }
   1239            
   1240            if ( UNICAST_MSG( inMsg.msg ) && inMsg.hdr.fc.disableDefaultRsp == 0 )
   1241            {
   1242              // Send a Default Response command back
   1243              defautlRspCmd.statusCode = status;
   1244              defautlRspCmd.commandID = inMsg.hdr.commandID;
   1245              zcl_SendDefaultRspCmd( inMsg.msg->endPoint, &(inMsg.msg->srcAddr),
   1246                                     inMsg.msg->clusterId, &defautlRspCmd, 
   1247                                     ZCL_FRAME_SERVER_CLIENT_DIR, true, 
   1248                                     inMsg.hdr.manuCode, inMsg.hdr.transSeqNum );
   1249            }
   1250          }
   1251          
   1252          uint8 *zclParseHdr( zclFrameHdr_t *hdr, uint8 *pData )
   1253          {
   1254            // Clear the header
   1255            osal_memset( (uint8 *)hdr, 0, sizeof ( zclFrameHdr_t ) );
   1256          
   1257            // Parse the Frame Control
   1258            hdr->fc.type = zcl_FCType( *pData );
   1259            hdr->fc.manuSpecific = zcl_FCManuSpecific( *pData ) ? 1 : 0;
   1260            if ( zcl_FCDirection( *pData ) )
   1261              hdr->fc.direction = ZCL_FRAME_SERVER_CLIENT_DIR;
   1262            else
   1263              hdr->fc.direction = ZCL_FRAME_CLIENT_SERVER_DIR;
   1264            
   1265            hdr->fc.disableDefaultRsp = zcl_FCDisableDefaultRsp( *pData ) ? 1 : 0;
   1266            pData++;  // move past the frame control field
   1267          
   1268            // parse the manfacturer code
   1269            if ( hdr->fc.manuSpecific )
   1270            {
   1271              hdr->manuCode = BUILD_UINT16( pData[0], pData[1] );
   1272              pData += 2;
   1273            }
   1274          
   1275            // parse the Transaction Sequence Number
   1276            hdr->transSeqNum = *pData++;
   1277          
   1278            // parse the Cluster's command ID
   1279            hdr->commandID = *pData++;
   1280          
   1281            // Should point to the frame payload
   1282            return ( pData );
   1283          }
   1284          
   1285          static uint8 *zclBuildHdr( zclFrameHdr_t *hdr, uint8 *pData )
   1286          {
   1287            // Build the Frame Control byte
   1288            *pData = hdr->fc.type;
   1289            *pData |= hdr->fc.manuSpecific << 2;
   1290            *pData |= hdr->fc.direction << 3;
   1291            *pData |= hdr->fc.disableDefaultRsp << 4;
   1292            pData++;  // move past the frame control field
   1293          
   1294            // Add the manfacturer code
   1295            if ( hdr->fc.manuSpecific )
   1296            {
   1297              *pData++ = LO_UINT16( hdr->manuCode );
   1298              *pData++ = HI_UINT16( hdr->manuCode );
   1299            }
   1300          
   1301            // Add the Transaction Sequence Number
   1302            *pData++ = hdr->transSeqNum;
   1303            
   1304            // Add the Cluster's command ID
   1305            *pData++ = hdr->commandID;
   1306          
   1307            // Should point to the frame payload
   1308            return ( pData );
   1309          }
   1310          
   1311          static uint8 zclCalcHdrSize( zclFrameHdr_t *hdr )
   1312          {
   1313            uint8 needed = (1 + 1 + 1); // frame control + transaction seq num + cmd ID
   1314          
   1315            // Add the manfacturer code
   1316            if ( hdr->fc.manuSpecific )
   1317              needed += 2;
   1318          
   1319            return ( needed );
   1320          }
   1321          
   1322          static zclLibPlugin_t *zclFindPlugin( uint16 clusterID, uint16 profileID )
   1323          {
   1324            zclLibPlugin_t *pLoop;
   1325            
   1326            (void)profileID;  // Intentionally unreferenced parameter
   1327          
   1328            if ( clusterID != ZCL_INVALID_CLUSTER_ID )
   1329            {
   1330              pLoop = plugins;
   1331              while ( pLoop != NULL )
   1332              {
   1333                if ( clusterID >= pLoop->startClusterID && clusterID <= pLoop->endClusterID )
   1334                  return ( pLoop );
   1335                pLoop = pLoop->next;
   1336              }
   1337            }
   1338            return ( (zclLibPlugin_t *)NULL );
   1339          }
   1340          
   1341          uint8 zclFindAttrRec( uint8 endpoint, uint16 clusterID, uint16 attrId, zclAttrRec_t *pAttr )
   1342          {
   1343            uint8 x;
   1344            zclAttrRecsList *pLoop;
   1345          
   1346            pLoop = attrList;
   1347          
   1348            while ( pLoop != NULL )
   1349            {
   1350              if ( pLoop->endpoint == endpoint )
   1351              {
   1352                for ( x = 0; x < pLoop->numAttributes; x++ )
   1353                {
   1354                  if ( pLoop->attrs[x].clusterID == clusterID && pLoop->attrs[x].attr.attrId == attrId )
   1355                  {
   1356                    *pAttr = pLoop->attrs[x];
   1357                    return ( TRUE ); // EMBEDDED RETURN
   1358                  }
   1359                }
   1360              }
   1361              pLoop = pLoop->next;
   1362            }
   1363          
   1364            return ( FALSE );
   1365          }
   1366          
   1367          static zclOptionRec_t *zclFindClusterOption( uint8 endpoint, uint16 clusterID )
   1368          {
   1369            uint8 x;
   1370            zclClusterOptionList *pLoop;
   1371          
   1372            pLoop = clusterOptionList;
   1373          
   1374            while ( pLoop != NULL )
   1375            {
   1376              if ( pLoop->endpoint == endpoint )
   1377              {
   1378                for ( x = 0; x < pLoop->numOptions; x++ )
   1379                {
   1380                  if ( pLoop->options[x].clusterID == clusterID )
   1381                    return ( &(pLoop->options[x]) ); // EMBEDDED RETURN
   1382                }
   1383              }
   1384              pLoop = pLoop->next;
   1385            }
   1386          
   1387            return ( NULL );
   1388          }
   1389          
   1390          static uint8 zclGetClusterOption( uint8 endpoint, uint16 clusterID )
   1391          {
   1392            uint8 option;
   1393            zclOptionRec_t *pOption;
   1394          
   1395             pOption = zclFindClusterOption( endpoint, clusterID );
   1396            if ( pOption != NULL )
   1397            {
   1398              option = pOption->option;
   1399              if ( !ZG_SECURE_ENABLED )
   1400                option &= (AF_EN_SECURITY ^ 0xFF); // make sure Application Link Key security is off
   1401          
   1402              return ( option ); // EMBEDDED RETURN
   1403            }
   1404          
   1405            return ( AF_TX_OPTIONS_NONE );
   1406          }
   1407          
   1408          static void zclSetSecurityOption( uint8 endpoint, uint16 clusterID, uint8 enable )
   1409          {
   1410            zclOptionRec_t *pOption;
   1411          
   1412            pOption = zclFindClusterOption( endpoint, clusterID );
   1413            if ( pOption != NULL )
   1414            {
   1415              if ( enable )
   1416                pOption->option |= AF_EN_SECURITY;
   1417              else
   1418                pOption->option &= (AF_EN_SECURITY ^ 0xFF);
   1419            }
   1420          }
   1421          
   1422          #ifdef ZCL_DISCOVER
   1423          
   1424          static uint8 zclFindNextAttrRec( uint8 endpoint, uint16 clusterID,
   1425                                           uint16 *attrId, zclAttrRec_t *pAttr )
   1426          {
   1427            uint16 x;
   1428            zclAttrRecsList *pLoop;
   1429          
   1430            pLoop = attrList;
   1431          
   1432            while ( pLoop != NULL )
   1433            {
   1434              if ( pLoop->endpoint == endpoint )
   1435              {
   1436                for ( x = 0; x < pLoop->numAttributes; x++ )
   1437                {
   1438                  if ( pLoop->attrs[x].clusterID == clusterID && pLoop->attrs[x].attr.attrId >= *attrId )
   1439                  {
   1440                    *pAttr = pLoop->attrs[x];
   1441                    
   1442                    // Update attribute ID
   1443                    *attrId = pAttr->attr.attrId; 
   1444                    return ( TRUE ); // EMBEDDED RETURN
   1445                  }
   1446                }
   1447              }
   1448              pLoop = pLoop->next;
   1449            }
   1450          
   1451            return ( FALSE );
   1452          }
   1453          #endif // ZCL_DISCOVER
   1454          
   1455          #if defined(ZCL_READ) || defined(ZCL_WRITE) || defined(ZCL_REPORT)
   1456          static void zclSerializeData( uint8 dataType, void *attrData, uint8 *buf )
   1457          {
   1458            uint8 *pStr;
   1459            uint8 len;
   1460          
   1461            switch ( dataType )
   1462            {
   1463              case ZCL_DATATYPE_DATA8:
   1464              case ZCL_DATATYPE_BOOLEAN:
   1465              case ZCL_DATATYPE_BITMAP8:
   1466              case ZCL_DATATYPE_INT8:
   1467              case ZCL_DATATYPE_UINT8:
   1468              case ZCL_DATATYPE_ENUM8:
   1469                *buf = *((uint8 *)attrData);
   1470                 break;
   1471          
   1472              case ZCL_DATATYPE_DATA16:
   1473              case ZCL_DATATYPE_BITMAP16:
   1474              case ZCL_DATATYPE_UINT16:
   1475              case ZCL_DATATYPE_INT16: 
   1476              case ZCL_DATATYPE_ENUM16:
   1477              case ZCL_DATATYPE_SEMI_PREC:
   1478              case ZCL_DATATYPE_CLUSTER_ID:
   1479              case ZCL_DATATYPE_ATTR_ID:
   1480                *buf++ = LO_UINT16( *((uint16*)attrData) );
   1481                *buf++ = HI_UINT16( *((uint16*)attrData) );
   1482                break;
   1483          
   1484              case ZCL_DATATYPE_DATA24:
   1485              case ZCL_DATATYPE_BITMAP24: 
   1486              case ZCL_DATATYPE_UINT24:
   1487              case ZCL_DATATYPE_INT24:
   1488                *buf++ = BREAK_UINT32( *((uint32*)attrData), 0 );
   1489                *buf++ = BREAK_UINT32( *((uint32*)attrData), 1 );
   1490                *buf++ = BREAK_UINT32( *((uint32*)attrData), 2 );
   1491                break;
   1492                
   1493              case ZCL_DATATYPE_DATA32:
   1494              case ZCL_DATATYPE_BITMAP32:
   1495              case ZCL_DATATYPE_UINT32:
   1496              case ZCL_DATATYPE_INT32:
   1497              case ZCL_DATATYPE_SINGLE_PREC:
   1498              case ZCL_DATATYPE_TOD:
   1499              case ZCL_DATATYPE_DATE:
   1500              case ZCL_DATATYPE_UTC:
   1501              case ZCL_DATATYPE_BAC_OID:
   1502                buf = osal_buffer_uint32( buf, *((uint32*)attrData) );
   1503                break;
   1504                
   1505              case ZCL_DATATYPE_UINT40:
   1506                pStr = (uint8*)attrData;
   1507                osal_memcpy( buf, pStr, 5 );
   1508                break;
   1509                
   1510              case ZCL_DATATYPE_UINT48:
   1511                pStr = (uint8*)attrData;
   1512                osal_memcpy( buf, pStr, 6 );
   1513                break;
   1514                
   1515              case ZCL_DATATYPE_IEEE_ADDR:
   1516                pStr = (uint8*)attrData;
   1517                osal_memcpy( buf, pStr, 8 );
   1518                break;
   1519                
   1520              case ZCL_DATATYPE_CHAR_STR:
   1521              case ZCL_DATATYPE_OCTET_STR:
   1522                pStr = (uint8*)attrData;
   1523                len = *pStr++;
   1524                *buf++ = len;
   1525                osal_memcpy( buf, pStr, len );
   1526                break;
   1527                
   1528              case ZCL_DATATYPE_NO_DATA:
   1529              case ZCL_DATATYPE_UNKNOWN:
   1530                // Fall through
   1531          
   1532              default:
   1533                break;
   1534            }
   1535          }
   1536          #endif // ZCL_READ || ZCL_WRITE || ZCL_REPORT
   1537          
   1538          #ifdef ZCL_REPORT
   1539          uint8 zclAnalogDataType( uint8 dataType )
   1540          {
   1541            uint8 analog;
   1542            
   1543            switch ( dataType )
   1544            {
   1545              case ZCL_DATATYPE_UINT8:
   1546              case ZCL_DATATYPE_UINT16:
   1547              case ZCL_DATATYPE_UINT24:
   1548              case ZCL_DATATYPE_UINT32:
   1549              case ZCL_DATATYPE_UINT40:
   1550              case ZCL_DATATYPE_UINT48:
   1551              case ZCL_DATATYPE_INT8:
   1552              case ZCL_DATATYPE_INT16:
   1553              case ZCL_DATATYPE_INT24:
   1554              case ZCL_DATATYPE_INT32:
   1555              case ZCL_DATATYPE_SEMI_PREC:
   1556              case ZCL_DATATYPE_SINGLE_PREC:
   1557              case ZCL_DATATYPE_DOUBLE_PREC:
   1558              case ZCL_DATATYPE_TOD:
   1559              case ZCL_DATATYPE_DATE:
   1560              case ZCL_DATATYPE_UTC:
   1561                analog = TRUE;
   1562                break;
   1563                
   1564              default:
   1565                analog = FALSE;
   1566                break;
   1567            }
   1568            return ( analog );
   1569          }
   1570          
   1571          static void zcl_BuildAnalogData( uint8 dataType, uint8 *pData, uint8 *pBuf)
   1572          {
   1573            switch ( dataType )
   1574            {
   1575              case ZCL_DATATYPE_UINT8:
   1576              case ZCL_DATATYPE_INT8:
   1577                *pData = *pBuf;
   1578                break;
   1579          
   1580              case ZCL_DATATYPE_UINT16:
   1581              case ZCL_DATATYPE_INT16:
   1582              case ZCL_DATATYPE_SEMI_PREC:
   1583                *((uint16*)pData) = BUILD_UINT16( pBuf[0], pBuf[1] ); 
   1584                break;
   1585           
   1586              case ZCL_DATATYPE_UINT24:
   1587              case ZCL_DATATYPE_INT24:
   1588                *((uint32*)pData) = osal_build_uint32( pBuf, 3 );
   1589                break;
   1590                
   1591              case ZCL_DATATYPE_UINT32:
   1592              case ZCL_DATATYPE_INT32:
   1593              case ZCL_DATATYPE_SINGLE_PREC:
   1594              case ZCL_DATATYPE_TOD:
   1595              case ZCL_DATATYPE_DATE:
   1596              case ZCL_DATATYPE_UTC:
   1597                *((uint32*)pData) = osal_build_uint32( pBuf, 4 );
   1598                break;
   1599                
   1600              case ZCL_DATATYPE_DOUBLE_PREC:
   1601                *pData = 0;
   1602                break;
   1603           
   1604              default:
   1605                break;
   1606            }
   1607          }
   1608          #endif // ZCL_REPORT
   1609          
   1610          uint8 zclGetDataTypeLength( uint8 dataType )
   1611          {
   1612            uint8 len;
   1613            
   1614            switch ( dataType )
   1615            {
   1616              case ZCL_DATATYPE_DATA8:
   1617              case ZCL_DATATYPE_BOOLEAN:
   1618              case ZCL_DATATYPE_BITMAP8:
   1619              case ZCL_DATATYPE_INT8:
   1620              case ZCL_DATATYPE_UINT8:
   1621              case ZCL_DATATYPE_ENUM8:
   1622                len = 1;
   1623                break;
   1624                
   1625              case ZCL_DATATYPE_DATA16:
   1626              case ZCL_DATATYPE_BITMAP16:
   1627              case ZCL_DATATYPE_UINT16:
   1628              case ZCL_DATATYPE_INT16: 
   1629              case ZCL_DATATYPE_ENUM16:
   1630              case ZCL_DATATYPE_SEMI_PREC:
   1631              case ZCL_DATATYPE_CLUSTER_ID:
   1632              case ZCL_DATATYPE_ATTR_ID:
   1633                len = 2;
   1634                break;
   1635                
   1636              case ZCL_DATATYPE_DATA24:
   1637              case ZCL_DATATYPE_BITMAP24: 
   1638              case ZCL_DATATYPE_UINT24:
   1639              case ZCL_DATATYPE_INT24:
   1640                len = 3;
   1641                break;
   1642                
   1643              case ZCL_DATATYPE_DATA32:
   1644              case ZCL_DATATYPE_BITMAP32:
   1645              case ZCL_DATATYPE_UINT32:
   1646              case ZCL_DATATYPE_INT32:
   1647              case ZCL_DATATYPE_SINGLE_PREC:
   1648              case ZCL_DATATYPE_TOD:
   1649              case ZCL_DATATYPE_DATE:
   1650              case ZCL_DATATYPE_UTC:
   1651              case ZCL_DATATYPE_BAC_OID:
   1652                len = 4;
   1653                break;                       
   1654                          
   1655             case ZCL_DATATYPE_UINT40:
   1656                 len = 5;
   1657                 break;
   1658                 
   1659             case ZCL_DATATYPE_UINT48:
   1660                 len = 6;
   1661                 break;
   1662                 
   1663             case ZCL_DATATYPE_DOUBLE_PREC:
   1664             case ZCL_DATATYPE_IEEE_ADDR:
   1665               len = 8;
   1666               break;
   1667          
   1668              case ZCL_DATATYPE_NO_DATA:
   1669              case ZCL_DATATYPE_UNKNOWN:
   1670                // Fall through
   1671                
   1672              default:
   1673                len = 0;
   1674                break;
   1675            }  
   1676            return ( len );
   1677          }
   1678          
   1679          /*********************************************************************
   1680           * @fn      zclGetAttrDataLength
   1681           * @brief   Return the length of the attribute.
   1682           * @param   dataType - data type
   1683           *          pData - pointer to data
   1684           * @return  returns atrribute lentgh
   1685           */
   1686          uint8 zclGetAttrDataLength( uint8  dataType, uint8 *pData)
   1687          {
   1688            uint8 dataLen = 0;
   1689            
   1690            if ( dataType  == ZCL_DATATYPE_CHAR_STR || dataType == ZCL_DATATYPE_OCTET_STR )
   1691            {
   1692              dataLen = *pData + 1; // string length + 1 for length field
   1693            }
   1694            else
   1695            {
   1696              dataLen = zclGetDataTypeLength( dataType );
   1697            }
   1698          
   1699            return ( dataLen );
   1700          }
   1701          
   1702          /*********************************************************************
   1703           * @fn      zclReadAttrData
   1704           * @brief   Read the attribute's current value into pAttrData.
   1705           * @param   pAttrData - where to put attribute data
   1706           *          pAttr - pointer to attribute
   1707           * @return Success
   1708           */
   1709          uint8 zclReadAttrData( uint8 *pAttrData, zclAttrRec_t *pAttr )
   1710          {
   1711            uint8 dataLen;
   1712              
   1713            dataLen = zclGetAttrDataLength( pAttr->attr.dataType, (uint8*)(pAttr->attr.dataPtr) );
   1714            osal_memcpy( pAttrData, pAttr->attr.dataPtr, dataLen );
   1715            return ( ZCL_STATUS_SUCCESS );
   1716          }
   1717          
   1718          #ifdef ZCL_WRITE
   1719          /*********************************************************************
   1720           * @fn      zclWriteAttrData
   1721           * @brief   Write the received data.
   1722           * @param   pAttr - where to write data to
   1723           *          pWriteRec - data to be written
   1724           * @return  Successful if data was written
   1725           */
   1726          static uint8 zclWriteAttrData( zclAttrRec_t *pAttr, zclWriteRec_t *pWriteRec )
   1727          {
   1728            uint8 len;
   1729          
   1730            if ( zcl_AccessCtrlWrite( pAttr->attr.accessControl ) )
   1731            {
   1732              if ( zcl_ValidateAttrDataCB && !zcl_ValidateAttrDataCB( pAttr, pWriteRec ) )
   1733                return ( ZCL_STATUS_INVALID_VALUE );
   1734              
   1735              len = zclGetAttrDataLength( pAttr->attr.dataType, pWriteRec->attrData );
   1736              osal_memcpy( pAttr->attr.dataPtr, pWriteRec->attrData, len );
   1737              return ( ZCL_STATUS_SUCCESS );
   1738            }
   1739            return ( ZCL_STATUS_READ_ONLY );
   1740          }
   1741          #endif // ZCL_WRITE
   1742          
   1743          #ifdef ZCL_READ
   1744          /*********************************************************************
   1745           * @fn      zclParseInReadCmd
   1746           * @brief   Parse the "Profile" Read Commands
   1747           *          NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   1748           *                FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   1749           * @param   pCmd - pointer to incoming data to parse
   1750           * @return  pointer to the parsed command structure
   1751           */
   1752          void *zclParseInReadCmd( zclParseCmd_t *pCmd )
   1753          {
   1754            zclReadCmd_t *readCmd;
   1755            uint8 *pBuf = pCmd->pData;
   1756            
   1757            readCmd = (zclReadCmd_t *)osal_mem_alloc( sizeof ( zclReadCmd_t ) + pCmd->dataLen );
   1758            if ( readCmd != NULL )
   1759            {
   1760              uint8 i;
   1761              
   1762              readCmd->numAttr = pCmd->dataLen / 2; // Atrribute ID
   1763              for ( i = 0; i < readCmd->numAttr; i++ )
   1764              {
   1765                readCmd->attrID[i] = BUILD_UINT16( pBuf[0], pBuf[1] );
   1766                pBuf += 2;
   1767              }
   1768            }
   1769            return ( (void *)readCmd );
   1770          }
   1771          
   1772          /*********************************************************************
   1773           * @fn      zclParseInReadRspCmd
   1774           * @brief   Parse the "Profile" Read Response Commands
   1775           *          NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   1776           *                FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   1777           * @param   pCmd - pointer to incoming data to parse
   1778           * @return  pointer to the parsed command structure
   1779           */
   1780          static void *zclParseInReadRspCmd( zclParseCmd_t *pCmd )
   1781          {
   1782            zclReadRspCmd_t *readRspCmd;
   1783            zclReadRspStatus_t *statusRec;
   1784            uint8 *pBuf = pCmd->pData;
   1785            uint8 *dataPtr;
   1786            uint8 numAttr = 0;
   1787            uint8 hdrLen;
   1788            uint8 dataLen = 0;
   1789            uint8 attrDataLen;
   1790            uint8 dataType;
   1791            uint8 status;
   1792            uint8 i;
   1793            
   1794            // find out the number of attributes and the length of attribute data
   1795            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   1796            {
   1797              numAttr++;
   1798          
   1799              pBuf += 2; // move pass attribute id
   1800              
   1801              status = *pBuf++;  
   1802              if ( status == ZCL_STATUS_SUCCESS )
   1803              {
   1804                dataType = *pBuf++;
   1805          
   1806                attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   1807                pBuf += attrDataLen; // move pass attribute data
   1808                
   1809                if ( PADDING_NEEDED( attrDataLen ) ) // add padding if needed
   1810                  attrDataLen++;
   1811                dataLen += attrDataLen;
   1812              }
   1813            }
   1814           
   1815            hdrLen = sizeof( zclReadRspCmd_t ) + ( numAttr * sizeof( zclReadRspStatus_t ) ); // calculate the length of the response header
   1816            
   1817            readRspCmd = (zclReadRspCmd_t *)osal_mem_alloc( hdrLen + dataLen );
   1818            if ( readRspCmd != NULL )
   1819            {
   1820              pBuf = pCmd->pData;
   1821              dataPtr = (uint8 *)( (uint8 *)readRspCmd + hdrLen );
   1822                  
   1823              readRspCmd->numAttr = numAttr;
   1824              for ( i = 0; i < numAttr; i++ )
   1825              {
   1826                statusRec = &(readRspCmd->attrList[i]);
   1827                
   1828                statusRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   1829                pBuf += 2;
   1830                
   1831                statusRec->status = *pBuf++;
   1832                if ( statusRec->status == ZCL_STATUS_SUCCESS )
   1833                {
   1834                  statusRec->dataType = *pBuf++;
   1835          
   1836                  attrDataLen = zclGetAttrDataLength( statusRec->dataType, pBuf );
   1837                  osal_memcpy( dataPtr, pBuf, attrDataLen);
   1838                  statusRec->data = dataPtr;
   1839                  
   1840                  pBuf += attrDataLen; // move pass attribute data
   1841                 
   1842                  if ( PADDING_NEEDED( attrDataLen ) ) // advance attribute data pointer
   1843                    attrDataLen++;
   1844                  dataPtr += attrDataLen;
   1845                }
   1846              }
   1847            }
   1848            return ( (void *)readRspCmd );
   1849          }
   1850          #endif // ZCL_READ
   1851          
   1852          #ifdef ZCL_WRITE
   1853          /*********************************************************************
   1854           * @fn      zclParseInWriteCmd
   1855           * @brief   Parse the "Profile" Write, Write Undivided and Write No
   1856           *          Response Commands
   1857           *          NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   1858           *                FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   1859           * @param   pCmd - pointer to incoming data to parse
   1860           * @return  pointer to the parsed command structure
   1861           */
   1862          void *zclParseInWriteCmd( zclParseCmd_t *pCmd )
   1863          {
   1864            zclWriteCmd_t *writeCmd;
   1865            zclWriteRec_t *statusRec;
   1866            uint8 *pBuf = pCmd->pData;
   1867            uint8 attrDataLen;
   1868            uint8 *dataPtr;
   1869            uint8 numAttr = 0;
   1870            uint8 hdrLen;
   1871            uint8 dataLen = 0;
   1872            uint8 dataType;
   1873            uint8 i;
   1874          
   1875            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) ) // find out the number of attributes and the length of attribute data
   1876            {
   1877              numAttr++;
   1878          
   1879              pBuf += 2; // move pass attribute id
   1880          
   1881              dataType = *pBuf++;
   1882          
   1883              attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   1884              pBuf += attrDataLen; // move pass attribute data
   1885              
   1886              if ( PADDING_NEEDED( attrDataLen ) ) // add padding if needed
   1887                attrDataLen++;
   1888              dataLen += attrDataLen;
   1889            }
   1890            
   1891            hdrLen = sizeof( zclWriteCmd_t ) + ( numAttr * sizeof( zclWriteRec_t ) ); // calculate the length of the response header
   1892            
   1893            writeCmd = (zclWriteCmd_t *)osal_mem_alloc( hdrLen + dataLen );
   1894            if ( writeCmd != NULL )
   1895            {
   1896              pBuf = pCmd->pData;
   1897              dataPtr = (uint8 *)( (uint8 *)writeCmd + hdrLen );
   1898          
   1899              writeCmd->numAttr = numAttr;
   1900              for ( i = 0; i < numAttr; i++ )
   1901              {
   1902                statusRec = &(writeCmd->attrList[i]);
   1903                
   1904                statusRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   1905                pBuf += 2;
   1906                statusRec->dataType = *pBuf++;
   1907          
   1908                attrDataLen = zclGetAttrDataLength( statusRec->dataType, pBuf );
   1909                osal_memcpy( dataPtr, pBuf, attrDataLen);
   1910                statusRec->attrData = dataPtr;
   1911                
   1912                pBuf += attrDataLen; // move pass attribute data
   1913          
   1914                if ( PADDING_NEEDED( attrDataLen ) ) // advance attribute data pointer
   1915                  attrDataLen++;
   1916                dataPtr += attrDataLen;
   1917              }
   1918            }
   1919            
   1920            return ( (void *)writeCmd );
   1921          }
   1922          
   1923          /*********************************************************************
   1924           * @fn      zclParseInWriteRspCmd
   1925           * @brief   Parse the "Profile" Write Response Commands
   1926           *          NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   1927           *                FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   1928           * @param   pCmd - pointer to incoming data to parse
   1929           * @return  pointer to the parsed command structure
   1930           */
   1931          static void *zclParseInWriteRspCmd( zclParseCmd_t *pCmd )
   1932          {
   1933            zclWriteRspCmd_t *writeRspCmd;
   1934            uint8 *pBuf = pCmd->pData;
   1935            uint8 i = 0;
   1936          
   1937            writeRspCmd = (zclWriteRspCmd_t *)osal_mem_alloc( sizeof ( zclWriteRspCmd_t ) + pCmd->dataLen );
   1938            if ( writeRspCmd != NULL )
   1939            {
   1940              if ( pCmd->dataLen == 1 )
   1941              {
   1942                writeRspCmd->attrList[i++].status = *pBuf; // special case when all writes were successfull
   1943              }
   1944              else
   1945              {
   1946                while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   1947                {
   1948                  writeRspCmd->attrList[i].status = *pBuf++;
   1949                  writeRspCmd->attrList[i++].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   1950                  pBuf += 2;
   1951                }
   1952              }
   1953              writeRspCmd->numAttr = i; 
   1954            }
   1955            return ( (void *)writeRspCmd );
   1956          }
   1957          #endif // ZCL_WRITE
   1958          
   1959          #ifdef ZCL_REPORT
   1960          /*********************************************************************
   1961           * @fn      zclParseInConfigReportCmd
   1962           * @brief   Parse the "Profile" Configure Reporting Command
   1963           *          NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   1964           *                FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   1965           * @param   pCmd - pointer to incoming data to parse
   1966           * @return  pointer to the parsed command structure
   1967           */
   1968          void *zclParseInConfigReportCmd( zclParseCmd_t *pCmd )
   1969          {
   1970            zclCfgReportCmd_t *cfgReportCmd;
   1971            zclCfgReportRec_t *reportRec;
   1972            uint8 *pBuf = pCmd->pData;
   1973            uint8 *dataPtr;
   1974            uint8 numAttr = 0;
   1975            uint8 direction;
   1976            uint8 dataType;
   1977            uint8 hdrLen;
   1978            uint8 dataLen = 0;
   1979            uint8 reportChangeLen; // length of Reportable Change field
   1980            uint8 i;
   1981           
   1982            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) ) // Calculate the length of the Request command
   1983            {
   1984              numAttr++;
   1985              
   1986              direction = *pBuf++;
   1987              pBuf += 2; // move pass the attribute ID
   1988              
   1989              if ( direction == ZCL_SEND_ATTR_REPORTS ) // Is there a Reportable Change field?
   1990              {
   1991                dataType = *pBuf++;
   1992                pBuf += 4; // move pass the Min and Max Reporting Intervals
   1993           
   1994                if ( zclAnalogDataType( dataType ) ) // For attributes of 'discrete' data types this field is omitted
   1995                {
   1996                  reportChangeLen = zclGetDataTypeLength( dataType );
   1997                  pBuf += reportChangeLen;
   1998                  
   1999                  if ( PADDING_NEEDED( reportChangeLen ) ) // add padding if needed
   2000                    reportChangeLen++;
   2001                  dataLen += reportChangeLen;
   2002                }
   2003              }
   2004              else
   2005              {
   2006                pBuf += 2; // move pass the Timeout Period
   2007              }
   2008            } // while loop
   2009          
   2010            hdrLen = sizeof( zclCfgReportCmd_t ) + ( numAttr * sizeof( zclCfgReportRec_t ) );
   2011            
   2012            cfgReportCmd = (zclCfgReportCmd_t *)osal_mem_alloc( hdrLen + dataLen );
   2013            if ( cfgReportCmd != NULL )
   2014            { 
   2015              pBuf = pCmd->pData;
   2016              dataPtr = (uint8 *)( (uint8 *)cfgReportCmd + hdrLen );
   2017              
   2018              cfgReportCmd->numAttr = numAttr;
   2019              for ( i = 0; i < numAttr; i++ )
   2020              {
   2021                reportRec = &(cfgReportCmd->attrList[i]);
   2022                
   2023                osal_memset( reportRec, 0, sizeof( zclCfgReportRec_t ) );
   2024                  
   2025                reportRec->direction = *pBuf++;
   2026                reportRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   2027                pBuf += 2;
   2028                if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
   2029                {
   2030                 
   2031                  reportRec->dataType = *pBuf++; // Attribute to be reported
   2032                  reportRec->minReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   2033                  pBuf += 2;
   2034                  reportRec->maxReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   2035                  pBuf += 2;
   2036                 
   2037                  if ( zclAnalogDataType( reportRec->dataType ) ) // For attributes of 'discrete' data types this field is omitted
   2038                  {
   2039                    zcl_BuildAnalogData( reportRec->dataType, dataPtr, pBuf);
   2040                    reportRec->reportableChange = dataPtr;
   2041                    
   2042                    reportChangeLen = zclGetDataTypeLength( reportRec->dataType );
   2043                    pBuf += reportChangeLen;
   2044                   
   2045                    if ( PADDING_NEEDED( reportChangeLen ) ) // advance attribute data pointer
   2046                      reportChangeLen++;
   2047                    dataPtr += reportChangeLen;
   2048                  }
   2049                }
   2050                else
   2051                {
   2052                  reportRec->timeoutPeriod = BUILD_UINT16( pBuf[0], pBuf[1] ); // Attribute reports to be received
   2053                  pBuf += 2;
   2054                }
   2055              } // while loop
   2056            }
   2057            return ( (void *)cfgReportCmd );
   2058          }
   2059          
   2060          /*********************************************************************
   2061           * @fn      zclParseInConfigReportRspCmd
   2062           * @brief   Parse the "Profile" Configure Reporting Response Command
   2063           *          NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2064           *                FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2065           * @param   pCmd - pointer to incoming data to parse
   2066           * @return  pointer to the parsed command structure
   2067           */
   2068          static void *zclParseInConfigReportRspCmd( zclParseCmd_t *pCmd )
   2069          {
   2070            zclCfgReportRspCmd_t *cfgReportRspCmd;
   2071            uint8 *pBuf = pCmd->pData;
   2072            uint8 numAttr;
   2073            uint8 i; 
   2074            
   2075            numAttr = pCmd->dataLen / ( 1 + 1 + 2 ); // Status + Direction + Attribute ID
   2076            
   2077            cfgReportRspCmd = (zclCfgReportRspCmd_t *)osal_mem_alloc( sizeof( zclCfgReportRspCmd_t ) 
   2078                                                      + ( numAttr * sizeof( zclCfgReportStatus_t ) ) );
   2079            if ( cfgReportRspCmd != NULL )
   2080            {
   2081              cfgReportRspCmd->numAttr = numAttr;
   2082              for ( i = 0; i < cfgReportRspCmd->numAttr; i++ )
   2083              {
   2084                cfgReportRspCmd->attrList[i].status = *pBuf++;
   2085                cfgReportRspCmd->attrList[i].direction = *pBuf++;
   2086                cfgReportRspCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   2087                pBuf += 2;
   2088              }
   2089            }
   2090            return ( (void *)cfgReportRspCmd );  
   2091          }
   2092          
   2093          /*********************************************************************
   2094           * @fn      zclParseInReadReportCfgCmd
   2095           * @brief   Parse the "Profile" Read Reporting Configuration Command
   2096           *          NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2097           *                FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2098           * @param   pCmd - pointer to incoming data to parse
   2099           * @return  pointer to the parsed command structure
   2100           */
   2101          void *zclParseInReadReportCfgCmd( zclParseCmd_t *pCmd )
   2102          {
   2103            zclReadReportCfgCmd_t *readReportCfgCmd;
   2104            uint8 *pBuf = pCmd->pData;
   2105            uint8 numAttr;
   2106            uint8 i;
   2107            
   2108            numAttr = pCmd->dataLen / ( 1 + 2 ); // Direction + Attribute ID
   2109            
   2110            readReportCfgCmd = (zclReadReportCfgCmd_t *)osal_mem_alloc( sizeof( zclReadReportCfgCmd_t ) 
   2111                                                            + ( numAttr * sizeof( zclReadReportCfgRec_t ) ) );
   2112            if ( readReportCfgCmd != NULL )
   2113            {
   2114              readReportCfgCmd->numAttr = numAttr;
   2115              for ( i = 0; i < readReportCfgCmd->numAttr; i++)
   2116              {
   2117                readReportCfgCmd->attrList[i].direction = *pBuf++;;
   2118                readReportCfgCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   2119                pBuf += 2;
   2120              }
   2121            }
   2122            return ( (void *)readReportCfgCmd );
   2123          }
   2124          
   2125          /*********************************************************************
   2126           * @fn      zclParseInReadReportCfgRspCmd
   2127           * @brief   Parse the "Profile" Read Reporting Configuration Response Command
   2128           *          NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2129           *                FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2130           * @param   pCmd - pointer to incoming data to parse
   2131           * @return  pointer to the parsed command structure
   2132           */
   2133          static void *zclParseInReadReportCfgRspCmd( zclParseCmd_t *pCmd )
   2134          {
   2135            zclReadReportCfgRspCmd_t *readReportCfgRspCmd;
   2136            zclReportCfgRspRec_t *reportRspRec;
   2137            uint8 reportChangeLen;
   2138            uint8 *pBuf = pCmd->pData;
   2139            uint8 *dataPtr;
   2140            uint8 numAttr = 0;
   2141            uint8 hdrLen;
   2142            uint8 dataLen = 0;
   2143            uint8 status;
   2144            uint8 direction;
   2145            uint8 dataType;
   2146            uint8 i;
   2147            
   2148            // Calculate the length of the response command
   2149            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   2150            { 
   2151              numAttr++;
   2152              
   2153              status = *pBuf++;
   2154              direction = *pBuf++; 
   2155              pBuf += 2; // move pass the attribute ID
   2156              
   2157              if ( status == ZCL_STATUS_SUCCESS )
   2158              {
   2159                if ( direction == ZCL_SEND_ATTR_REPORTS )
   2160                {
   2161                  dataType = *pBuf++;
   2162                  pBuf += 4; // move pass the Min and Max Reporting Intervals
   2163           
   2164                  // For attributes of 'discrete' data types this field is omitted
   2165                  if ( zclAnalogDataType( dataType ) )
   2166                  {
   2167                    reportChangeLen = zclGetDataTypeLength( dataType );
   2168                    pBuf += reportChangeLen;
   2169                    
   2170                    // add padding if needed
   2171                    if ( PADDING_NEEDED( reportChangeLen ) )
   2172                      reportChangeLen++;
   2173                    dataLen += reportChangeLen;
   2174                  }
   2175                }
   2176                else
   2177                {
   2178                  pBuf += 2; // move pass the Timeout field
   2179                }
   2180              }
   2181            } // while loop
   2182            
   2183            hdrLen = sizeof( zclReadReportCfgRspCmd_t ) + ( numAttr * sizeof( zclReportCfgRspRec_t ) );
   2184            
   2185            readReportCfgRspCmd = (zclReadReportCfgRspCmd_t *)osal_mem_alloc( hdrLen + dataLen );
   2186            if ( readReportCfgRspCmd != NULL )
   2187            {
   2188              pBuf = pCmd->pData;
   2189              dataPtr = (uint8 *)( (uint8 *)readReportCfgRspCmd + hdrLen );
   2190              
   2191              readReportCfgRspCmd->numAttr = numAttr;
   2192              for ( i = 0; i < numAttr; i++ )
   2193              {
   2194                reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   2195                
   2196                reportRspRec->status = *pBuf++;
   2197                reportRspRec->direction = *pBuf++;
   2198                reportRspRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   2199                pBuf += 2;
   2200           
   2201                if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   2202                {
   2203                  if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   2204                  {
   2205                    reportRspRec->dataType = *pBuf++;
   2206                    reportRspRec->minReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   2207                    pBuf += 2;
   2208                    reportRspRec->maxReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   2209                    pBuf += 2;
   2210          
   2211                    if ( zclAnalogDataType( reportRspRec->dataType ) )
   2212                    {
   2213                      zcl_BuildAnalogData( reportRspRec->dataType, dataPtr, pBuf);
   2214                      reportRspRec->reportableChange = dataPtr;
   2215                      
   2216                      reportChangeLen = zclGetDataTypeLength( reportRspRec->dataType ); 
   2217                      pBuf += reportChangeLen;
   2218                      
   2219                      // advance attribute data pointer
   2220                      if ( PADDING_NEEDED( reportChangeLen ) )
   2221                        reportChangeLen++;
   2222                      dataPtr += reportChangeLen;
   2223                    }
   2224                  }
   2225                  else
   2226                  {
   2227                    reportRspRec->timeoutPeriod = BUILD_UINT16( pBuf[0], pBuf[1] );
   2228                    pBuf += 2;
   2229                  }
   2230                }
   2231              } 
   2232            }
   2233            
   2234            return ( (void *)readReportCfgRspCmd );
   2235          }
   2236          
   2237          /*********************************************************************
   2238           * @fn      zclParseInReportCmd
   2239           * @brief   Parse the "Profile" Report Command
   2240           *          NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2241           *                FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2242           * @param   pCmd - pointer to incoming data to parse
   2243           * @return  pointer to the parsed command structure
   2244           */
   2245          void *zclParseInReportCmd( zclParseCmd_t *pCmd )
   2246          {
   2247            zclReportCmd_t *reportCmd;
   2248            zclReport_t *reportRec;
   2249            uint8 *pBuf = pCmd->pData;
   2250            uint8 attrDataLen;
   2251            uint8 *dataPtr;
   2252            uint8 numAttr = 0;
   2253            uint8 hdrLen;
   2254            uint8 dataLen = 0;
   2255            uint8 dataType;
   2256            uint8 i;
   2257          
   2258            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) ) // find out the number of attributes and the length of attribute data
   2259            {
   2260              numAttr++;
   2261          
   2262              pBuf += 2; // move pass attribute id
   2263              dataType = *pBuf++;
   2264              attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   2265              pBuf += attrDataLen; // move pass attribute data
   2266                
   2267              if ( PADDING_NEEDED( attrDataLen ) ) // add padding if needed
   2268                attrDataLen++;
   2269              dataLen += attrDataLen;
   2270            }
   2271            
   2272            hdrLen = sizeof( zclReportCmd_t ) + ( numAttr * sizeof( zclReport_t ) );
   2273            
   2274            reportCmd = (zclReportCmd_t *)osal_mem_alloc( hdrLen + dataLen );
   2275            if (reportCmd != NULL )
   2276            {
   2277              pBuf = pCmd->pData;
   2278              dataPtr = (uint8 *)( (uint8 *)reportCmd + hdrLen );
   2279              
   2280              reportCmd->numAttr = numAttr;
   2281              for ( i = 0; i < numAttr; i++ )
   2282              {
   2283                reportRec = &(reportCmd->attrList[i]);
   2284                
   2285                reportRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   2286                pBuf += 2;
   2287                reportRec->dataType = *pBuf++;
   2288          
   2289                attrDataLen = zclGetAttrDataLength( reportRec->dataType, pBuf );  
   2290                osal_memcpy( dataPtr, pBuf, attrDataLen );
   2291                reportRec->attrData = dataPtr;
   2292                
   2293                pBuf += attrDataLen; // move pass attribute data
   2294                
   2295                if ( PADDING_NEEDED( attrDataLen ) ) // advance attribute data pointer
   2296                  attrDataLen++;
   2297                dataPtr += attrDataLen;
   2298              }
   2299            }
   2300            return ( (void *)reportCmd );
   2301          }
   2302          #endif // ZCL_REPORT
   2303          
   2304          /*********************************************************************
   2305           * @fn      zclParseInDefaultRspCmd
   2306           * @brief   Parse the "Profile" Default Response Command
   2307           *          NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2308           *                FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2309           * @param   pCmd - pointer to incoming data to parse
   2310           * @return  pointer to the parsed command structure
   2311           */
   2312          static void *zclParseInDefaultRspCmd( zclParseCmd_t *pCmd )
   2313          {
   2314            zclDefaultRspCmd_t *defaultRspCmd;
   2315            uint8 *pBuf = pCmd->pData;
   2316          
   2317            defaultRspCmd = (zclDefaultRspCmd_t *)osal_mem_alloc( sizeof ( zclDefaultRspCmd_t ) );
   2318            if ( defaultRspCmd != NULL )
   2319            {
   2320              defaultRspCmd->commandID = *pBuf++;
   2321              defaultRspCmd->statusCode = *pBuf;
   2322            }
   2323            return ( (void *)defaultRspCmd );
   2324          }
   2325          
   2326          #ifdef ZCL_DISCOVER
   2327          /*********************************************************************
   2328           * @fn      zclParseInDiscCmd
   2329           * @brief   Parse the "Profile" Discovery Commands
   2330           *          NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2331           *                FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2332           * @param   pCmd - pointer to incoming data to parse
   2333           * @return  pointer to the parsed command structure
   2334           */
   2335          void *zclParseInDiscCmd( zclParseCmd_t *pCmd )
   2336          {
   2337            zclDiscoverCmd_t *discoverCmd;
   2338            uint8 *pBuf = pCmd->pData;
   2339          
   2340            discoverCmd = (zclDiscoverCmd_t *)osal_mem_alloc( sizeof ( zclDiscoverCmd_t ) );
   2341            if ( discoverCmd != NULL )
   2342            {
   2343              discoverCmd->startAttr = BUILD_UINT16( pBuf[0], pBuf[1] );
   2344              pBuf += 2;
   2345              discoverCmd->maxAttrIDs = *pBuf;
   2346            }
   2347            return ( (void *)discoverCmd );
   2348          }
   2349          
   2350          /*********************************************************************
   2351           * @fn      zclParseInDiscRspCmd
   2352           * @brief   Parse the "Profile" Discovery Response Commands
   2353           *          NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2354           *                FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2355           * @param   pCmd - pointer to incoming data to parse
   2356           * @return  pointer to the parsed command structure
   2357           */
   2358          #define ZCLDISCRSPCMD_DATALEN(a)  ((a)-1) // data len - Discovery Complete
   2359          static void *zclParseInDiscRspCmd( zclParseCmd_t *pCmd )
   2360          {
   2361            zclDiscoverRspCmd_t *discoverRspCmd;
   2362            uint8 *pBuf = pCmd->pData;
   2363            uint8 numAttr = ZCLDISCRSPCMD_DATALEN(pCmd->dataLen) / ( 2 + 1 ); // Attr ID + Data Type
   2364            uint8 i;
   2365          
   2366            discoverRspCmd = (zclDiscoverRspCmd_t *)osal_mem_alloc( sizeof ( zclDiscoverRspCmd_t ) 
   2367                                                           + ( numAttr * sizeof(zclDiscoverInfo_t) ) );
   2368            if ( discoverRspCmd != NULL )
   2369            {
   2370              discoverRspCmd->discComplete = *pBuf++;
   2371              discoverRspCmd->numAttr = numAttr;
   2372              
   2373              for ( i = 0; i < numAttr; i++ )
   2374              {
   2375                discoverRspCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   2376                pBuf += 2;
   2377                discoverRspCmd->attrList[i].dataType = *pBuf++;;
   2378              }
   2379            }
   2380            return ( (void *)discoverRspCmd );
   2381          }
   2382          #endif // ZCL_DISCOVER
   2383          
   2384          #ifdef ZCL_READ
   2385          /*********************************************************************
   2386           * @fn      zclProcessInReadCmd
   2387           * @brief   Process the "Profile" Read Command
   2388           * @param   pInMsg - incoming message to process
   2389           * @return  TRUE if command processed. FALSE, otherwise.
   2390           */
   2391          static uint8 zclProcessInReadCmd( zclIncoming_t *pInMsg )
   2392          {
   2393            zclReadCmd_t *readCmd;
   2394            zclReadRspCmd_t *readRspCmd;
   2395            zclReadRspStatus_t *statusRec;
   2396            zclAttrRec_t attrRec;
   2397            uint8 len;
   2398            uint8 i;
   2399            
   2400            readCmd = (zclReadCmd_t *)pInMsg->attrCmd;
   2401            
   2402            // calculate the length of the response status record
   2403            len = sizeof( zclReadRspCmd_t ) + (readCmd->numAttr * sizeof( zclReadRspStatus_t ));
   2404            
   2405            readRspCmd = osal_mem_alloc( len );
   2406            if ( readRspCmd == NULL )
   2407              return FALSE; // EMBEDDED RETURN
   2408          
   2409            readRspCmd->numAttr = readCmd->numAttr;
   2410            for (i = 0; i < readCmd->numAttr; i++)
   2411            {
   2412              statusRec = &(readRspCmd->attrList[i]);
   2413              statusRec->attrID = readCmd->attrID[i];
   2414              
   2415              if ( zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, readCmd->attrID[i], &attrRec ) )
   2416              {
   2417                statusRec->data = attrRec.attr.dataPtr;
   2418                statusRec->status = ZCL_STATUS_SUCCESS;
   2419                statusRec->dataType = attrRec.attr.dataType;
   2420              }
   2421              else
   2422              {
   2423                statusRec->status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   2424              }
   2425            }
   2426            
   2427            // Build and send Read Response command
   2428            zcl_SendReadRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr), pInMsg->msg->clusterId,
   2429                             readRspCmd, ZCL_FRAME_SERVER_CLIENT_DIR,
   2430                             true, pInMsg->hdr.transSeqNum );
   2431            osal_mem_free( readRspCmd );
   2432              
   2433            return TRUE;
   2434          }
   2435          #endif // ZCL_READ
   2436          
   2437          #ifdef ZCL_WRITE
   2438          /*********************************************************************
   2439           * @fn      processInWriteCmd
   2440           * @brief   Process the "Profile" Write and Write No Response Commands
   2441           * @param   pInMsg - incoming message to process
   2442           * @return  TRUE if command processed. FALSE, otherwise.
   2443           */
   2444          static uint8 zclProcessInWriteCmd( zclIncoming_t *pInMsg )
   2445          {
   2446            zclWriteCmd_t *writeCmd;
   2447            zclWriteRec_t *statusRec;
   2448            zclWriteRspCmd_t *writeRspCmd;
   2449            zclAttrRec_t attrRec;
   2450            uint8 sendRsp = FALSE;
   2451            uint8 status;
   2452            uint8 i, j = 0;
   2453          
   2454            writeCmd = (zclWriteCmd_t *)pInMsg->attrCmd;
   2455            if ( pInMsg->hdr.commandID == ZCL_CMD_WRITE )
   2456            {
   2457              // We need to send a response back - allocate space for it
   2458              writeRspCmd = (zclWriteRspCmd_t *)osal_mem_alloc( sizeof( zclWriteRspCmd_t ) 
   2459                      + sizeof( zclWriteRspStatus_t ) * writeCmd->numAttr );
   2460              if ( writeRspCmd == NULL )
   2461                return FALSE; // EMBEDDED RETURN
   2462              sendRsp = TRUE;
   2463            }
   2464            
   2465            for (i = 0; i < writeCmd->numAttr; i++)
   2466            {
   2467              statusRec = &(writeCmd->attrList[i]);
   2468              if ( zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, statusRec->attrID, &attrRec ) )
   2469              {
   2470                if ( statusRec->dataType == attrRec.attr.dataType )
   2471                {
   2472                  status = zclWriteAttrData( &attrRec, statusRec );
   2473          
   2474                  if ( sendRsp && status != ZCL_STATUS_SUCCESS ) // If successful, a write attribute status record shall NOT be generated
   2475                  {
   2476                    writeRspCmd->attrList[j].status = status; // Attribute is read only - move on to the next write attribute record
   2477                    writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   2478                  }
   2479                }
   2480                else
   2481                {
   2482                  if ( sendRsp ) // Attribute data type is incorrect - move on to the next write attribute record
   2483                  {
   2484                    writeRspCmd->attrList[j].status = ZCL_STATUS_INVALID_DATA_TYPE;
   2485                    writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   2486                  }
   2487                }
   2488              }
   2489              else
   2490              {
   2491                if ( sendRsp ) // Attribute is not supported - move on to the next write attribute record
   2492                {
   2493                  writeRspCmd->attrList[j].status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   2494                  writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   2495                }
   2496              }
   2497            } // for loop
   2498          
   2499            if ( sendRsp )
   2500            {
   2501              writeRspCmd->numAttr = j;
   2502              if ( writeRspCmd->numAttr == 0 )
   2503              {
   2504                // Since all records were written successful, include a single status record in the resonse command 
   2505                // with the status field set to SUCCESS and the attribute ID field omitted.
   2506                writeRspCmd->attrList[0].status = ZCL_STATUS_SUCCESS;
   2507                writeRspCmd->numAttr = 1;
   2508              }
   2509              zcl_SendWriteRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   2510                                pInMsg->msg->clusterId, writeRspCmd, ZCL_FRAME_SERVER_CLIENT_DIR, 
   2511                                true, pInMsg->hdr.transSeqNum );
   2512              osal_mem_free( writeRspCmd );
   2513            }
   2514            return TRUE; 
   2515          }
   2516          
   2517          /*********************************************************************
   2518           * @fn      zclRevertWriteUndividedCmd
   2519           * @brief   Revert the "Profile" Write Undevided Command
   2520           * @param   pInMsg - incoming message to process
   2521           *          curWriteRec - old data
   2522           *          numAttr - number of attributes to be reverted
   2523           */
   2524          static void zclRevertWriteUndividedCmd( zclIncoming_t *pInMsg, zclWriteRec_t *curWriteRec, uint16 numAttr )
   2525          {
   2526            zclWriteRec_t *statusRec;
   2527            zclAttrRec_t attrRec;
   2528            uint8 dataLen;
   2529            uint8 i;
   2530          
   2531            statusRec = curWriteRec;
   2532            for (i = 0; i < numAttr; i++)
   2533            {
   2534              statusRec = &(curWriteRec[i]);
   2535              
   2536              if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, statusRec->attrID, &attrRec ) )
   2537                break; // should never happen
   2538           
   2539              // Just copy the old data back - no need to validate the data
   2540              dataLen = zclGetAttrDataLength( attrRec.attr.dataType, statusRec->attrData );
   2541              osal_memcpy( attrRec.attr.dataPtr, statusRec->attrData, dataLen );
   2542            } // for loop
   2543          }
   2544          
   2545          /*********************************************************************
   2546           * @fn      zclProcessInWriteUndividedCmd
   2547           * @brief   Process the "Profile" Write Undivided Command
   2548           * @param   pInMsg - incoming message to process
   2549           * @return  TRUE if command processed. FALSE, otherwise.
   2550           */
   2551          static uint8 zclProcessInWriteUndividedCmd( zclIncoming_t *pInMsg )
   2552          {
   2553            zclWriteCmd_t *writeCmd;
   2554            zclWriteRec_t *statusRec;
   2555            zclWriteRec_t *curWriteRec;
   2556            zclWriteRec_t *curStatusRec;
   2557            zclWriteRspCmd_t *writeRspCmd;
   2558            zclAttrRec_t attrRec;
   2559            uint8 *curDataPtr;
   2560            uint8 hdrLen;
   2561            uint8 dataLen;
   2562            uint8 curLen = 0;
   2563            uint8 status;
   2564            uint8 i, j = 0;
   2565          
   2566            writeCmd = (zclWriteCmd_t *)pInMsg->attrCmd;
   2567            
   2568            // Allocate space for Write Response Command
   2569            writeRspCmd = (zclWriteRspCmd_t *)osal_mem_alloc( sizeof( zclWriteRspCmd_t ) + sizeof( zclWriteRspStatus_t )* writeCmd->numAttr );
   2570            
   2571            if ( writeRspCmd == NULL )
   2572              return FALSE; // EMBEDDED RETURN
   2573            
   2574            // If any attribute cannot be written, no attribute values are changed. Hence,
   2575            // make sure all the attributes are supported and writable
   2576            for (i = 0; i < writeCmd->numAttr; i++)
   2577            {
   2578              statusRec = &(writeCmd->attrList[i]);
   2579              
   2580              if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, statusRec->attrID, &attrRec ) )
   2581              {
   2582                // Attribute is not supported - stop here
   2583                writeRspCmd->attrList[j].status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   2584                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   2585                break;
   2586              }
   2587              
   2588              if ( statusRec->dataType != attrRec.attr.dataType )
   2589              {
   2590                // Attribute data type is incorrect - stope here
   2591                writeRspCmd->attrList[j].status = ZCL_STATUS_INVALID_DATA_TYPE;
   2592                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   2593                break;
   2594              }
   2595              
   2596              if ( !zcl_AccessCtrlWrite( attrRec.attr.accessControl ) )
   2597              {
   2598                // Attribute is not writable - stop here
   2599                writeRspCmd->attrList[j].status = ZCL_STATUS_READ_ONLY;
   2600                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   2601                break;
   2602              }  
   2603              dataLen = zclGetAttrDataLength( statusRec->dataType, statusRec->attrData );
   2604              
   2605              // add padding if needed
   2606              if ( PADDING_NEEDED( dataLen ) )
   2607                dataLen++;
   2608              curLen += dataLen;
   2609            } // for loop
   2610            
   2611            writeRspCmd->numAttr = j;
   2612            if ( writeRspCmd->numAttr == 0 ) // All attributes can be written
   2613            {
   2614              // calculate the length of the current data header
   2615              hdrLen = j * sizeof( zclWriteRec_t );
   2616            
   2617              // Allocate space to keep a copy of the current data
   2618              curWriteRec = (zclWriteRec_t *) osal_mem_alloc( hdrLen + curLen ); 
   2619              if ( curWriteRec == NULL )
   2620              {
   2621                osal_mem_free(writeRspCmd );
   2622                return FALSE; // EMBEDDED RETURN
   2623              }
   2624          
   2625              curDataPtr = (uint8 *)((uint8 *)curWriteRec + hdrLen);
   2626              
   2627              // Write the new data over
   2628              for (i = 0; i < writeCmd->numAttr; i++)
   2629              {
   2630                statusRec = &(writeCmd->attrList[i]);
   2631                curStatusRec = &(curWriteRec[i]);
   2632              
   2633                if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, statusRec->attrID, &attrRec ) )
   2634                  break; // should never happen
   2635          
   2636                // Keep a copy of the current data before before writing the new data over
   2637                curStatusRec->attrID = statusRec->attrID;
   2638                zclReadAttrData( curDataPtr, &attrRec );
   2639                curStatusRec->attrData = curDataPtr;
   2640                
   2641                status = zclWriteAttrData( &attrRec, statusRec );
   2642                   
   2643                // If successful, a write attribute status record shall NOT be generated
   2644                if ( status != ZCL_STATUS_SUCCESS )
   2645                {
   2646                  writeRspCmd->attrList[j].status = status;
   2647                  writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   2648                    
   2649                  // Since this write failed, we need to revert all the pervious writes
   2650                  zclRevertWriteUndividedCmd( pInMsg, curWriteRec, i);
   2651                  break;
   2652                }
   2653                
   2654                dataLen = zclGetAttrDataLength( statusRec->dataType, statusRec->attrData );
   2655                
   2656                // add padding if needed
   2657                if ( PADDING_NEEDED( dataLen ) )
   2658                  dataLen++;
   2659                curDataPtr += dataLen;
   2660              } // for loop
   2661            
   2662              writeRspCmd->numAttr = j;
   2663              if ( writeRspCmd->numAttr  == 0 )
   2664              {
   2665                // Since all records were written successful, include a single status record in the resonse command
   2666                // with the status field set to SUCCESS and the attribute ID field omitted.
   2667                writeRspCmd->attrList[0].status = ZCL_STATUS_SUCCESS;
   2668                writeRspCmd->numAttr = 1;
   2669              }
   2670          
   2671              osal_mem_free( curWriteRec );
   2672            }
   2673            
   2674            zcl_SendWriteRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   2675                              pInMsg->msg->clusterId, writeRspCmd, ZCL_FRAME_SERVER_CLIENT_DIR, 
   2676                              true, pInMsg->hdr.transSeqNum );  
   2677            osal_mem_free( writeRspCmd );
   2678           
   2679            return TRUE; 
   2680          }
   2681          #endif // ZCL_WRITE
   2682          
   2683          #ifdef ZCL_DISCOVER
   2684          /*********************************************************************
   2685           * @fn      zclProcessInDiscCmd
   2686           * @brief   Process the "Profile" Discover Command
   2687           * @param   pInMsg - incoming message to process
   2688           * @return  TRUE if command processed. FALSE, otherwise.
   2689           */
   2690          static uint8 zclProcessInDiscCmd( zclIncoming_t *pInMsg )
   2691          {
   2692            zclDiscoverCmd_t *discoverCmd;
   2693            zclDiscoverRspCmd_t *discoverRspCmd;
   2694            uint8 discComplete = TRUE;
   2695            zclAttrRec_t attrRec;
   2696            uint16 attrID;
   2697            uint8 i;
   2698            
   2699            discoverCmd = (zclDiscoverCmd_t *)pInMsg->attrCmd;
   2700            
   2701            // Find out the number of attributes supported within the specified range
   2702            for ( i = 0, attrID = discoverCmd->startAttr; i < discoverCmd->maxAttrIDs; i++, attrID++ )
   2703            {
   2704              if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, &attrID, &attrRec ) )
   2705                break;
   2706            }
   2707            
   2708            // Allocate space for the response command
   2709            discoverRspCmd = (zclDiscoverRspCmd_t *)osal_mem_alloc( sizeof (zclDiscoverRspCmd_t) 
   2710                                                                   + sizeof ( zclDiscoverInfo_t ) * i );
   2711            if ( discoverRspCmd == NULL )
   2712              return FALSE; // EMEDDED RETURN
   2713            
   2714            discoverRspCmd->numAttr = i;
   2715            if ( discoverRspCmd->numAttr != 0 )
   2716            {
   2717              for ( i = 0, attrID = discoverCmd->startAttr; i < discoverRspCmd->numAttr; i++, attrID++ )
   2718              {
   2719                if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, &attrID, &attrRec ) )
   2720                  break; // Attribute not supported
   2721                
   2722                discoverRspCmd->attrList[i].attrID = attrRec.attr.attrId;
   2723                discoverRspCmd->attrList[i].dataType = attrRec.attr.dataType;
   2724              }
   2725              
   2726              // Are there more attributes to be discovered?
   2727              if ( zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, &attrID, &attrRec ) )
   2728                discComplete = FALSE;
   2729            }
   2730            
   2731            discoverRspCmd->discComplete = discComplete;
   2732            zcl_SendDiscoverRspCmd( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr, 
   2733                                    pInMsg->msg->clusterId, discoverRspCmd, ZCL_FRAME_SERVER_CLIENT_DIR, 
   2734                                    true, pInMsg->hdr.transSeqNum );
   2735            osal_mem_free( discoverRspCmd );
   2736            
   2737            return TRUE;
   2738          }
   2739          #endif // ZCL_DISCOVER
   2740          
   2741          /*********************************************************************
   2742           * @fn      zclSendMsg
   2743           * @brief   Send an incoming message to the Application
   2744           * @param   pInMsg - incoming message to process
   2745           * @return  TRUE
   2746           */
   2747          static uint8 zclSendMsg( zclIncoming_t *pInMsg )
   2748          {
   2749            zclIncomingMsg_t *pCmd;
   2750              
   2751            if ( zcl_RegisteredMsgTaskID == TASK_NO_TASK )
   2752              return ( TRUE );
   2753            
   2754            pCmd = (zclIncomingMsg_t *)osal_msg_allocate( sizeof ( zclIncomingMsg_t ) );
   2755            if ( pCmd != NULL )
   2756            {
   2757              // fill in the message
   2758              pCmd->hdr.event = ZCL_INCOMING_MSG;
   2759              pCmd->zclHdr    = pInMsg->hdr;
   2760              pCmd->clusterId = pInMsg->msg->clusterId;
   2761              pCmd->srcAddr   = pInMsg->msg->srcAddr;
   2762              pCmd->attrCmd   = pInMsg->attrCmd;
   2763              
   2764              // Application will free the attrCmd buffer
   2765              pInMsg->attrCmd = NULL;
   2766              
   2767              /* send message through task message */
   2768              osal_msg_send( zcl_RegisteredMsgTaskID, (uint8 *)pCmd );
   2769            }
   2770            return ( TRUE );
   2771          }
   2772          
   2773          /*********************************************************************
   2774          *********************************************************************/

Errors: 1
Warnings: none
