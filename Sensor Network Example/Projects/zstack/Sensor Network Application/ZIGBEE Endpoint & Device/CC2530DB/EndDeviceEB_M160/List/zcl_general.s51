///////////////////////////////////////////////////////////////////////////////
//                                                                            /
// IAR C/C++ Compiler V7.51A/W32 for 8051               06/Sep/2013  11:20:58 /
// Copyright 2004-2009 IAR Systems AB.                                        /
//                                                                            /
//    Core               =  plain                                             /
//    Code model         =  banked                                            /
//    Data model         =  large                                             /
//    Calling convention =  xdata reentrant                                   /
//    Constant location  =  data_rom                                          /
//    Dptr setup         =  1,16                                              /
//    Source file        =  D:\GitHub\z-stack\Sensor Network                  /
//                          Example\Components\stack\zcl\zcl_general.c        /
//    Command line       =  -f "D:\GitHub\z-stack\Sensor Network              /
//                          Example\Projects\zstack\Sensor Network            /
//                          Application\ZIGBEE Endpoint &                     /
//                          Device\CC2530DB\..\..\..\Tools\CC2530DB\f8wEndev. /
//                          cfg" (-DCPU32MHZ -DROOT=__near_func               /
//                          -DBLINK_LEDS) -f "D:\GitHub\z-stack\Sensor        /
//                          Network Example\Projects\zstack\Sensor Network    /
//                          Application\ZIGBEE Endpoint &                     /
//                          Device\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig /
//                          .cfg" (-DSECURE=0 -DZG_SECURE_DYNAMIC=0           /
//                          -DREFLECTOR -DDEFAULT_CHANLIST=0x00000800         /
//                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                      /
//                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_M /
//                          ASK=0x007F -DBEACON_REQUEST_DELAY=100             /
//                          -DBEACON_REQ_DELAY_MASK=0x00FF                    /
//                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_P /
//                          OLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7           /
//                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3   /
//                          -DNWK_MAX_DATA_RETRIES=2                          /
//                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9        /
//                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40          /
//                          -DNWK_MAX_BINDING_ENTRIES=4                       /
//                          -DMAX_BINDING_CLUSTER_IDS=4                       /
//                          "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07, 0x09,     /
//                          0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08,   /
//                          0x0A, 0x0C, 0x0D}" -DMAC_MAX_FRAME_SIZE=116       /
//                          "-DCONST=const __code" -DGENERIC=__generic        /
//                          -DRFD_RCVC_ALWAYS_ON=TRUE -DPOLL_RATE=1000        /
//                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100   /
//                          -DREJOIN_POLL_RATE=440) -f                        /
//                          "D:\GitHub\z-stack\Sensor Network                 /
//                          Example\Projects\zstack\Sensor Network            /
//                          Application\ZIGBEE Endpoint &                     /
//                          Device\CC2530DB\..\..\..\Tools\CC2530DB\f8wZCL.cf /
//                          g" (-DZCL_READ -DZCL_WRITE -DZCL_BASIC            /
//                          -DZCL_IDENTIFY -DZCL_ON_OFF -DZCL_KEY_ESTABLISH   /
//                          -DZCL_LOAD_CONTROL -DZCL_SIMPLE_METERING          /
//                          -DZCL_PRICING) -DZCL_MESSAGE                      /
//                          "D:\GitHub\z-stack\Sensor Network                 /
//                          Example\Components\stack\zcl\zcl_general.c" -D    /
//                          NWK_AUTO_POLL -D ZTOOL_P1 -D MT_TASK -D           /
//                          MT_APP_FUNC -D MT_SYS_FUNC -D MT_ZDO_FUNC -D      /
//                          LCD_SUPPORTED=DEBUG -D xPOWER_SAVING -D           /
//                          End_Device -D HAL_KEYPAD -D xPA2591 -D            /
//                          HAL_TIMER=TRUE -D MMN_UART -lC                    /
//                          "D:\GitHub\z-stack\Sensor Network                 /
//                          Example\Projects\zstack\Sensor Network            /
//                          Application\ZIGBEE Endpoint &                     /
//                          Device\CC2530DB\EndDeviceEB_M160\List\" -lA       /
//                          "D:\GitHub\z-stack\Sensor Network                 /
//                          Example\Projects\zstack\Sensor Network            /
//                          Application\ZIGBEE Endpoint &                     /
//                          Device\CC2530DB\EndDeviceEB_M160\List\"           /
//                          --diag_suppress Pe001,Pa010 -o                    /
//                          "D:\GitHub\z-stack\Sensor Network                 /
//                          Example\Projects\zstack\Sensor Network            /
//                          Application\ZIGBEE Endpoint &                     /
//                          Device\CC2530DB\EndDeviceEB_M160\Obj\" -e         /
//                          --require_prototypes --debug --core=plain         /
//                          --dptr=16,1 --data_model=large                    /
//                          --code_model=banked --calling_convention=xdata_re /
//                          entrant --place_constants=data_rom                /
//                          --nr_virtual_regs 16 -I                           /
//                          "D:\GitHub\z-stack\Sensor Network                 /
//                          Example\Projects\zstack\Sensor Network            /
//                          Application\ZIGBEE Endpoint & Device\CC2530DB\"   /
//                          -I "D:\GitHub\z-stack\Sensor Network              /
//                          Example\Projects\zstack\Sensor Network            /
//                          Application\ZIGBEE Endpoint &                     /
//                          Device\CC2530DB\..\SOURCE\" -I                    /
//                          "D:\GitHub\z-stack\Sensor Network                 /
//                          Example\Projects\zstack\Sensor Network            /
//                          Application\ZIGBEE Endpoint &                     /
//                          Device\CC2530DB\..\..\SOURCE\" -I                 /
//                          "D:\GitHub\z-stack\Sensor Network                 /
//                          Example\Projects\zstack\Sensor Network            /
//                          Application\ZIGBEE Endpoint &                     /
//                          Device\CC2530DB\..\..\..\ZMAIN\TI2530DB\" -I      /
//                          "D:\GitHub\z-stack\Sensor Network                 /
//                          Example\Projects\zstack\Sensor Network            /
//                          Application\ZIGBEE Endpoint &                     /
//                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\MT\"    /
//                          -I "D:\GitHub\z-stack\Sensor Network              /
//                          Example\Projects\zstack\Sensor Network            /
//                          Application\ZIGBEE Endpoint &                     /
//                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\INC /
//                          LUDE\" -I "D:\GitHub\z-stack\Sensor Network       /
//                          Example\Projects\zstack\Sensor Network            /
//                          Application\ZIGBEE Endpoint &                     /
//                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\MOD /
//                          ULE\" -I "D:\GitHub\z-stack\Sensor Network        /
//                          Example\Projects\zstack\Sensor Network            /
//                          Application\ZIGBEE Endpoint &                     /
//                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\TAR /
//                          GET\CC2530EB\" -I "D:\GitHub\z-stack\Sensor       /
//                          Network Example\Projects\zstack\Sensor Network    /
//                          Application\ZIGBEE Endpoint &                     /
//                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\OSAL\MC /
//                          U\CCSOC\" -I "D:\GitHub\z-stack\Sensor Network    /
//                          Example\Projects\zstack\Sensor Network            /
//                          Application\ZIGBEE Endpoint &                     /
//                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\OSAL\IN /
//                          CLUDE\" -I "D:\GitHub\z-stack\Sensor Network      /
//                          Example\Projects\zstack\Sensor Network            /
//                          Application\ZIGBEE Endpoint &                     /
//                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\A /
//                          F\" -I "D:\GitHub\z-stack\Sensor Network          /
//                          Example\Projects\zstack\Sensor Network            /
//                          Application\ZIGBEE Endpoint &                     /
//                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\N /
//                          WK\" -I "D:\GitHub\z-stack\Sensor Network         /
//                          Example\Projects\zstack\Sensor Network            /
//                          Application\ZIGBEE Endpoint &                     /
//                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\S /
//                          EC\" -I "D:\GitHub\z-stack\Sensor Network         /
//                          Example\Projects\zstack\Sensor Network            /
//                          Application\ZIGBEE Endpoint &                     /
//                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\S /
//                          API\" -I "D:\GitHub\z-stack\Sensor Network        /
//                          Example\Projects\zstack\Sensor Network            /
//                          Application\ZIGBEE Endpoint &                     /
//                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\S /
//                          YS\" -I "D:\GitHub\z-stack\Sensor Network         /
//                          Example\Projects\zstack\Sensor Network            /
//                          Application\ZIGBEE Endpoint &                     /
//                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\Z /
//                          CL\" -I "D:\GitHub\z-stack\Sensor Network         /
//                          Example\Projects\zstack\Sensor Network            /
//                          Application\ZIGBEE Endpoint &                     /
//                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\Z /
//                          DO\" -I "D:\GitHub\z-stack\Sensor Network         /
//                          Example\Projects\zstack\Sensor Network            /
//                          Application\ZIGBEE Endpoint &                     /
//                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\ZMAC\F8 /
//                          W\" -I "D:\GitHub\z-stack\Sensor Network          /
//                          Example\Projects\zstack\Sensor Network            /
//                          Application\ZIGBEE Endpoint &                     /
//                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\ZMAC\"  /
//                          -I "D:\GitHub\z-stack\Sensor Network              /
//                          Example\Projects\zstack\Sensor Network            /
//                          Application\ZIGBEE Endpoint &                     /
//                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\SERVICE /
//                          S\SADDR\" -I "D:\GitHub\z-stack\Sensor Network    /
//                          Example\Projects\zstack\Sensor Network            /
//                          Application\ZIGBEE Endpoint &                     /
//                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\SERVICE /
//                          S\SDATA\" -I "D:\GitHub\z-stack\Sensor Network    /
//                          Example\Projects\zstack\Sensor Network            /
//                          Application\ZIGBEE Endpoint &                     /
//                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\INC /
//                          LUDE\" -I "D:\GitHub\z-stack\Sensor Network       /
//                          Example\Projects\zstack\Sensor Network            /
//                          Application\ZIGBEE Endpoint &                     /
//                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\HIG /
//                          H_LEVEL\" -I "D:\GitHub\z-stack\Sensor Network    /
//                          Example\Projects\zstack\Sensor Network            /
//                          Application\ZIGBEE Endpoint &                     /
//                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\LOW /
//                          _LEVEL\srf04\" -I "D:\GitHub\z-stack\Sensor       /
//                          Network Example\Projects\zstack\Sensor Network    /
//                          Application\ZIGBEE Endpoint &                     /
//                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\LOW /
//                          _LEVEL\srf04\SINGLE_CHIP\" -I "C:\Program Files   /
//                          (x86)\IAR Systems\Embedded Workbench              /
//                          5.3\8051\INC\" -I "C:\Program Files (x86)\IAR     /
//                          Systems\Embedded Workbench 5.3\8051\INC\CLIB\"    /
//                          -Ohz                                              /
//    List file          =  D:\GitHub\z-stack\Sensor Network                  /
//                          Example\Projects\zstack\Sensor Network            /
//                          Application\ZIGBEE Endpoint &                     /
//                          Device\CC2530DB\EndDeviceEB_M160\List\zcl_general /
//                          .s51                                              /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME zcl_general

        RTMODEL "__calling_convention", "xdata_reentrant"
        RTMODEL "__code_model", "banked"
        RTMODEL "__core", "plain"
        RTMODEL "__data_model", "large"
        RTMODEL "__dptr_size", "16"
        RTMODEL "__extended_stack", "disabled"
        RTMODEL "__location_for_constants", "data"
        RTMODEL "__number_of_dptrs", "1"
        RTMODEL "__rt_version", "1"

        RSEG DOVERLAY:DATA:NOROOT(0)
        RSEG IOVERLAY:IDATA:NOROOT(0)
        RSEG ISTACK:IDATA:NOROOT(0)
        RSEG PSTACK:XDATA:NOROOT(0)
        RSEG XSTACK:XDATA:NOROOT(0)

        EXTERN ??zclGeneral_HdlInSpecificCommands?relay
        EXTERN ??zclGeneral_HdlIncoming?relay
        EXTERN ??zclGeneral_ProcessInIdentity?relay
        EXTERN ??zclGeneral_SendIdentifyQueryResponse?relay
        EXTERN ?ALLOC_XSTACK8
        EXTERN ?BANKED_ENTER_XDATA
        EXTERN ?BANKED_LEAVE_XDATA
        EXTERN ?BDISPATCH
        EXTERN ?BRET
        EXTERN ?CALL_IND
        EXTERN ?DEALLOC_XSTACK8
        EXTERN ?PUSH_XSTACK_I_ONE
        EXTERN ?PUSH_XSTACK_I_TWO
        EXTERN ?UC_SWITCH_SPARSE
        EXTERN ?V0
        EXTERN ?XSP
        EXTERN ?XSTACK_DISP0_8
        EXTERN __INIT_XDATA_Z

        FUNCTION ??zclGeneral_HdlInSpecificCommands?relay,0203H
        FUNCTION ??zclGeneral_HdlIncoming?relay,0203H
        FUNCTION ??zclGeneral_ProcessInIdentity?relay,0203H
        PUBLIC ??zclGeneral_RegisterCmdCallbacks?relay
        FUNCTION ??zclGeneral_RegisterCmdCallbacks?relay,0203H
        PUBLIC ??zclGeneral_SendIdentify?relay
        FUNCTION ??zclGeneral_SendIdentify?relay,0203H
        PUBLIC ??zclGeneral_SendIdentifyQueryResponse?relay
        FUNCTION ??zclGeneral_SendIdentifyQueryResponse?relay,0203H
        FUNCTION zclGeneral_HdlInSpecificCommands,0a1203H
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 10, STACK
        FUNCTION zclGeneral_HdlIncoming,021603H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        FUNCTION zclGeneral_ProcessInIdentity,021203H
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 28, STACK
        PUBLIC zclGeneral_RegisterCmdCallbacks
        FUNCTION zclGeneral_RegisterCmdCallbacks,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 14, STACK
        PUBLIC zclGeneral_SendIdentify
        FUNCTION zclGeneral_SendIdentify,021203H
        ARGFRAME XSTACK, 2, STACK
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 23, STACK
        PUBLIC zclGeneral_SendIdentifyQueryResponse
        FUNCTION zclGeneral_SendIdentifyQueryResponse,021203H
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 23, STACK
        
        CFI Names cfiNames0
        CFI StackFrame CFA_SP SP IDATA
        CFI StackFrame CFA_PSP16 PSP16 XDATA
        CFI StackFrame CFA_XSP16 XSP16 XDATA
        CFI StaticOverlayFrame CFA_IOVERLAY IOVERLAY
        CFI StaticOverlayFrame CFA_DOVERLAY DOVERLAY
        CFI Resource `PSW.CY`:1, `B.BR0`:1, `B.BR1`:1, `B.BR2`:1, `B.BR3`:1
        CFI Resource `B.BR4`:1, `B.BR5`:1, `B.BR6`:1, `B.BR7`:1, `VB.BR8`:1
        CFI Resource `VB.BR9`:1, `VB.BR10`:1, `VB.BR11`:1, `VB.BR12`:1
        CFI Resource `VB.BR13`:1, `VB.BR14`:1, `VB.BR15`:1, VB:8, B:8, A:8
        CFI Resource PSW:8, DPL0:8, DPH0:8, R0:8, R1:8, R2:8, R3:8, R4:8, R5:8
        CFI Resource R6:8, R7:8, V0:8, V1:8, V2:8, V3:8, V4:8, V5:8, V6:8, V7:8
        CFI Resource V8:8, V9:8, V10:8, V11:8, V12:8, V13:8, V14:8, V15:8, SP:8
        CFI Resource PSPH:8, PSPL:8, PSP16:16, XSPH:8, XSPL:8, XSP16:16
        CFI VirtualResource ?RET:24
        CFI Resource ?BRET_EXT:8
        CFI VirtualResource ?RET_HIGH:8, ?RET_LOW:8
        CFI ResourceParts PSP16 PSPH, PSPL
        CFI ResourceParts XSP16 XSPH, XSPL
        CFI ResourceParts ?RET ?BRET_EXT, ?RET_HIGH, ?RET_LOW
        CFI EndNames cfiNames0
        
        CFI Common cfiCommon0 Using cfiNames0
        CFI CodeAlign 1
        CFI DataAlign -1
        CFI ReturnAddress ?RET CODE
        CFI CFA_DOVERLAY Used
        CFI CFA_IOVERLAY Used
        CFI CFA_SP SP+-3
        CFI CFA_PSP16 PSP16+0
        CFI CFA_XSP16 XSP16+0
        CFI `PSW.CY` SameValue
        CFI `B.BR0` SameValue
        CFI `B.BR1` SameValue
        CFI `B.BR2` SameValue
        CFI `B.BR3` SameValue
        CFI `B.BR4` SameValue
        CFI `B.BR5` SameValue
        CFI `B.BR6` SameValue
        CFI `B.BR7` SameValue
        CFI `VB.BR8` SameValue
        CFI `VB.BR9` SameValue
        CFI `VB.BR10` SameValue
        CFI `VB.BR11` SameValue
        CFI `VB.BR12` SameValue
        CFI `VB.BR13` SameValue
        CFI `VB.BR14` SameValue
        CFI `VB.BR15` SameValue
        CFI VB SameValue
        CFI B Undefined
        CFI A Undefined
        CFI PSW SameValue
        CFI DPL0 SameValue
        CFI DPH0 SameValue
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 Undefined
        CFI R5 Undefined
        CFI R6 SameValue
        CFI R7 SameValue
        CFI V0 SameValue
        CFI V1 SameValue
        CFI V2 SameValue
        CFI V3 SameValue
        CFI V4 SameValue
        CFI V5 SameValue
        CFI V6 SameValue
        CFI V7 SameValue
        CFI V8 SameValue
        CFI V9 SameValue
        CFI V10 SameValue
        CFI V11 SameValue
        CFI V12 SameValue
        CFI V13 SameValue
        CFI V14 SameValue
        CFI V15 SameValue
        CFI PSPH Undefined
        CFI PSPL Undefined
        CFI XSPH Undefined
        CFI XSPL Undefined
        CFI ?RET Concat
        CFI ?BRET_EXT Frame(CFA_SP, 3)
        CFI ?RET_HIGH Frame(CFA_SP, 2)
        CFI ?RET_LOW Frame(CFA_SP, 1)
        CFI EndCommon cfiCommon0
        
        
        CFI Common cfiCommon1 Using cfiNames0
        CFI CodeAlign 1
        CFI DataAlign -1
        CFI ReturnAddress ?RET CODE
        CFI CFA_DOVERLAY Used
        CFI CFA_IOVERLAY Used
        CFI CFA_SP SP+-2
        CFI CFA_PSP16 PSP16+0
        CFI CFA_XSP16 XSP16+0
        CFI `PSW.CY` SameValue
        CFI `B.BR0` SameValue
        CFI `B.BR1` SameValue
        CFI `B.BR2` SameValue
        CFI `B.BR3` SameValue
        CFI `B.BR4` SameValue
        CFI `B.BR5` SameValue
        CFI `B.BR6` SameValue
        CFI `B.BR7` SameValue
        CFI `VB.BR8` SameValue
        CFI `VB.BR9` SameValue
        CFI `VB.BR10` SameValue
        CFI `VB.BR11` SameValue
        CFI `VB.BR12` SameValue
        CFI `VB.BR13` SameValue
        CFI `VB.BR14` SameValue
        CFI `VB.BR15` SameValue
        CFI VB SameValue
        CFI B SameValue
        CFI A SameValue
        CFI PSW SameValue
        CFI DPL0 SameValue
        CFI DPH0 SameValue
        CFI R0 SameValue
        CFI R1 SameValue
        CFI R2 SameValue
        CFI R3 SameValue
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI V0 SameValue
        CFI V1 SameValue
        CFI V2 SameValue
        CFI V3 SameValue
        CFI V4 SameValue
        CFI V5 SameValue
        CFI V6 SameValue
        CFI V7 SameValue
        CFI V8 SameValue
        CFI V9 SameValue
        CFI V10 SameValue
        CFI V11 SameValue
        CFI V12 SameValue
        CFI V13 SameValue
        CFI V14 SameValue
        CFI V15 SameValue
        CFI PSPH Undefined
        CFI PSPL Undefined
        CFI XSPH Undefined
        CFI XSPL Undefined
        CFI ?RET Concat
        CFI ?BRET_EXT SameValue
        CFI ?RET_HIGH Frame(CFA_SP, 2)
        CFI ?RET_LOW Frame(CFA_SP, 1)
        CFI EndCommon cfiCommon1
        
zcl_registerPlugin  SYMBOL "zcl_registerPlugin"
osal_mem_alloc      SYMBOL "osal_mem_alloc"
zcl_SendCommand     SYMBOL "zcl_SendCommand"
zclFindAttrRec      SYMBOL "zclFindAttrRec"
zclReadAttrData     SYMBOL "zclReadAttrData"
??osal_mem_alloc?relay SYMBOL "?relay", osal_mem_alloc
??zclFindAttrRec?relay SYMBOL "?relay", zclFindAttrRec
??zclReadAttrData?relay SYMBOL "?relay", zclReadAttrData
??zcl_SendCommand?relay SYMBOL "?relay", zcl_SendCommand
??zcl_registerPlugin?relay SYMBOL "?relay", zcl_registerPlugin
zclGeneral_RegisterCmdCallbacks SYMBOL "zclGeneral_RegisterCmdCallbacks"
??zclGeneral_RegisterCmdCallbacks?relay SYMBOL "?relay", zclGeneral_RegisterCmdCallbacks
zclGeneral_SendIdentify SYMBOL "zclGeneral_SendIdentify"
??zclGeneral_SendIdentify?relay SYMBOL "?relay", zclGeneral_SendIdentify
zclGeneral_SendIdentifyQueryResponse SYMBOL "zclGeneral_SendIdentifyQueryResponse"
??zclGeneral_SendIdentifyQueryResponse?relay SYMBOL "?relay", zclGeneral_SendIdentifyQueryResponse

        EXTERN zcl_registerPlugin
        FUNCTION zcl_registerPlugin,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN osal_mem_alloc
        FUNCTION osal_mem_alloc,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN zcl_SendCommand
        FUNCTION zcl_SendCommand,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 23, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN zclFindAttrRec
        FUNCTION zclFindAttrRec,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN zclReadAttrData
        FUNCTION zclReadAttrData,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 26, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN ??osal_mem_alloc?relay
        FUNCTION ??osal_mem_alloc?relay,00H
        EXTERN ??zclFindAttrRec?relay
        FUNCTION ??zclFindAttrRec?relay,00H
        EXTERN ??zclReadAttrData?relay
        FUNCTION ??zclReadAttrData?relay,00H
        EXTERN ??zcl_SendCommand?relay
        FUNCTION ??zcl_SendCommand?relay,00H
        EXTERN ??zcl_registerPlugin?relay
        FUNCTION ??zcl_registerPlugin?relay,00H

// D:\GitHub\z-stack\Sensor Network Example\Components\stack\zcl\zcl_general.c
//    1 /**************************************************************************************************
//    2   Filename:       zcl_general.c
//    3   Revised:        $Date: 2009-10-26 15:51:02 -0700 (Mon, 26 Oct 2009) $
//    4   Revision:       $Revision: 20979 $
//    5 
//    6   Description:    Zigbee Cluster Library - General.  This application receives all
//    7                   ZCL messages and initially parses them before passing to application.
//    8 
//    9 
//   10   Copyright 2006-2008 Texas Instruments Incorporated. All rights reserved.
//   11 
//   12   Should you have any questions regarding your right to use this Software,
//   13   contact Texas Instruments Incorporated at www.TI.com.
//   14 **************************************************************************************************/
//   15 
//   16 /*********************************************************************
//   17  * INCLUDES
//   18  */
//   19 #include "ZComDef.h"
//   20 #include "OSAL.h"
//   21 #include "OSAL_Nv.h"
//   22 #include "zcl.h"
//   23 #include "zcl_general.h"
//   24 #include "ZDApp.h"
//   25 
//   26 #if defined ( INTER_PAN )
//   27   #include "stub_aps.h"
//   28 #endif
//   29 
//   30 /*********************************************************************
//   31  * MACROS
//   32  */
//   33 #define locationTypeAbsolute( a )          ( (a) & LOCATION_TYPE_ABSOLUTE )
//   34 #define locationType2D( a )                ( (a) & LOCATION_TYPE_2_D )
//   35 #define locationTypeCoordinateSystem( a )  ( (a) & LOCATION_TYPE_COORDINATE_SYSTEM )
//   36 
//   37 #ifdef ZCL_SCENES
//   38 #define zclGeneral_ScenesRemaingCapacity() ( ZCL_GEN_MAX_SCENES - zclGeneral_CountAllScenes() )
//   39 #endif // ZCL_SCENES
//   40 
//   41 /*********************************************************************
//   42  * CONSTANTS
//   43  */
//   44 
//   45 /*********************************************************************
//   46  * TYPEDEFS
//   47  */
//   48 typedef struct zclGenCBRec
//   49 {
//   50   struct zclGenCBRec        *next;
//   51   uint8                     endpoint; // Used to link it into the endpoint descriptor
//   52   zclGeneral_AppCallbacks_t *CBs;     // Pointer to Callback function
//   53 } zclGenCBRec_t;
//   54 
//   55 typedef struct zclGenSceneItem
//   56 {
//   57   struct zclGenSceneItem    *next;
//   58   uint8                     endpoint; // Used to link it into the endpoint descriptor
//   59   zclGeneral_Scene_t        scene;    // Scene info
//   60 } zclGenSceneItem_t;
//   61 
//   62 typedef struct zclGenAlarmItem
//   63 {
//   64   struct zclGenAlarmItem    *next;
//   65   uint8                     endpoint; // Used to link it into the endpoint descriptor
//   66   zclGeneral_Alarm_t        alarm;    // Alarm info
//   67 } zclGenAlarmItem_t;
//   68 
//   69 // Scene NV types
//   70 typedef struct
//   71 {
//   72   uint16                    numRecs;
//   73 } nvGenScenesHdr_t;
//   74 
//   75 typedef struct zclGenSceneNVItem
//   76 {
//   77   uint8                     endpoint;
//   78   zclGeneral_Scene_t        scene;
//   79 } zclGenSceneNVItem_t;
//   80 
//   81 /*********************************************************************
//   82  * GLOBAL VARIABLES
//   83  */
//   84 
//   85 /*********************************************************************
//   86  * GLOBAL FUNCTIONS
//   87  */
//   88 
//   89 /*********************************************************************
//   90  * LOCAL VARIABLES
//   91  */

        RSEG XDATA_Z:XDATA:NOROOT(0)
//   92 static zclGenCBRec_t *zclGenCBs = (zclGenCBRec_t *)NULL;
zclGenCBs:
        DS 2
        REQUIRE __INIT_XDATA_Z

        RSEG XDATA_Z:XDATA:NOROOT(0)
//   93 static uint8 zclGenPluginRegisted = FALSE;
zclGenPluginRegisted:
        DS 1
        REQUIRE __INIT_XDATA_Z
//   94 #ifdef ZCL_SCENES
//   95 static zclGenSceneItem_t *zclGenSceneTable = (zclGenSceneItem_t *)NULL;
//   96 #endif // ZCL_SCENES
//   97 #ifdef ZCL_ALARMS
//   98 static zclGenAlarmItem_t *zclGenAlarmTable = (zclGenAlarmItem_t *)NULL;
//   99 #endif // ZCL_ALARMS
//  100 
//  101 /*********************************************************************
//  102  * LOCAL FUNCTIONS
//  103  */
//  104 static ZStatus_t zclGeneral_HdlIncoming( zclIncoming_t *pInMsg );
//  105 static ZStatus_t zclGeneral_HdlInSpecificCommands( zclIncoming_t *pInMsg );
//  106 static zclGeneral_AppCallbacks_t *zclGeneral_FindCallbacks( uint8 endpoint );
//  107 
//  108 // Device Configuration and Installation clusters
//  109 #ifdef ZCL_BASIC
//  110 static ZStatus_t zclGeneral_ProcessInBasic( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
//  111 #endif // ZCL_BASIC
//  112 
//  113 #ifdef ZCL_IDENTIFY
//  114 static ZStatus_t zclGeneral_ProcessInIdentity( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
//  115 #endif // ZCL_IDENTIFY
//  116 
//  117 // Groups and Scenes clusters
//  118 #ifdef ZCL_GROUPS
//  119 static ZStatus_t zclGeneral_ProcessInGroupsServer( zclIncoming_t *pInMsg );
//  120 static ZStatus_t zclGeneral_ProcessInGroupsClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
//  121 static ZStatus_t zclGeneral_AddGroup( uint8 endPoint, aps_Group_t *group, uint8 *pData );
//  122 #endif // ZCL_GROUPS
//  123 
//  124 #ifdef ZCL_SCENES
//  125 static ZStatus_t zclGeneral_ProcessInScenesServer( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
//  126 static ZStatus_t zclGeneral_ProcessInScenesClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
//  127 #endif // ZCL_SCENES
//  128 
//  129 // On/Off and Level Control Configuration clusters
//  130 #ifdef ZCL_ON_OFF
//  131 static ZStatus_t zclGeneral_ProcessInOnOff( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
//  132 #endif // ZCL_ONOFF
//  133 
//  134 #ifdef ZCL_LEVEL_CTRL
//  135 static ZStatus_t zclGeneral_ProcessInLevelControl( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
//  136 #endif // ZCL_LEVEL_CTRL
//  137 
//  138 // Alarms cluster
//  139 #ifdef ZCL_ALARMS
//  140 static ZStatus_t zclGeneral_ProcessInAlarmsServer( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
//  141 static ZStatus_t zclGeneral_ProcessInAlarmsClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
//  142 #endif // ZCL_ALARMS
//  143 
//  144 // Location cluster
//  145 #ifdef ZCL_LOCATION
//  146 static ZStatus_t zclGeneral_ProcessInLocationServer( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
//  147 static ZStatus_t zclGeneral_ProcessInLocationClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
//  148 #endif // ZCL_LOCATION
//  149 
//  150 #ifdef ZCL_SCENES
//  151 static uint8 zclGeneral_ScenesInitNV( void );
//  152 static void zclGeneral_ScenesSetDefaultNV( void );
//  153 static void zclGeneral_ScenesWriteNV( void );
//  154 static uint16 zclGeneral_ScenesRestoreFromNV( void );
//  155 #endif // ZCL_SCENES
//  156 
//  157 /*********************************************************************
//  158  * @fn      zclGeneral_RegisterCmdCallbacks
//  159  *
//  160  * @brief   Register an applications command callbacks
//  161  *
//  162  * @param   endpoint - application's endpoint
//  163  * @param   callbacks - pointer to the callback record.
//  164  *
//  165  * @return  ZMemError if not able to allocate
//  166  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  167 ZStatus_t zclGeneral_RegisterCmdCallbacks( uint8 endpoint, zclGeneral_AppCallbacks_t *callbacks )
zclGeneral_RegisterCmdCallbacks:
        CFI Block cfiBlock0 Using cfiCommon0
        CFI Function zclGeneral_RegisterCmdCallbacks
//  168 {
        FUNCALL zclGeneral_RegisterCmdCallbacks, zcl_registerPlugin
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclGeneral_RegisterCmdCallbacks, osal_mem_alloc
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xc
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 12)
        ; Saved register size: 12
        ; Auto size: 0
        MOV     ?V0 + 0,R1
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
//  169   zclGenCBRec_t *pNewItem;
//  170   zclGenCBRec_t *pLoop;
//  171 
//  172   // Register as a ZCL Plugin
//  173   if ( zclGenPluginRegisted == FALSE )
        MOV     DPTR,#zclGenPluginRegisted
        MOVX    A,@DPTR
        JNZ     ??zclGeneral_RegisterCmdCallbacks_0
//  174   {
//  175     zcl_registerPlugin( ZCL_CLUSTER_ID_GEN_BASIC,
//  176                         ZCL_CLUSTER_ID_GEN_LOCATION,
//  177                         zclGeneral_HdlIncoming );
        ; Setup parameters for call to function zcl_registerPlugin
        MOV     ?V0 + 2,#(??zclGeneral_HdlIncoming?relay & 0xff)
        MOV     ?V0 + 3,#((??zclGeneral_HdlIncoming?relay >> 8) & 0xff)
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 14)
        MOV     R4,#0xb
        MOV     R5,#0x0
        MOV     R2,#0x0
        MOV     R3,#0x0
        LCALL   ??zcl_registerPlugin?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 12)
//  178 
//  179 #ifdef ZCL_SCENES
//  180     // Initialize NV items
//  181     zclGeneral_ScenesInitNV();
//  182 
//  183     // Restore the Scene table
//  184     zclGeneral_ScenesRestoreFromNV();
//  185 #endif // ZCL_SCENES
//  186 
//  187     zclGenPluginRegisted = TRUE;
        MOV     A,#0x1
        MOV     DPTR,#zclGenPluginRegisted
        MOVX    @DPTR,A
//  188   }
//  189 
//  190   // Fill in the new profile list
//  191   pNewItem = osal_mem_alloc( sizeof( zclGenCBRec_t ) );
??zclGeneral_RegisterCmdCallbacks_0:
        ; Setup parameters for call to function osal_mem_alloc
        MOV     R2,#0x5
        MOV     R3,#0x0
        LCALL   ??osal_mem_alloc?relay
        MOV     ?V0 + 2,R2
        MOV     ?V0 + 3,R3
        MOV     R0,?V0 + 2
        MOV     R1,?V0 + 3
//  192   if ( pNewItem == NULL )
        MOV     A,R0
        JNZ     ??zclGeneral_RegisterCmdCallbacks_1
        MOV     A,R1
??zclGeneral_RegisterCmdCallbacks_1:
        JNZ     ??zclGeneral_RegisterCmdCallbacks_2
//  193     return (ZMemError);
        MOV     R1,#0x10
        SJMP    ??zclGeneral_RegisterCmdCallbacks_3
//  194 
//  195   pNewItem->next = (zclGenCBRec_t *)NULL;
??zclGeneral_RegisterCmdCallbacks_2:
        MOV     DPL,R0
        MOV     DPH,R1
        CLR     A
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    @DPTR,A
//  196   pNewItem->endpoint = endpoint;
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        MOV     A,?V0 + 0
        MOVX    @DPTR,A
//  197   pNewItem->CBs = callbacks;
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,R6
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R7
        MOVX    @DPTR,A
//  198 
//  199   // Find spot in list
//  200   if (  zclGenCBs == NULL )
        MOV     DPTR,#zclGenCBs
        MOVX    A,@DPTR
        JNZ     ??zclGeneral_RegisterCmdCallbacks_4
        INC     DPTR
        MOVX    A,@DPTR
??zclGeneral_RegisterCmdCallbacks_4:
        MOV     DPTR,#zclGenCBs
        JZ      ??zclGeneral_RegisterCmdCallbacks_5
//  201   {
//  202     zclGenCBs = pNewItem;
//  203   }
//  204   else
//  205   {
//  206     // Look for end of list
//  207     pLoop = zclGenCBs;
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        SJMP    ??zclGeneral_RegisterCmdCallbacks_6
//  208     while ( pLoop->next != NULL )
//  209       pLoop = pLoop->next;
??zclGeneral_RegisterCmdCallbacks_7:
        MOV     A,R2
        MOV     R4,A
        MOV     A,R3
??zclGeneral_RegisterCmdCallbacks_6:
        MOV     R5,A
        MOV     DPL,R4
        MOV     DPH,R5
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     A,R2
        JNZ     ??zclGeneral_RegisterCmdCallbacks_8
        MOV     A,R3
??zclGeneral_RegisterCmdCallbacks_8:
        JNZ     ??zclGeneral_RegisterCmdCallbacks_7
//  210 
//  211     // Put new item at end of list
//  212     pLoop->next = pNewItem;
        MOV     DPL,R4
        MOV     DPH,R5
??zclGeneral_RegisterCmdCallbacks_5:
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
//  213   }
//  214 
//  215   return ( ZSuccess );
        MOV     R1,#0x0
        CFI EndBlock cfiBlock0
??zclGeneral_RegisterCmdCallbacks_3:
        REQUIRE ?Subroutine9
        ; // Fall through to label ?Subroutine9
//  216 }

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine9:
        CFI Block cfiBlock1 Using cfiCommon0
        CFI NoFunction
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 12)
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        MOV     R7,#0x4
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock1
//  217 
//  218 #ifdef ZCL_IDENTIFY
//  219 /*********************************************************************
//  220  * @fn      zclGeneral_SendIdentify
//  221  *
//  222  * @brief   Call to send out an Identify Command
//  223  *
//  224  * @param   srcEP - Sending application's endpoint
//  225  * @param   dstAddr - where you want the message to go
//  226  * @param   identifyTime - how long the device will continue to identify itself (in seconds)
//  227  * @param   seqNum - identification number for the transaction
//  228  *
//  229  * @return  ZStatus_t
//  230  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  231 ZStatus_t zclGeneral_SendIdentify( uint8 srcEP, afAddrType_t *dstAddr,
zclGeneral_SendIdentify:
        CFI Block cfiBlock2 Using cfiCommon0
        CFI Function zclGeneral_SendIdentify
//  232                       uint16 identifyTime, uint8 disableDefaultRsp, uint8 seqNum )
//  233 {
        FUNCALL zclGeneral_SendIdentify, zcl_SendCommand
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 23, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 23, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 2
        MOV     A,#-0x2
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 12)
        MOV     A,#0xc
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R6,A
        MOV     A,#0xd
        LCALL   ?XSTACK_DISP0_8
        LCALL   ?Subroutine1 & 0xFFFF
//  234   uint8 buf[2];
//  235 
//  236   buf[0] = LO_UINT16( identifyTime );
//  237   buf[1] = HI_UINT16( identifyTime );
??CrossCallReturnLabel_2:
        LCALL   ?XSTACK_DISP0_8
        LCALL   ?Subroutine0 & 0xFFFF
//  238 
//  239   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_IDENTIFY,
//  240                           COMMAND_IDENTIFY, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
//  241                           disableDefaultRsp, 0, seqNum, 2, buf );
??CrossCallReturnLabel_0:
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 14)
        MOV     ?V0 + 0,#0x2
        MOV     ?V0 + 1,#0x0
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 16)
        MOV     A,R7
        MOV     ?V0 + 0,A
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_ONE
        CFI CFA_XSP16 add(XSP16, 17)
        MOV     ?V0 + 0,#0x0
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 19)
        MOV     A,R6
        MOV     ?V0 + 0,A
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_ONE
        CFI CFA_XSP16 add(XSP16, 20)
        MOV     ?V0 + 0,#0x0
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_ONE
        CFI CFA_XSP16 add(XSP16, 21)
        MOV     ?V0 + 0,#0x1
        CFI EndBlock cfiBlock2
        REQUIRE ?Subroutine10
        ; // Fall through to label ?Subroutine10

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine10:
        CFI Block cfiBlock3 Using cfiCommon0
        CFI NoFunction
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 21)
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_ONE
        CFI CFA_XSP16 add(XSP16, 22)
        MOV     ?V0 + 0,#0x0
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_ONE
        CFI CFA_XSP16 add(XSP16, 23)
        MOV     R4,#0x3
        MOV     R5,#0x0
        LCALL   ??zcl_SendCommand?relay
        MOV     A,#0xb
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 12)
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI EndBlock cfiBlock3
        REQUIRE ??Subroutine11_0
        ; // Fall through to label ??Subroutine11_0

        RSEG BANKED_CODE:CODE:NOROOT(0)
??Subroutine11_0:
        CFI Block cfiBlock4 Using cfiCommon0
        CFI NoFunction
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        MOV     R7,#0x2
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock4
//  242 }
//  243 
//  244 /*********************************************************************
//  245  * @fn      zclGeneral_SendIdentifyQueryResponse
//  246  *
//  247  * @brief   Call to send out an Identify Query Response Command
//  248  *
//  249  * @param   srcEP - Sending application's endpoint
//  250  * @param   dstAddr - where you want the message to go
//  251  * @param   timeout - how long the device will continue to identify itself (in seconds)
//  252  * @param   seqNum - identification number for the transaction
//  253  *
//  254  * @return  ZStatus_t
//  255  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  256 ZStatus_t zclGeneral_SendIdentifyQueryResponse( uint8 srcEP, afAddrType_t *dstAddr,
zclGeneral_SendIdentifyQueryResponse:
        CFI Block cfiBlock5 Using cfiCommon0
        CFI Function zclGeneral_SendIdentifyQueryResponse
//  257                             uint16 timeout, uint8 disableDefaultRsp, uint8 seqNum )
//  258 {
        FUNCALL zclGeneral_SendIdentifyQueryResponse, zcl_SendCommand
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 23, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 23, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 2
        MOV     A,#-0x2
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 12)
        MOV     A,#0xc
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R6,A
        MOV     A,#0xd
        LCALL   ?XSTACK_DISP0_8
        LCALL   ?Subroutine1 & 0xFFFF
//  259   uint8 buf[2];
//  260 
//  261   buf[0] = LO_UINT16( timeout );
//  262   buf[1] = HI_UINT16( timeout );
??CrossCallReturnLabel_3:
        LCALL   ?XSTACK_DISP0_8
        LCALL   ?Subroutine0 & 0xFFFF
//  263 
//  264   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_IDENTIFY,
//  265                           COMMAND_IDENTIFY_QUERY_RSP, TRUE,
//  266                           ZCL_FRAME_SERVER_CLIENT_DIR, disableDefaultRsp, 0, seqNum, 2, buf );
??CrossCallReturnLabel_1:
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 14)
        MOV     ?V0 + 0,#0x2
        MOV     ?V0 + 1,#0x0
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 16)
        MOV     A,R7
        MOV     ?V0 + 0,A
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_ONE
        CFI CFA_XSP16 add(XSP16, 17)
        MOV     ?V0 + 0,#0x0
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 19)
        MOV     A,R6
        MOV     ?V0 + 0,A
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_ONE
        CFI CFA_XSP16 add(XSP16, 20)
        MOV     ?V0 + 0,#0x1
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_ONE
        CFI CFA_XSP16 add(XSP16, 21)
        SJMP    ?Subroutine10
        CFI EndBlock cfiBlock5

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine1:
        CFI Block cfiCond6 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_2
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 12)
        CFI Block cfiCond7 Using cfiCommon0
        CFI (cfiCond7) NoFunction
        CFI (cfiCond7) Conditional ??CrossCallReturnLabel_3
        CFI (cfiCond7) R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond7) VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond7) V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond7) V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond7) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond7) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond7) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond7) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond7) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond7) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond7) CFA_SP SP+0
        CFI (cfiCond7) CFA_XSP16 add(XSP16, 12)
        CFI Block cfiPicker8 Using cfiCommon1
        CFI (cfiPicker8) NoFunction
        CFI (cfiPicker8) Picker
        MOVX    A,@DPTR
        MOV     R7,A
        MOV     A,R4
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    @DPTR,A
        MOV     A,#0x1
        RET
        CFI EndBlock cfiCond6
        CFI EndBlock cfiCond7
        CFI EndBlock cfiPicker8

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine0:
        CFI Block cfiCond9 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_0
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 12)
        CFI Block cfiCond10 Using cfiCommon0
        CFI (cfiCond10) NoFunction
        CFI (cfiCond10) Conditional ??CrossCallReturnLabel_1
        CFI (cfiCond10) R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond10) VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond10) V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond10) V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond10) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond10) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond10) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond10) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond10) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond10) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond10) CFA_SP SP+0
        CFI (cfiCond10) CFA_XSP16 add(XSP16, 12)
        CFI Block cfiPicker11 Using cfiCommon1
        CFI (cfiPicker11) NoFunction
        CFI (cfiPicker11) Picker
        MOV     A,R5
        MOVX    @DPTR,A
        ; Setup parameters for call to function zcl_SendCommand
        ; Setup parameters for call to function zcl_SendCommand
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     ?V0 + 0,DPL
        MOV     ?V0 + 1,DPH
        MOV     R0,#?V0 + 0
        RET
        CFI EndBlock cfiCond9
        CFI EndBlock cfiCond10
        CFI EndBlock cfiPicker11
//  267 }
//  268 #endif // ZCL_IDENTIFY
//  269 
//  270 #ifdef ZCL_GROUPS
//  271 /*********************************************************************
//  272  * @fn      zclGeneral_SendGroupRequest
//  273  *
//  274  * @brief   Send a Group Request to a device.  You can also use the
//  275  *          appropriate macro.
//  276  *
//  277  * @param   srcEP - Sending Apps endpoint
//  278  * @param   dstAddr - where to send the request
//  279  * @param   cmd - one of the following:
//  280  *              COMMAND_GROUP_VIEW
//  281  *              COMMAND_GROUP_REMOVE
//  282  * @param   groupID -
//  283  *
//  284  * @return  ZStatus_t
//  285  */
//  286 ZStatus_t zclGeneral_SendGroupRequest( uint8 srcEP, afAddrType_t *dstAddr,
//  287                      uint8 cmd, uint16 groupID, uint8 disableDefaultRsp, uint8 seqNum )
//  288 {
//  289   uint8 buf[2];
//  290 
//  291   buf[0] = LO_UINT16( groupID );
//  292   buf[1] = HI_UINT16( groupID );
//  293 
//  294   return ( zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
//  295                             cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
//  296                             disableDefaultRsp, 0, seqNum, 2, buf ) );
//  297 }
//  298 
//  299 /*********************************************************************
//  300  * @fn      zclGeneral_SendAddGroupRequest
//  301  *
//  302  * @brief   Send the Add Group Request to a device
//  303  *
//  304  * @param   srcEP - Sending Apps endpoint
//  305  * @param   dstAddr - where to send the request
//  306  * @param   cmd - one of the following:
//  307  *                COMMAND_GROUP_ADD
//  308  *                COMMAND_GROUP_ADD_IF_IDENTIFYING
//  309  * @param   groupID - pointer to the group structure
//  310  * @param   groupName - pointer to Group Name.  This is a Zigbee
//  311  *          string data type, so the first byte is the length of the
//  312  *          name (in bytes), then the name.
//  313  *
//  314  * @return  ZStatus_t
//  315  */
//  316 ZStatus_t zclGeneral_SendAddGroupRequest( uint8 srcEP, afAddrType_t *dstAddr,
//  317                                           uint8 cmd, uint16 groupID, uint8 *groupName,
//  318                                           uint8 disableDefaultRsp, uint8 seqNum )
//  319 {
//  320   uint8 *buf;
//  321   uint8 *pBuf;
//  322   uint8 len;
//  323   ZStatus_t status;
//  324 
//  325   len = 2;    // Group ID
//  326   len += groupName[0] + 1;  // String + 1 for length
//  327 
//  328   buf = osal_mem_alloc( len );
//  329   if ( buf )
//  330   {
//  331     pBuf = buf;
//  332     *pBuf++ = LO_UINT16( groupID );
//  333     *pBuf++ = HI_UINT16( groupID );
//  334     *pBuf++ = groupName[0]; // string length
//  335     osal_memcpy( pBuf, &(groupName[1]), groupName[0] );
//  336 
//  337     status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
//  338                               cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
//  339                               disableDefaultRsp, 0, seqNum, len, buf );
//  340     osal_mem_free( buf );
//  341   }
//  342   else
//  343     status = ZMemError;
//  344 
//  345   return ( status );
//  346 }
//  347 
//  348 /*********************************************************************
//  349  * @fn      zclGeneral_SendGroupGetMembershipRequest
//  350  *
//  351  * @brief   Send a Get Group Membership (Resposne) Command to a device
//  352  *
//  353  * @param   srcEP - Sending Apps endpoint
//  354  * @param   dstAddr - where to send the request
//  355  * @param   cmd - one of the following:
//  356  *                COMMAND_GROUP_GET_MEMBERSHIP
//  357  *                COMMAND_GROUP_GET_MEMBERSHIP_RSP
//  358  * @param   groupID - pointer to the group structure
//  359  * @param   groupName - pointer to Group Name.  This is a Zigbee
//  360  *          string data type, so the first byte is the length of the
//  361  *          name (in bytes), then the name.
//  362  *
//  363  * @return  ZStatus_t
//  364  */
//  365 ZStatus_t zclGeneral_SendGroupGetMembershipRequest( uint8 srcEP, afAddrType_t *dstAddr,
//  366                               uint8 cmd, uint8 rspCmd, uint8 direction, uint8 capacity,
//  367                               uint8 grpCnt, uint16 *grpList, uint8 disableDefaultRsp, uint8 seqNum )
//  368 {
//  369   uint8 *buf;
//  370   uint8 *pBuf;
//  371   uint8 len = 0;
//  372   uint8 i;
//  373   ZStatus_t status;
//  374 
//  375   if ( rspCmd )
//  376     len++;  // Capacity
//  377 
//  378   len++;  // Group Count
//  379   len += sizeof ( uint16 ) * grpCnt;  // Group List
//  380 
//  381   buf = osal_mem_alloc( len );
//  382   if ( buf )
//  383   {
//  384     pBuf = buf;
//  385     if ( rspCmd )
//  386       *pBuf++ = capacity;
//  387 
//  388     *pBuf++ = grpCnt;
//  389     for ( i = 0; i < grpCnt; i++ )
//  390     {
//  391       *pBuf++ = LO_UINT16( grpList[i] );
//  392       *pBuf++ = HI_UINT16( grpList[i] );
//  393     }
//  394 
//  395     status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
//  396                               cmd, TRUE, direction,
//  397                               disableDefaultRsp, 0, seqNum, len, buf );
//  398     osal_mem_free( buf );
//  399   }
//  400   else
//  401     status = ZMemError;
//  402 
//  403   return ( status );
//  404 }
//  405 
//  406 /*********************************************************************
//  407  * @fn      zclGeneral_SendGroupResponse
//  408  *
//  409  * @brief   Send Group Response (not Group View Response)
//  410  *
//  411  * @param   srcEP - Sending application's endpoint
//  412  * @param   dstAddr - where you want the message to go
//  413  * @param   cmd - either COMMAND_GROUP_ADD_RSP or COMMAND_GROUP_REMOVE_RSP
//  414  * @param   status - group command status
//  415  * @param   groupID - what group
//  416  *
//  417  * @return  ZStatus_t
//  418  */
//  419 ZStatus_t zclGeneral_SendGroupResponse( uint8 srcEP, afAddrType_t *dstAddr,
//  420                                         uint8 cmd, uint8 status, uint16 groupID,
//  421                                         uint8 disableDefaultRsp, uint8 seqNum )
//  422 {
//  423   uint8 buf[3];
//  424 
//  425   buf[0] = status;
//  426   buf[1] = LO_UINT16( groupID );
//  427   buf[2] = HI_UINT16( groupID );
//  428 
//  429   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
//  430                           cmd, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
//  431                           disableDefaultRsp, 0, seqNum, 3, buf );
//  432 }
//  433 
//  434 /*********************************************************************
//  435  * @fn      zclGeneral_SendGroupViewResponse
//  436  *
//  437  * @brief   Call to send Group Response Command
//  438  *
//  439  * @param   srcEP - Sending application's endpoint
//  440  * @param   dstAddr - where you want the message to go
//  441  * @param   cmd - either COMMAND_GROUP_ADD_RSP or COMMAND_GROUP_REMOVE_RSP
//  442  * @param   status - group command status
//  443  * @param   grp - group info
//  444  *
//  445  * @return  ZStatus_t
//  446  */
//  447 ZStatus_t zclGeneral_SendGroupViewResponse( uint8 srcEP, afAddrType_t *dstAddr,
//  448                  uint8 status, aps_Group_t *grp, uint8 disableDefaultRsp, uint8 seqNum )
//  449 {
//  450   uint8 *buf;
//  451   uint8 len;
//  452   ZStatus_t stat;
//  453 
//  454   len = 1 + 2; // Status + Group ID
//  455 
//  456   if ( status == ZCL_STATUS_SUCCESS )
//  457     len += grp->name[0] + 1;  // String + 1 for length
//  458 
//  459   buf = osal_mem_alloc( len );
//  460   if ( buf )
//  461   {
//  462     buf[0] = status;
//  463     buf[1] = LO_UINT16( grp->ID );
//  464     buf[2] = HI_UINT16( grp->ID );
//  465 
//  466     if ( status == ZCL_STATUS_SUCCESS )
//  467     {
//  468       buf[3] = grp->name[0]; // string length
//  469       osal_memcpy( &buf[4], (&grp->name[1]), grp->name[0] );
//  470     }
//  471 
//  472     stat = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
//  473                             COMMAND_GROUP_VIEW_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
//  474                             disableDefaultRsp, 0, seqNum, len, buf );
//  475     osal_mem_free( buf );
//  476   }
//  477   else
//  478     stat = ZMemError;
//  479 
//  480   return ( stat );
//  481 }
//  482 #endif // ZCL_GROUPS
//  483 
//  484 #ifdef ZCL_SCENES
//  485 /*********************************************************************
//  486  * @fn      zclGeneral_SendAddScene
//  487  *
//  488  * @brief   Send the Add Scene Request to a device
//  489  *
//  490  * @param   srcEP - Sending Apps endpoint
//  491  * @param   dstAddr - where to send the request
//  492  * @param   scene - pointer to the scene structure
//  493  *
//  494  * @return  ZStatus_t
//  495  */
//  496 ZStatus_t zclGeneral_SendAddScene( uint8 srcEP, afAddrType_t *dstAddr,
//  497                       zclGeneral_Scene_t *scene, uint8 disableDefaultRsp, uint8 seqNum )
//  498 {
//  499   uint8 *buf;
//  500   uint8 *pBuf;
//  501   uint8 len;
//  502   ZStatus_t status;
//  503 
//  504   len = 2 + 1 + 2;    // Group ID + Scene ID + transition time
//  505   len += scene->name[0] + 1; // String + 1 for length
//  506 
//  507   // Add something for the extension field length
//  508   len += scene->extLen;
//  509 
//  510   buf = osal_mem_alloc( len );
//  511   if ( buf )
//  512   {
//  513     pBuf = buf;
//  514     *pBuf++ = LO_UINT16( scene->groupID );
//  515     *pBuf++ = HI_UINT16( scene->groupID );
//  516     *pBuf++ = scene->ID;
//  517     *pBuf++ = LO_UINT16( scene->transTime );
//  518     *pBuf++ = HI_UINT16( scene->transTime );
//  519     *pBuf++ = scene->name[0]; // string length
//  520     osal_memcpy( pBuf, &(scene->name[1]), scene->name[0] );
//  521     pBuf += scene->name[0]; // move pass name
//  522 
//  523     // Add the extension fields
//  524     if ( scene->extLen > 0 )
//  525       osal_memcpy( pBuf, scene->extField, scene->extLen );
//  526 
//  527     status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
//  528                               COMMAND_SCENE_ADD, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
//  529                               disableDefaultRsp, 0, seqNum, len, buf );
//  530     osal_mem_free( buf );
//  531   }
//  532   else
//  533     status = ZMemError;
//  534 
//  535   return ( status );
//  536 }
//  537 
//  538 /*********************************************************************
//  539  * @fn      zclGeneral_SendSceneRequest
//  540  *
//  541  * @brief   Send a Scene Request to a device.  You can also use the
//  542  *          appropriate macro.
//  543  *
//  544  * @param   srcEP - Sending Apps endpoint
//  545  * @param   dstAddr - where to send the request
//  546  * @param   cmd - one of the following:
//  547  *              COMMAND_SCENE_VIEW
//  548  *              COMMAND_SCENE_REMOVE
//  549  *              COMMAND_SCENE_REMOVE_ALL
//  550  *              COMMAND_SCENE_STORE
//  551  *              COMMAND_SCENE_RECALL
//  552  *              COMMAND_SCENE_GET_MEMBERSHIP
//  553  * @param   groupID - group ID
//  554  * @param   sceneID - scene ID (not applicable to COMMAND_SCENE_REMOVE_ALL and
//  555  *                    COMMAND_SCENE_GET_MEMBERSHIP)
//  556  * @return  ZStatus_t
//  557  */
//  558 ZStatus_t zclGeneral_SendSceneRequest( uint8 srcEP, afAddrType_t *dstAddr,
//  559                                        uint8 cmd, uint16 groupID, uint8 sceneID,
//  560                                        uint8 disableDefaultRsp, uint8 seqNum )
//  561 {
//  562   uint8 buf[3];
//  563   uint8 len = 2;
//  564 
//  565   buf[0] = LO_UINT16( groupID );
//  566   buf[1] = HI_UINT16( groupID );
//  567 
//  568   if ( cmd != COMMAND_SCENE_REMOVE_ALL && cmd != COMMAND_SCENE_GET_MEMBERSHIP )
//  569   {
//  570     buf[2] = sceneID;
//  571     len++;
//  572   }
//  573 
//  574   return ( zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
//  575                             cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
//  576                             disableDefaultRsp, 0, seqNum, len, buf ) );
//  577 }
//  578 
//  579 /*********************************************************************
//  580  * @fn      zclGeneral_SendSceneResponse
//  581  *
//  582  * @brief   Send Group Response (not Group View Response)
//  583  *
//  584  * @param   srcEP - Sending application's endpoint
//  585  * @param   dstAddr - where you want the message to go
//  586  * @param   cmd - either COMMAND_SCENE_ADD_RSP, COMMAND_SCENE_REMOVE_RSP
//  587  *                COMMAND_SCENE_STORE_RSP, or COMMAND_SCENE_REMOVE_ALL_RSP
//  588  * @param   status - scene command status
//  589  * @param   groupID - what group
//  590  * @param   sceneID - what scene (not applicable to COMMAND_SCENE_REMOVE_ALL_RSP)
//  591  *
//  592  * @return  ZStatus_t
//  593  */
//  594 ZStatus_t zclGeneral_SendSceneResponse( uint8 srcEP, afAddrType_t *dstAddr,
//  595                                   uint8 cmd, uint8 status, uint16 groupID,
//  596                                   uint8 sceneID, uint8 disableDefaultRsp, uint8 seqNum )
//  597 {
//  598   uint8 buf[4];
//  599   uint8 len = 1 + 2; // Status + Group ID
//  600 
//  601   buf[0] = status;
//  602   buf[1] = LO_UINT16( groupID );
//  603   buf[2] = HI_UINT16( groupID );
//  604 
//  605   if ( cmd != COMMAND_SCENE_REMOVE_ALL_RSP )
//  606   {
//  607     buf[3] = sceneID;
//  608     len++;
//  609   }
//  610 
//  611   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
//  612                           cmd, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
//  613                           disableDefaultRsp, 0, seqNum, len, buf );
//  614 }
//  615 
//  616 /*********************************************************************
//  617  * @fn      zclGeneral_SendSceneViewResponse
//  618  *
//  619  * @brief   Call to send Scene Response Command
//  620  *
//  621  * @param   srcEP - Sending application's endpoint
//  622  * @param   dstAddr - where you want the message to go
//  623  * @param   status - scene command status
//  624  * @param   scene - scene info
//  625  *
//  626  * @return  ZStatus_t
//  627  */
//  628 ZStatus_t zclGeneral_SendSceneViewResponse( uint8 srcEP, afAddrType_t *dstAddr,
//  629                                        uint8 status, zclGeneral_Scene_t *scene,
//  630                                        uint8 disableDefaultRsp, uint8 seqNum )
//  631 {
//  632   uint8 *buf;
//  633   uint8 *pBuf;
//  634   uint8 len = 1 + 2 + 1; // Status + Group ID + Scene ID
//  635   ZStatus_t stat;
//  636 
//  637   if ( status == ZCL_STATUS_SUCCESS )
//  638   {
//  639     len += 2; // Transition Time
//  640     len += scene->name[0] + 1; // string + 1 for length
//  641 
//  642     // Add something for the extension field length
//  643     len += scene->extLen;
//  644   }
//  645 
//  646   buf = osal_mem_alloc( len );
//  647   if ( buf )
//  648   {
//  649     pBuf = buf;
//  650     *pBuf++ = status;
//  651     *pBuf++ = LO_UINT16( scene->groupID );
//  652     *pBuf++ = HI_UINT16( scene->groupID );
//  653     *pBuf++ = scene->ID;
//  654     if ( status == ZCL_STATUS_SUCCESS )
//  655     {
//  656       *pBuf++ = LO_UINT16( scene->transTime );
//  657       *pBuf++ = HI_UINT16( scene->transTime );
//  658       *pBuf++ = scene->name[0]; // string length
//  659       if ( scene->name[0] != 0 )
//  660       {
//  661         osal_memcpy( pBuf, &(scene->name[1]), scene->name[0] );
//  662         pBuf += scene->name[0]; // move pass name
//  663       }
//  664 
//  665       // Add the extension fields
//  666       if ( scene->extLen > 0 )
//  667         osal_memcpy( pBuf, scene->extField, scene->extLen );
//  668     }
//  669 
//  670     stat = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
//  671                             COMMAND_SCENE_VIEW_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
//  672                             disableDefaultRsp, 0, seqNum, len, buf );
//  673     osal_mem_free( buf );
//  674   }
//  675   else
//  676     stat = ZMemError;
//  677 
//  678   return ( stat );
//  679 }
//  680 
//  681 /*********************************************************************
//  682  * @fn      zclGeneral_SendSceneGetMembershipResponse
//  683  *
//  684  * @brief   Call to send Scene Get Membership Response Command
//  685  *
//  686  * @param   srcEP - Sending application's endpoint
//  687  * @param   dstAddr - where you want the message to go
//  688  * @param   status - scene command status
//  689  * @param   capacity - remaining capacity of the scene table
//  690  * @param   sceneCnt - number of scenes in the scene list
//  691  * @param   sceneList - list of scene IDs
//  692  * @param   groupID - group ID that scene belongs to
//  693  * @param   seqNum - sequence number
//  694  *
//  695  * @return  ZStatus_t
//  696  */
//  697 ZStatus_t zclGeneral_SendSceneGetMembershipResponse( uint8 srcEP, afAddrType_t *dstAddr,
//  698                        uint8 status, uint8 capacity, uint8 sceneCnt, uint8 *sceneList,
//  699                        uint16 groupID, uint8 disableDefaultRsp, uint8 seqNum )
//  700 {
//  701   uint8 *buf;
//  702   uint8 *pBuf;
//  703   uint8 len = 1 + 1 + 2; // Status + Capacity + Group ID;
//  704   uint8 i;
//  705   ZStatus_t stat;
//  706 
//  707   if ( status == ZCL_STATUS_SUCCESS )
//  708   {
//  709     len++; // Scene Count
//  710     len += sceneCnt; // Scene List (Scene ID is a single octet)
//  711   }
//  712 
//  713   buf = osal_mem_alloc( len );
//  714   if ( buf )
//  715   {
//  716     pBuf = buf;
//  717     *pBuf++ = status;
//  718     *pBuf++ = capacity;
//  719     *pBuf++ = LO_UINT16( groupID );
//  720     *pBuf++ = HI_UINT16( groupID );
//  721     if ( status == ZCL_STATUS_SUCCESS )
//  722     {
//  723       *pBuf++ = sceneCnt;
//  724       for ( i = 0; i < sceneCnt; i++ )
//  725         *pBuf++ = sceneList[i];
//  726     }
//  727 
//  728     stat = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
//  729                             COMMAND_SCENE_GET_MEMBERSHIP_RSP, TRUE,
//  730                             ZCL_FRAME_SERVER_CLIENT_DIR, disableDefaultRsp, 0, seqNum, len, buf );
//  731     osal_mem_free( buf );
//  732   }
//  733   else
//  734     stat = ZMemError;
//  735 
//  736   return ( stat );
//  737 }
//  738 #endif // ZCL_SCENES
//  739 
//  740 #ifdef ZCL_LEVEL_CTRL
//  741 /*********************************************************************
//  742  * @fn      zclGeneral_SendLevelControlMoveToLevelRequest
//  743  *
//  744  * @brief   Call to send out a Level Control Request. You can also use
//  745  *          the appropriate macro.
//  746  *
//  747  * @param   srcEP - Sending application's endpoint
//  748  * @param   dstAddr - where you want the message to go
//  749  * @param   cmd - one of the following:
//  750  *              COMMAND_LEVEL_MOVE_TO_LEVEL or
//  751  *              COMMAND_LEVEL_MOVE_TO_LEVEL_WITH_ON_OFF
//  752  * @param   level - what level to move to
//  753  * @param   transitionTime - how long to take to get to the level (in seconds)
//  754  *
//  755  * @return  ZStatus_t
//  756  */
//  757 ZStatus_t zclGeneral_SendLevelControlMoveToLevelRequest( uint8 srcEP, afAddrType_t *dstAddr,
//  758                                                          uint8 cmd, uint8 level, uint16 transTime,
//  759                                                          uint8 disableDefaultRsp, uint8 seqNum )
//  760 {
//  761   uint8 buf[3];
//  762 
//  763   buf[0] = level;
//  764   buf[1] = LO_UINT16( transTime );
//  765   buf[2] = HI_UINT16( transTime );
//  766 
//  767   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL,
//  768                           cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
//  769                           disableDefaultRsp, 0, seqNum, 3, buf );
//  770 }
//  771 
//  772 /*********************************************************************
//  773  * @fn      zclGeneral_SendLevelControlMoveRequest
//  774  *
//  775  * @brief   Call to send out a Level Control Request. You can also use
//  776  *          the appropriate macro.
//  777  *
//  778  * @param   srcEP - Sending application's endpoint
//  779  * @param   dstAddr - where you want the message to go
//  780  * @param   cmd - one of the following:
//  781  *              COMMAND_LEVEL_MOVE or
//  782  *              COMMAND_LEVEL_MOVE_WITH_ON_OFF
//  783  * @param   moveMode - LEVEL_MOVE_UP or
//  784  *                     LEVEL_MOVE_DOWN
//  785  * @param   rate - number of steps to take per second
//  786  *
//  787  * @return  ZStatus_t
//  788  */
//  789 ZStatus_t zclGeneral_SendLevelControlMoveRequest( uint8 srcEP, afAddrType_t *dstAddr,
//  790                                                   uint8 cmd, uint8 moveMode, uint8 rate,
//  791                                                   uint8 disableDefaultRsp, uint8 seqNum )
//  792 {
//  793   uint8 buf[2];
//  794 
//  795   buf[0] = moveMode;
//  796   buf[1] = rate;
//  797 
//  798   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL,
//  799                           cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
//  800                           disableDefaultRsp, 0, seqNum, 2, buf );
//  801 }
//  802 
//  803 /*********************************************************************
//  804  * @fn      zclGeneral_SendLevelControlStepRequest
//  805  *
//  806  * @brief   Call to send out a Level Control Request. You can also use
//  807  *          the appropriate macro.
//  808  *
//  809  * @param   srcEP - Sending application's endpoint
//  810  * @param   dstAddr - where you want the message to go
//  811  * @param   cmd - one of the following:
//  812  *              COMMAND_LEVEL_STEP
//  813  *              COMMAND_LEVEL_STEP_WITH_ON_OFF
//  814  * @param   stepMode - LEVEL_STEP_UP or
//  815  *                     LEVEL_STEP_DOWN
//  816  * @param   amount - number of levels to step
//  817  * @param   transitionTime - time, in 1/10ths of a second, to take to perform the step
//  818  *
//  819  * @return  ZStatus_t
//  820  */
//  821 ZStatus_t zclGeneral_SendLevelControlStepRequest( uint8 srcEP, afAddrType_t *dstAddr,
//  822                          uint8 cmd, uint8 stepMode, uint8 stepSize, uint16 transTime,
//  823                          uint8 disableDefaultRsp, uint8 seqNum )
//  824 {
//  825   uint8 buf[4];
//  826 
//  827   buf[0] = stepMode;
//  828   buf[1] = stepSize;
//  829   buf[2] = LO_UINT16( transTime );
//  830   buf[3] = HI_UINT16( transTime );
//  831 
//  832   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL,
//  833                           cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
//  834                           disableDefaultRsp, 0, seqNum, 4, buf );
//  835 }
//  836 #endif // ZCL_LEVEL_CTRL
//  837 
//  838 #ifdef ZCL_ALARMS
//  839 /*********************************************************************
//  840  * @fn      zclGeneral_SendAlarmRequest
//  841  *
//  842  * @brief   Call to send out an Alarm Request Command
//  843  *
//  844  * @param   srcEP - Sending application's endpoint
//  845  * @param   dstAddr - where you want the message to go
//  846  * @param   cmd - either COMMAND_ALARMS_RESET or COMMAND_ALARMS_ALARM
//  847  * @param   alarmCode - code for the cause of the alarm
//  848  * @param   clusterID - cluster whose attribute generate the alarm
//  849  *
//  850  * @return  ZStatus_t
//  851  */
//  852 ZStatus_t zclGeneral_SendAlarmRequest( uint8 srcEP, afAddrType_t *dstAddr,
//  853                                        uint8 cmd, uint8 alarmCode, uint16 clusterID,
//  854                                        uint8 disableDefaultRsp, uint8 seqNum )
//  855 {
//  856   uint8 buf[3];
//  857 
//  858   buf[0] = alarmCode;
//  859   buf[1] = LO_UINT16( clusterID );
//  860   buf[2] = HI_UINT16( clusterID );
//  861 
//  862   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ALARMS,
//  863                           cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
//  864                           disableDefaultRsp, 0, seqNum, 3, buf );
//  865 }
//  866 
//  867 /*********************************************************************
//  868  * @fn      zclGeneral_SendAlarmGetRespnose
//  869  *
//  870  * @brief   Call to send out an Alarm Get Response Command
//  871  *
//  872  * @param   srcEP - Sending application's endpoint
//  873  * @param   dstAddr - where you want the message to go
//  874  * @param   status - SUCCESS or NOT_FOUND
//  875  * @param   alarmCode - code for the cause of the alarm
//  876  * @param   clusterID - cluster whose attribute generate the alarm
//  877  * @param   timeStamp - time at which the alarm occured
//  878  *
//  879  * @return  ZStatus_t
//  880  */
//  881 ZStatus_t zclGeneral_SendAlarmGetRespnose( uint8 srcEP, afAddrType_t *dstAddr,
//  882                               uint8 status, uint8 alarmCode, uint16 clusterID,
//  883                               uint32 timeStamp, uint8 disableDefaultRsp, uint8 seqNum )
//  884 {
//  885   uint8 buf[8];
//  886   uint8 len = 1; // Status
//  887 
//  888   buf[0] = status;
//  889   if ( status == ZCL_STATUS_SUCCESS )
//  890   {
//  891     len += 1 + 2 + 4; // Alarm code + Cluster ID + Time stamp
//  892     buf[1] = alarmCode;
//  893     buf[2] = LO_UINT16( clusterID );
//  894     buf[3] = HI_UINT16( clusterID );
//  895     osal_buffer_uint32( &buf[4], timeStamp );
//  896   }
//  897 
//  898   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ALARMS,
//  899                           COMMAND_ALARMS_GET_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
//  900                           disableDefaultRsp, 0, seqNum, len, buf );
//  901 }
//  902 #endif // ZCL_ALARMS
//  903 
//  904 #ifdef ZCL_LOCATION
//  905 /*********************************************************************
//  906  * @fn      zclGeneral_SendLocationSetAbsolute
//  907  *
//  908  * @brief   Call to send out a Set Absolute Location Command
//  909  *
//  910  * @param   srcEP - Sending application's endpoint
//  911  * @param   dstAddr - where you want the message to go
//  912  * @param   absLoc - absolute location info
//  913  *
//  914  * @return  ZStatus_t
//  915  */
//  916 ZStatus_t zclGeneral_SendLocationSetAbsolute( uint8 srcEP, afAddrType_t *dstAddr,
//  917                                               zclLocationAbsolute_t *absLoc,
//  918                                               uint8 disableDefaultRsp, uint8 seqNum )
//  919 {
//  920    uint8 buf[10]; // 5 fields (2 octects each)
//  921 
//  922    buf[0] = LO_UINT16( absLoc->coordinate1 );
//  923    buf[1] = HI_UINT16( absLoc->coordinate1 );
//  924    buf[2] = LO_UINT16( absLoc->coordinate2 );
//  925    buf[3] = HI_UINT16( absLoc->coordinate2 );
//  926    buf[4] = LO_UINT16( absLoc->coordinate3 );
//  927    buf[5] = HI_UINT16( absLoc->coordinate3 );
//  928    buf[6] = LO_UINT16( absLoc->power );
//  929    buf[7] = HI_UINT16( absLoc->power );
//  930    buf[8] = LO_UINT16( absLoc->pathLossExponent );
//  931    buf[9] = HI_UINT16( absLoc->pathLossExponent );
//  932 
//  933    return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
//  934                            COMMAND_LOCATION_SET_ABSOLUTE, TRUE,
//  935                            ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, 10, buf );
//  936 }
//  937 
//  938 ZStatus_t zclGeneral_SendLocationSetDevCfg( uint8 srcEP, afAddrType_t *dstAddr,
//  939                                             zclLocationDevCfg_t *devCfg,
//  940                                             uint8 disableDefaultRsp, uint8 seqNum )
//  941 {
//  942    uint8 buf[9];  // 4 fields (2 octects each) + 1 field with 1 octect
//  943 
//  944    buf[0] = LO_UINT16( devCfg->power );
//  945    buf[1] = HI_UINT16( devCfg->power );
//  946    buf[2] = LO_UINT16( devCfg->pathLossExponent );
//  947    buf[3] = HI_UINT16( devCfg->pathLossExponent );
//  948    buf[4] = LO_UINT16( devCfg->calcPeriod );
//  949    buf[5] = HI_UINT16( devCfg->calcPeriod );
//  950    buf[6] = devCfg->numMeasurements;
//  951    buf[7] = LO_UINT16( devCfg->reportPeriod );
//  952    buf[8] = HI_UINT16( devCfg->reportPeriod );
//  953 
//  954    return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
//  955                            COMMAND_LOCATION_SET_DEV_CFG, TRUE,
//  956                            ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, 9, buf );
//  957 }
//  958 
//  959 ZStatus_t zclGeneral_SendLocationGetDevCfg( uint8 srcEP, afAddrType_t *dstAddr,
//  960                        uint8 *targetAddr, uint8 disableDefaultRsp, uint8 seqNum )
//  961 {
//  962   uint8 buf[8];
//  963 
//  964   osal_cpyExtAddr( buf, targetAddr );
//  965 
//  966   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
//  967                           COMMAND_LOCATION_GET_DEV_CFG, TRUE,
//  968                           ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, 8, buf );
//  969 }
//  970 
//  971 ZStatus_t zclGeneral_SendLocationGetData( uint8 srcEP, afAddrType_t *dstAddr,
//  972                                           zclLocationGetData_t *locData,
//  973                                           uint8 disableDefaultRsp, uint8 seqNum )
//  974 {
//  975   uint8 buf[10]; // bitmap (1) + number responses (1) + IEEE Address (8)
//  976   uint8 *pBuf = buf;
//  977   uint8 len = 2; // bitmap + number responses
//  978 
//  979   *pBuf  = locData->absoluteOnly;
//  980   *pBuf |= locData->recalculate << 1;
//  981   *pBuf |= locData->brdcastIndicator << 2;
//  982   *pBuf |= locData->brdcastResponse << 3;
//  983   *pBuf |= locData->compactResponse << 4;
//  984   pBuf++;  // move past the bitmap field
//  985 
//  986   *pBuf++ = locData->numResponses;
//  987 
//  988   if ( locData->brdcastIndicator == 0 )
//  989   {
//  990     osal_cpyExtAddr( pBuf, locData->targetAddr );
//  991     len += 8; // ieee addr
//  992   }
//  993 
//  994   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
//  995                           COMMAND_LOCATION_GET_DATA, TRUE,
//  996                           ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, len, buf );
//  997 }
//  998 
//  999 ZStatus_t zclGeneral_SendLocationDevCfgResponse( uint8 srcEP, afAddrType_t *dstAddr,
// 1000                                                  zclLocationDevCfgRsp_t *devCfg,
// 1001                                                  uint8 disableDefaultRsp, uint8 seqNum )
// 1002 {
// 1003   uint8 buf[10]; // 4 fields (2 octects each) + 2 fields (1 octect each)
// 1004   uint8 len = 1; // Status
// 1005 
// 1006   buf[0] = devCfg->status;
// 1007   if ( devCfg->status == ZCL_STATUS_SUCCESS )
// 1008   {
// 1009     buf[1] = LO_UINT16( devCfg->data.power );
// 1010     buf[2] = HI_UINT16( devCfg->data.power );
// 1011     buf[3] = LO_UINT16( devCfg->data.pathLossExponent );
// 1012     buf[4] = HI_UINT16( devCfg->data.pathLossExponent );
// 1013     buf[5] = LO_UINT16( devCfg->data.calcPeriod );
// 1014     buf[6] = HI_UINT16( devCfg->data.calcPeriod );
// 1015     buf[7] = devCfg->data.numMeasurements;
// 1016     buf[8] = LO_UINT16( devCfg->data.reportPeriod );
// 1017     buf[9] = HI_UINT16( devCfg->data.reportPeriod );
// 1018     len += 9;
// 1019   }
// 1020 
// 1021   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
// 1022                           COMMAND_LOCATION_DEV_CFG_RSP, TRUE,
// 1023                           ZCL_FRAME_SERVER_CLIENT_DIR, disableDefaultRsp, 0, seqNum, len, buf );
// 1024 }
// 1025 
// 1026 /*********************************************************************
// 1027  * @fn      zclGeneral_SendLocationData
// 1028  *
// 1029  * @brief   Call to send out location data
// 1030  *
// 1031  * @param   srcEP - Sending application's endpoint
// 1032  * @param   dstAddr - where you want the message to go
// 1033  * @param   status - indicates whether response to request was successful or not
// 1034  * @param   locData - location information and channel parameters being sent
// 1035  *
// 1036  * @return  ZStatus_t
// 1037  */
// 1038 ZStatus_t zclGeneral_SendLocationData( uint8 srcEP, afAddrType_t *dstAddr, uint8 cmd,
// 1039                                        uint8 status, zclLocationData_t *locData,
// 1040                                        uint8 disableDefaultRsp, uint8 seqNum )
// 1041 {
// 1042   uint8 buf[16];
// 1043   uint8 *pBuf = buf;
// 1044   uint8 len = 0;
// 1045 
// 1046   if ( cmd == COMMAND_LOCATION_DATA_RSP )
// 1047   {
// 1048     // Only response command includes a status field
// 1049     *pBuf++ = status;
// 1050     len++;
// 1051   }
// 1052 
// 1053   if ( cmd != COMMAND_LOCATION_DATA_RSP || status == ZCL_STATUS_SUCCESS )
// 1054   {
// 1055     // Notification or Response with successful status
// 1056     *pBuf++ = locData->type;
// 1057     *pBuf++ = LO_UINT16( locData->absLoc.coordinate1 );
// 1058     *pBuf++ = HI_UINT16( locData->absLoc.coordinate1 );
// 1059     *pBuf++ = LO_UINT16( locData->absLoc.coordinate2 );
// 1060     *pBuf++ = HI_UINT16( locData->absLoc.coordinate2 );
// 1061     len += 5;
// 1062 
// 1063     if ( locationType2D(locData->type) == 0 )
// 1064     {
// 1065       // 2D location doesn't have coordinate 3
// 1066       *pBuf++ = LO_UINT16( locData->absLoc.coordinate3 );
// 1067       *pBuf++ = HI_UINT16( locData->absLoc.coordinate3 );
// 1068       len += 2;
// 1069     }
// 1070 
// 1071     if ( cmd != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
// 1072     {
// 1073       // Compact notification doesn't include these fields
// 1074       *pBuf++ = LO_UINT16( locData->absLoc.power );
// 1075       *pBuf++ = HI_UINT16( locData->absLoc.power );
// 1076       *pBuf++ = LO_UINT16( locData->absLoc.pathLossExponent );
// 1077       *pBuf++ = HI_UINT16( locData->absLoc.pathLossExponent );
// 1078       len += 4;
// 1079     }
// 1080 
// 1081     if ( locationTypeAbsolute(locData->type) == 0 )
// 1082     {
// 1083       // Absolute location doesn't include these fields
// 1084       if ( cmd != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
// 1085       {
// 1086         // Compact notification doesn't include this field
// 1087         *pBuf++ = locData->calcLoc.locationMethod;
// 1088         len++;
// 1089       }
// 1090 
// 1091       *pBuf++ = locData->calcLoc.qualityMeasure;
// 1092       *pBuf++ = LO_UINT16( locData->calcLoc.locationAge );
// 1093       *pBuf++ = HI_UINT16( locData->calcLoc.locationAge );
// 1094       len += 3;
// 1095     }
// 1096   }
// 1097 
// 1098   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
// 1099                           cmd, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
// 1100                           disableDefaultRsp, 0, seqNum, len, buf );
// 1101 }
// 1102 #endif // ZCL_LOCATION
// 1103 
// 1104 /*********************************************************************
// 1105  * @fn      zclGeneral_FindCallbacks
// 1106  *
// 1107  * @brief   Find the callbacks for an endpoint
// 1108  *
// 1109  * @param   endpoint - endpoint to find the application callbacks for
// 1110  *
// 1111  * @return  pointer to the callbacks
// 1112  */
// 1113 static zclGeneral_AppCallbacks_t *zclGeneral_FindCallbacks( uint8 endpoint )
// 1114 {
// 1115   zclGenCBRec_t *pCBs;
// 1116 
// 1117   pCBs = zclGenCBs;
// 1118   while ( pCBs )
// 1119   {
// 1120     if ( pCBs->endpoint == endpoint )
// 1121       return ( pCBs->CBs );
// 1122     pCBs = pCBs->next;
// 1123   }
// 1124   return ( (zclGeneral_AppCallbacks_t *)NULL );
// 1125 }
// 1126 
// 1127 /*********************************************************************
// 1128  * @fn      zclGeneral_HdlIncoming
// 1129  *
// 1130  * @brief   Callback from ZCL to process incoming Commands specific
// 1131  *          to this cluster library or Profile commands for attributes
// 1132  *          that aren't in the attribute list
// 1133  *
// 1134  *
// 1135  * @param   pInMsg - pointer to the incoming message
// 1136  *
// 1137  * @return  ZStatus_t
// 1138  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1139 static ZStatus_t zclGeneral_HdlIncoming( zclIncoming_t *pInMsg )
zclGeneral_HdlIncoming:
        CFI Block cfiBlock12 Using cfiCommon0
        CFI Function zclGeneral_HdlIncoming
// 1140 {
        FUNCALL zclGeneral_HdlIncoming, zclGeneral_HdlInSpecificCommands
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
// 1141   ZStatus_t stat = ZSuccess;
// 1142 
// 1143 #if defined ( INTER_PAN )
// 1144   if ( StubAPS_InterPan( pInMsg->msg->srcAddr.panId, pInMsg->msg->srcAddr.endPoint ) )
// 1145     return ( stat ); // Cluster not supported thru Inter-PAN
// 1146 #endif
// 1147   if ( zcl_ClusterCmd( pInMsg->hdr.fc.type ) )
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        ANL     A,#0x3
        XRL     A,#0x1
        JNZ     ??zclGeneral_HdlIncoming_0
// 1148   {
// 1149     // Is this a manufacturer specific command?
// 1150     if ( pInMsg->hdr.fc.manuSpecific == 0 )
        MOV     A,R0
        ANL     A,#0x4
        JNZ     ??zclGeneral_HdlIncoming_0
// 1151     {
// 1152       stat = zclGeneral_HdlInSpecificCommands( pInMsg );
        ; Setup parameters for call to function zclGeneral_HdlInSpecificCommands
        LCALL   ??zclGeneral_HdlInSpecificCommands?relay
        SJMP    ??zclGeneral_HdlIncoming_1
// 1153     }
// 1154     else
// 1155     {
// 1156       // We don't support any manufacturer specific command.
// 1157       stat = ZFailure;
??zclGeneral_HdlIncoming_0:
        MOV     R1,#0x1
// 1158     }
// 1159   }
// 1160   else
// 1161   {
// 1162     // Handle all the normal (Read, Write...) commands -- should never get here
// 1163     stat = ZFailure;
// 1164   }
// 1165   return ( stat );
??zclGeneral_HdlIncoming_1:
        POP     DPH
        CFI DPH0 SameValue
        CFI CFA_SP SP+-4
        POP     DPL
        CFI DPL0 SameValue
        CFI CFA_SP SP+-3
        LJMP    ?BRET
        CFI EndBlock cfiBlock12
// 1166 }
// 1167 
// 1168 /*********************************************************************
// 1169  * @fn      zclGeneral_HdlInSpecificCommands
// 1170  *
// 1171  * @brief   Callback from ZCL to process incoming Commands specific
// 1172  *          to this cluster library
// 1173 
// 1174  * @param   pInMsg - pointer to the incoming message
// 1175  *
// 1176  * @return  ZStatus_t
// 1177  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1178 static ZStatus_t zclGeneral_HdlInSpecificCommands( zclIncoming_t *pInMsg )
zclGeneral_HdlInSpecificCommands:
        CFI Block cfiBlock13 Using cfiCommon0
        CFI Function zclGeneral_HdlInSpecificCommands
// 1179 {
        FUNCALL zclGeneral_HdlInSpecificCommands, zclGeneral_ProcessInIdentity
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 0
// 1180   ZStatus_t stat;
// 1181   zclGeneral_AppCallbacks_t *pCBs;
// 1182 
// 1183   // make sure endpoint exists
// 1184   pCBs = zclGeneral_FindCallbacks( pInMsg->msg->endPoint );
        MOV     DPL,R2
        LCALL   ?Subroutine5 & 0xFFFF
??CrossCallReturnLabel_10:
        LCALL   ?Subroutine6 & 0xFFFF
??CrossCallReturnLabel_12:
        MOV     R4,A
        MOV     DPTR,#zclGenCBs
??zclGeneral_HdlInSpecificCommands_0:
        LCALL   ?Subroutine7 & 0xFFFF
??CrossCallReturnLabel_14:
        JNZ     ??zclGeneral_HdlInSpecificCommands_1
        MOV     A,R1
??zclGeneral_HdlInSpecificCommands_1:
        JZ      ??zclGeneral_HdlInSpecificCommands_2
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,R4
        MOV     DPL,R0
        MOV     DPH,R1
        JNZ     ??zclGeneral_HdlInSpecificCommands_0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
// 1185   if ( pCBs == NULL )
        MOV     A,R4
        JNZ     ??zclGeneral_HdlInSpecificCommands_3
        MOV     A,R5
??zclGeneral_HdlInSpecificCommands_3:
        JZ      ??zclGeneral_HdlInSpecificCommands_2
// 1186     return ( ZFailure );
// 1187 
// 1188   switch ( pInMsg->msg->clusterId )
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 0,A
        INC     DPTR
        MOVX    A,@DPTR
        JNZ     ??zclGeneral_HdlInSpecificCommands_4
        MOV     A,?V0 + 0
        LCALL   ?UC_SWITCH_SPARSE
`?<Jumptable for zclGeneral_HdlInSpecificComman_0`:
        DATA
        DB        0
        DB        3
        DB        0
        DW        ??zclGeneral_HdlInSpecificCommands_5
        DB        3
        DW        ??zclGeneral_HdlInSpecificCommands_6
        DB        6
        DW        ??zclGeneral_HdlInSpecificCommands_7
        DW        ??zclGeneral_HdlInSpecificCommands_4
        CODE
// 1189   {
// 1190 #ifdef ZCL_BASIC
// 1191     case ZCL_CLUSTER_ID_GEN_BASIC:
// 1192       stat = zclGeneral_ProcessInBasic( pInMsg, pCBs );
??zclGeneral_HdlInSpecificCommands_5:
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        ANL     A,#0x8
        JNZ     ??zclGeneral_HdlInSpecificCommands_8
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        JNZ     ??zclGeneral_HdlInSpecificCommands_4
        MOV     DPL,R4
        MOV     DPH,R5
        LCALL   ?Subroutine2 & 0xFFFF
??CrossCallReturnLabel_4:
        JNZ     ??zclGeneral_HdlInSpecificCommands_9
        MOV     A,DPH
??zclGeneral_HdlInSpecificCommands_9:
        JZ      ??zclGeneral_HdlInSpecificCommands_8
        ; Setup parameters for indirect call
        SJMP    ??zclGeneral_HdlInSpecificCommands_10
??zclGeneral_HdlInSpecificCommands_2:
        SJMP    ??zclGeneral_HdlInSpecificCommands_4
// 1193       break;
// 1194 #endif // ZCL_BASIC
// 1195 
// 1196 #ifdef ZCL_IDENTIFY
// 1197     case ZCL_CLUSTER_ID_GEN_IDENTIFY:
// 1198       stat = zclGeneral_ProcessInIdentity( pInMsg, pCBs );
??zclGeneral_HdlInSpecificCommands_6:
        ; Setup parameters for call to function zclGeneral_ProcessInIdentity
        LCALL   ??zclGeneral_ProcessInIdentity?relay
        SJMP    ??zclGeneral_HdlInSpecificCommands_11
// 1199       break;
// 1200 #endif // ZCL_IDENTIFY
// 1201 
// 1202 #ifdef ZCL_GROUPS
// 1203     case ZCL_CLUSTER_ID_GEN_GROUPS:
// 1204       if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
// 1205         stat = zclGeneral_ProcessInGroupsServer( pInMsg );
// 1206       else
// 1207         stat = zclGeneral_ProcessInGroupsClient( pInMsg, pCBs );
// 1208       break;
// 1209 #endif // ZCL_GROUPS
// 1210 
// 1211 #ifdef ZCL_SCENES
// 1212     case ZCL_CLUSTER_ID_GEN_SCENES:
// 1213       if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
// 1214         stat = zclGeneral_ProcessInScenesServer( pInMsg, pCBs );
// 1215       else
// 1216         stat = zclGeneral_ProcessInScenesClient( pInMsg, pCBs );
// 1217       break;
// 1218 #endif // ZCL_SCENES
// 1219 
// 1220 #ifdef ZCL_ON_OFF
// 1221     case ZCL_CLUSTER_ID_GEN_ON_OFF:
// 1222       stat = zclGeneral_ProcessInOnOff( pInMsg, pCBs );
??zclGeneral_HdlInSpecificCommands_7:
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        ANL     A,#0x8
        JNZ     ??zclGeneral_HdlInSpecificCommands_8
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        CLR     C
        SUBB    A,#0x3
        JNC     ??zclGeneral_HdlInSpecificCommands_4
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        LCALL   ?Subroutine2 & 0xFFFF
??CrossCallReturnLabel_5:
        JNZ     ??zclGeneral_HdlInSpecificCommands_12
        MOV     A,DPH
??zclGeneral_HdlInSpecificCommands_12:
        JZ      ??zclGeneral_HdlInSpecificCommands_8
        ; Setup parameters for indirect call
        MOV     A,R2
        MOV     R1,A
??zclGeneral_HdlInSpecificCommands_10:
        LCALL   ?CALL_IND
??zclGeneral_HdlInSpecificCommands_8:
        MOV     R1,#0x0
        SJMP    ??zclGeneral_HdlInSpecificCommands_11
// 1223       break;
// 1224 #endif // ZCL_ON_OFF
// 1225 
// 1226 #ifdef ZCL_LEVEL_CTRL
// 1227     case ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL:
// 1228       stat = zclGeneral_ProcessInLevelControl( pInMsg, pCBs );
// 1229       break;
// 1230 #endif // ZCL_LEVEL_CTRL
// 1231 
// 1232 #ifdef ZCL_ALARMS
// 1233     case ZCL_CLUSTER_ID_GEN_ALARMS:
// 1234       if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
// 1235         stat = zclGeneral_ProcessInAlarmsServer( pInMsg, pCBs );
// 1236       else
// 1237         stat = zclGeneral_ProcessInAlarmsClient( pInMsg, pCBs );
// 1238       break;
// 1239 #endif // ZCL_ALARMS
// 1240 
// 1241 #ifdef ZCL_LOCATION
// 1242     case ZCL_CLUSTER_ID_GEN_LOCATION:
// 1243       if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
// 1244         stat = zclGeneral_ProcessInLocationServer( pInMsg, pCBs );
// 1245       else
// 1246         stat = zclGeneral_ProcessInLocationClient( pInMsg, pCBs );
// 1247       break;
// 1248 #endif // ZCL_LOCATION
// 1249 
// 1250     case ZCL_CLUSTER_ID_GEN_POWER_CFG:
// 1251     case ZCL_CLUSTER_ID_GEN_DEVICE_TEMP_CONFIG:
// 1252     case ZCL_CLUSTER_ID_GEN_ON_OFF_SWITCH_CONFIG:
// 1253     case ZCL_CLUSTER_ID_GEN_TIME:
// 1254     default:
// 1255       stat = ZFailure;
??zclGeneral_HdlInSpecificCommands_4:
        MOV     R1,#0x1
// 1256       break;
// 1257   }
// 1258 
// 1259   return ( stat );
??zclGeneral_HdlInSpecificCommands_11:
        LJMP    ??Subroutine11_0 & 0xFFFF
        CFI EndBlock cfiBlock13
// 1260 }

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine2:
        CFI Block cfiCond14 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_4
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        CFI Block cfiCond15 Using cfiCommon0
        CFI (cfiCond15) NoFunction
        CFI (cfiCond15) Conditional ??CrossCallReturnLabel_5
        CFI (cfiCond15) R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond15) VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond15) V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond15) V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond15) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond15) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond15) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond15) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond15) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond15) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond15) CFA_SP SP+0
        CFI (cfiCond15) CFA_XSP16 add(XSP16, 10)
        CFI Block cfiPicker16 Using cfiCommon1
        CFI (cfiPicker16) NoFunction
        CFI (cfiPicker16) Picker
        LCALL   ?Subroutine8 & 0xFFFF
??CrossCallReturnLabel_18:
        MOV     A,DPL
        RET
        CFI EndBlock cfiCond14
        CFI EndBlock cfiCond15
        CFI EndBlock cfiPicker16
// 1261 
// 1262 #ifdef ZCL_BASIC
// 1263 /*********************************************************************
// 1264  * @fn      zclGeneral_ProcessInBasic
// 1265  *
// 1266  * @brief   Process in the received Basic Command.
// 1267  *
// 1268  * @param   pInMsg - pointer to the incoming message
// 1269  *
// 1270  * @return  ZStatus_t
// 1271  */
// 1272 static ZStatus_t zclGeneral_ProcessInBasic( zclIncoming_t *pInMsg,
// 1273                                             zclGeneral_AppCallbacks_t *pCBs )
// 1274 {
// 1275   if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
// 1276   {
// 1277     if ( pInMsg->hdr.commandID > COMMAND_BASIC_RESET_FACT_DEFAULT )
// 1278       return ( ZFailure );   // Error ignore the command
// 1279 
// 1280     if ( pCBs->pfnBasicReset )
// 1281       pCBs->pfnBasicReset();
// 1282   }
// 1283   // no Client command
// 1284 
// 1285   return ( ZSuccess );
// 1286 }
// 1287 #endif // ZCL_BASIC
// 1288 
// 1289 #ifdef ZCL_IDENTIFY
// 1290 /*********************************************************************
// 1291  * @fn      zclGeneral_ProcessInIdentity
// 1292  *
// 1293  * @brief   Process in the received Identity Command.
// 1294  *
// 1295  * @param   pInMsg - pointer to the incoming message
// 1296  *
// 1297  * @return  ZStatus_t
// 1298  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1299 static ZStatus_t zclGeneral_ProcessInIdentity( zclIncoming_t *pInMsg,
zclGeneral_ProcessInIdentity:
        CFI Block cfiBlock17 Using cfiCommon0
        CFI Function zclGeneral_ProcessInIdentity
// 1300                                                zclGeneral_AppCallbacks_t *pCBs )
// 1301 {
        FUNCALL zclGeneral_ProcessInIdentity, zclFindAttrRec
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclGeneral_ProcessInIdentity, zclReadAttrData
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 26, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 26, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclGeneral_ProcessInIdentity, zclGeneral_SendIdentifyQueryResponse
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xc
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 12)
        ; Saved register size: 12
        ; Auto size: 14
        MOV     A,#-0xe
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 26)
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
// 1302   if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPL,?V0 + 0
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        ANL     A,#0x8
        JZ      $+5
        LJMP    ??zclGeneral_ProcessInIdentity_0 & 0xFFFF
// 1303   {
// 1304     if ( pInMsg->hdr.commandID > COMMAND_IDENTIFY_QUERY )
        MOV     A,R2
        CLR     C
        SUBB    A,#0x2
        JC      ??zclGeneral_ProcessInIdentity_1
// 1305       return ( ZFailure );   // Error ignore the command
??zclGeneral_ProcessInIdentity_2:
        MOV     R1,#0x1
        LJMP    ??zclGeneral_ProcessInIdentity_3 & 0xFFFF
// 1306 
// 1307     if ( pInMsg->hdr.commandID == COMMAND_IDENTIFY )
??zclGeneral_ProcessInIdentity_1:
        MOV     A,R2
        JNZ     ??zclGeneral_ProcessInIdentity_4
// 1308     {
// 1309       if ( pCBs->pfnIdentify )
        MOV     DPL,R4
        MOV     DPH,R5
        LCALL   ?Subroutine4 & 0xFFFF
// 1310       {
// 1311         zclIdentify_t cmd;
// 1312 
// 1313         cmd.srcAddr = &(pInMsg->msg->srcAddr);
// 1314         cmd.identifyTime = BUILD_UINT16( pInMsg->pData[0], pInMsg->pData[1] );
// 1315 
// 1316         pCBs->pfnIdentify( &cmd );
// 1317       }
// 1318     }
??CrossCallReturnLabel_8:
        JNZ     ??zclGeneral_ProcessInIdentity_5
        MOV     A,R5
??zclGeneral_ProcessInIdentity_5:
        LJMP    ??zclGeneral_ProcessInIdentity_6 & 0xFFFF
// 1319     else
// 1320     {
// 1321       zclAttrRec_t attrRec;
// 1322       uint16 identifyTime = 0;
??zclGeneral_ProcessInIdentity_4:
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        CLR     A
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    @DPTR,A
// 1323 
// 1324       // Retrieve Identify Time
// 1325       if ( zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, ATTRID_IDENTIFY_TIME, &attrRec ) )
        MOV     DPL,?V0 + 0
        LCALL   ?Subroutine5 & 0xFFFF
??CrossCallReturnLabel_11:
        ; Setup parameters for call to function zclFindAttrRec
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOV     ?V0 + 2,DPL
        MOV     ?V0 + 3,DPH
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 28)
        MOV     R4,#0x0
        MOV     R5,#0x0
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        LCALL   ?Subroutine3 & 0xFFFF
??CrossCallReturnLabel_6:
        LCALL   ??zclFindAttrRec?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 26)
        MOV     A,R1
        JZ      ??zclGeneral_ProcessInIdentity_7
// 1326         zclReadAttrData( (uint8 *)&identifyTime, &attrRec );
        ; Setup parameters for call to function zclReadAttrData
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??zclReadAttrData?relay
// 1327 
// 1328       // Is device identifying itself?
// 1329       if ( identifyTime > 0 )
??zclGeneral_ProcessInIdentity_7:
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        JNZ     ??zclGeneral_ProcessInIdentity_8
        INC     DPTR
        MOVX    A,@DPTR
??zclGeneral_ProcessInIdentity_8:
        JZ      ??zclGeneral_ProcessInIdentity_9
// 1330       {
// 1331         zclGeneral_SendIdentifyQueryResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 1332                                               identifyTime, true, pInMsg->hdr.transSeqNum );
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    A,@DPTR
        MOV     R6,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R7,A
        ; Setup parameters for call to function zclGeneral_SendIdentifyQueryResponse
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 0,A
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_ONE
        CFI CFA_XSP16 add(XSP16, 27)
        MOV     ?V0 + 0,#0x1
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_ONE
        CFI CFA_XSP16 add(XSP16, 28)
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     A,R6
        ADD     A,#0x6
        MOV     R2,A
        MOV     A,R7
        ADDC    A,#0x0
        LCALL   ?Subroutine3 & 0xFFFF
// 1333       }
??CrossCallReturnLabel_7:
        LCALL   ??zclGeneral_SendIdentifyQueryResponse?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 26)
// 1334 
// 1335       return ( ZCL_STATUS_CMD_HAS_RSP );
??zclGeneral_ProcessInIdentity_9:
        MOV     R1,#-0x1
        SJMP    ??zclGeneral_ProcessInIdentity_3
// 1336     }
// 1337   }
// 1338   else // Client Command
// 1339   {
// 1340     if ( pInMsg->hdr.commandID > COMMAND_IDENTIFY_QUERY_RSP )
??zclGeneral_ProcessInIdentity_0:
        MOV     A,R2
        JZ      $+5
        LJMP    ??zclGeneral_ProcessInIdentity_2 & 0xFFFF
// 1341       return ( ZFailure );   // Error ignore the command
// 1342 
// 1343     if ( pCBs->pfnIdentifyQueryRsp )
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        INC     DPTR
        LCALL   ?Subroutine4 & 0xFFFF
??CrossCallReturnLabel_9:
        JNZ     ??zclGeneral_ProcessInIdentity_6
        MOV     A,R5
??zclGeneral_ProcessInIdentity_6:
        JZ      ??zclGeneral_ProcessInIdentity_10
// 1344     {
// 1345       zclIdentifyQueryRsp_t rsp;
// 1346 
// 1347       rsp.srcAddr = &(pInMsg->msg->srcAddr);
        MOV     DPL,?V0 + 0
        MOV     DPH,R3
        MOVX    A,@DPTR
        ADD     A,#0x6
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1348       rsp.timeout = BUILD_UINT16( pInMsg->pData[0], pInMsg->pData[1] );
        MOV     DPL,?V0 + 0
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        LCALL   ?Subroutine8 & 0xFFFF
??CrossCallReturnLabel_17:
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R2
        MOV     R0,A
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1349 
// 1350       pCBs->pfnIdentifyQueryRsp( &rsp );
        ; Setup parameters for indirect call
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R2,DPL
        MOV     R3,DPH
        MOV     DPL,R4
        MOV     DPH,R5
        LCALL   ?CALL_IND
// 1351     }
// 1352   }
// 1353 
// 1354   return ( ZSuccess );
??zclGeneral_ProcessInIdentity_10:
        MOV     R1,#0x0
??zclGeneral_ProcessInIdentity_3:
        MOV     A,#0xe
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 12)
        LJMP    ?Subroutine9 & 0xFFFF
        CFI EndBlock cfiBlock17
// 1355 }

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine8:
        CFI Block cfiCond18 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_18, ??CrossCallReturnLabel_4
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        CFI Block cfiCond19 Using cfiCommon0
        CFI (cfiCond19) NoFunction
        CFI (cfiCond19) Conditional ??CrossCallReturnLabel_18, ??CrossCallReturnLabel_5
        CFI (cfiCond19) R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond19) VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond19) V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond19) V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond19) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond19) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond19) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond19) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond19) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond19) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond19) CFA_SP SP+0
        CFI (cfiCond19) CFA_XSP16 add(XSP16, 10)
        CFI Block cfiCond20 Using cfiCommon0
        CFI (cfiCond20) NoFunction
        CFI (cfiCond20) Conditional ??CrossCallReturnLabel_17
        CFI (cfiCond20) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond20) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond20) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond20) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond20) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond20) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond20) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond20) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond20) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond20) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond20) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond20) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond20) CFA_SP SP+0
        CFI (cfiCond20) CFA_XSP16 add(XSP16, 26)
        CFI Block cfiPicker21 Using cfiCommon1
        CFI (cfiPicker21) NoFunction
        CFI (cfiPicker21) Picker
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        RET
        CFI EndBlock cfiCond18
        CFI EndBlock cfiCond19
        CFI EndBlock cfiCond20
        CFI EndBlock cfiPicker21

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine5:
        CFI Block cfiCond22 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_10
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        CFI Block cfiCond23 Using cfiCommon0
        CFI (cfiCond23) NoFunction
        CFI (cfiCond23) Conditional ??CrossCallReturnLabel_11
        CFI (cfiCond23) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond23) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond23) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond23) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond23) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond23) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond23) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond23) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond23) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond23) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond23) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond23) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond23) CFA_SP SP+0
        CFI (cfiCond23) CFA_XSP16 add(XSP16, 26)
        CFI Block cfiPicker24 Using cfiCommon1
        CFI (cfiPicker24) NoFunction
        CFI (cfiPicker24) Picker
        MOV     DPH,R3
        LCALL   ?Subroutine7 & 0xFFFF
??CrossCallReturnLabel_16:
        MOV     R6,A
        MOV     A,R1
        MOV     R7,A
        RET
        CFI EndBlock cfiCond22
        CFI EndBlock cfiCond23
        CFI EndBlock cfiPicker24

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine7:
        CFI Block cfiCond25 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_14
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        CFI Block cfiCond26 Using cfiCommon0
        CFI (cfiCond26) NoFunction
        CFI (cfiCond26) Conditional ??CrossCallReturnLabel_16, ??CrossCallReturnLabel_10
        CFI (cfiCond26) R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond26) VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond26) V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond26) V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond26) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond26) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond26) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond26) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond26) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond26) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond26) CFA_SP SP+0
        CFI (cfiCond26) CFA_XSP16 add(XSP16, 10)
        CFI Block cfiCond27 Using cfiCommon0
        CFI (cfiCond27) NoFunction
        CFI (cfiCond27) Conditional ??CrossCallReturnLabel_16, ??CrossCallReturnLabel_11
        CFI (cfiCond27) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond27) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond27) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond27) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond27) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond27) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond27) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond27) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond27) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond27) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond27) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond27) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond27) CFA_SP SP+0
        CFI (cfiCond27) CFA_XSP16 add(XSP16, 26)
        CFI Block cfiCond28 Using cfiCommon0
        CFI (cfiCond28) NoFunction
        CFI (cfiCond28) Conditional ??CrossCallReturnLabel_15, ??CrossCallReturnLabel_8
        CFI (cfiCond28) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond28) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond28) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond28) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond28) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond28) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond28) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond28) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond28) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond28) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond28) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond28) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond28) CFA_SP SP+0
        CFI (cfiCond28) CFA_XSP16 add(XSP16, 26)
        CFI Block cfiCond29 Using cfiCommon0
        CFI (cfiCond29) NoFunction
        CFI (cfiCond29) Conditional ??CrossCallReturnLabel_15, ??CrossCallReturnLabel_9
        CFI (cfiCond29) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond29) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond29) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond29) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond29) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond29) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond29) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond29) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond29) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond29) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond29) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond29) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond29) CFA_SP SP+0
        CFI (cfiCond29) CFA_XSP16 add(XSP16, 26)
        CFI Block cfiPicker30 Using cfiCommon1
        CFI (cfiPicker30) NoFunction
        CFI (cfiPicker30) Picker
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        RET
        CFI EndBlock cfiCond25
        CFI EndBlock cfiCond26
        CFI EndBlock cfiCond27
        CFI EndBlock cfiCond28
        CFI EndBlock cfiCond29
        CFI EndBlock cfiPicker30

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine4:
        CFI Block cfiCond31 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_8
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 26)
        CFI Block cfiCond32 Using cfiCommon0
        CFI (cfiCond32) NoFunction
        CFI (cfiCond32) Conditional ??CrossCallReturnLabel_9
        CFI (cfiCond32) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond32) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond32) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond32) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond32) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond32) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond32) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond32) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond32) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond32) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond32) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond32) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond32) CFA_SP SP+0
        CFI (cfiCond32) CFA_XSP16 add(XSP16, 26)
        CFI Block cfiPicker33 Using cfiCommon1
        CFI (cfiPicker33) NoFunction
        CFI (cfiPicker33) Picker
        INC     DPTR
        INC     DPTR
        LCALL   ?Subroutine7 & 0xFFFF
??CrossCallReturnLabel_15:
        MOV     R4,A
        MOV     A,R1
        MOV     R5,A
        MOV     A,R4
        RET
        CFI EndBlock cfiCond31
        CFI EndBlock cfiCond32
        CFI EndBlock cfiPicker33

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine3:
        CFI Block cfiCond34 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_6
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 28)
        CFI Block cfiCond35 Using cfiCommon0
        CFI (cfiCond35) NoFunction
        CFI (cfiCond35) Conditional ??CrossCallReturnLabel_7
        CFI (cfiCond35) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond35) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond35) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond35) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond35) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond35) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond35) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond35) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond35) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond35) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond35) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond35) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond35) CFA_SP SP+0
        CFI (cfiCond35) CFA_XSP16 add(XSP16, 28)
        CFI Block cfiPicker36 Using cfiCommon1
        CFI (cfiPicker36) NoFunction
        CFI (cfiPicker36) Picker
        MOV     R3,A
        LCALL   ?Subroutine6 & 0xFFFF
??CrossCallReturnLabel_13:
        MOV     R1,A
        RET
        CFI EndBlock cfiCond34
        CFI EndBlock cfiCond35
        CFI EndBlock cfiPicker36

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine6:
        CFI Block cfiCond37 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_12
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        CFI Block cfiCond38 Using cfiCommon0
        CFI (cfiCond38) NoFunction
        CFI (cfiCond38) Conditional ??CrossCallReturnLabel_13, ??CrossCallReturnLabel_6
        CFI (cfiCond38) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond38) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond38) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond38) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond38) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond38) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond38) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond38) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond38) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond38) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond38) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond38) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond38) CFA_SP SP+0
        CFI (cfiCond38) CFA_XSP16 add(XSP16, 28)
        CFI Block cfiCond39 Using cfiCommon0
        CFI (cfiCond39) NoFunction
        CFI (cfiCond39) Conditional ??CrossCallReturnLabel_13, ??CrossCallReturnLabel_7
        CFI (cfiCond39) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond39) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond39) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond39) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond39) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond39) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond39) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond39) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond39) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond39) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond39) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond39) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond39) CFA_SP SP+0
        CFI (cfiCond39) CFA_XSP16 add(XSP16, 28)
        CFI Block cfiPicker40 Using cfiCommon1
        CFI (cfiPicker40) NoFunction
        CFI (cfiPicker40) Picker
        MOV     A,R6
        ADD     A,#0x14
        MOV     DPL,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        RET
        CFI EndBlock cfiCond37
        CFI EndBlock cfiCond38
        CFI EndBlock cfiCond39
        CFI EndBlock cfiPicker40

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclGeneral_RegisterCmdCallbacks?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    zclGeneral_RegisterCmdCallbacks

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclGeneral_SendIdentify?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    zclGeneral_SendIdentify

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclGeneral_SendIdentifyQueryResponse?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    zclGeneral_SendIdentifyQueryResponse

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclGeneral_HdlIncoming?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    zclGeneral_HdlIncoming

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclGeneral_HdlInSpecificCommands?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    zclGeneral_HdlInSpecificCommands

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclGeneral_ProcessInIdentity?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    zclGeneral_ProcessInIdentity

        END
// 1356 #endif // ZCL_IDENTIFY
// 1357 
// 1358 #ifdef ZCL_GROUPS
// 1359 
// 1360 /*********************************************************************
// 1361  * @fn      zclGeneral_AddGroup
// 1362  *
// 1363  * @brief   Add a Group.
// 1364  *
// 1365  * @param   endPoint - application endpoint
// 1366  * @param   group - group to be added
// 1367  * @param   pData - pointer to the group info
// 1368  *
// 1369  * @return  ZStatus_t
// 1370  */
// 1371 static ZStatus_t zclGeneral_AddGroup( uint8 endPoint, aps_Group_t *group, uint8 *pData )
// 1372 {
// 1373   zclAttrRec_t attrRec;
// 1374   uint8 nameLen;
// 1375   uint8 nameSupport = FALSE;
// 1376 
// 1377   pData += 2;   // Move past group ID
// 1378   nameLen = *pData++;
// 1379 
// 1380   // Retrieve Name Support attribute
// 1381   if ( zclFindAttrRec( endPoint, ZCL_CLUSTER_ID_GEN_GROUPS, ATTRID_GROUP_NAME_SUPPORT, &attrRec ) )
// 1382      zclReadAttrData( &nameSupport, &attrRec );
// 1383 
// 1384   if ( nameSupport )
// 1385   {
// 1386     if ( nameLen > (APS_GROUP_NAME_LEN-1) )
// 1387        nameLen = (APS_GROUP_NAME_LEN-1);
// 1388     group->name[0] = nameLen;
// 1389     osal_memcpy( &(group->name[1]), pData, nameLen );
// 1390   }
// 1391 
// 1392   return ( aps_AddGroup( endPoint, group ) );
// 1393 }
// 1394 
// 1395 /*********************************************************************
// 1396  * @fn      zclGeneral_ProcessInGroupsServer
// 1397  *
// 1398  * @brief   Process in the received Groups Command.
// 1399  *
// 1400  * @param   pInMsg - pointer to the incoming message
// 1401  *
// 1402  * @return  ZStatus_t
// 1403  */
// 1404 static ZStatus_t zclGeneral_ProcessInGroupsServer( zclIncoming_t *pInMsg )
// 1405 {
// 1406   zclAttrRec_t attrRec;
// 1407   aps_Group_t group;
// 1408   aps_Group_t *pGroup;
// 1409   uint8 *pData;
// 1410   uint8 status;
// 1411   uint8 grpCnt;
// 1412   uint8 grpRspCnt = 0;
// 1413   uint16 *grpList;
// 1414   uint16 identifyTime = 0;
// 1415   uint8 i;
// 1416   ZStatus_t stat = ZSuccess;
// 1417 
// 1418   osal_memset( (uint8*)&group, 0, sizeof( aps_Group_t ) );
// 1419 
// 1420   pData = pInMsg->pData;
// 1421   group.ID = BUILD_UINT16( pData[0], pData[1] );
// 1422   switch ( pInMsg->hdr.commandID )
// 1423   {
// 1424     case COMMAND_GROUP_ADD:
// 1425       status = zclGeneral_AddGroup( pInMsg->msg->endPoint, &group, pData );
// 1426       if ( status != ZSuccess )
// 1427       {
// 1428         if ( status == ZApsDuplicateEntry )
// 1429           status = ZCL_STATUS_DUPLICATE_EXISTS;
// 1430         else
// 1431           status = ZCL_STATUS_INSUFFICIENT_SPACE;
// 1432       }
// 1433 
// 1434       zclGeneral_SendGroupAddResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 1435                                        status, group.ID, true, pInMsg->hdr.transSeqNum );
// 1436       stat = ZCL_STATUS_CMD_HAS_RSP;
// 1437       break;
// 1438 
// 1439     case COMMAND_GROUP_VIEW:
// 1440       pGroup = aps_FindGroup( pInMsg->msg->endPoint, group.ID );
// 1441       if ( pGroup )
// 1442       {
// 1443         status = ZCL_STATUS_SUCCESS;
// 1444       }
// 1445       else
// 1446       {
// 1447         // Group not found
// 1448         status = ZCL_STATUS_NOT_FOUND;
// 1449         pGroup = &group;
// 1450       }
// 1451       zclGeneral_SendGroupViewResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 1452                                         status, pGroup, true, pInMsg->hdr.transSeqNum );
// 1453       stat = ZCL_STATUS_CMD_HAS_RSP;
// 1454       break;
// 1455 
// 1456     case COMMAND_GROUP_GET_MEMBERSHIP:
// 1457       grpCnt = *pData++;
// 1458         
// 1459       // Allocate space for the group list
// 1460       grpList = osal_mem_alloc( sizeof( uint16 ) * APS_MAX_GROUPS );
// 1461       if ( grpList != NULL )
// 1462       {
// 1463         if ( grpCnt == 0 )
// 1464         {
// 1465           // Find out all the groups of which the endpoint is a member.
// 1466           grpRspCnt = aps_FindAllGroupsForEndpoint( pInMsg->msg->endPoint, grpList );
// 1467         }
// 1468         else
// 1469         {
// 1470           // Find out the groups (in the list) of which the endpoint is a member.
// 1471           for ( i = 0; i < grpCnt; i++ )
// 1472           {
// 1473             group.ID = BUILD_UINT16( pData[0], pData[1] );
// 1474             pData += 2;
// 1475 
// 1476             if ( aps_FindGroup( pInMsg->msg->endPoint, group.ID ) )
// 1477               grpList[grpRspCnt++] = group.ID;
// 1478           }
// 1479         }
// 1480       
// 1481         if ( grpCnt == 0 ||  grpRspCnt != 0 )
// 1482         {
// 1483           zclGeneral_SendGroupGetMembershipResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr, 
// 1484                                                      aps_GroupsRemaingCapacity(), grpRspCnt, 
// 1485                                                      grpList, true, pInMsg->hdr.transSeqNum );
// 1486         }
// 1487 
// 1488         osal_mem_free( grpList );
// 1489       }
// 1490       else
// 1491       {
// 1492         // Couldn't allocate space for the group list -- send a Default Response command back.
// 1493         zclDefaultRspCmd_t defaultRspCmd;
// 1494         
// 1495         defaultRspCmd.commandID = pInMsg->hdr.commandID;
// 1496         defaultRspCmd.statusCode = ZCL_STATUS_INSUFFICIENT_SPACE;
// 1497         zcl_SendDefaultRspCmd( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
// 1498                                pInMsg->msg->clusterId, &defaultRspCmd,
// 1499                                ZCL_FRAME_SERVER_CLIENT_DIR, true, 0, pInMsg->hdr.transSeqNum );
// 1500       }
// 1501 
// 1502       stat = ZCL_STATUS_CMD_HAS_RSP;
// 1503       break;
// 1504 
// 1505     case COMMAND_GROUP_REMOVE:
// 1506       if ( aps_RemoveGroup( pInMsg->msg->endPoint, group.ID ) )
// 1507         status = ZCL_STATUS_SUCCESS;
// 1508       else
// 1509         status = ZCL_STATUS_NOT_FOUND;
// 1510       zclGeneral_SendGroupRemoveResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 1511                                           status, group.ID, true, pInMsg->hdr.transSeqNum );
// 1512       stat = ZCL_STATUS_CMD_HAS_RSP;
// 1513       break;
// 1514 
// 1515     case COMMAND_GROUP_REMOVE_ALL:
// 1516       aps_RemoveAllGroup( pInMsg->msg->endPoint );
// 1517       break;
// 1518 
// 1519     case COMMAND_GROUP_ADD_IF_IDENTIFYING:
// 1520       // Retrieve Identify Time
// 1521       if ( zclFindAttrRec( pInMsg->msg->endPoint, ZCL_CLUSTER_ID_GEN_IDENTIFY, ATTRID_IDENTIFY_TIME, &attrRec ) )
// 1522         zclReadAttrData( (uint8 *)&identifyTime, &attrRec );
// 1523 
// 1524       // Is device identifying itself?
// 1525       if ( identifyTime > 0 )
// 1526         zclGeneral_AddGroup( pInMsg->msg->endPoint, &group, pData );
// 1527       break;
// 1528 
// 1529     default:
// 1530       stat = ZFailure;
// 1531       break;
// 1532   }
// 1533 
// 1534   return ( stat );
// 1535 }
// 1536 
// 1537 /*********************************************************************
// 1538  * @fn      zclGeneral_ProcessInGroupsClient
// 1539  *
// 1540  * @brief   Process in the received Groups Command.
// 1541  *
// 1542  * @param   pInMsg - pointer to the incoming message
// 1543  *
// 1544  * @return  ZStatus_t
// 1545  */
// 1546 static ZStatus_t zclGeneral_ProcessInGroupsClient( zclIncoming_t *pInMsg,
// 1547                                                    zclGeneral_AppCallbacks_t *pCBs )
// 1548 {
// 1549   aps_Group_t group;
// 1550   uint8 *pData = pInMsg->pData;
// 1551   uint16 *grpList;
// 1552   uint8 grpCnt;
// 1553   uint8 nameLen;
// 1554   zclGroupRsp_t rsp;
// 1555   uint8 i;
// 1556   ZStatus_t stat = ZSuccess;
// 1557 
// 1558   osal_memset( (uint8*)&group, 0, sizeof( aps_Group_t ) );
// 1559   osal_memset( (uint8*)&rsp, 0, sizeof( zclGroupRsp_t ) );
// 1560 
// 1561   switch ( pInMsg->hdr.commandID )
// 1562   {
// 1563     case COMMAND_GROUP_ADD_RSP:
// 1564     case COMMAND_GROUP_VIEW_RSP:
// 1565     case COMMAND_GROUP_REMOVE_RSP:
// 1566       rsp.status = *pData++;
// 1567       group.ID = BUILD_UINT16( pData[0], pData[1] );
// 1568 
// 1569       if ( rsp.status == ZCL_STATUS_SUCCESS && pInMsg->hdr.commandID == COMMAND_GROUP_VIEW_RSP )
// 1570       {
// 1571         pData += 2;   // Move past ID
// 1572         nameLen = *pData++;
// 1573         if ( nameLen > (APS_GROUP_NAME_LEN-1) )
// 1574           nameLen = (APS_GROUP_NAME_LEN-1);
// 1575         group.name[0] = nameLen;
// 1576         osal_memcpy( &(group.name[1]), pData, nameLen );
// 1577         rsp.grpName = group.name;
// 1578       }
// 1579 
// 1580       if ( pCBs->pfnGroupRsp )
// 1581       {
// 1582         rsp.srcAddr = &(pInMsg->msg->srcAddr);
// 1583         rsp.cmdID = pInMsg->hdr.commandID;
// 1584         rsp.grpCnt = 1;
// 1585         rsp.grpList = &group.ID;
// 1586         rsp.capacity = 0;
// 1587 
// 1588         pCBs->pfnGroupRsp( &rsp );
// 1589       }
// 1590       break;
// 1591 
// 1592     case COMMAND_GROUP_GET_MEMBERSHIP_RSP:
// 1593       rsp.capacity = *pData++;
// 1594       grpCnt = *pData++;
// 1595 
// 1596       if ( grpCnt > 0 )
// 1597       {
// 1598         // Allocate space for the group list
// 1599         grpList = osal_mem_alloc( sizeof( uint16 ) * grpCnt );
// 1600         if ( grpList != NULL )
// 1601         {
// 1602           rsp.grpCnt = grpCnt;
// 1603           for ( i = 0; i < grpCnt; i++ )
// 1604           {
// 1605             grpList[i] = BUILD_UINT16( pData[0], pData[1] );
// 1606             pData += 2;
// 1607           }
// 1608         }
// 1609       }
// 1610 
// 1611       if ( pCBs->pfnGroupRsp )
// 1612       {
// 1613         rsp.srcAddr = &(pInMsg->msg->srcAddr);
// 1614         rsp.cmdID = pInMsg->hdr.commandID;
// 1615         rsp.grpList = grpList;
// 1616 
// 1617         pCBs->pfnGroupRsp( &rsp );
// 1618       }
// 1619       
// 1620       if ( grpList != NULL )
// 1621         osal_mem_free( grpList );
// 1622       break;
// 1623 
// 1624     default:
// 1625       stat = ZFailure;
// 1626       break;
// 1627   }
// 1628 
// 1629   return ( stat );
// 1630 }
// 1631 #endif // ZCL_GROUPS
// 1632 
// 1633 #ifdef ZCL_SCENES
// 1634 /*********************************************************************
// 1635  * @fn      zclGeneral_AddScene
// 1636  *
// 1637  * @brief   Add a scene for an endpoint
// 1638  *
// 1639  * @param   endpoint -
// 1640  * @param   scene - new scene item
// 1641  *
// 1642  * @return  ZStatus_t
// 1643  */
// 1644 ZStatus_t zclGeneral_AddScene( uint8 endpoint, zclGeneral_Scene_t *scene )
// 1645 {
// 1646   zclGenSceneItem_t *pNewItem;
// 1647   zclGenSceneItem_t *pLoop;
// 1648 
// 1649   // Fill in the new profile list
// 1650   pNewItem = osal_mem_alloc( sizeof( zclGenSceneItem_t ) );
// 1651   if ( pNewItem == NULL )
// 1652     return ( ZMemError );
// 1653 
// 1654   // Fill in the plugin record.
// 1655   pNewItem->next = (zclGenSceneItem_t *)NULL;
// 1656   pNewItem->endpoint = endpoint;
// 1657   osal_memcpy( (uint8*)&(pNewItem->scene), (uint8*)scene, sizeof ( zclGeneral_Scene_t ));
// 1658 
// 1659   // Find spot in list
// 1660   if (  zclGenSceneTable == NULL )
// 1661   {
// 1662     zclGenSceneTable = pNewItem;
// 1663   }
// 1664   else
// 1665   {
// 1666     // Look for end of list
// 1667     pLoop = zclGenSceneTable;
// 1668     while ( pLoop->next != NULL )
// 1669       pLoop = pLoop->next;
// 1670 
// 1671     // Put new item at end of list
// 1672     pLoop->next = pNewItem;
// 1673   }
// 1674 
// 1675   // Update NV
// 1676   zclGeneral_ScenesWriteNV();
// 1677 
// 1678   return ( ZSuccess );
// 1679 }
// 1680 
// 1681 /*********************************************************************
// 1682  * @fn      zclGeneral_FindScene
// 1683  *
// 1684  * @brief   Find a scene with endpoint and sceneID
// 1685  *
// 1686  * @param   endpoint -
// 1687  * @param   groupID - what group the scene belongs to
// 1688  * @param   sceneID - ID to look for scene
// 1689  *
// 1690  * @return  a pointer to the scene information, NULL if not found
// 1691  */
// 1692 zclGeneral_Scene_t *zclGeneral_FindScene( uint8 endpoint, uint16 groupID, uint8 sceneID )
// 1693 {
// 1694   zclGenSceneItem_t *pLoop;
// 1695 
// 1696   // Look for end of list
// 1697   pLoop = zclGenSceneTable;
// 1698   while ( pLoop )
// 1699   {
// 1700     if ( (pLoop->endpoint == endpoint || endpoint == 0xFF)
// 1701         && pLoop->scene.groupID == groupID && pLoop->scene.ID == sceneID )
// 1702     {
// 1703       return ( &(pLoop->scene) );
// 1704     }
// 1705     pLoop = pLoop->next;
// 1706   }
// 1707 
// 1708   return ( (zclGeneral_Scene_t *)NULL );
// 1709 }
// 1710 
// 1711 /*********************************************************************
// 1712  * @fn      aps_FindAllScensForGroup
// 1713  *
// 1714  * @brief   Find all the scenes with groupID
// 1715  *
// 1716  * @param   endpoint - endpoint to look for
// 1717  * @param   sceneList - List to hold scene IDs (should hold APS_MAX_SCENES entries)
// 1718  *
// 1719  * @return  number of scenes copied to sceneList
// 1720  */
// 1721 uint8 zclGeneral_FindAllScenesForGroup( uint8 endpoint, uint16 groupID, uint8 *sceneList )
// 1722 {
// 1723   zclGenSceneItem_t *pLoop;
// 1724   uint8 cnt = 0;
// 1725 
// 1726   // Look for end of list
// 1727   pLoop = zclGenSceneTable;
// 1728   while ( pLoop )
// 1729   {
// 1730     if ( pLoop->endpoint == endpoint && pLoop->scene.groupID == groupID )
// 1731       sceneList[cnt++] = pLoop->scene.ID;
// 1732     pLoop = pLoop->next;
// 1733   }
// 1734   return ( cnt );
// 1735 }
// 1736 
// 1737 /*********************************************************************
// 1738  * @fn      zclGeneral_RemoveScene
// 1739  *
// 1740  * @brief   Remove a scene with endpoint and sceneID
// 1741  *
// 1742  * @param   endpoint -
// 1743  * @param   groupID - what group the scene belongs to
// 1744  * @param   sceneID - ID to look for scene
// 1745  *
// 1746  * @return  TRUE if removed, FALSE if not found
// 1747  */
// 1748 uint8 zclGeneral_RemoveScene( uint8 endpoint, uint16 groupID, uint8 sceneID )
// 1749 {
// 1750   zclGenSceneItem_t *pLoop;
// 1751   zclGenSceneItem_t *pPrev;
// 1752 
// 1753   // Look for end of list
// 1754   pLoop = zclGenSceneTable;
// 1755   pPrev = NULL;
// 1756   while ( pLoop )
// 1757   {
// 1758     if ( pLoop->endpoint == endpoint
// 1759         && pLoop->scene.groupID == groupID && pLoop->scene.ID == sceneID )
// 1760     {
// 1761       if ( pPrev == NULL )
// 1762         zclGenSceneTable = pLoop->next;
// 1763       else
// 1764         pPrev->next = pLoop->next;
// 1765 
// 1766       // Free the memory
// 1767       osal_mem_free( pLoop );
// 1768 
// 1769       // Update NV
// 1770       zclGeneral_ScenesWriteNV();
// 1771 
// 1772       return ( TRUE );
// 1773     }
// 1774     pPrev = pLoop;
// 1775     pLoop = pLoop->next;
// 1776   }
// 1777 
// 1778   return ( FALSE );
// 1779 }
// 1780 
// 1781 /*********************************************************************
// 1782  * @fn      zclGeneral_RemoveAllScenes
// 1783  *
// 1784  * @brief   Remove all scenes with endpoint and group Id
// 1785  *
// 1786  * @param   endpoint -
// 1787  * @param   groupID - ID to look for group
// 1788  *
// 1789  * @return  none
// 1790  */
// 1791 void zclGeneral_RemoveAllScenes( uint8 endpoint, uint16 groupID )
// 1792 {
// 1793   zclGenSceneItem_t *pLoop;
// 1794   zclGenSceneItem_t *pPrev;
// 1795   zclGenSceneItem_t *pNext;
// 1796 
// 1797   // Look for end of list
// 1798   pLoop = zclGenSceneTable;
// 1799   pPrev = NULL;
// 1800   while ( pLoop )
// 1801   {
// 1802     if ( pLoop->endpoint == endpoint && pLoop->scene.groupID == groupID )
// 1803     {
// 1804       if ( pPrev == NULL )
// 1805         zclGenSceneTable = pLoop->next;
// 1806       else
// 1807         pPrev->next = pLoop->next;
// 1808       pNext = pLoop->next;
// 1809 
// 1810       // Free the memory
// 1811       osal_mem_free( pLoop );
// 1812       pLoop = pNext;
// 1813     }
// 1814     else
// 1815     {
// 1816       pPrev = pLoop;
// 1817       pLoop = pLoop->next;
// 1818     }
// 1819   }
// 1820 
// 1821   // Update NV
// 1822   zclGeneral_ScenesWriteNV();
// 1823 }
// 1824 
// 1825 /*********************************************************************
// 1826  * @fn      zclGeneral_CountScenes
// 1827  *
// 1828  * @brief   Count the number of scenes for an endpoint
// 1829  *
// 1830  * @param   endpoint -
// 1831  *
// 1832  * @return  number of scenes assigned to an endpoint
// 1833  */
// 1834 uint8 zclGeneral_CountScenes( uint8 endpoint )
// 1835 {
// 1836   zclGenSceneItem_t *pLoop;
// 1837   uint8 cnt = 0;
// 1838 
// 1839   // Look for end of list
// 1840   pLoop = zclGenSceneTable;
// 1841   while ( pLoop )
// 1842   {
// 1843     if ( pLoop->endpoint == endpoint  )
// 1844       cnt++;
// 1845     pLoop = pLoop->next;
// 1846   }
// 1847   return ( cnt );
// 1848 }
// 1849 
// 1850 /*********************************************************************
// 1851  * @fn      zclGeneral_CountAllScenes
// 1852  *
// 1853  * @brief   Count the total number of scenes
// 1854  *
// 1855  * @param   none
// 1856  *
// 1857  * @return  number of scenes
// 1858  */
// 1859 uint8 zclGeneral_CountAllScenes( void )
// 1860 {
// 1861   zclGenSceneItem_t *pLoop;
// 1862   uint8 cnt = 0;
// 1863 
// 1864   // Look for end of list
// 1865   pLoop = zclGenSceneTable;
// 1866   while ( pLoop )
// 1867   {
// 1868     cnt++;
// 1869     pLoop = pLoop->next;
// 1870   }
// 1871   return ( cnt );
// 1872 }
// 1873 
// 1874 /*********************************************************************
// 1875  * @fn      zclGeneral_ProcessInScenesServer
// 1876  *
// 1877  * @brief   Process in the received Scenes Command.
// 1878  *
// 1879  * @param   pInMsg - pointer to the incoming message
// 1880  *
// 1881  * @return  ZStatus_t
// 1882  */
// 1883 static ZStatus_t zclGeneral_ProcessInScenesServer( zclIncoming_t *pInMsg,
// 1884                                                    zclGeneral_AppCallbacks_t *pCBs )
// 1885 {
// 1886   zclAttrRec_t attrRec;
// 1887   zclGeneral_Scene_t scene;
// 1888   zclGeneral_Scene_t *pScene;
// 1889   uint8 *pData = pInMsg->pData;
// 1890   uint8 nameLen;
// 1891   uint8 status;
// 1892   uint8 sceneCnt = 0;
// 1893   uint8 *sceneList = NULL;
// 1894   uint8 sendRsp = FALSE;
// 1895   uint8 nameSupport = FALSE;
// 1896   ZStatus_t stat = ZSuccess;
// 1897 
// 1898   osal_memset( (uint8*)&scene, 0, sizeof( zclGeneral_Scene_t ) );
// 1899 
// 1900   scene.groupID = BUILD_UINT16( pData[0], pData[1] );
// 1901   pData += 2;   // Move past group ID
// 1902   scene.ID = *pData++;
// 1903 
// 1904   switch ( pInMsg->hdr.commandID )
// 1905   {
// 1906     case COMMAND_SCENE_ADD:
// 1907       // Parse the rest of the incoming message
// 1908       scene.transTime = BUILD_UINT16( pData[0], pData[1] );
// 1909       pData += 2;
// 1910       nameLen= *pData++; // Name length
// 1911 
// 1912       // Retrieve Name Support attribute
// 1913       if ( zclFindAttrRec( pInMsg->msg->endPoint, ZCL_CLUSTER_ID_GEN_SCENES, ATTRID_SCENES_NAME_SUPPORT, &attrRec ) )
// 1914         zclReadAttrData( &nameSupport, &attrRec );
// 1915 
// 1916       if ( nameSupport )
// 1917       {
// 1918         if ( nameLen > (ZCL_GEN_SCENE_NAME_LEN-1) )
// 1919           nameLen = (ZCL_GEN_SCENE_NAME_LEN-1);
// 1920         scene.name[0] = nameLen;
// 1921         osal_memcpy( &(scene.name[1]), pData, nameLen );
// 1922       }
// 1923 
// 1924       pData += nameLen; // move pass name
// 1925 
// 1926       scene.extLen = pInMsg->pDataLen - ( (uint16)( pData - pInMsg->pData ) );
// 1927       if ( scene.extLen > 0 )
// 1928       {
// 1929         // Copy the extention field(s)
// 1930         if ( scene.extLen > ZCL_GEN_SCENE_EXT_LEN )
// 1931           scene.extLen = ZCL_GEN_SCENE_EXT_LEN;
// 1932         osal_memcpy( scene.extField, pData, scene.extLen );
// 1933       }
// 1934 
// 1935       if ( scene.groupID == 0x0000 ||
// 1936            aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
// 1937       {
// 1938         // Either the Scene doesn't belong to a Group (Group ID = 0x0000) or it
// 1939         // does and the corresponding Group exits
// 1940         pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
// 1941         if ( pScene || ( zclGeneral_CountAllScenes() < ZCL_GEN_MAX_SCENES ) )
// 1942         {
// 1943           status = ZCL_STATUS_SUCCESS;
// 1944           if ( pScene != NULL )
// 1945           {
// 1946             // The Scene already exists so update it
// 1947             pScene->transTime = scene.transTime;
// 1948             osal_memcpy( pScene->name, scene.name, ZCL_GEN_SCENE_NAME_LEN );
// 1949 
// 1950             // Use the new extention field(s)
// 1951             osal_memcpy( pScene->extField, scene.extField, scene.extLen );
// 1952             pScene->extLen = scene.extLen;
// 1953 
// 1954             // Update NV
// 1955             zclGeneral_ScenesWriteNV();
// 1956           }
// 1957           else
// 1958           {
// 1959             // The Scene doesn't exist so add it
// 1960             zclGeneral_AddScene( pInMsg->msg->endPoint, &scene );
// 1961           }
// 1962         }
// 1963         else
// 1964           status = ZCL_STATUS_INSUFFICIENT_SPACE; // The Scene Table is full
// 1965       }
// 1966       else
// 1967         status = ZCL_STATUS_INVALID_FIELD; // The Group is not in the Group Table
// 1968 
// 1969       zclGeneral_SendSceneAddResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 1970                                        status, scene.groupID, scene.ID,
// 1971                                        true, pInMsg->hdr.transSeqNum );
// 1972       stat = ZCL_STATUS_CMD_HAS_RSP;
// 1973       break;
// 1974 
// 1975     case COMMAND_SCENE_VIEW:
// 1976       pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
// 1977       if ( pScene != NULL )
// 1978       {
// 1979         status = ZCL_STATUS_SUCCESS;
// 1980       }
// 1981       else
// 1982       {
// 1983         // Scene not found
// 1984         if ( scene.groupID != 0x0000 &&
// 1985              aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) == NULL )
// 1986         {
// 1987           status = ZCL_STATUS_INVALID_FIELD; // The Group is not in the Group Table
// 1988         }
// 1989         else
// 1990           status = ZCL_STATUS_NOT_FOUND;
// 1991         pScene = &scene;
// 1992       }
// 1993       zclGeneral_SendSceneViewResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 1994                                         status, pScene, true, pInMsg->hdr.transSeqNum );
// 1995       stat = ZCL_STATUS_CMD_HAS_RSP;
// 1996       break;
// 1997 
// 1998     case COMMAND_SCENE_REMOVE:
// 1999       if ( zclGeneral_RemoveScene( pInMsg->msg->endPoint, scene.groupID, scene.ID ) )
// 2000       {
// 2001         status = ZCL_STATUS_SUCCESS;
// 2002       }
// 2003       else
// 2004       {
// 2005         // Scene not found
// 2006         if ( aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) == NULL )
// 2007         {
// 2008           // The Group is not in the Group Table
// 2009           status = ZCL_STATUS_INVALID_FIELD;
// 2010         }
// 2011         else
// 2012           status = ZCL_STATUS_NOT_FOUND;
// 2013       }
// 2014 
// 2015       if ( UNICAST_MSG( pInMsg->msg ) )
// 2016       {
// 2017         // Addressed to this device (not to a group) - send a response back
// 2018         zclGeneral_SendSceneRemoveResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 2019                                             status, scene.groupID,
// 2020                                             scene.ID, true, pInMsg->hdr.transSeqNum );
// 2021       }
// 2022       stat = ZCL_STATUS_CMD_HAS_RSP;
// 2023       break;
// 2024 
// 2025     case COMMAND_SCENE_REMOVE_ALL:
// 2026       if ( scene.groupID == 0x0000 ||
// 2027            aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
// 2028       {
// 2029         zclGeneral_RemoveAllScenes( pInMsg->msg->endPoint, scene.groupID );
// 2030         status = ZCL_STATUS_SUCCESS;
// 2031       }
// 2032       else
// 2033         status = ZCL_STATUS_INVALID_FIELD;
// 2034 
// 2035       if ( UNICAST_MSG( pInMsg->msg ) )
// 2036       {
// 2037         // Addressed to this device (not to a group) - send a response back
// 2038         zclGeneral_SendSceneRemoveAllResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 2039                                                status, scene.groupID, true, pInMsg->hdr.transSeqNum );
// 2040       }
// 2041       stat = ZCL_STATUS_CMD_HAS_RSP;
// 2042       break;
// 2043 
// 2044     case COMMAND_SCENE_STORE:
// 2045       if ( scene.groupID == 0x0000 ||
// 2046            aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
// 2047       {
// 2048         // Either the Scene doesn't belong to a Group (Group ID = 0x0000) or it
// 2049         // does and the corresponding Group exits
// 2050         pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
// 2051         if ( pScene || ( zclGeneral_CountAllScenes() < ZCL_GEN_MAX_SCENES ) )
// 2052         {
// 2053           uint8 sceneChanged = FALSE;
// 2054 
// 2055           status = ZCL_STATUS_SUCCESS;
// 2056           if ( pScene == NULL )
// 2057           {
// 2058             // Haven't been added yet
// 2059             pScene = &scene;
// 2060           }
// 2061 
// 2062           if ( pCBs->pfnSceneStoreReq )
// 2063           {
// 2064             zclSceneReq_t req;
// 2065 
// 2066             req.srcAddr = &(pInMsg->msg->srcAddr);
// 2067             req.scene = pScene;
// 2068 
// 2069             // Get the latest Scene info
// 2070             if ( pCBs->pfnSceneStoreReq( &req ) )
// 2071               sceneChanged = TRUE;
// 2072           }
// 2073 
// 2074           if ( pScene == &scene )
// 2075           {
// 2076             // The Scene doesn't exist so add it
// 2077             zclGeneral_AddScene( pInMsg->msg->endPoint, &scene );
// 2078           }
// 2079           else if ( sceneChanged )
// 2080           {
// 2081             // The Scene already exists so update only NV
// 2082             zclGeneral_ScenesWriteNV();
// 2083           }
// 2084         }
// 2085         else
// 2086           status = ZCL_STATUS_INSUFFICIENT_SPACE; // The Scene Table is full
// 2087       }
// 2088       else
// 2089         status = ZCL_STATUS_INVALID_FIELD; // The Group is not in the Group Table
// 2090 
// 2091       if ( UNICAST_MSG( pInMsg->msg ) )
// 2092       {
// 2093         // Addressed to this device (not to a group) - send a response back
// 2094         zclGeneral_SendSceneStoreResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 2095                                            status, scene.groupID, scene.ID,
// 2096                                            true, pInMsg->hdr.transSeqNum );
// 2097       }
// 2098       stat = ZCL_STATUS_CMD_HAS_RSP;
// 2099       break;
// 2100 
// 2101     case COMMAND_SCENE_RECALL:
// 2102       pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
// 2103       if ( pScene && pCBs->pfnSceneRecallReq )
// 2104       {
// 2105         zclSceneReq_t req;
// 2106 
// 2107         req.srcAddr = &(pInMsg->msg->srcAddr);
// 2108         req.scene = pScene;
// 2109 
// 2110         pCBs->pfnSceneRecallReq( &req );
// 2111       }
// 2112       // No response
// 2113       break;
// 2114 
// 2115     case COMMAND_SCENE_GET_MEMBERSHIP:
// 2116       // Find all the Scenes corresponding to the Group ID
// 2117       if ( scene.groupID == 0x0000 ||
// 2118            aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
// 2119       {
// 2120         // Allocate space for the scene list
// 2121         sceneList = osal_mem_alloc( ZCL_GEN_MAX_SCENES );
// 2122         if ( sceneList != NULL )
// 2123         {
// 2124           sceneCnt = zclGeneral_FindAllScenesForGroup( pInMsg->msg->endPoint, 
// 2125                                                        scene.groupID, sceneList ); 
// 2126           status = ZCL_STATUS_SUCCESS;
// 2127           if ( UNICAST_MSG( pInMsg->msg ) )
// 2128           {
// 2129             // Addressed only to this device - send a response back
// 2130             sendRsp = TRUE;
// 2131           }
// 2132           else
// 2133           {
// 2134             // Addressed to the Group - ONLY send a response if an entry within the 
// 2135             // Scene Table corresponds to the Group ID
// 2136             if ( sceneCnt != 0 )
// 2137               sendRsp = TRUE;
// 2138           }
// 2139         }
// 2140         else
// 2141         {
// 2142           // Couldn't allocate space for the scene list!
// 2143           status = ZCL_STATUS_INSUFFICIENT_SPACE;
// 2144           sendRsp = TRUE;
// 2145         }
// 2146       }
// 2147       else
// 2148       {
// 2149         // The Group is not in the Group Table - send a response back
// 2150         status = ZCL_STATUS_INVALID_FIELD;
// 2151         sendRsp = TRUE;
// 2152       }
// 2153 
// 2154       if ( sendRsp )
// 2155       {
// 2156         zclGeneral_SendSceneGetMembershipResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 2157                                     status, zclGeneral_ScenesRemaingCapacity(), sceneCnt, sceneList,
// 2158                                     scene.groupID, true, pInMsg->hdr.transSeqNum );
// 2159       }
// 2160       
// 2161       if ( sceneList != NULL )
// 2162         osal_mem_free( sceneList );
// 2163       
// 2164       stat = ZCL_STATUS_CMD_HAS_RSP;
// 2165       break;
// 2166 
// 2167     default:
// 2168       stat = ZFailure;
// 2169     break;
// 2170   }
// 2171 
// 2172   return ( stat );
// 2173 }
// 2174 
// 2175 /*********************************************************************
// 2176  * @fn      zclGeneral_ProcessInScenesClient
// 2177  *
// 2178  * @brief   Process in the received Scenes Command.
// 2179  *
// 2180  * @param   pInMsg - pointer to the incoming message
// 2181  *
// 2182  * @return  ZStatus_t
// 2183  */
// 2184 static ZStatus_t zclGeneral_ProcessInScenesClient( zclIncoming_t *pInMsg,
// 2185                                                    zclGeneral_AppCallbacks_t *pCBs )
// 2186 {
// 2187   zclGeneral_Scene_t scene;
// 2188   uint8 *pData = pInMsg->pData;
// 2189   uint8 nameLen;
// 2190   uint8 *sceneList = NULL;
// 2191   zclSceneRsp_t rsp;
// 2192   uint8 i;
// 2193   ZStatus_t stat = ZSuccess;
// 2194 
// 2195   osal_memset( (uint8*)&scene, 0, sizeof( zclGeneral_Scene_t ) );
// 2196   osal_memset( (uint8*)&rsp, 0, sizeof( zclSceneRsp_t ) );
// 2197 
// 2198   // Get the status field first
// 2199   rsp.status = *pData++;
// 2200 
// 2201   if ( pInMsg->hdr.commandID == COMMAND_SCENE_GET_MEMBERSHIP_RSP )
// 2202     rsp.capacity = *pData++;
// 2203 
// 2204   scene.groupID = BUILD_UINT16( pData[0], pData[1] );
// 2205   pData += 2;   // Move past group ID
// 2206 
// 2207   switch ( pInMsg->hdr.commandID )
// 2208   {
// 2209     case COMMAND_SCENE_VIEW_RSP:
// 2210       // Parse the rest of the incoming message
// 2211       scene.ID = *pData++; // Not applicable to Remove All Response command
// 2212       scene.transTime = BUILD_UINT16( pData[0], pData[1] );
// 2213       pData += 2;
// 2214       nameLen = *pData++; // Name length
// 2215       if ( nameLen > (ZCL_GEN_SCENE_NAME_LEN-1) )
// 2216         nameLen = (ZCL_GEN_SCENE_NAME_LEN-1);
// 2217       scene.name[0] = nameLen;
// 2218       osal_memcpy( &(scene.name[1]), pData, nameLen );
// 2219       pData += nameLen; // move pass name
// 2220 
// 2221       //*** Do something with the extension field(s)
// 2222 
// 2223       // Fall through to callback - break is left off intentionally
// 2224 
// 2225     case COMMAND_SCENE_ADD_RSP:
// 2226     case COMMAND_SCENE_REMOVE_RSP:
// 2227     case COMMAND_SCENE_REMOVE_ALL_RSP:
// 2228     case COMMAND_SCENE_STORE_RSP:
// 2229       if ( pCBs->pfnSceneRsp )
// 2230       {
// 2231         rsp.srcAddr = &(pInMsg->msg->srcAddr);
// 2232         rsp.cmdID = pInMsg->hdr.commandID;
// 2233         rsp.scene = &scene;
// 2234 
// 2235         pCBs->pfnSceneRsp( &rsp );
// 2236       }
// 2237       break;
// 2238 
// 2239     case COMMAND_SCENE_GET_MEMBERSHIP_RSP:
// 2240       if ( rsp.status == ZCL_STATUS_SUCCESS )
// 2241       {
// 2242         uint8 sceneCnt = *pData++;
// 2243         
// 2244         if ( sceneCnt > 0 )
// 2245         {
// 2246           // Allocate space for the scene list
// 2247           sceneList = osal_mem_alloc( sceneCnt );
// 2248           if ( sceneList != NULL )
// 2249           {
// 2250             rsp.sceneCnt = sceneCnt;
// 2251             for ( i = 0; i < sceneCnt; i++ )
// 2252               sceneList[i] = *pData++;
// 2253           }
// 2254         }
// 2255       }
// 2256 
// 2257       if ( pCBs->pfnSceneRsp )
// 2258       {
// 2259         rsp.srcAddr = &(pInMsg->msg->srcAddr);
// 2260         rsp.cmdID = pInMsg->hdr.commandID;
// 2261         rsp.sceneList = sceneList;
// 2262         rsp.scene = &scene;
// 2263 
// 2264         pCBs->pfnSceneRsp( &rsp);
// 2265       }
// 2266       
// 2267       if ( sceneList != NULL )
// 2268         osal_mem_free( sceneList );
// 2269       break;
// 2270 
// 2271     default:
// 2272       stat = ZFailure;
// 2273       break;
// 2274   }
// 2275 
// 2276   return ( stat );
// 2277 }
// 2278 #endif // ZCL_SCENES
// 2279 
// 2280 #ifdef ZCL_ON_OFF
// 2281 /*********************************************************************
// 2282  * @fn      zclGeneral_ProcessInCmdOnOff
// 2283  *
// 2284  * @brief   Process in the received On/Off Command.
// 2285  *
// 2286  * @param   pInMsg - pointer to the incoming message
// 2287  *
// 2288  * @return  ZStatus_t
// 2289  */
// 2290 static ZStatus_t zclGeneral_ProcessInOnOff( zclIncoming_t *pInMsg,
// 2291                                             zclGeneral_AppCallbacks_t *pCBs )
// 2292 {
// 2293   if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
// 2294   {
// 2295     if ( pInMsg->hdr.commandID > COMMAND_TOGGLE )
// 2296       return ( ZFailure );   // Error ignore the command
// 2297 
// 2298     if ( pCBs->pfnOnOff )
// 2299       pCBs->pfnOnOff( pInMsg->hdr.commandID );
// 2300   }
// 2301   // no Client command
// 2302 
// 2303   return ( ZSuccess );
// 2304 }
// 2305 #endif // ZCL_ON_OFF
// 2306 
// 2307 #ifdef ZCL_LEVEL_CTRL
// 2308 /*********************************************************************
// 2309  * @fn      zclGeneral_ProcessInLevelControl
// 2310  *
// 2311  * @brief   Process in the received Level Control Command.
// 2312  *
// 2313  * @param   pInMsg - pointer to the incoming message
// 2314  *
// 2315  * @return  ZStatus_t
// 2316  */
// 2317 static ZStatus_t zclGeneral_ProcessInLevelControl( zclIncoming_t *pInMsg,
// 2318                                                    zclGeneral_AppCallbacks_t *pCBs )
// 2319 {
// 2320   uint8 withOnOff = FALSE;
// 2321   ZStatus_t stat = ZSuccess;
// 2322 
// 2323   if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
// 2324   {
// 2325     switch ( pInMsg->hdr.commandID )
// 2326     {
// 2327       case COMMAND_LEVEL_MOVE_TO_LEVEL_WITH_ON_OFF:
// 2328         withOnOff = TRUE;
// 2329         // fall through
// 2330       case COMMAND_LEVEL_MOVE_TO_LEVEL:
// 2331         if ( pCBs->pfnLevelControlMoveToLevel )
// 2332         {
// 2333           zclLCMoveToLevel_t cmd;
// 2334 
// 2335           cmd.level = pInMsg->pData[0];
// 2336           cmd.transitionTime = BUILD_UINT16( pInMsg->pData[1], pInMsg->pData[2] );
// 2337           cmd.withOnOff = withOnOff;
// 2338 
// 2339           pCBs->pfnLevelControlMoveToLevel( &cmd );
// 2340         }
// 2341         break;
// 2342 
// 2343       case COMMAND_LEVEL_MOVE_WITH_ON_OFF:
// 2344         withOnOff = TRUE;
// 2345         // fall through
// 2346       case COMMAND_LEVEL_MOVE:
// 2347         if ( pCBs->pfnLevelControlMove )
// 2348         {
// 2349           zclLCMove_t cmd;
// 2350 
// 2351           cmd.moveMode = pInMsg->pData[0];
// 2352           cmd.rate = pInMsg->pData[1];
// 2353           cmd.withOnOff = withOnOff;
// 2354 
// 2355           pCBs->pfnLevelControlMove( &cmd );
// 2356         }
// 2357         break;
// 2358 
// 2359       case COMMAND_LEVEL_STEP_WITH_ON_OFF:
// 2360         withOnOff = TRUE;
// 2361         // fall through
// 2362       case COMMAND_LEVEL_STEP:
// 2363         if ( pCBs->pfnLevelControlStep )
// 2364         {
// 2365           zclLCStep_t cmd;
// 2366 
// 2367           cmd.stepMode = pInMsg->pData[0];
// 2368           cmd.amount =  pInMsg->pData[1];
// 2369           cmd.transitionTime = BUILD_UINT16( pInMsg->pData[2], pInMsg->pData[3] );
// 2370           cmd.withOnOff = withOnOff;
// 2371 
// 2372           pCBs->pfnLevelControlStep( &cmd );
// 2373         }
// 2374         break;
// 2375 
// 2376       case COMMAND_LEVEL_STOP:
// 2377       case COMMAND_LEVEL_STOP_WITH_ON_OFF:
// 2378         // Both Stop commands are identical
// 2379         if ( pCBs->pfnLevelControlStop )
// 2380         {
// 2381           pCBs->pfnLevelControlStop();
// 2382         }
// 2383         break;
// 2384 
// 2385       default:
// 2386         stat = ZFailure;
// 2387         break;
// 2388     }
// 2389   }
// 2390   // no Client command
// 2391 
// 2392   return ( stat );
// 2393 }
// 2394 #endif // ZCL_LEVEL_CTRL
// 2395 
// 2396 #ifdef ZCL_ALARMS
// 2397 /*********************************************************************
// 2398  * @fn      zclGeneral_AddAlarm
// 2399  *
// 2400  * @brief   Add an alarm for a cluster
// 2401  *
// 2402  * @param   endpoint -
// 2403  * @param   alarm - new alarm item
// 2404  *
// 2405  * @return  ZStatus_t
// 2406  */
// 2407 ZStatus_t zclGeneral_AddAlarm( uint8 endpoint, zclGeneral_Alarm_t *alarm )
// 2408 {
// 2409   zclGenAlarmItem_t *pNewItem;
// 2410   zclGenAlarmItem_t *pLoop;
// 2411 
// 2412   // Fill in the new profile list
// 2413   pNewItem = osal_mem_alloc( sizeof( zclGenAlarmItem_t ) );
// 2414   if ( pNewItem == NULL )
// 2415     return ( ZMemError );
// 2416 
// 2417   // Fill in the plugin record.
// 2418   pNewItem->next = (zclGenAlarmItem_t *)NULL;
// 2419   pNewItem->endpoint =  endpoint;
// 2420   osal_memcpy( (uint8*)(&pNewItem->alarm), (uint8*)alarm, sizeof ( zclGeneral_Alarm_t ) );
// 2421 
// 2422   // Find spot in list
// 2423   if (  zclGenAlarmTable == NULL )
// 2424   {
// 2425     zclGenAlarmTable = pNewItem;
// 2426   }
// 2427   else
// 2428   {
// 2429     // Look for end of list
// 2430     pLoop = zclGenAlarmTable;
// 2431     while ( pLoop->next != NULL )
// 2432       pLoop = pLoop->next;
// 2433 
// 2434     // Put new item at end of list
// 2435     pLoop->next = pNewItem;
// 2436   }
// 2437 
// 2438   return ( ZSuccess );
// 2439 }
// 2440 
// 2441 /*********************************************************************
// 2442  * @fn      zclGeneral_FindAlarm
// 2443  *
// 2444  * @brief   Find an alarm with alarmCode and clusterID
// 2445  *
// 2446  * @param   endpoint -
// 2447  * @param   groupID - what group the scene belongs to
// 2448  * @param   sceneID - ID to look for scene
// 2449  *
// 2450  * @return  a pointer to the alarm information, NULL if not found
// 2451  */
// 2452 zclGeneral_Alarm_t *zclGeneral_FindAlarm( uint8 endpoint, uint8 alarmCode, uint16 clusterID )
// 2453 {
// 2454   zclGenAlarmItem_t *pLoop;
// 2455 
// 2456   // Look for the alarm
// 2457   pLoop = zclGenAlarmTable;
// 2458   while ( pLoop )
// 2459   {
// 2460     if ( pLoop->endpoint == endpoint &&
// 2461          pLoop->alarm.code == alarmCode && pLoop->alarm.clusterID == clusterID )
// 2462     {
// 2463       return ( &(pLoop->alarm) );
// 2464     }
// 2465     pLoop = pLoop->next;
// 2466   }
// 2467 
// 2468   return ( (zclGeneral_Alarm_t *)NULL );
// 2469 }
// 2470 
// 2471 /*********************************************************************
// 2472  * @fn      zclGeneral_FindEarliestAlarm
// 2473  *
// 2474  * @brief   Find an alarm with the earliest timestamp
// 2475  *
// 2476  * @param   endpoint -
// 2477  *
// 2478  * @return  a pointer to the alarm information, NULL if not found
// 2479  */
// 2480 zclGeneral_Alarm_t *zclGeneral_FindEarliestAlarm( uint8 endpoint )
// 2481 {
// 2482   zclGenAlarmItem_t *pLoop;
// 2483   zclGenAlarmItem_t earliestAlarm;
// 2484   zclGenAlarmItem_t *pEarliestAlarm = &earliestAlarm;
// 2485 
// 2486   pEarliestAlarm->alarm.timeStamp = 0xFFFFFFFF;
// 2487 
// 2488   // Look for alarm with earliest time
// 2489   pLoop = zclGenAlarmTable;
// 2490   while ( pLoop )
// 2491   {
// 2492     if ( pLoop->endpoint == endpoint &&
// 2493          pLoop->alarm.timeStamp < pEarliestAlarm->alarm.timeStamp )
// 2494     {
// 2495       pEarliestAlarm = pLoop;
// 2496     }
// 2497     pLoop = pLoop->next;
// 2498   }
// 2499 
// 2500   if ( pEarliestAlarm->alarm.timeStamp != 0xFFFFFFFF )
// 2501     return ( &(pEarliestAlarm->alarm) );
// 2502 
// 2503   // No alarm
// 2504   return ( (zclGeneral_Alarm_t *)NULL );
// 2505 }
// 2506 
// 2507 /*********************************************************************
// 2508  * @fn      zclGeneral_ResetAlarm
// 2509  *
// 2510  * @brief   Remove a scene with endpoint and sceneID
// 2511  *
// 2512  * @param   endpoint -
// 2513  * @param   alarmCode -
// 2514  * @param   clusterID -
// 2515  *
// 2516  * @return  TRUE if removed, FALSE if not found
// 2517  */
// 2518 void zclGeneral_ResetAlarm( uint8 endpoint, uint8 alarmCode, uint16 clusterID )
// 2519 {
// 2520   zclGenAlarmItem_t *pLoop;
// 2521   zclGenAlarmItem_t *pPrev;
// 2522 
// 2523   // Look for end of list
// 2524   pLoop = zclGenAlarmTable;
// 2525   pPrev = NULL;
// 2526   while ( pLoop )
// 2527   {
// 2528     if ( pLoop->endpoint == endpoint &&
// 2529          pLoop->alarm.code == alarmCode && pLoop->alarm.clusterID == clusterID )
// 2530     {
// 2531       if ( pPrev == NULL )
// 2532         zclGenAlarmTable = pLoop->next;
// 2533       else
// 2534         pPrev->next = pLoop->next;
// 2535 
// 2536       // Free the memory
// 2537       osal_mem_free( pLoop );
// 2538 
// 2539       // Notify the Application so that if the alarm condition still active then
// 2540       // a new notification will be generated, and a new alarm record will be
// 2541       // added to the alarm log
// 2542       // zclGeneral_NotifyReset( alarmCode, clusterID ); // callback function?
// 2543       return;
// 2544     }
// 2545     pPrev = pLoop;
// 2546     pLoop = pLoop->next;
// 2547   }
// 2548 }
// 2549 
// 2550 /*********************************************************************
// 2551  * @fn      zclGeneral_ResetAllAlarms
// 2552  *
// 2553  * @brief   Remove all alarms with endpoint
// 2554  *
// 2555  * @param   endpoint -
// 2556  * @param   notifyApp -
// 2557  *
// 2558  * @return  none
// 2559  */
// 2560 void zclGeneral_ResetAllAlarms( uint8 endpoint, uint8 notifyApp )
// 2561 {
// 2562   zclGenAlarmItem_t *pLoop;
// 2563   zclGenAlarmItem_t *pPrev;
// 2564   zclGenAlarmItem_t *pNext;
// 2565 
// 2566   // Look for end of list
// 2567   pLoop = zclGenAlarmTable;
// 2568   pPrev = NULL;
// 2569   while ( pLoop )
// 2570   {
// 2571     if (  pLoop->endpoint == endpoint )
// 2572     {
// 2573       if ( pPrev == NULL )
// 2574         zclGenAlarmTable = pLoop->next;
// 2575       else
// 2576         pPrev->next = pLoop->next;
// 2577 
// 2578       pNext = pLoop->next;
// 2579 
// 2580       // Free the memory
// 2581       osal_mem_free( pLoop );
// 2582 
// 2583       pLoop = pNext;
// 2584     }
// 2585     else
// 2586     {
// 2587       pPrev = pLoop;
// 2588       pLoop = pLoop->next;
// 2589     }
// 2590   }
// 2591 
// 2592   if ( notifyApp )
// 2593   {
// 2594     // Notify the Application so that if any alarm conditions still active then
// 2595     // a new notification will be generated, and a new alarm record will be
// 2596     // added to the alarm log
// 2597     // zclGeneral_NotifyResetAll(); // callback function?
// 2598   }
// 2599 }
// 2600 
// 2601 /*********************************************************************
// 2602  * @fn      zclGeneral_ProcessInAlarmsServer
// 2603  *
// 2604  * @brief   Process in the received Alarms Command.
// 2605  *
// 2606  * @param   pInMsg - pointer to the incoming message
// 2607  *
// 2608  * @return  ZStatus_t
// 2609  */
// 2610 static ZStatus_t zclGeneral_ProcessInAlarmsServer( zclIncoming_t *pInMsg,
// 2611                                                    zclGeneral_AppCallbacks_t *pCBs )
// 2612 {
// 2613   zclGeneral_Alarm_t *pAlarm;
// 2614   uint8 *pData = pInMsg->pData;
// 2615   ZStatus_t stat = ZSuccess;
// 2616 
// 2617   switch ( pInMsg->hdr.commandID )
// 2618   {
// 2619     case COMMAND_ALARMS_RESET:
// 2620       zclGeneral_ResetAlarm( pInMsg->msg->endPoint, pData[0],
// 2621                              BUILD_UINT16( pData[1], pData[2] ) );
// 2622       break;
// 2623 
// 2624     case COMMAND_ALARMS_RESET_ALL:
// 2625       zclGeneral_ResetAllAlarms( pInMsg->msg->endPoint, TRUE );
// 2626       break;
// 2627 
// 2628     case COMMAND_ALARMS_GET:
// 2629       pAlarm = zclGeneral_FindEarliestAlarm( pInMsg->msg->endPoint );
// 2630       if ( pAlarm )
// 2631       {
// 2632         // Send a response back
// 2633         zclGeneral_SendAlarmGetRespnose( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 2634                                          ZCL_STATUS_SUCCESS, pAlarm->code,
// 2635                                          pAlarm->clusterID, pAlarm->timeStamp,
// 2636                                          true, pInMsg->hdr.transSeqNum );
// 2637         // Remove the entry from the Alarm table
// 2638         zclGeneral_ResetAlarm( pInMsg->msg->endPoint, pAlarm->code, pAlarm->clusterID );
// 2639       }
// 2640       else
// 2641       {
// 2642         // Send a response back
// 2643         zclGeneral_SendAlarmGetRespnose( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 2644                                          ZCL_STATUS_NOT_FOUND, 0, 0, 0,
// 2645                                          true, pInMsg->hdr.transSeqNum );
// 2646       }
// 2647       stat = ZCL_STATUS_CMD_HAS_RSP;
// 2648       break;
// 2649 
// 2650     case COMMAND_ALARMS_RESET_LOG:
// 2651       zclGeneral_ResetAllAlarms( pInMsg->msg->endPoint, FALSE );
// 2652       break;
// 2653 
// 2654     default:
// 2655       stat = ZFailure;
// 2656       break;
// 2657   }
// 2658 
// 2659   return ( stat );
// 2660 }
// 2661 
// 2662 /*********************************************************************
// 2663  * @fn      zclGeneral_ProcessInAlarmsClient
// 2664  *
// 2665  * @brief   Process in the received Alarms Command.
// 2666  *
// 2667  * @param   pInMsg - pointer to the incoming message
// 2668  *
// 2669  * @return  ZStatus_t
// 2670  */
// 2671 static ZStatus_t zclGeneral_ProcessInAlarmsClient( zclIncoming_t *pInMsg,
// 2672                                                    zclGeneral_AppCallbacks_t *pCBs )
// 2673 {
// 2674   uint8 *pData = pInMsg->pData;
// 2675   zclAlarm_t alarm;
// 2676   ZStatus_t stat = ZSuccess;
// 2677 
// 2678   osal_memset( (uint8*)&alarm, 0, sizeof( zclAlarm_t ) );
// 2679 
// 2680   switch ( pInMsg->hdr.commandID )
// 2681   {
// 2682     case COMMAND_ALARMS_ALARM:
// 2683       if ( pCBs->pfnAlarm )
// 2684       {
// 2685         alarm.srcAddr = &(pInMsg->msg->srcAddr);
// 2686         alarm.cmdID = pInMsg->hdr.commandID;
// 2687         alarm.status = *pData++;
// 2688         alarm.alarmCode = *pData++;
// 2689         alarm.clusterID = BUILD_UINT16( pData[0], pData[1] );
// 2690         pData += 2;
// 2691         alarm.timeStamp = osal_build_uint32( pData, 4 );
// 2692 
// 2693         pCBs->pfnAlarm( &alarm );
// 2694       }
// 2695       break;
// 2696 
// 2697     case COMMAND_ALARMS_GET_RSP:
// 2698       if ( pCBs->pfnAlarm )
// 2699       {
// 2700         alarm.srcAddr = &(pInMsg->msg->srcAddr);
// 2701         alarm.cmdID = pInMsg->hdr.commandID;
// 2702         alarm.alarmCode = *pData++;
// 2703         alarm.clusterID = BUILD_UINT16( pData[0], pData[1] );
// 2704 
// 2705         pCBs->pfnAlarm( &alarm );
// 2706       }
// 2707       break;
// 2708 
// 2709     default:
// 2710       stat = ZFailure;
// 2711       break;
// 2712   }
// 2713 
// 2714   return ( stat );
// 2715 }
// 2716 #endif // ZCL_ALARMS
// 2717 
// 2718 #ifdef ZCL_LOCATION
// 2719 /*********************************************************************
// 2720  * @fn      zclGeneral_ProcessInLocationServer
// 2721  *
// 2722  * @brief   Process in the received Location Command.
// 2723  *
// 2724  * @param   pInMsg - pointer to the incoming message
// 2725  *
// 2726  * @return  ZStatus_t
// 2727  */
// 2728 static ZStatus_t zclGeneral_ProcessInLocationServer( zclIncoming_t *pInMsg,
// 2729                                                      zclGeneral_AppCallbacks_t *pCBs )
// 2730 {
// 2731   uint8 *pData = pInMsg->pData;
// 2732   zclLocation_t cmd;
// 2733   ZStatus_t stat = ZSuccess;
// 2734 
// 2735   osal_memset( (uint8*)&cmd, 0, sizeof( zclLocation_t ) );
// 2736 
// 2737   switch ( pInMsg->hdr.commandID )
// 2738   {
// 2739     case COMMAND_LOCATION_SET_ABSOLUTE:
// 2740       cmd.un.absLoc.coordinate1 = BUILD_UINT16( pData[0], pData[1] );
// 2741       pData += 2;
// 2742       cmd.un.absLoc.coordinate2 = BUILD_UINT16( pData[0], pData[1] );
// 2743       pData += 2;
// 2744       cmd.un.absLoc.coordinate3 = BUILD_UINT16( pData[0], pData[1] );
// 2745       pData += 2;
// 2746       cmd.un.absLoc.power = BUILD_UINT16( pData[0], pData[1] );
// 2747       pData += 2;
// 2748       cmd.un.absLoc.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
// 2749 
// 2750       if ( pCBs->pfnLocation )
// 2751       {
// 2752         cmd.srcAddr = &(pInMsg->msg->srcAddr);
// 2753         cmd.cmdID = pInMsg->hdr.commandID;
// 2754 
// 2755         // Update the absolute location info
// 2756         pCBs->pfnLocation( &cmd );
// 2757       }
// 2758       break;
// 2759 
// 2760     case COMMAND_LOCATION_SET_DEV_CFG:
// 2761       cmd.un.devCfg.power = BUILD_UINT16( pData[0], pData[1] );
// 2762       pData += 2;
// 2763       cmd.un.devCfg.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
// 2764       pData += 2;
// 2765       cmd.un.devCfg.calcPeriod = BUILD_UINT16( pData[0], pData[1] );
// 2766       pData += 2;
// 2767       cmd.un.devCfg.numMeasurements = *pData++;
// 2768       cmd.un.devCfg.reportPeriod = BUILD_UINT16( pData[0], pData[1] );
// 2769 
// 2770       if ( pCBs->pfnLocation )
// 2771       {
// 2772         cmd.srcAddr = &(pInMsg->msg->srcAddr);
// 2773         cmd.cmdID = pInMsg->hdr.commandID;
// 2774 
// 2775         // Update the device configuration info
// 2776         pCBs->pfnLocation( &cmd );
// 2777       }
// 2778       break;
// 2779 
// 2780     case COMMAND_LOCATION_GET_DEV_CFG:
// 2781       cmd.un.ieeeAddr = pData;
// 2782 
// 2783       if ( pCBs->pfnLocation )
// 2784       {
// 2785         cmd.srcAddr = &(pInMsg->msg->srcAddr);
// 2786         cmd.cmdID = pInMsg->hdr.commandID;
// 2787         cmd.seqNum = pInMsg->hdr.transSeqNum;
// 2788 
// 2789         // Retreive the Device Configuration
// 2790         pCBs->pfnLocation( &cmd );
// 2791       }
// 2792       stat = ZCL_STATUS_CMD_HAS_RSP;
// 2793       break;
// 2794 
// 2795     case COMMAND_LOCATION_GET_DATA:
// 2796       cmd.un.loc.bitmap.locByte = *pData++;
// 2797       cmd.un.loc.numResponses = *pData++;
// 2798 
// 2799       if ( cmd.un.loc.brdcastResponse == 0 ) // command is sent as a unicast
// 2800         osal_cpyExtAddr( cmd.un.loc.targetAddr, pData );
// 2801 
// 2802       if ( pCBs->pfnLocation )
// 2803       {
// 2804         cmd.srcAddr = &(pInMsg->msg->srcAddr);
// 2805         cmd.cmdID = pInMsg->hdr.commandID;
// 2806         cmd.seqNum = pInMsg->hdr.transSeqNum;
// 2807 
// 2808         // Retreive the Location Data
// 2809         pCBs->pfnLocation( &cmd );
// 2810       }
// 2811       stat = ZCL_STATUS_CMD_HAS_RSP;
// 2812       break;
// 2813 
// 2814     default:
// 2815       stat = ZFailure;
// 2816       break;
// 2817   }
// 2818 
// 2819   return ( stat );
// 2820 }
// 2821 
// 2822 /*********************************************************************
// 2823  * @fn      zclGeneral_ProcessInLocationDataRsp
// 2824  *
// 2825  * @brief   Process in the received Location Command.
// 2826  *
// 2827  * @param   pInMsg - pointer to the incoming message
// 2828  *
// 2829  * @return  ZStatus_t
// 2830  */
// 2831 static void zclGeneral_ProcessInLocationDataRsp( zclIncoming_t *pInMsg,
// 2832                                                  zclGeneral_AppCallbacks_t *pCBs )
// 2833 {
// 2834   uint8 *pData = pInMsg->pData;
// 2835   zclLocationRsp_t rsp;
// 2836 
// 2837   osal_memset( (uint8*)&rsp, 0, sizeof( zclLocationRsp_t ) );
// 2838 
// 2839   if ( pCBs->pfnLocationRsp )
// 2840   {
// 2841     if ( pInMsg->hdr.commandID == COMMAND_LOCATION_DATA_RSP )
// 2842       rsp.un.loc.status = *pData++;
// 2843 
// 2844     if ( pInMsg->hdr.commandID != COMMAND_LOCATION_DATA_RSP ||
// 2845          rsp.un.loc.status == ZCL_STATUS_SUCCESS )
// 2846     {
// 2847       rsp.un.loc.data.type = *pData++;
// 2848       rsp.un.loc.data.absLoc.coordinate1 = BUILD_UINT16( pData[0], pData[1] );
// 2849       pData += 2;
// 2850       rsp.un.loc.data.absLoc.coordinate2 = BUILD_UINT16( pData[0], pData[1] );
// 2851       pData += 2;
// 2852 
// 2853       if ( locationType2D( rsp.un.loc.data.type ) == 0 )
// 2854       {
// 2855         rsp.un.loc.data.absLoc.coordinate3 = BUILD_UINT16( pData[0], pData[1] );
// 2856         pData += 2;
// 2857       }
// 2858 
// 2859       if ( pInMsg->hdr.commandID != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
// 2860       {
// 2861         rsp.un.loc.data.absLoc.power = BUILD_UINT16( pData[0], pData[1] );
// 2862         pData += 2;
// 2863         rsp.un.loc.data.absLoc.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
// 2864         pData += 2;
// 2865       }
// 2866 
// 2867       if ( locationTypeAbsolute( rsp.un.loc.data.type ) == 0 )
// 2868       {
// 2869         if ( pInMsg->hdr.commandID != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
// 2870           rsp.un.loc.data.calcLoc.locationMethod = *pData++;
// 2871 
// 2872         rsp.un.loc.data.calcLoc.qualityMeasure = *pData++;
// 2873         rsp.un.loc.data.calcLoc.locationAge = BUILD_UINT16( pData[0], pData[1] );
// 2874       }
// 2875     }
// 2876 
// 2877     rsp.srcAddr = &(pInMsg->msg->srcAddr);
// 2878     rsp.cmdID = pInMsg->hdr.commandID;
// 2879 
// 2880     // Notify the Application
// 2881     pCBs->pfnLocationRsp( &rsp );
// 2882   }
// 2883 }
// 2884 
// 2885 /*********************************************************************
// 2886  * @fn      zclGeneral_ProcessInLocationClient
// 2887  *
// 2888  * @brief   Process in the received Location Command.
// 2889  *
// 2890  * @param   pInMsg - pointer to the incoming message
// 2891  *
// 2892  * @return  ZStatus_t
// 2893  */
// 2894 static ZStatus_t zclGeneral_ProcessInLocationClient( zclIncoming_t *pInMsg,
// 2895                                                      zclGeneral_AppCallbacks_t *pCBs )
// 2896 {
// 2897   uint8 *pData = pInMsg->pData;
// 2898   zclLocationRsp_t rsp;
// 2899   ZStatus_t stat = ZSuccess;
// 2900 
// 2901   osal_memset( (uint8*)&rsp, 0, sizeof( zclLocationRsp_t ) );
// 2902 
// 2903   switch ( pInMsg->hdr.commandID )
// 2904   {
// 2905     case COMMAND_LOCATION_DEV_CFG_RSP:
// 2906       if ( pCBs->pfnLocationRsp )
// 2907       {
// 2908         rsp.un.devCfg.status = *pData++;
// 2909         if ( rsp.un.devCfg.status == ZCL_STATUS_SUCCESS )
// 2910         {
// 2911           rsp.un.devCfg.data.power = BUILD_UINT16( pData[0], pData[1] );
// 2912           pData += 2;
// 2913           rsp.un.devCfg.data.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
// 2914           pData += 2;
// 2915           rsp.un.devCfg.data.calcPeriod = BUILD_UINT16( pData[0], pData[1] );
// 2916           pData += 2;
// 2917           rsp.un.devCfg.data.numMeasurements = *pData++;
// 2918           rsp.un.devCfg.data.reportPeriod = BUILD_UINT16( pData[0], pData[1] );
// 2919 
// 2920           rsp.srcAddr = &(pInMsg->msg->srcAddr);
// 2921           rsp.cmdID = pInMsg->hdr.commandID;
// 2922 
// 2923           // Notify the Application
// 2924           pCBs->pfnLocationRsp( &rsp );
// 2925         }
// 2926       }
// 2927       break;
// 2928 
// 2929     case COMMAND_LOCATION_DATA_RSP:
// 2930     case COMMAND_LOCATION_DATA_NOTIF:
// 2931     case COMMAND_LOCATION_COMPACT_DATA_NOTIF:
// 2932       zclGeneral_ProcessInLocationDataRsp( pInMsg, pCBs );
// 2933       break;
// 2934 
// 2935     case COMMAND_LOCATION_RSSI_PING:
// 2936       if ( pCBs->pfnLocationRsp )
// 2937       {
// 2938         rsp.un.locationType = *pData;
// 2939 
// 2940         rsp.srcAddr = &(pInMsg->msg->srcAddr);
// 2941         rsp.cmdID = pInMsg->hdr.commandID;
// 2942 
// 2943         // Notify the Application
// 2944         pCBs->pfnLocationRsp( &rsp );
// 2945       }
// 2946       break;
// 2947 
// 2948     default:
// 2949       stat = ZFailure;
// 2950       break;
// 2951   }
// 2952 
// 2953   return ( stat );
// 2954 }
// 2955 #endif // ZCL_LOCATION
// 2956 
// 2957 #ifdef ZCL_SCENES
// 2958 /*********************************************************************
// 2959  * @fn      zclGeneral_ScenesInitNV
// 2960  *
// 2961  * @brief   Initialize the NV Scene Table Items
// 2962  *
// 2963  * @param   none
// 2964  *
// 2965  * @return  number of scenes
// 2966  */
// 2967 static uint8 zclGeneral_ScenesInitNV( void )
// 2968 {
// 2969   uint8  status;
// 2970   uint16 size;
// 2971 
// 2972   size = (uint16)((sizeof ( nvGenScenesHdr_t ))
// 2973                   + ( sizeof( zclGenSceneNVItem_t ) * ZCL_GEN_MAX_SCENES ));
// 2974 
// 2975   status = osal_nv_item_init( ZCD_NV_SCENE_TABLE, size, NULL );
// 2976 
// 2977   if ( status != ZSUCCESS )
// 2978   {
// 2979     zclGeneral_ScenesSetDefaultNV();
// 2980   }
// 2981 
// 2982   return status;
// 2983 }
// 2984 
// 2985 /*********************************************************************
// 2986  * @fn          zclGeneral_ScenesSetDefaultNV
// 2987  *
// 2988  * @brief       Write the defaults to NV
// 2989  *
// 2990  * @param       none
// 2991  *
// 2992  * @return      none
// 2993  */
// 2994 static void zclGeneral_ScenesSetDefaultNV( void )
// 2995 {
// 2996   nvGenScenesHdr_t hdr;
// 2997 
// 2998   // Initialize the header
// 2999   hdr.numRecs = 0;
// 3000 
// 3001   // Save off the header
// 3002   osal_nv_write( ZCD_NV_SCENE_TABLE, 0, sizeof( nvGenScenesHdr_t ), &hdr );
// 3003 }
// 3004 
// 3005 /*********************************************************************
// 3006  * @fn          zclGeneral_ScenesWriteNV
// 3007  *
// 3008  * @brief       Save the Scene Table in NV
// 3009  *
// 3010  * @param       none
// 3011  *
// 3012  * @return      none
// 3013  */
// 3014 static void zclGeneral_ScenesWriteNV( void )
// 3015 {
// 3016   nvGenScenesHdr_t hdr;
// 3017   zclGenSceneItem_t *pLoop;
// 3018   zclGenSceneNVItem_t item;
// 3019 
// 3020   hdr.numRecs = 0;
// 3021 
// 3022   // Look for end of list
// 3023   pLoop = zclGenSceneTable;
// 3024   while ( pLoop )
// 3025   {
// 3026     // Build the record
// 3027     item.endpoint = pLoop->endpoint;
// 3028     osal_memcpy( &(item.scene), &(pLoop->scene), sizeof ( zclGeneral_Scene_t ) );
// 3029 
// 3030     // Save the record to NV
// 3031     osal_nv_write( ZCD_NV_SCENE_TABLE,
// 3032             (uint16)((sizeof( nvGenScenesHdr_t )) + (hdr.numRecs * sizeof ( zclGenSceneNVItem_t ))),
// 3033                     sizeof ( zclGenSceneNVItem_t ), &item );
// 3034 
// 3035     hdr.numRecs++;
// 3036 
// 3037     pLoop = pLoop->next;
// 3038   }
// 3039 
// 3040   // Save off the header
// 3041   osal_nv_write( ZCD_NV_SCENE_TABLE, 0, sizeof( nvGenScenesHdr_t ), &hdr );
// 3042 }
// 3043 
// 3044 /*********************************************************************
// 3045  * @fn          zclGeneral_ScenesRestoreFromNV
// 3046  *
// 3047  * @brief       Restore the Scene table from NV
// 3048  *
// 3049  * @param       none
// 3050  *
// 3051  * @return      Number of entries restored
// 3052  */
// 3053 static uint16 zclGeneral_ScenesRestoreFromNV( void )
// 3054 {
// 3055   uint16 x;
// 3056   nvGenScenesHdr_t hdr;
// 3057 
// 3058   zclGenSceneNVItem_t item;
// 3059   uint16 numAdded = 0;
// 3060 
// 3061   if ( osal_nv_read( ZCD_NV_SCENE_TABLE, 0, sizeof(nvGenScenesHdr_t), &hdr ) == ZSuccess )
// 3062   {
// 3063     // Read in the device list
// 3064     for ( x = 0; x < hdr.numRecs; x++ )
// 3065     {
// 3066       if ( osal_nv_read( ZCD_NV_SCENE_TABLE,
// 3067                 (uint16)(sizeof(nvGenScenesHdr_t) + (x * sizeof ( zclGenSceneNVItem_t ))),
// 3068                                   sizeof ( zclGenSceneNVItem_t ), &item ) == ZSUCCESS )
// 3069       {
// 3070         // Add the scene
// 3071         if ( zclGeneral_AddScene( item.endpoint, &(item.scene) ) == ZSuccess )
// 3072         {
// 3073           numAdded++;
// 3074         }
// 3075       }
// 3076     }
// 3077   }
// 3078 
// 3079   return ( numAdded );
// 3080 }
// 3081 #endif // ZCL_SCENES
// 3082 
// 3083 /***************************************************************************
// 3084 ****************************************************************************/
// 
// 1 013 bytes in segment BANKED_CODE
//    36 bytes in segment BANK_RELAYS
//     3 bytes in segment XDATA_Z
// 
// 1 049 bytes of CODE  memory
//     3 bytes of XDATA memory
//
//Errors: none
//Warnings: none
