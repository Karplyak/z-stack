///////////////////////////////////////////////////////////////////////////////
//                                                                            /
// IAR C/C++ Compiler V7.51A/W32 for 8051               01/Dec/2010  16:50:59 /
// Copyright 2004-2009 IAR Systems AB.                                        /
//                                                                            /
//    Core               =  plain                                             /
//    Code model         =  banked                                            /
//    Data model         =  large                                             /
//    Calling convention =  xdata reentrant                                   /
//    Constant location  =  data_rom                                          /
//    Dptr setup         =  1,16                                              /
//    Source file        =  D:\R.D Dept\程式開發\TI CC2530 example\ZIGBEE     /
//                          Z-Stack\CC2530_ZStack-2.3.0-1.4.0\Sensor Network  /
//                          Example\Components\stack\zcl\zcl_general.c        /
//    Command line       =  -f "D:\R.D Dept\程式開發\TI CC2530                /
//                          example\ZIGBEE Z-Stack\CC2530_ZStack-2.3.0-1.4.0\ /
//                          Sensor Network Example\Projects\zstack\Sensor     /
//                          Network Application\ZIGBEE Endpoint &             /
//                          Device\CC2530DB\..\..\..\Tools\CC2530DB\f8wEndev. /
//                          cfg" (-DCPU32MHZ -DROOT=__near_func               /
//                          -DBLINK_LEDS) -f "D:\R.D Dept\程式開發\TI CC2530  /
//                          example\ZIGBEE Z-Stack\CC2530_ZStack-2.3.0-1.4.0\ /
//                          Sensor Network Example\Projects\zstack\Sensor     /
//                          Network Application\ZIGBEE Endpoint &             /
//                          Device\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig /
//                          .cfg" (-DSECURE=0 -DZG_SECURE_DYNAMIC=0           /
//                          -DREFLECTOR -DDEFAULT_CHANLIST=0x00000800         /
//                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                      /
//                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_M /
//                          ASK=0x007F -DBEACON_REQUEST_DELAY=100             /
//                          -DBEACON_REQ_DELAY_MASK=0x00FF                    /
//                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_P /
//                          OLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7           /
//                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3   /
//                          -DNWK_MAX_DATA_RETRIES=2                          /
//                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9        /
//                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40          /
//                          -DNWK_MAX_BINDING_ENTRIES=4                       /
//                          -DMAX_BINDING_CLUSTER_IDS=4                       /
//                          "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07, 0x09,     /
//                          0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08,   /
//                          0x0A, 0x0C, 0x0D}" -DMAC_MAX_FRAME_SIZE=116       /
//                          "-DCONST=const __code" -DGENERIC=__generic        /
//                          -DRFD_RCVC_ALWAYS_ON=TRUE -DPOLL_RATE=1000        /
//                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100   /
//                          -DREJOIN_POLL_RATE=440) -f "D:\R.D                /
//                          Dept\程式開發\TI CC2530 example\ZIGBEE            /
//                          Z-Stack\CC2530_ZStack-2.3.0-1.4.0\Sensor Network  /
//                          Example\Projects\zstack\Sensor Network            /
//                          Application\ZIGBEE Endpoint &                     /
//                          Device\CC2530DB\..\..\..\Tools\CC2530DB\f8wZCL.cf /
//                          g" (-DZCL_READ -DZCL_WRITE -DZCL_BASIC            /
//                          -DZCL_IDENTIFY -DZCL_ON_OFF -DZCL_KEY_ESTABLISH   /
//                          -DZCL_LOAD_CONTROL -DZCL_SIMPLE_METERING          /
//                          -DZCL_PRICING) -DZCL_MESSAGE "D:\R.D              /
//                          Dept\程式開發\TI CC2530 example\ZIGBEE            /
//                          Z-Stack\CC2530_ZStack-2.3.0-1.4.0\Sensor Network  /
//                          Example\Components\stack\zcl\zcl_general.c" -D    /
//                          NWK_AUTO_POLL -D ZTOOL_P1 -D MT_TASK -D           /
//                          MT_APP_FUNC -D MT_SYS_FUNC -D MT_ZDO_FUNC -D      /
//                          LCD_SUPPORTED=DEBUG -D xPOWER_SAVING -D           /
//                          End_Device -D HAL_KEYPAD -D M270 -D xPA2591 -lC   /
//                          "D:\R.D Dept\程式開發\TI CC2530 example\ZIGBEE    /
//                          Z-Stack\CC2530_ZStack-2.3.0-1.4.0\Sensor Network  /
//                          Example\Projects\zstack\Sensor Network            /
//                          Application\ZIGBEE Endpoint &                     /
//                          Device\CC2530DB\EndDeviceEB_M270\List\" -lA       /
//                          "D:\R.D Dept\程式開發\TI CC2530 example\ZIGBEE    /
//                          Z-Stack\CC2530_ZStack-2.3.0-1.4.0\Sensor Network  /
//                          Example\Projects\zstack\Sensor Network            /
//                          Application\ZIGBEE Endpoint &                     /
//                          Device\CC2530DB\EndDeviceEB_M270\List\"           /
//                          --diag_suppress Pe001,Pa010 -o "D:\R.D            /
//                          Dept\程式開發\TI CC2530 example\ZIGBEE            /
//                          Z-Stack\CC2530_ZStack-2.3.0-1.4.0\Sensor Network  /
//                          Example\Projects\zstack\Sensor Network            /
//                          Application\ZIGBEE Endpoint &                     /
//                          Device\CC2530DB\EndDeviceEB_M270\Obj\" -e         /
//                          --require_prototypes --debug --core=plain         /
//                          --dptr=16,1 --data_model=large                    /
//                          --code_model=banked --calling_convention=xdata_re /
//                          entrant --place_constants=data_rom                /
//                          --nr_virtual_regs 16 -I "D:\R.D Dept\程式開發\TI  /
//                          CC2530 example\ZIGBEE Z-Stack\CC2530_ZStack-2.3.0 /
//                          -1.4.0\Sensor Network Example\Projects\zstack\Sen /
//                          sor Network Application\ZIGBEE Endpoint &         /
//                          Device\CC2530DB\" -I "D:\R.D Dept\程式開發\TI     /
//                          CC2530 example\ZIGBEE Z-Stack\CC2530_ZStack-2.3.0 /
//                          -1.4.0\Sensor Network Example\Projects\zstack\Sen /
//                          sor Network Application\ZIGBEE Endpoint &         /
//                          Device\CC2530DB\..\SOURCE\" -I "D:\R.D            /
//                          Dept\程式開發\TI CC2530 example\ZIGBEE            /
//                          Z-Stack\CC2530_ZStack-2.3.0-1.4.0\Sensor Network  /
//                          Example\Projects\zstack\Sensor Network            /
//                          Application\ZIGBEE Endpoint &                     /
//                          Device\CC2530DB\..\..\SOURCE\" -I "D:\R.D         /
//                          Dept\程式開發\TI CC2530 example\ZIGBEE            /
//                          Z-Stack\CC2530_ZStack-2.3.0-1.4.0\Sensor Network  /
//                          Example\Projects\zstack\Sensor Network            /
//                          Application\ZIGBEE Endpoint &                     /
//                          Device\CC2530DB\..\..\..\ZMAIN\TI2530DB\" -I      /
//                          "D:\R.D Dept\程式開發\TI CC2530 example\ZIGBEE    /
//                          Z-Stack\CC2530_ZStack-2.3.0-1.4.0\Sensor Network  /
//                          Example\Projects\zstack\Sensor Network            /
//                          Application\ZIGBEE Endpoint &                     /
//                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\MT\"    /
//                          -I "D:\R.D Dept\程式開發\TI CC2530                /
//                          example\ZIGBEE Z-Stack\CC2530_ZStack-2.3.0-1.4.0\ /
//                          Sensor Network Example\Projects\zstack\Sensor     /
//                          Network Application\ZIGBEE Endpoint &             /
//                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\INC /
//                          LUDE\" -I "D:\R.D Dept\程式開發\TI CC2530         /
//                          example\ZIGBEE Z-Stack\CC2530_ZStack-2.3.0-1.4.0\ /
//                          Sensor Network Example\Projects\zstack\Sensor     /
//                          Network Application\ZIGBEE Endpoint &             /
//                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\MOD /
//                          ULE\" -I "D:\R.D Dept\程式開發\TI CC2530          /
//                          example\ZIGBEE Z-Stack\CC2530_ZStack-2.3.0-1.4.0\ /
//                          Sensor Network Example\Projects\zstack\Sensor     /
//                          Network Application\ZIGBEE Endpoint &             /
//                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\TAR /
//                          GET\CC2530EB\" -I "D:\R.D Dept\程式開發\TI        /
//                          CC2530 example\ZIGBEE Z-Stack\CC2530_ZStack-2.3.0 /
//                          -1.4.0\Sensor Network Example\Projects\zstack\Sen /
//                          sor Network Application\ZIGBEE Endpoint &         /
//                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\OSAL\MC /
//                          U\CCSOC\" -I "D:\R.D Dept\程式開發\TI CC2530      /
//                          example\ZIGBEE Z-Stack\CC2530_ZStack-2.3.0-1.4.0\ /
//                          Sensor Network Example\Projects\zstack\Sensor     /
//                          Network Application\ZIGBEE Endpoint &             /
//                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\OSAL\IN /
//                          CLUDE\" -I "D:\R.D Dept\程式開發\TI CC2530        /
//                          example\ZIGBEE Z-Stack\CC2530_ZStack-2.3.0-1.4.0\ /
//                          Sensor Network Example\Projects\zstack\Sensor     /
//                          Network Application\ZIGBEE Endpoint &             /
//                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\A /
//                          F\" -I "D:\R.D Dept\程式開發\TI CC2530            /
//                          example\ZIGBEE Z-Stack\CC2530_ZStack-2.3.0-1.4.0\ /
//                          Sensor Network Example\Projects\zstack\Sensor     /
//                          Network Application\ZIGBEE Endpoint &             /
//                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\N /
//                          WK\" -I "D:\R.D Dept\程式開發\TI CC2530           /
//                          example\ZIGBEE Z-Stack\CC2530_ZStack-2.3.0-1.4.0\ /
//                          Sensor Network Example\Projects\zstack\Sensor     /
//                          Network Application\ZIGBEE Endpoint &             /
//                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\S /
//                          EC\" -I "D:\R.D Dept\程式開發\TI CC2530           /
//                          example\ZIGBEE Z-Stack\CC2530_ZStack-2.3.0-1.4.0\ /
//                          Sensor Network Example\Projects\zstack\Sensor     /
//                          Network Application\ZIGBEE Endpoint &             /
//                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\S /
//                          API\" -I "D:\R.D Dept\程式開發\TI CC2530          /
//                          example\ZIGBEE Z-Stack\CC2530_ZStack-2.3.0-1.4.0\ /
//                          Sensor Network Example\Projects\zstack\Sensor     /
//                          Network Application\ZIGBEE Endpoint &             /
//                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\S /
//                          YS\" -I "D:\R.D Dept\程式開發\TI CC2530           /
//                          example\ZIGBEE Z-Stack\CC2530_ZStack-2.3.0-1.4.0\ /
//                          Sensor Network Example\Projects\zstack\Sensor     /
//                          Network Application\ZIGBEE Endpoint &             /
//                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\Z /
//                          CL\" -I "D:\R.D Dept\程式開發\TI CC2530           /
//                          example\ZIGBEE Z-Stack\CC2530_ZStack-2.3.0-1.4.0\ /
//                          Sensor Network Example\Projects\zstack\Sensor     /
//                          Network Application\ZIGBEE Endpoint &             /
//                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\Z /
//                          DO\" -I "D:\R.D Dept\程式開發\TI CC2530           /
//                          example\ZIGBEE Z-Stack\CC2530_ZStack-2.3.0-1.4.0\ /
//                          Sensor Network Example\Projects\zstack\Sensor     /
//                          Network Application\ZIGBEE Endpoint &             /
//                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\ZMAC\F8 /
//                          W\" -I "D:\R.D Dept\程式開發\TI CC2530            /
//                          example\ZIGBEE Z-Stack\CC2530_ZStack-2.3.0-1.4.0\ /
//                          Sensor Network Example\Projects\zstack\Sensor     /
//                          Network Application\ZIGBEE Endpoint &             /
//                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\ZMAC\"  /
//                          -I "D:\R.D Dept\程式開發\TI CC2530                /
//                          example\ZIGBEE Z-Stack\CC2530_ZStack-2.3.0-1.4.0\ /
//                          Sensor Network Example\Projects\zstack\Sensor     /
//                          Network Application\ZIGBEE Endpoint &             /
//                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\SERVICE /
//                          S\SADDR\" -I "D:\R.D Dept\程式開發\TI CC2530      /
//                          example\ZIGBEE Z-Stack\CC2530_ZStack-2.3.0-1.4.0\ /
//                          Sensor Network Example\Projects\zstack\Sensor     /
//                          Network Application\ZIGBEE Endpoint &             /
//                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\SERVICE /
//                          S\SDATA\" -I "D:\R.D Dept\程式開發\TI CC2530      /
//                          example\ZIGBEE Z-Stack\CC2530_ZStack-2.3.0-1.4.0\ /
//                          Sensor Network Example\Projects\zstack\Sensor     /
//                          Network Application\ZIGBEE Endpoint &             /
//                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\INC /
//                          LUDE\" -I "D:\R.D Dept\程式開發\TI CC2530         /
//                          example\ZIGBEE Z-Stack\CC2530_ZStack-2.3.0-1.4.0\ /
//                          Sensor Network Example\Projects\zstack\Sensor     /
//                          Network Application\ZIGBEE Endpoint &             /
//                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\HIG /
//                          H_LEVEL\" -I "D:\R.D Dept\程式開發\TI CC2530      /
//                          example\ZIGBEE Z-Stack\CC2530_ZStack-2.3.0-1.4.0\ /
//                          Sensor Network Example\Projects\zstack\Sensor     /
//                          Network Application\ZIGBEE Endpoint &             /
//                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\LOW /
//                          _LEVEL\srf04\" -I "D:\R.D Dept\程式開發\TI        /
//                          CC2530 example\ZIGBEE Z-Stack\CC2530_ZStack-2.3.0 /
//                          -1.4.0\Sensor Network Example\Projects\zstack\Sen /
//                          sor Network Application\ZIGBEE Endpoint &         /
//                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\LOW /
//                          _LEVEL\srf04\SINGLE_CHIP\" -I "C:\IAR             /
//                          Systems\Embedded Workbench for MCS-51             /
//                          V7.51\8051\INC\" -I "C:\IAR Systems\Embedded      /
//                          Workbench for MCS-51 V7.51\8051\INC\CLIB\" -Ohz   /
//    List file          =  D:\R.D Dept\程式開發\TI CC2530 example\ZIGBEE     /
//                          Z-Stack\CC2530_ZStack-2.3.0-1.4.0\Sensor Network  /
//                          Example\Projects\zstack\Sensor Network            /
//                          Application\ZIGBEE Endpoint &                     /
//                          Device\CC2530DB\EndDeviceEB_M270\List\zcl_general /
//                          .s51                                              /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME zcl_general

        RTMODEL "__calling_convention", "xdata_reentrant"
        RTMODEL "__code_model", "banked"
        RTMODEL "__core", "plain"
        RTMODEL "__data_model", "large"
        RTMODEL "__dptr_size", "16"
        RTMODEL "__extended_stack", "disabled"
        RTMODEL "__location_for_constants", "data"
        RTMODEL "__number_of_dptrs", "1"
        RTMODEL "__rt_version", "1"

        RSEG DOVERLAY:DATA:NOROOT(0)
        RSEG IOVERLAY:IDATA:NOROOT(0)
        RSEG ISTACK:IDATA:NOROOT(0)
        RSEG PSTACK:XDATA:NOROOT(0)
        RSEG XSTACK:XDATA:NOROOT(0)

        EXTERN ??zclGeneral_HdlInSpecificCommands?relay
        EXTERN ??zclGeneral_HdlIncoming?relay
        EXTERN ??zclGeneral_ProcessInIdentity?relay
        EXTERN ??zclGeneral_SendIdentifyQueryResponse?relay
        EXTERN ?ALLOC_XSTACK8
        EXTERN ?BANKED_ENTER_XDATA
        EXTERN ?BANKED_LEAVE_XDATA
        EXTERN ?BDISPATCH
        EXTERN ?BRET
        EXTERN ?CALL_IND
        EXTERN ?DEALLOC_XSTACK8
        EXTERN ?PUSH_XSTACK_I_ONE
        EXTERN ?PUSH_XSTACK_I_TWO
        EXTERN ?UC_SWITCH_SPARSE
        EXTERN ?V0
        EXTERN ?XSP
        EXTERN ?XSTACK_DISP0_8
        EXTERN __INIT_XDATA_Z

        FUNCTION ??zclGeneral_HdlInSpecificCommands?relay,0203H
        FUNCTION ??zclGeneral_HdlIncoming?relay,0203H
        FUNCTION ??zclGeneral_ProcessInIdentity?relay,0203H
        PUBLIC ??zclGeneral_RegisterCmdCallbacks?relay
        FUNCTION ??zclGeneral_RegisterCmdCallbacks?relay,0203H
        PUBLIC ??zclGeneral_SendIdentify?relay
        FUNCTION ??zclGeneral_SendIdentify?relay,0203H
        PUBLIC ??zclGeneral_SendIdentifyQueryResponse?relay
        FUNCTION ??zclGeneral_SendIdentifyQueryResponse?relay,0203H
        FUNCTION zclGeneral_HdlInSpecificCommands,0a1203H
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 10, STACK
        FUNCTION zclGeneral_HdlIncoming,021603H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        FUNCTION zclGeneral_ProcessInIdentity,021203H
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 28, STACK
        PUBLIC zclGeneral_RegisterCmdCallbacks
        FUNCTION zclGeneral_RegisterCmdCallbacks,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 14, STACK
        PUBLIC zclGeneral_SendIdentify
        FUNCTION zclGeneral_SendIdentify,021203H
        ARGFRAME XSTACK, 2, STACK
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 23, STACK
        PUBLIC zclGeneral_SendIdentifyQueryResponse
        FUNCTION zclGeneral_SendIdentifyQueryResponse,021203H
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 23, STACK
        
        CFI Names cfiNames0
        CFI StackFrame CFA_SP SP IDATA
        CFI StackFrame CFA_PSP16 PSP16 XDATA
        CFI StackFrame CFA_XSP16 XSP16 XDATA
        CFI StaticOverlayFrame CFA_IOVERLAY IOVERLAY
        CFI StaticOverlayFrame CFA_DOVERLAY DOVERLAY
        CFI Resource `PSW.CY`:1, `B.BR0`:1, `B.BR1`:1, `B.BR2`:1, `B.BR3`:1
        CFI Resource `B.BR4`:1, `B.BR5`:1, `B.BR6`:1, `B.BR7`:1, `VB.BR8`:1
        CFI Resource `VB.BR9`:1, `VB.BR10`:1, `VB.BR11`:1, `VB.BR12`:1
        CFI Resource `VB.BR13`:1, `VB.BR14`:1, `VB.BR15`:1, VB:8, B:8, A:8
        CFI Resource PSW:8, DPL0:8, DPH0:8, R0:8, R1:8, R2:8, R3:8, R4:8, R5:8
        CFI Resource R6:8, R7:8, V0:8, V1:8, V2:8, V3:8, V4:8, V5:8, V6:8, V7:8
        CFI Resource V8:8, V9:8, V10:8, V11:8, V12:8, V13:8, V14:8, V15:8, SP:8
        CFI Resource PSPH:8, PSPL:8, PSP16:16, XSPH:8, XSPL:8, XSP16:16
        CFI VirtualResource ?RET:24
        CFI Resource ?BRET_EXT:8
        CFI VirtualResource ?RET_HIGH:8, ?RET_LOW:8
        CFI ResourceParts PSP16 PSPH, PSPL
        CFI ResourceParts XSP16 XSPH, XSPL
        CFI ResourceParts ?RET ?BRET_EXT, ?RET_HIGH, ?RET_LOW
        CFI EndNames cfiNames0
        
        CFI Common cfiCommon0 Using cfiNames0
        CFI CodeAlign 1
        CFI DataAlign -1
        CFI ReturnAddress ?RET CODE
        CFI CFA_DOVERLAY Used
        CFI CFA_IOVERLAY Used
        CFI CFA_SP SP+-3
        CFI CFA_PSP16 PSP16+0
        CFI CFA_XSP16 XSP16+0
        CFI `PSW.CY` SameValue
        CFI `B.BR0` SameValue
        CFI `B.BR1` SameValue
        CFI `B.BR2` SameValue
        CFI `B.BR3` SameValue
        CFI `B.BR4` SameValue
        CFI `B.BR5` SameValue
        CFI `B.BR6` SameValue
        CFI `B.BR7` SameValue
        CFI `VB.BR8` SameValue
        CFI `VB.BR9` SameValue
        CFI `VB.BR10` SameValue
        CFI `VB.BR11` SameValue
        CFI `VB.BR12` SameValue
        CFI `VB.BR13` SameValue
        CFI `VB.BR14` SameValue
        CFI `VB.BR15` SameValue
        CFI VB SameValue
        CFI B Undefined
        CFI A Undefined
        CFI PSW SameValue
        CFI DPL0 SameValue
        CFI DPH0 SameValue
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 Undefined
        CFI R5 Undefined
        CFI R6 SameValue
        CFI R7 SameValue
        CFI V0 SameValue
        CFI V1 SameValue
        CFI V2 SameValue
        CFI V3 SameValue
        CFI V4 SameValue
        CFI V5 SameValue
        CFI V6 SameValue
        CFI V7 SameValue
        CFI V8 SameValue
        CFI V9 SameValue
        CFI V10 SameValue
        CFI V11 SameValue
        CFI V12 SameValue
        CFI V13 SameValue
        CFI V14 SameValue
        CFI V15 SameValue
        CFI PSPH Undefined
        CFI PSPL Undefined
        CFI XSPH Undefined
        CFI XSPL Undefined
        CFI ?RET Concat
        CFI ?BRET_EXT Frame(CFA_SP, 3)
        CFI ?RET_HIGH Frame(CFA_SP, 2)
        CFI ?RET_LOW Frame(CFA_SP, 1)
        CFI EndCommon cfiCommon0
        
        
        CFI Common cfiCommon1 Using cfiNames0
        CFI CodeAlign 1
        CFI DataAlign -1
        CFI ReturnAddress ?RET CODE
        CFI CFA_DOVERLAY Used
        CFI CFA_IOVERLAY Used
        CFI CFA_SP SP+-2
        CFI CFA_PSP16 PSP16+0
        CFI CFA_XSP16 XSP16+0
        CFI `PSW.CY` SameValue
        CFI `B.BR0` SameValue
        CFI `B.BR1` SameValue
        CFI `B.BR2` SameValue
        CFI `B.BR3` SameValue
        CFI `B.BR4` SameValue
        CFI `B.BR5` SameValue
        CFI `B.BR6` SameValue
        CFI `B.BR7` SameValue
        CFI `VB.BR8` SameValue
        CFI `VB.BR9` SameValue
        CFI `VB.BR10` SameValue
        CFI `VB.BR11` SameValue
        CFI `VB.BR12` SameValue
        CFI `VB.BR13` SameValue
        CFI `VB.BR14` SameValue
        CFI `VB.BR15` SameValue
        CFI VB SameValue
        CFI B SameValue
        CFI A SameValue
        CFI PSW SameValue
        CFI DPL0 SameValue
        CFI DPH0 SameValue
        CFI R0 SameValue
        CFI R1 SameValue
        CFI R2 SameValue
        CFI R3 SameValue
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI V0 SameValue
        CFI V1 SameValue
        CFI V2 SameValue
        CFI V3 SameValue
        CFI V4 SameValue
        CFI V5 SameValue
        CFI V6 SameValue
        CFI V7 SameValue
        CFI V8 SameValue
        CFI V9 SameValue
        CFI V10 SameValue
        CFI V11 SameValue
        CFI V12 SameValue
        CFI V13 SameValue
        CFI V14 SameValue
        CFI V15 SameValue
        CFI PSPH Undefined
        CFI PSPL Undefined
        CFI XSPH Undefined
        CFI XSPL Undefined
        CFI ?RET Concat
        CFI ?BRET_EXT SameValue
        CFI ?RET_HIGH Frame(CFA_SP, 2)
        CFI ?RET_LOW Frame(CFA_SP, 1)
        CFI EndCommon cfiCommon1
        
zcl_registerPlugin  SYMBOL "zcl_registerPlugin"
osal_mem_alloc      SYMBOL "osal_mem_alloc"
zcl_SendCommand     SYMBOL "zcl_SendCommand"
zclFindAttrRec      SYMBOL "zclFindAttrRec"
zclReadAttrData     SYMBOL "zclReadAttrData"
??osal_mem_alloc?relay SYMBOL "?relay", osal_mem_alloc
??zclFindAttrRec?relay SYMBOL "?relay", zclFindAttrRec
??zclReadAttrData?relay SYMBOL "?relay", zclReadAttrData
??zcl_SendCommand?relay SYMBOL "?relay", zcl_SendCommand
??zcl_registerPlugin?relay SYMBOL "?relay", zcl_registerPlugin
zclGeneral_RegisterCmdCallbacks SYMBOL "zclGeneral_RegisterCmdCallbacks"
??zclGeneral_RegisterCmdCallbacks?relay SYMBOL "?relay", zclGeneral_RegisterCmdCallbacks
zclGeneral_SendIdentify SYMBOL "zclGeneral_SendIdentify"
??zclGeneral_SendIdentify?relay SYMBOL "?relay", zclGeneral_SendIdentify
zclGeneral_SendIdentifyQueryResponse SYMBOL "zclGeneral_SendIdentifyQueryResponse"
??zclGeneral_SendIdentifyQueryResponse?relay SYMBOL "?relay", zclGeneral_SendIdentifyQueryResponse

        EXTERN zcl_registerPlugin
        FUNCTION zcl_registerPlugin,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN osal_mem_alloc
        FUNCTION osal_mem_alloc,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN zcl_SendCommand
        FUNCTION zcl_SendCommand,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 23, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN zclFindAttrRec
        FUNCTION zclFindAttrRec,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN zclReadAttrData
        FUNCTION zclReadAttrData,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 26, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN ??osal_mem_alloc?relay
        FUNCTION ??osal_mem_alloc?relay,00H
        EXTERN ??zclFindAttrRec?relay
        FUNCTION ??zclFindAttrRec?relay,00H
        EXTERN ??zclReadAttrData?relay
        FUNCTION ??zclReadAttrData?relay,00H
        EXTERN ??zcl_SendCommand?relay
        FUNCTION ??zcl_SendCommand?relay,00H
        EXTERN ??zcl_registerPlugin?relay
        FUNCTION ??zcl_registerPlugin?relay,00H

// D:\R.D Dept\程式開發\TI CC2530 example\ZIGBEE Z-Stack\CC2530_ZStack-2.3.0-1.4.0\Sensor Network Example\Components\stack\zcl\zcl_general.c
//    1 /**************************************************************************************************
//    2   Filename:       zcl_general.c
//    3   Revised:        $Date: 2009-10-26 15:51:02 -0700 (Mon, 26 Oct 2009) $
//    4   Revision:       $Revision: 20979 $
//    5 
//    6   Description:    Zigbee Cluster Library - General.  This application receives all
//    7                   ZCL messages and initially parses them before passing to application.
//    8 
//    9 
//   10   Copyright 2006-2008 Texas Instruments Incorporated. All rights reserved.
//   11 
//   12   Should you have any questions regarding your right to use this Software,
//   13   contact Texas Instruments Incorporated at www.TI.com.
//   14 **************************************************************************************************/
//   15 
//   16 /*********************************************************************
//   17  * INCLUDES
//   18  */
//   19 #include "ZComDef.h"
//   20 #include "OSAL.h"
//   21 #include "OSAL_Nv.h"
//   22 #include "zcl.h"
//   23 #include "zcl_general.h"
//   24 #include "ZDApp.h"
//   25 
//   26 #if defined ( INTER_PAN )
//   27   #include "stub_aps.h"
//   28 #endif
//   29 
//   30 /*********************************************************************
//   31  * MACROS
//   32  */
//   33 #define locationTypeAbsolute( a )          ( (a) & LOCATION_TYPE_ABSOLUTE )
//   34 #define locationType2D( a )                ( (a) & LOCATION_TYPE_2_D )
//   35 #define locationTypeCoordinateSystem( a )  ( (a) & LOCATION_TYPE_COORDINATE_SYSTEM )
//   36 
//   37 #ifdef ZCL_SCENES
//   38 #define zclGeneral_ScenesRemaingCapacity() ( ZCL_GEN_MAX_SCENES - zclGeneral_CountAllScenes() )
//   39 #endif // ZCL_SCENES
//   40 
//   41 /*********************************************************************
//   42  * CONSTANTS
//   43  */
//   44 
//   45 /*********************************************************************
//   46  * TYPEDEFS
//   47  */
//   48 typedef struct zclGenCBRec
//   49 {
//   50   struct zclGenCBRec        *next;
//   51   uint8                     endpoint; // Used to link it into the endpoint descriptor
//   52   zclGeneral_AppCallbacks_t *CBs;     // Pointer to Callback function
//   53 } zclGenCBRec_t;
//   54 
//   55 typedef struct zclGenSceneItem
//   56 {
//   57   struct zclGenSceneItem    *next;
//   58   uint8                     endpoint; // Used to link it into the endpoint descriptor
//   59   zclGeneral_Scene_t        scene;    // Scene info
//   60 } zclGenSceneItem_t;
//   61 
//   62 typedef struct zclGenAlarmItem
//   63 {
//   64   struct zclGenAlarmItem    *next;
//   65   uint8                     endpoint; // Used to link it into the endpoint descriptor
//   66   zclGeneral_Alarm_t        alarm;    // Alarm info
//   67 } zclGenAlarmItem_t;
//   68 
//   69 // Scene NV types
//   70 typedef struct
//   71 {
//   72   uint16                    numRecs;
//   73 } nvGenScenesHdr_t;
//   74 
//   75 typedef struct zclGenSceneNVItem
//   76 {
//   77   uint8                     endpoint;
//   78   zclGeneral_Scene_t        scene;
//   79 } zclGenSceneNVItem_t;
//   80 
//   81 /*********************************************************************
//   82  * GLOBAL VARIABLES
//   83  */
//   84 
//   85 /*********************************************************************
//   86  * GLOBAL FUNCTIONS
//   87  */
//   88 
//   89 /*********************************************************************
//   90  * LOCAL VARIABLES
//   91  */

        RSEG XDATA_Z:XDATA:NOROOT(0)
//   92 static zclGenCBRec_t *zclGenCBs = (zclGenCBRec_t *)NULL;
zclGenCBs:
        DS 2
        REQUIRE __INIT_XDATA_Z

        RSEG XDATA_Z:XDATA:NOROOT(0)
//   93 static uint8 zclGenPluginRegisted = FALSE;
zclGenPluginRegisted:
        DS 1
        REQUIRE __INIT_XDATA_Z
//   94 #ifdef ZCL_SCENES
//   95 static zclGenSceneItem_t *zclGenSceneTable = (zclGenSceneItem_t *)NULL;
//   96 #endif // ZCL_SCENES
//   97 #ifdef ZCL_ALARMS
//   98 static zclGenAlarmItem_t *zclGenAlarmTable = (zclGenAlarmItem_t *)NULL;
//   99 #endif // ZCL_ALARMS
//  100 
//  101 /*********************************************************************
//  102  * LOCAL FUNCTIONS
//  103  */
//  104 static ZStatus_t zclGeneral_HdlIncoming( zclIncoming_t *pInMsg );
//  105 static ZStatus_t zclGeneral_HdlInSpecificCommands( zclIncoming_t *pInMsg );
//  106 static zclGeneral_AppCallbacks_t *zclGeneral_FindCallbacks( uint8 endpoint );
//  107 
//  108 // Device Configuration and Installation clusters
//  109 #ifdef ZCL_BASIC
//  110 static ZStatus_t zclGeneral_ProcessInBasic( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
//  111 #endif // ZCL_BASIC
//  112 
//  113 #ifdef ZCL_IDENTIFY
//  114 static ZStatus_t zclGeneral_ProcessInIdentity( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
//  115 #endif // ZCL_IDENTIFY
//  116 
//  117 // Groups and Scenes clusters
//  118 #ifdef ZCL_GROUPS
//  119 static ZStatus_t zclGeneral_ProcessInGroupsServer( zclIncoming_t *pInMsg );
//  120 static ZStatus_t zclGeneral_ProcessInGroupsClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
//  121 static ZStatus_t zclGeneral_AddGroup( uint8 endPoint, aps_Group_t *group, uint8 *pData );
//  122 #endif // ZCL_GROUPS
//  123 
//  124 #ifdef ZCL_SCENES
//  125 static ZStatus_t zclGeneral_ProcessInScenesServer( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
//  126 static ZStatus_t zclGeneral_ProcessInScenesClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
//  127 #endif // ZCL_SCENES
//  128 
//  129 // On/Off and Level Control Configuration clusters
//  130 #ifdef ZCL_ON_OFF
//  131 static ZStatus_t zclGeneral_ProcessInOnOff( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
//  132 #endif // ZCL_ONOFF
//  133 
//  134 #ifdef ZCL_LEVEL_CTRL
//  135 static ZStatus_t zclGeneral_ProcessInLevelControl( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
//  136 #endif // ZCL_LEVEL_CTRL
//  137 
//  138 // Alarms cluster
//  139 #ifdef ZCL_ALARMS
//  140 static ZStatus_t zclGeneral_ProcessInAlarmsServer( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
//  141 static ZStatus_t zclGeneral_ProcessInAlarmsClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
//  142 #endif // ZCL_ALARMS
//  143 
//  144 // Location cluster
//  145 #ifdef ZCL_LOCATION
//  146 static ZStatus_t zclGeneral_ProcessInLocationServer( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
//  147 static ZStatus_t zclGeneral_ProcessInLocationClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
//  148 #endif // ZCL_LOCATION
//  149 
//  150 #ifdef ZCL_SCENES
//  151 static uint8 zclGeneral_ScenesInitNV( void );
//  152 static void zclGeneral_ScenesSetDefaultNV( void );
//  153 static void zclGeneral_ScenesWriteNV( void );
//  154 static uint16 zclGeneral_ScenesRestoreFromNV( void );
//  155 #endif // ZCL_SCENES
//  156 
//  157 /*********************************************************************
//  158  * @fn      zclGeneral_RegisterCmdCallbacks
//  159  *
//  160  * @brief   Register an applications command callbacks
//  161  *
//  162  * @param   endpoint - application's endpoint
//  163  * @param   callbacks - pointer to the callback record.
//  164  *
//  165  * @return  ZMemError if not able to allocate
//  166  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  167 ZStatus_t zclGeneral_RegisterCmdCallbacks( uint8 endpoint, zclGeneral_AppCallbacks_t *callbacks )
zclGeneral_RegisterCmdCallbacks:
        CFI Block cfiBlock0 Using cfiCommon0
        CFI Function zclGeneral_RegisterCmdCallbacks
//  168 {
        FUNCALL zclGeneral_RegisterCmdCallbacks, zcl_registerPlugin
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclGeneral_RegisterCmdCallbacks, osal_mem_alloc
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xc
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 12)
        ; Saved register size: 12
        ; Auto size: 0
        MOV     ?V0 + 0,R1
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
//  169   zclGenCBRec_t *pNewItem;
//  170   zclGenCBRec_t *pLoop;
//  171 
//  172   // Register as a ZCL Plugin
//  173   if ( zclGenPluginRegisted == FALSE )
        MOV     DPTR,#zclGenPluginRegisted
        MOVX    A,@DPTR
        JNZ     ??zclGeneral_RegisterCmdCallbacks_0
//  174   {
//  175     zcl_registerPlugin( ZCL_CLUSTER_ID_GEN_BASIC,
//  176                         ZCL_CLUSTER_ID_GEN_LOCATION,
//  177                         zclGeneral_HdlIncoming );
        ; Setup parameters for call to function zcl_registerPlugin
        MOV     ?V0 + 2,#(??zclGeneral_HdlIncoming?relay & 0xff)
        MOV     ?V0 + 3,#((??zclGeneral_HdlIncoming?relay >> 8) & 0xff)
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 14)
        MOV     R4,#0xb
        MOV     R5,#0x0
        MOV     R2,#0x0
        MOV     R3,#0x0
        LCALL   ??zcl_registerPlugin?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 12)
//  178 
//  179 #ifdef ZCL_SCENES
//  180     // Initialize NV items
//  181     zclGeneral_ScenesInitNV();
//  182 
//  183     // Restore the Scene table
//  184     zclGeneral_ScenesRestoreFromNV();
//  185 #endif // ZCL_SCENES
//  186 
//  187     zclGenPluginRegisted = TRUE;
        MOV     A,#0x1
        MOV     DPTR,#zclGenPluginRegisted
        MOVX    @DPTR,A
//  188   }
//  189 
//  190   // Fill in the new profile list
//  191   pNewItem = osal_mem_alloc( sizeof( zclGenCBRec_t ) );
??zclGeneral_RegisterCmdCallbacks_0:
        ; Setup parameters for call to function osal_mem_alloc
        MOV     R2,#0x5
        MOV     R3,#0x0
        LCALL   ??osal_mem_alloc?relay
        MOV     ?V0 + 2,R2
        MOV     ?V0 + 3,R3
        MOV     R0,?V0 + 2
        MOV     R1,?V0 + 3
//  192   if ( pNewItem == NULL )
        MOV     A,R0
        JNZ     ??zclGeneral_RegisterCmdCallbacks_1
        MOV     A,R1
??zclGeneral_RegisterCmdCallbacks_1:
        JNZ     ??zclGeneral_RegisterCmdCallbacks_2
//  193     return (ZMemError);
        MOV     R1,#0x10
        SJMP    ??zclGeneral_RegisterCmdCallbacks_3
//  194 
//  195   pNewItem->next = (zclGenCBRec_t *)NULL;
??zclGeneral_RegisterCmdCallbacks_2:
        MOV     DPL,R0
        MOV     DPH,R1
        CLR     A
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    @DPTR,A
//  196   pNewItem->endpoint = endpoint;
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        MOV     A,?V0 + 0
        MOVX    @DPTR,A
//  197   pNewItem->CBs = callbacks;
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,R6
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R7
        MOVX    @DPTR,A
//  198 
//  199   // Find spot in list
//  200   if (  zclGenCBs == NULL )
        MOV     DPTR,#zclGenCBs
        MOVX    A,@DPTR
        JNZ     ??zclGeneral_RegisterCmdCallbacks_4
        INC     DPTR
        MOVX    A,@DPTR
??zclGeneral_RegisterCmdCallbacks_4:
        MOV     DPTR,#zclGenCBs
        JZ      ??zclGeneral_RegisterCmdCallbacks_5
//  201   {
//  202     zclGenCBs = pNewItem;
//  203   }
//  204   else
//  205   {
//  206     // Look for end of list
//  207     pLoop = zclGenCBs;
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        SJMP    ??zclGeneral_RegisterCmdCallbacks_6
//  208     while ( pLoop->next != NULL )
//  209       pLoop = pLoop->next;
??zclGeneral_RegisterCmdCallbacks_7:
        MOV     A,R2
        MOV     R4,A
        MOV     A,R3
??zclGeneral_RegisterCmdCallbacks_6:
        MOV     R5,A
        MOV     DPL,R4
        MOV     DPH,R5
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     A,R2
        JNZ     ??zclGeneral_RegisterCmdCallbacks_8
        MOV     A,R3
??zclGeneral_RegisterCmdCallbacks_8:
        JNZ     ??zclGeneral_RegisterCmdCallbacks_7
//  210 
//  211     // Put new item at end of list
//  212     pLoop->next = pNewItem;
        MOV     DPL,R4
        MOV     DPH,R5
??zclGeneral_RegisterCmdCallbacks_5:
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
//  213   }
//  214 
//  215   return ( ZSuccess );
        MOV     R1,#0x0
        CFI EndBlock cfiBlock0
??zclGeneral_RegisterCmdCallbacks_3:
        REQUIRE ?Subroutine9
        ; // Fall through to label ?Subroutine9
//  216 }

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine9:
        CFI Block cfiBlock1 Using cfiCommon0
        CFI NoFunction
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 12)
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        MOV     R7,#0x4
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock1
//  217 
//  218 #ifdef ZCL_IDENTIFY
//  219 /*********************************************************************
//  220  * @fn      zclGeneral_SendIdentify
//  221  *
//  222  * @brief   Call to send out an Identify Command
//  223  *
//  224  * @param   srcEP - Sending application's endpoint
//  225  * @param   dstAddr - where you want the message to go
//  226  * @param   identifyTime - how long the device will continue to identify itself (in seconds)
//  227  * @param   seqNum - identification number for the transaction
//  228  *
//  229  * @return  ZStatus_t
//  230  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  231 ZStatus_t zclGeneral_SendIdentify( uint8 srcEP, afAddrType_t *dstAddr,
zclGeneral_SendIdentify:
        CFI Block cfiBlock2 Using cfiCommon0
        CFI Function zclGeneral_SendIdentify
//  232                       uint16 identifyTime, uint8 disableDefaultRsp, uint8 seqNum )
//  233 {
        FUNCALL zclGeneral_SendIdentify, zcl_SendCommand
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 23, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 23, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 2
        MOV     A,#-0x2
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 12)
        MOV     A,#0xc
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R6,A
        MOV     A,#0xd
        LCALL   ?XSTACK_DISP0_8
        LCALL   ?Subroutine1 & 0xFFFF
//  234   uint8 buf[2];
//  235 
//  236   buf[0] = LO_UINT16( identifyTime );
//  237   buf[1] = HI_UINT16( identifyTime );
??CrossCallReturnLabel_2:
        LCALL   ?XSTACK_DISP0_8
        LCALL   ?Subroutine0 & 0xFFFF
//  238 
//  239   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_IDENTIFY,
//  240                           COMMAND_IDENTIFY, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
//  241                           disableDefaultRsp, 0, seqNum, 2, buf );
??CrossCallReturnLabel_0:
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 14)
        MOV     ?V0 + 0,#0x2
        MOV     ?V0 + 1,#0x0
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 16)
        MOV     A,R7
        MOV     ?V0 + 0,A
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_ONE
        CFI CFA_XSP16 add(XSP16, 17)
        MOV     ?V0 + 0,#0x0
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 19)
        MOV     A,R6
        MOV     ?V0 + 0,A
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_ONE
        CFI CFA_XSP16 add(XSP16, 20)
        MOV     ?V0 + 0,#0x0
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_ONE
        CFI CFA_XSP16 add(XSP16, 21)
        MOV     ?V0 + 0,#0x1
        CFI EndBlock cfiBlock2
        REQUIRE ?Subroutine10
        ; // Fall through to label ?Subroutine10

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine10:
        CFI Block cfiBlock3 Using cfiCommon0
        CFI NoFunction
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 21)
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_ONE
        CFI CFA_XSP16 add(XSP16, 22)
        MOV     ?V0 + 0,#0x0
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_ONE
        CFI CFA_XSP16 add(XSP16, 23)
        MOV     R4,#0x3
        MOV     R5,#0x0
        LCALL   ??zcl_SendCommand?relay
        MOV     A,#0xb
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 12)
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI EndBlock cfiBlock3
        REQUIRE ??Subroutine11_0
        ; // Fall through to label ??Subroutine11_0

        RSEG BANKED_CODE:CODE:NOROOT(0)
??Subroutine11_0:
        CFI Block cfiBlock4 Using cfiCommon0
        CFI NoFunction
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        MOV     R7,#0x2
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock4
//  242 }
//  243 
//  244 /*********************************************************************
//  245  * @fn      zclGeneral_SendIdentifyQueryResponse
//  246  *
//  247  * @brief   Call to send out an Identify Query Response Command
//  248  *
//  249  * @param   srcEP - Sending application's endpoint
//  250  * @param   dstAddr - where you want the message to go
//  251  * @param   timeout - how long the device will continue to identify itself (in seconds)
//  252  * @param   seqNum - identification number for the transaction
//  253  *
//  254  * @return  ZStatus_t
//  255  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  256 ZStatus_t zclGeneral_SendIdentifyQueryResponse( uint8 srcEP, afAddrType_t *dstAddr,
zclGeneral_SendIdentifyQueryResponse:
        CFI Block cfiBlock5 Using cfiCommon0
        CFI Function zclGeneral_SendIdentifyQueryResponse
//  257                             uint16 timeout, uint8 disableDefaultRsp, uint8 seqNum )
//  258 {
        FUNCALL zclGeneral_SendIdentifyQueryResponse, zcl_SendCommand
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 23, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 23, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 2
        MOV     A,#-0x2
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 12)
        MOV     A,#0xc
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R6,A
        MOV     A,#0xd
        LCALL   ?XSTACK_DISP0_8
        LCALL   ?Subroutine1 & 0xFFFF
//  259   uint8 buf[2];
//  260 
//  261   buf[0] = LO_UINT16( timeout );
//  262   buf[1] = HI_UINT16( timeout );
??CrossCallReturnLabel_3:
        LCALL   ?XSTACK_DISP0_8
        LCALL   ?Subroutine0 & 0xFFFF
//  263 
//  264   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_IDENTIFY,
//  265                           COMMAND_IDENTIFY_QUERY_RSP, TRUE,
//  266                           ZCL_FRAME_SERVER_CLIENT_DIR, disableDefaultRsp, 0, seqNum, 2, buf );
??CrossCallReturnLabel_1:
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 14)
        MOV     ?V0 + 0,#0x2
        MOV     ?V0 + 1,#0x0
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 16)
        MOV     A,R7
        MOV     ?V0 + 0,A
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_ONE
        CFI CFA_XSP16 add(XSP16, 17)
        MOV     ?V0 + 0,#0x0
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 19)
        MOV     A,R6
        MOV     ?V0 + 0,A
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_ONE
        CFI CFA_XSP16 add(XSP16, 20)
        MOV     ?V0 + 0,#0x1
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_ONE
        CFI CFA_XSP16 add(XSP16, 21)
        SJMP    ?Subroutine10
        CFI EndBlock cfiBlock5

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine1:
        CFI Block cfiCond6 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_2
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 12)
        CFI Block cfiCond7 Using cfiCommon0
        CFI (cfiCond7) NoFunction
        CFI (cfiCond7) Conditional ??CrossCallReturnLabel_3
        CFI (cfiCond7) R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond7) VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond7) V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond7) V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond7) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond7) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond7) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond7) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond7) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond7) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond7) CFA_SP SP+0
        CFI (cfiCond7) CFA_XSP16 add(XSP16, 12)
        CFI Block cfiPicker8 Using cfiCommon1
        CFI (cfiPicker8) NoFunction
        CFI (cfiPicker8) Picker
        MOVX    A,@DPTR
        MOV     R7,A
        MOV     A,R4
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    @DPTR,A
        MOV     A,#0x1
        RET
        CFI EndBlock cfiCond6
        CFI EndBlock cfiCond7
        CFI EndBlock cfiPicker8

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine0:
        CFI Block cfiCond9 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_0
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 12)
        CFI Block cfiCond10 Using cfiCommon0
        CFI (cfiCond10) NoFunction
        CFI (cfiCond10) Conditional ??CrossCallReturnLabel_1
        CFI (cfiCond10) R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond10) VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond10) V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond10) V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond10) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond10) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond10) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond10) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond10) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond10) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond10) CFA_SP SP+0
        CFI (cfiCond10) CFA_XSP16 add(XSP16, 12)
        CFI Block cfiPicker11 Using cfiCommon1
        CFI (cfiPicker11) NoFunction
        CFI (cfiPicker11) Picker
        MOV     A,R5
        MOVX    @DPTR,A
        ; Setup parameters for call to function zcl_SendCommand
        ; Setup parameters for call to function zcl_SendCommand
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     ?V0 + 0,DPL
        MOV     ?V0 + 1,DPH
        MOV     R0,#?V0 + 0
        RET
        CFI EndBlock cfiCond9
        CFI EndBlock cfiCond10
        CFI EndBlock cfiPicker11
//  267 }
//  268 #endif // ZCL_IDENTIFY
//  269 
//  270 #ifdef ZCL_GROUPS
//  271 /*********************************************************************
//  272  * @fn      zclGeneral_SendGroupRequest
//  273  *
//  274  * @brief   Send a Group Request to a device.  You can also use the
//  275  *          appropriate macro.
//  276  *
//  277  * @param   srcEP - Sending Apps endpoint
//  278  * @param   dstAddr - where to send the request
//  279  * @param   cmd - one of the following:
//  280  *              COMMAND_GROUP_VIEW
//  281  *              COMMAND_GROUP_REMOVE
//  282  * @param   groupID -
//  283  *
//  284  * @return  ZStatus_t
//  285  */
//  286 ZStatus_t zclGeneral_SendGroupRequest( uint8 srcEP, afAddrType_t *dstAddr,
//  287                      uint8 cmd, uint16 groupID, uint8 disableDefaultRsp, uint8 seqNum )
//  288 {
//  289   uint8 buf[2];
//  290 
//  291   buf[0] = LO_UINT16( groupID );
//  292   buf[1] = HI_UINT16( groupID );
//  293 
//  294   return ( zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
//  295                             cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
//  296                             disableDefaultRsp, 0, seqNum, 2, buf ) );
//  297 }
//  298 
//  299 /*********************************************************************
//  300  * @fn      zclGeneral_SendAddGroupRequest
//  301  *
//  302  * @brief   Send the Add Group Request to a device
//  303  *
//  304  * @param   srcEP - Sending Apps endpoint
//  305  * @param   dstAddr - where to send the request
//  306  * @param   cmd - one of the following:
//  307  *                COMMAND_GROUP_ADD
//  308  *                COMMAND_GROUP_ADD_IF_IDENTIFYING
//  309  * @param   groupID - pointer to the group structure
//  310  * @param   groupName - pointer to Group Name.  This is a Zigbee
//  311  *          string data type, so the first byte is the length of the
//  312  *          name (in bytes), then the name.
//  313  *
//  314  * @return  ZStatus_t
//  315  */
//  316 ZStatus_t zclGeneral_SendAddGroupRequest( uint8 srcEP, afAddrType_t *dstAddr,
//  317                                           uint8 cmd, uint16 groupID, uint8 *groupName,
//  318                                           uint8 disableDefaultRsp, uint8 seqNum )
//  319 {
//  320   uint8 *buf;
//  321   uint8 *pBuf;
//  322   uint8 len;
//  323   ZStatus_t status;
//  324 
//  325   len = 2;    // Group ID
//  326   len += groupName[0] + 1;  // String + 1 for length
//  327 
//  328   buf = osal_mem_alloc( len );
//  329   if ( buf )
//  330   {
//  331     pBuf = buf;
//  332     *pBuf++ = LO_UINT16( groupID );
//  333     *pBuf++ = HI_UINT16( groupID );
//  334     *pBuf++ = groupName[0]; // string length
//  335     osal_memcpy( pBuf, &(groupName[1]), groupName[0] );
//  336 
//  337     status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
//  338                               cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
//  339                               disableDefaultRsp, 0, seqNum, len, buf );
//  340     osal_mem_free( buf );
//  341   }
//  342   else
//  343     status = ZMemError;
//  344 
//  345   return ( status );
//  346 }
//  347 
//  348 /*********************************************************************
//  349  * @fn      zclGeneral_SendGroupGetMembershipRequest
//  350  *
//  351  * @brief   Send a Get Group Membership (Resposne) Command to a device
//  352  *
//  353  * @param   srcEP - Sending Apps endpoint
//  354  * @param   dstAddr - where to send the request
//  355  * @param   cmd - one of the following:
//  356  *                COMMAND_GROUP_GET_MEMBERSHIP
//  357  *                COMMAND_GROUP_GET_MEMBERSHIP_RSP
//  358  * @param   groupID - pointer to the group structure
//  359  * @param   groupName - pointer to Group Name.  This is a Zigbee
//  360  *          string data type, so the first byte is the length of the
//  361  *          name (in bytes), then the name.
//  362  *
//  363  * @return  ZStatus_t
//  364  */
//  365 ZStatus_t zclGeneral_SendGroupGetMembershipRequest( uint8 srcEP, afAddrType_t *dstAddr,
//  366                               uint8 cmd, uint8 rspCmd, uint8 direction, uint8 capacity,
//  367                               uint8 grpCnt, uint16 *grpList, uint8 disableDefaultRsp, uint8 seqNum )
//  368 {
//  369   uint8 *buf;
//  370   uint8 *pBuf;
//  371   uint8 len = 0;
//  372   uint8 i;
//  373   ZStatus_t status;
//  374 
//  375   if ( rspCmd )
//  376     len++;  // Capacity
//  377 
//  378   len++;  // Group Count
//  379   len += sizeof ( uint16 ) * grpCnt;  // Group List
//  380 
//  381   buf = osal_mem_alloc( len );
//  382   if ( buf )
//  383   {
//  384     pBuf = buf;
//  385     if ( rspCmd )
//  386       *pBuf++ = capacity;
//  387 
//  388     *pBuf++ = grpCnt;
//  389     for ( i = 0; i < grpCnt; i++ )
//  390     {
//  391       *pBuf++ = LO_UINT16( grpList[i] );
//  392       *pBuf++ = HI_UINT16( grpList[i] );
//  393     }
//  394 
//  395     status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
//  396                               cmd, TRUE, direction,
//  397                               disableDefaultRsp, 0, seqNum, len, buf );
//  398     osal_mem_free( buf );
//  399   }
//  400   else
//  401     status = ZMemError;
//  402 
//  403   return ( status );
//  404 }
//  405 
//  406 /*********************************************************************
//  407  * @fn      zclGeneral_SendGroupResponse
//  408  *
//  409  * @brief   Send Group Response (not Group View Response)
//  410  *
//  411  * @param   srcEP - Sending application's endpoint
//  412  * @param   dstAddr - where you want the message to go
//  413  * @param   cmd - either COMMAND_GROUP_ADD_RSP or COMMAND_GROUP_REMOVE_RSP
//  414  * @param   status - group command status
//  415  * @param   groupID - what group
//  416  *
//  417  * @return  ZStatus_t
//  418  */
//  419 ZStatus_t zclGeneral_SendGroupResponse( uint8 srcEP, afAddrType_t *dstAddr,
//  420                                         uint8 cmd, uint8 status, uint16 groupID,
//  421                                         uint8 disableDefaultRsp, uint8 seqNum )
//  422 {
//  423   uint8 buf[3];
//  424 
//  425   buf[0] = status;
//  426   buf[1] = LO_UINT16( groupID );
//  427   buf[2] = HI_UINT16( groupID );
//  428 
//  429   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
//  430                           cmd, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
//  431                           disableDefaultRsp, 0, seqNum, 3, buf );
//  432 }
//  433 
//  434 /*********************************************************************
//  435  * @fn      zclGeneral_SendGroupViewResponse
//  436  *
//  437  * @brief   Call to send Group Response Command
//  438  *
//  439  * @param   srcEP - Sending application's endpoint
//  440  * @param   dstAddr - where you want the message to go
//  441  * @param   cmd - either COMMAND_GROUP_ADD_RSP or COMMAND_GROUP_REMOVE_RSP
//  442  * @param   status - group command status
//  443  * @param   grp - group info
//  444  *
//  445  * @return  ZStatus_t
//  446  */
//  447 ZStatus_t zclGeneral_SendGroupViewResponse( uint8 srcEP, afAddrType_t *dstAddr,
//  448                  uint8 status, aps_Group_t *grp, uint8 disableDefaultRsp, uint8 seqNum )
//  449 {
//  450   uint8 *buf;
//  451   uint8 len;
//  452   ZStatus_t stat;
//  453 
//  454   len = 1 + 2; // Status + Group ID
//  455 
//  456   if ( status == ZCL_STATUS_SUCCESS )
//  457     len += grp->name[0] + 1;  // String + 1 for length
//  458 
//  459   buf = osal_mem_alloc( len );
//  460   if ( buf )
//  461   {
//  462     buf[0] = status;
//  463     buf[1] = LO_UINT16( grp->ID );
//  464     buf[2] = HI_UINT16( grp->ID );
//  465 
//  466     if ( status == ZCL_STATUS_SUCCESS )
//  467     {
//  468       buf[3] = grp->name[0]; // string length
//  469       osal_memcpy( &buf[4], (&grp->name[1]), grp->name[0] );
//  470     }
//  471 
//  472     stat = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
//  473                             COMMAND_GROUP_VIEW_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
//  474                             disableDefaultRsp, 0, seqNum, len, buf );
//  475     osal_mem_free( buf );
//  476   }
//  477   else
//  478     stat = ZMemError;
//  479 
//  480   return ( stat );
//  481 }
//  482 #endif // ZCL_GROUPS
//  483 
//  484 #ifdef ZCL_SCENES
//  485 /*********************************************************************
//  486  * @fn      zclGeneral_SendAddScene
//  487  *
//  488  * @brief   Send the Add Scene Request to a device
//  489  *
//  490  * @param   srcEP - Sending Apps endpoint
//  491  * @param   dstAddr - where to send the request
//  492  * @param   scene - pointer to the scene structure
//  493  *
//  494  * @return  ZStatus_t
//  495  */
//  496 ZStatus_t zclGeneral_SendAddScene( uint8 srcEP, afAddrType_t *dstAddr,
//  497                       zclGeneral_Scene_t *scene, uint8 disableDefaultRsp, uint8 seqNum )
//  498 {
//  499   uint8 *buf;
//  500   uint8 *pBuf;
//  501   uint8 len;
//  502   ZStatus_t status;
//  503 
//  504   len = 2 + 1 + 2;    // Group ID + Scene ID + transition time
//  505   len += scene->name[0] + 1; // String + 1 for length
//  506 
//  507   // Add something for the extension field length
//  508   len += scene->extLen;
//  509 
//  510   buf = osal_mem_alloc( len );
//  511   if ( buf )
//  512   {
//  513     pBuf = buf;
//  514     *pBuf++ = LO_UINT16( scene->groupID );
//  515     *pBuf++ = HI_UINT16( scene->groupID );
//  516     *pBuf++ = scene->ID;
//  517     *pBuf++ = LO_UINT16( scene->transTime );
//  518     *pBuf++ = HI_UINT16( scene->transTime );
//  519     *pBuf++ = scene->name[0]; // string length
//  520     osal_memcpy( pBuf, &(scene->name[1]), scene->name[0] );
//  521     pBuf += scene->name[0]; // move pass name
//  522 
//  523     // Add the extension fields
//  524     if ( scene->extLen > 0 )
//  525       osal_memcpy( pBuf, scene->extField, scene->extLen );
//  526 
//  527     status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
//  528                               COMMAND_SCENE_ADD, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
//  529                               disableDefaultRsp, 0, seqNum, len, buf );
//  530     osal_mem_free( buf );
//  531   }
//  532   else
//  533     status = ZMemError;
//  534 
//  535   return ( status );
//  536 }
//  537 
//  538 /*********************************************************************
//  539  * @fn      zclGeneral_SendSceneRequest
//  540  *
//  541  * @brief   Send a Scene Request to a device.  You can also use the
//  542  *          appropriate macro.
//  543  *
//  544  * @param   srcEP - Sending Apps endpoint
//  545  * @param   dstAddr - where to send the request
//  546  * @param   cmd - one of the following:
//  547  *              COMMAND_SCENE_VIEW
//  548  *              COMMAND_SCENE_REMOVE
//  549  *              COMMAND_SCENE_REMOVE_ALL
//  550  *              COMMAND_SCENE_STORE
//  551  *              COMMAND_SCENE_RECALL
//  552  *              COMMAND_SCENE_GET_MEMBERSHIP
//  553  * @param   groupID - group ID
//  554  * @param   sceneID - scene ID (not applicable to COMMAND_SCENE_REMOVE_ALL and
//  555  *                    COMMAND_SCENE_GET_MEMBERSHIP)
//  556  * @return  ZStatus_t
//  557  */
//  558 ZStatus_t zclGeneral_SendSceneRequest( uint8 srcEP, afAddrType_t *dstAddr,
//  559                                        uint8 cmd, uint16 groupID, uint8 sceneID,
//  560                                        uint8 disableDefaultRsp, uint8 seqNum )
//  561 {
//  562   uint8 buf[3];
//  563   uint8 len = 2;
//  564 
//  565   buf[0] = LO_UINT16( groupID );
//  566   buf[1] = HI_UINT16( groupID );
//  567 
//  568   if ( cmd != COMMAND_SCENE_REMOVE_ALL && cmd != COMMAND_SCENE_GET_MEMBERSHIP )
//  569   {
//  570     buf[2] = sceneID;
//  571     len++;
//  572   }
//  573 
//  574   return ( zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
//  575                             cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
//  576                             disableDefaultRsp, 0, seqNum, len, buf ) );
//  577 }
//  578 
//  579 /*********************************************************************
//  580  * @fn      zclGeneral_SendSceneResponse
//  581  *
//  582  * @brief   Send Group Response (not Group View Response)
//  583  *
//  584  * @param   srcEP - Sending application's endpoint
//  585  * @param   dstAddr - where you want the message to go
//  586  * @param   cmd - either COMMAND_SCENE_ADD_RSP, COMMAND_SCENE_REMOVE_RSP
//  587  *                COMMAND_SCENE_STORE_RSP, or COMMAND_SCENE_REMOVE_ALL_RSP
//  588  * @param   status - scene command status
//  589  * @param   groupID - what group
//  590  * @param   sceneID - what scene (not applicable to COMMAND_SCENE_REMOVE_ALL_RSP)
//  591  *
//  592  * @return  ZStatus_t
//  593  */
//  594 ZStatus_t zclGeneral_SendSceneResponse( uint8 srcEP, afAddrType_t *dstAddr,
//  595                                   uint8 cmd, uint8 status, uint16 groupID,
//  596                                   uint8 sceneID, uint8 disableDefaultRsp, uint8 seqNum )
//  597 {
//  598   uint8 buf[4];
//  599   uint8 len = 1 + 2; // Status + Group ID
//  600 
//  601   buf[0] = status;
//  602   buf[1] = LO_UINT16( groupID );
//  603   buf[2] = HI_UINT16( groupID );
//  604 
//  605   if ( cmd != COMMAND_SCENE_REMOVE_ALL_RSP )
//  606   {
//  607     buf[3] = sceneID;
//  608     len++;
//  609   }
//  610 
//  611   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
//  612                           cmd, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
//  613                           disableDefaultRsp, 0, seqNum, len, buf );
//  614 }
//  615 
//  616 /*********************************************************************
//  617  * @fn      zclGeneral_SendSceneViewResponse
//  618  *
//  619  * @brief   Call to send Scene Response Command
//  620  *
//  621  * @param   srcEP - Sending application's endpoint
//  622  * @param   dstAddr - where you want the message to go
//  623  * @param   status - scene command status
//  624  * @param   scene - scene info
//  625  *
//  626  * @return  ZStatus_t
//  627  */
//  628 ZStatus_t zclGeneral_SendSceneViewResponse( uint8 srcEP, afAddrType_t *dstAddr,
//  629                                        uint8 status, zclGeneral_Scene_t *scene,
//  630                                        uint8 disableDefaultRsp, uint8 seqNum )
//  631 {
//  632   uint8 *buf;
//  633   uint8 *pBuf;
//  634   uint8 len = 1 + 2 + 1; // Status + Group ID + Scene ID
//  635   ZStatus_t stat;
//  636 
//  637   if ( status == ZCL_STATUS_SUCCESS )
//  638   {
//  639     len += 2; // Transition Time
//  640     len += scene->name[0] + 1; // string + 1 for length
//  641 
//  642     // Add something for the extension field length
//  643     len += scene->extLen;
//  644   }
//  645 
//  646   buf = osal_mem_alloc( len );
//  647   if ( buf )
//  648   {
//  649     pBuf = buf;
//  650     *pBuf++ = status;
//  651     *pBuf++ = LO_UINT16( scene->groupID );
//  652     *pBuf++ = HI_UINT16( scene->groupID );
//  653     *pBuf++ = scene->ID;
//  654     if ( status == ZCL_STATUS_SUCCESS )
//  655     {
//  656       *pBuf++ = LO_UINT16( scene->transTime );
//  657       *pBuf++ = HI_UINT16( scene->transTime );
//  658       *pBuf++ = scene->name[0]; // string length
//  659       if ( scene->name[0] != 0 )
//  660       {
//  661         osal_memcpy( pBuf, &(scene->name[1]), scene->name[0] );
//  662         pBuf += scene->name[0]; // move pass name
//  663       }
//  664 
//  665       // Add the extension fields
//  666       if ( scene->extLen > 0 )
//  667         osal_memcpy( pBuf, scene->extField, scene->extLen );
//  668     }
//  669 
//  670     stat = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
//  671                             COMMAND_SCENE_VIEW_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
//  672                             disableDefaultRsp, 0, seqNum, len, buf );
//  673     osal_mem_free( buf );
//  674   }
//  675   else
//  676     stat = ZMemError;
//  677 
//  678   return ( stat );
//  679 }
//  680 
//  681 /*********************************************************************
//  682  * @fn      zclGeneral_SendSceneGetMembershipResponse
//  683  *
//  684  * @brief   Call to send Scene Get Membership Response Command
//  685  *
//  686  * @param   srcEP - Sending application's endpoint
//  687  * @param   dstAddr - where you want the message to go
//  688  * @param   status - scene command status
//  689  * @param   capacity - remaining capacity of the scene table
//  690  * @param   sceneCnt - number of scenes in the scene list
//  691  * @param   sceneList - list of scene IDs
//  692  * @param   groupID - group ID that scene belongs to
//  693  * @param   seqNum - sequence number
//  694  *
//  695  * @return  ZStatus_t
//  696  */
//  697 ZStatus_t zclGeneral_SendSceneGetMembershipResponse( uint8 srcEP, afAddrType_t *dstAddr,
//  698                        uint8 status, uint8 capacity, uint8 sceneCnt, uint8 *sceneList,
//  699                        uint16 groupID, uint8 disableDefaultRsp, uint8 seqNum )
//  700 {
//  701   uint8 *buf;
//  702   uint8 *pBuf;
//  703   uint8 len = 1 + 1 + 2; // Status + Capacity + Group ID;
//  704   uint8 i;
//  705   ZStatus_t stat;
//  706 
//  707   if ( status == ZCL_STATUS_SUCCESS )
//  708   {
//  709     len++; // Scene Count
//  710     len += sceneCnt; // Scene List (Scene ID is a single octet)
//  711   }
//  712 
//  713   buf = osal_mem_alloc( len );
//  714   if ( buf )
//  715   {
//  716     pBuf = buf;
//  717     *pBuf++ = status;
//  718     *pBuf++ = capacity;
//  719     *pBuf++ = LO_UINT16( groupID );
//  720     *pBuf++ = HI_UINT16( groupID );
//  721     if ( status == ZCL_STATUS_SUCCESS )
//  722     {
//  723       *pBuf++ = sceneCnt;
//  724       for ( i = 0; i < sceneCnt; i++ )
//  725         *pBuf++ = sceneList[i];
//  726     }
//  727 
//  728     stat = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
//  729                             COMMAND_SCENE_GET_MEMBERSHIP_RSP, TRUE,
//  730                             ZCL_FRAME_SERVER_CLIENT_DIR, disableDefaultRsp, 0, seqNum, len, buf );
//  731     osal_mem_free( buf );
//  732   }
//  733   else
//  734     stat = ZMemError;
//  735 
//  736   return ( stat );
//  737 }
//  738 #endif // ZCL_SCENES
//  739 
//  740 #ifdef ZCL_LEVEL_CTRL
//  741 /*********************************************************************
//  742  * @fn      zclGeneral_SendLevelControlMoveToLevelRequest
//  743  *
//  744  * @brief   Call to send out a Level Control Request. You can also use
//  745  *          the appropriate macro.
//  746  *
//  747  * @param   srcEP - Sending application's endpoint
//  748  * @param   dstAddr - where you want the message to go
//  749  * @param   cmd - one of the following:
//  750  *              COMMAND_LEVEL_MOVE_TO_LEVEL or
//  751  *              COMMAND_LEVEL_MOVE_TO_LEVEL_WITH_ON_OFF
//  752  * @param   level - what level to move to
//  753  * @param   transitionTime - how long to take to get to the level (in seconds)
//  754  *
//  755  * @return  ZStatus_t
//  756  */
//  757 ZStatus_t zclGeneral_SendLevelControlMoveToLevelRequest( uint8 srcEP, afAddrType_t *dstAddr,
//  758                                                          uint8 cmd, uint8 level, uint16 transTime,
//  759                                                          uint8 disableDefaultRsp, uint8 seqNum )
//  760 {
//  761   uint8 buf[3];
//  762 
//  763   buf[0] = level;
//  764   buf[1] = LO_UINT16( transTime );
//  765   buf[2] = HI_UINT16( transTime );
//  766 
//  767   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL,
//  768                           cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
//  769                           disableDefaultRsp, 0, seqNum, 3, buf );
//  770 }
//  771 
//  772 /*********************************************************************
//  773  * @fn      zclGeneral_SendLevelControlMoveRequest
//  774  *
//  775  * @brief   Call to send out a Level Control Request. You can also use
//  776  *          the appropriate macro.
//  777  *
//  778  * @param   srcEP - Sending application's endpoint
//  779  * @param   dstAddr - where you want the message to go
//  780  * @param   cmd - one of the following:
//  781  *              COMMAND_LEVEL_MOVE or
//  782  *              COMMAND_LEVEL_MOVE_WITH_ON_OFF
//  783  * @param   moveMode - LEVEL_MOVE_UP or
//  784  *                     LEVEL_MOVE_DOWN
//  785  * @param   rate - number of steps to take per second
//  786  *
//  787  * @return  ZStatus_t
//  788  */
//  789 ZStatus_t zclGeneral_SendLevelControlMoveRequest( uint8 srcEP, afAddrType_t *dstAddr,
//  790                                                   uint8 cmd, uint8 moveMode, uint8 rate,
//  791                                                   uint8 disableDefaultRsp, uint8 seqNum )
//  792 {
//  793   uint8 buf[2];
//  794 
//  795   buf[0] = moveMode;
//  796   buf[1] = rate;
//  797 
//  798   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL,
//  799                           cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
//  800                           disableDefaultRsp, 0, seqNum, 2, buf );
//  801 }
//  802 
//  803 /*********************************************************************
//  804  * @fn      zclGeneral_SendLevelControlStepRequest
//  805  *
//  806  * @brief   Call to send out a Level Control Request. You can also use
//  807  *          the appropriate macro.
//  808  *
//  809  * @param   srcEP - Sending application's endpoint
//  810  * @param   dstAddr - where you want the message to go
//  811  * @param   cmd - one of the following:
//  812  *              COMMAND_LEVEL_STEP
//  813  *              COMMAND_LEVEL_STEP_WITH_ON_OFF
//  814  * @param   stepMode - LEVEL_STEP_UP or
//  815  *                     LEVEL_STEP_DOWN
//  816  * @param   amount - number of levels to step
//  817  * @param   transitionTime - time, in 1/10ths of a second, to take to perform the step
//  818  *
//  819  * @return  ZStatus_t
//  820  */
//  821 ZStatus_t zclGeneral_SendLevelControlStepRequest( uint8 srcEP, afAddrType_t *dstAddr,
//  822                          uint8 cmd, uint8 stepMode, uint8 stepSize, uint16 transTime,
//  823                          uint8 disableDefaultRsp, uint8 seqNum )
//  824 {
//  825   uint8 buf[4];
//  826 
//  827   buf[0] = stepMode;
//  828   buf[1] = stepSize;
//  829   buf[2] = LO_UINT16( transTime );
//  830   buf[3] = HI_UINT16( transTime );
//  831 
//  832   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL,
//  833                           cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
//  834                           disableDefaultRsp, 0, seqNum, 4, buf );
//  835 }
//  836 #endif // ZCL_LEVEL_CTRL
//  837 
//  838 #ifdef ZCL_ALARMS
//  839 /*********************************************************************
//  840  * @fn      zclGeneral_SendAlarmRequest
//  841  *
//  842  * @brief   Call to send out an Alarm Request Command
//  843  *
//  844  * @param   srcEP - Sending application's endpoint
//  845  * @param   dstAddr - where you want the message to go
//  846  * @param   cmd - either COMMAND_ALARMS_RESET or COMMAND_ALARMS_ALARM
//  847  * @param   alarmCode - code for the cause of the alarm
//  848  * @param   clusterID - cluster whose attribute generate the alarm
//  849  *
//  850  * @return  ZStatus_t
//  851  */
//  852 ZStatus_t zclGeneral_SendAlarmRequest( uint8 srcEP, afAddrType_t *dstAddr,
//  853                                        uint8 cmd, uint8 alarmCode, uint16 clusterID,
//  854                                        uint8 disableDefaultRsp, uint8 seqNum )
//  855 {
//  856   uint8 buf[3];
//  857 
//  858   buf[0] = alarmCode;
//  859   buf[1] = LO_UINT16( clusterID );
//  860   buf[2] = HI_UINT16( clusterID );
//  861 
//  862   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ALARMS,
//  863                           cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
//  864                           disableDefaultRsp, 0, seqNum, 3, buf );
//  865 }
//  866 
//  867 /*********************************************************************
//  868  * @fn      zclGeneral_SendAlarmGetRespnose
//  869  *
//  870  * @brief   Call to send out an Alarm Get Response Command
//  871  *
//  872  * @param   srcEP - Sending application's endpoint
//  873  * @param   dstAddr - where you want the message to go
//  874  * @param   status - SUCCESS or NOT_FOUND
//  875  * @param   alarmCode - code for the cause of the alarm
//  876  * @param   clusterID - cluster whose attribute generate the alarm
//  877  * @param   timeStamp - time at which the alarm occured
//  878  *
//  879  * @return  ZStatus_t
//  880  */
//  881 ZStatus_t zclGeneral_SendAlarmGetRespnose( uint8 srcEP, afAddrType_t *dstAddr,
//  882                               uint8 status, uint8 alarmCode, uint16 clusterID,
//  883                               uint32 timeStamp, uint8 disableDefaultRsp, uint8 seqNum )
//  884 {
//  885   uint8 buf[8];
//  886   uint8 len = 1; // Status
//  887 
//  888   buf[0] = status;
//  889   if ( status == ZCL_STATUS_SUCCESS )
//  890   {
//  891     len += 1 + 2 + 4; // Alarm code + Cluster ID + Time stamp
//  892     buf[1] = alarmCode;
//  893     buf[2] = LO_UINT16( clusterID );
//  894     buf[3] = HI_UINT16( clusterID );
//  895     osal_buffer_uint32( &buf[4], timeStamp );
//  896   }
//  897 
//  898   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ALARMS,
//  899                           COMMAND_ALARMS_GET_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
//  900                           disableDefaultRsp, 0, seqNum, len, buf );
//  901 }
//  902 #endif // ZCL_ALARMS
//  903 
//  904 #ifdef ZCL_LOCATION
//  905 /*********************************************************************
//  906  * @fn      zclGeneral_SendLocationSetAbsolute
//  907  *
//  908  * @brief   Call to send out a Set Absolute Location Command
//  909  *
//  910  * @param   srcEP - Sending application's endpoint
//  911  * @param   dstAddr - where you want the message to go
//  912  * @param   absLoc - absolute location info
//  913  *
//  914  * @return  ZStatus_t
//  915  */
//  916 ZStatus_t zclGeneral_SendLocationSetAbsolute( uint8 srcEP, afAddrType_t *dstAddr,
//  917                                               zclLocationAbsolute_t *absLoc,
//  918                                               uint8 disableDefaultRsp, uint8 seqNum )
//  919 {
//  920    uint8 buf[10]; // 5 fields (2 octects each)
//  921 
//  922    buf[0] = LO_UINT16( absLoc->coordinate1 );
//  923    buf[1] = HI_UINT16( absLoc->coordinate1 );
//  924    buf[2] = LO_UINT16( absLoc->coordinate2 );
//  925    buf[3] = HI_UINT16( absLoc->coordinate2 );
//  926    buf[4] = LO_UINT16( absLoc->coordinate3 );
//  927    buf[5] = HI_UINT16( absLoc->coordinate3 );
//  928    buf[6] = LO_UINT16( absLoc->power );
//  929    buf[7] = HI_UINT16( absLoc->power );
//  930    buf[8] = LO_UINT16( absLoc->pathLossExponent );
//  931    buf[9] = HI_UINT16( absLoc->pathLossExponent );
//  932 
//  933    return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
//  934                            COMMAND_LOCATION_SET_ABSOLUTE, TRUE,
//  935                            ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, 10, buf );
//  936 }
//  937 
//  938 /*********************************************************************
//  939  * @fn      zclGeneral_SendLocationSetDevCfg
//  940  *
//  941  * @brief   Call to send out a Set Device Configuration Command
//  942  *
//  943  * @param   srcEP - Sending application's endpoint
//  944  * @param   dstAddr - where you want the message to go
//  945  * @param   devCfg - device configuration info
//  946  *
//  947  * @return  ZStatus_t
//  948  */
//  949 ZStatus_t zclGeneral_SendLocationSetDevCfg( uint8 srcEP, afAddrType_t *dstAddr,
//  950                                             zclLocationDevCfg_t *devCfg,
//  951                                             uint8 disableDefaultRsp, uint8 seqNum )
//  952 {
//  953    uint8 buf[9];  // 4 fields (2 octects each) + 1 field with 1 octect
//  954 
//  955    buf[0] = LO_UINT16( devCfg->power );
//  956    buf[1] = HI_UINT16( devCfg->power );
//  957    buf[2] = LO_UINT16( devCfg->pathLossExponent );
//  958    buf[3] = HI_UINT16( devCfg->pathLossExponent );
//  959    buf[4] = LO_UINT16( devCfg->calcPeriod );
//  960    buf[5] = HI_UINT16( devCfg->calcPeriod );
//  961    buf[6] = devCfg->numMeasurements;
//  962    buf[7] = LO_UINT16( devCfg->reportPeriod );
//  963    buf[8] = HI_UINT16( devCfg->reportPeriod );
//  964 
//  965    return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
//  966                            COMMAND_LOCATION_SET_DEV_CFG, TRUE,
//  967                            ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, 9, buf );
//  968 }
//  969 
//  970 /*********************************************************************
//  971  * @fn      zclGeneral_SendLocationGetDevCfg
//  972  *
//  973  * @brief   Call to send out a Get Device Configuration Command
//  974  *
//  975  * @param   srcEP - Sending application's endpoint
//  976  * @param   dstAddr - where you want the message to go
//  977  * @param   targetAddr - device for which location parameters are being requested
//  978  *
//  979  * @return  ZStatus_t
//  980  */
//  981 ZStatus_t zclGeneral_SendLocationGetDevCfg( uint8 srcEP, afAddrType_t *dstAddr,
//  982                        uint8 *targetAddr, uint8 disableDefaultRsp, uint8 seqNum )
//  983 {
//  984   uint8 buf[8];
//  985 
//  986   osal_cpyExtAddr( buf, targetAddr );
//  987 
//  988   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
//  989                           COMMAND_LOCATION_GET_DEV_CFG, TRUE,
//  990                           ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, 8, buf );
//  991 }
//  992 
//  993 /*********************************************************************
//  994  * @fn      zclGeneral_SendLocationGetData
//  995  *
//  996  * @brief   Call to send out a Get Location Data Command
//  997  *
//  998  * @param   srcEP - Sending application's endpoint
//  999  * @param   dstAddr - where you want the message to go
// 1000  * @param   locaData - location information and channel parameters that are requested.
// 1001  *
// 1002  * @return  ZStatus_t
// 1003  */
// 1004 ZStatus_t zclGeneral_SendLocationGetData( uint8 srcEP, afAddrType_t *dstAddr,
// 1005                                           zclLocationGetData_t *locData,
// 1006                                           uint8 disableDefaultRsp, uint8 seqNum )
// 1007 {
// 1008   uint8 buf[10]; // bitmap (1) + number responses (1) + IEEE Address (8)
// 1009   uint8 *pBuf = buf;
// 1010   uint8 len = 2; // bitmap + number responses
// 1011 
// 1012   *pBuf  = locData->absoluteOnly;
// 1013   *pBuf |= locData->recalculate << 1;
// 1014   *pBuf |= locData->brdcastIndicator << 2;
// 1015   *pBuf |= locData->brdcastResponse << 3;
// 1016   *pBuf |= locData->compactResponse << 4;
// 1017   pBuf++;  // move past the bitmap field
// 1018 
// 1019   *pBuf++ = locData->numResponses;
// 1020 
// 1021   if ( locData->brdcastIndicator == 0 )
// 1022   {
// 1023     osal_cpyExtAddr( pBuf, locData->targetAddr );
// 1024     len += 8; // ieee addr
// 1025   }
// 1026 
// 1027   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
// 1028                           COMMAND_LOCATION_GET_DATA, TRUE,
// 1029                           ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, len, buf );
// 1030 }
// 1031 
// 1032 /*********************************************************************
// 1033  * @fn      zclGeneral_SendLocationDevCfgResponse
// 1034  *
// 1035  * @brief   Call to send out a Device Configuration Response Command
// 1036  *
// 1037  * @param   srcEP - Sending application's endpoint
// 1038  * @param   dstAddr - where you want the message to go
// 1039  * @param   devCfg - device's location parameters that are requested
// 1040  *
// 1041  * @return  ZStatus_t
// 1042  */
// 1043 ZStatus_t zclGeneral_SendLocationDevCfgResponse( uint8 srcEP, afAddrType_t *dstAddr,
// 1044                                                  zclLocationDevCfgRsp_t *devCfg,
// 1045                                                  uint8 disableDefaultRsp, uint8 seqNum )
// 1046 {
// 1047   uint8 buf[10]; // 4 fields (2 octects each) + 2 fields (1 octect each)
// 1048   uint8 len = 1; // Status
// 1049 
// 1050   buf[0] = devCfg->status;
// 1051   if ( devCfg->status == ZCL_STATUS_SUCCESS )
// 1052   {
// 1053     buf[1] = LO_UINT16( devCfg->data.power );
// 1054     buf[2] = HI_UINT16( devCfg->data.power );
// 1055     buf[3] = LO_UINT16( devCfg->data.pathLossExponent );
// 1056     buf[4] = HI_UINT16( devCfg->data.pathLossExponent );
// 1057     buf[5] = LO_UINT16( devCfg->data.calcPeriod );
// 1058     buf[6] = HI_UINT16( devCfg->data.calcPeriod );
// 1059     buf[7] = devCfg->data.numMeasurements;
// 1060     buf[8] = LO_UINT16( devCfg->data.reportPeriod );
// 1061     buf[9] = HI_UINT16( devCfg->data.reportPeriod );
// 1062     len += 9;
// 1063   }
// 1064 
// 1065   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
// 1066                           COMMAND_LOCATION_DEV_CFG_RSP, TRUE,
// 1067                           ZCL_FRAME_SERVER_CLIENT_DIR, disableDefaultRsp, 0, seqNum, len, buf );
// 1068 }
// 1069 
// 1070 /*********************************************************************
// 1071  * @fn      zclGeneral_SendLocationData
// 1072  *
// 1073  * @brief   Call to send out location data
// 1074  *
// 1075  * @param   srcEP - Sending application's endpoint
// 1076  * @param   dstAddr - where you want the message to go
// 1077  * @param   status - indicates whether response to request was successful or not
// 1078  * @param   locData - location information and channel parameters being sent
// 1079  *
// 1080  * @return  ZStatus_t
// 1081  */
// 1082 ZStatus_t zclGeneral_SendLocationData( uint8 srcEP, afAddrType_t *dstAddr, uint8 cmd,
// 1083                                        uint8 status, zclLocationData_t *locData,
// 1084                                        uint8 disableDefaultRsp, uint8 seqNum )
// 1085 {
// 1086   uint8 buf[16];
// 1087   uint8 *pBuf = buf;
// 1088   uint8 len = 0;
// 1089 
// 1090   if ( cmd == COMMAND_LOCATION_DATA_RSP )
// 1091   {
// 1092     // Only response command includes a status field
// 1093     *pBuf++ = status;
// 1094     len++;
// 1095   }
// 1096 
// 1097   if ( cmd != COMMAND_LOCATION_DATA_RSP || status == ZCL_STATUS_SUCCESS )
// 1098   {
// 1099     // Notification or Response with successful status
// 1100     *pBuf++ = locData->type;
// 1101     *pBuf++ = LO_UINT16( locData->absLoc.coordinate1 );
// 1102     *pBuf++ = HI_UINT16( locData->absLoc.coordinate1 );
// 1103     *pBuf++ = LO_UINT16( locData->absLoc.coordinate2 );
// 1104     *pBuf++ = HI_UINT16( locData->absLoc.coordinate2 );
// 1105     len += 5;
// 1106 
// 1107     if ( locationType2D(locData->type) == 0 )
// 1108     {
// 1109       // 2D location doesn't have coordinate 3
// 1110       *pBuf++ = LO_UINT16( locData->absLoc.coordinate3 );
// 1111       *pBuf++ = HI_UINT16( locData->absLoc.coordinate3 );
// 1112       len += 2;
// 1113     }
// 1114 
// 1115     if ( cmd != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
// 1116     {
// 1117       // Compact notification doesn't include these fields
// 1118       *pBuf++ = LO_UINT16( locData->absLoc.power );
// 1119       *pBuf++ = HI_UINT16( locData->absLoc.power );
// 1120       *pBuf++ = LO_UINT16( locData->absLoc.pathLossExponent );
// 1121       *pBuf++ = HI_UINT16( locData->absLoc.pathLossExponent );
// 1122       len += 4;
// 1123     }
// 1124 
// 1125     if ( locationTypeAbsolute(locData->type) == 0 )
// 1126     {
// 1127       // Absolute location doesn't include these fields
// 1128       if ( cmd != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
// 1129       {
// 1130         // Compact notification doesn't include this field
// 1131         *pBuf++ = locData->calcLoc.locationMethod;
// 1132         len++;
// 1133       }
// 1134 
// 1135       *pBuf++ = locData->calcLoc.qualityMeasure;
// 1136       *pBuf++ = LO_UINT16( locData->calcLoc.locationAge );
// 1137       *pBuf++ = HI_UINT16( locData->calcLoc.locationAge );
// 1138       len += 3;
// 1139     }
// 1140   }
// 1141 
// 1142   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
// 1143                           cmd, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
// 1144                           disableDefaultRsp, 0, seqNum, len, buf );
// 1145 }
// 1146 #endif // ZCL_LOCATION
// 1147 
// 1148 /*********************************************************************
// 1149  * @fn      zclGeneral_FindCallbacks
// 1150  *
// 1151  * @brief   Find the callbacks for an endpoint
// 1152  *
// 1153  * @param   endpoint - endpoint to find the application callbacks for
// 1154  *
// 1155  * @return  pointer to the callbacks
// 1156  */
// 1157 static zclGeneral_AppCallbacks_t *zclGeneral_FindCallbacks( uint8 endpoint )
// 1158 {
// 1159   zclGenCBRec_t *pCBs;
// 1160 
// 1161   pCBs = zclGenCBs;
// 1162   while ( pCBs )
// 1163   {
// 1164     if ( pCBs->endpoint == endpoint )
// 1165       return ( pCBs->CBs );
// 1166     pCBs = pCBs->next;
// 1167   }
// 1168   return ( (zclGeneral_AppCallbacks_t *)NULL );
// 1169 }
// 1170 
// 1171 /*********************************************************************
// 1172  * @fn      zclGeneral_HdlIncoming
// 1173  *
// 1174  * @brief   Callback from ZCL to process incoming Commands specific
// 1175  *          to this cluster library or Profile commands for attributes
// 1176  *          that aren't in the attribute list
// 1177  *
// 1178  *
// 1179  * @param   pInMsg - pointer to the incoming message
// 1180  *
// 1181  * @return  ZStatus_t
// 1182  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1183 static ZStatus_t zclGeneral_HdlIncoming( zclIncoming_t *pInMsg )
zclGeneral_HdlIncoming:
        CFI Block cfiBlock12 Using cfiCommon0
        CFI Function zclGeneral_HdlIncoming
// 1184 {
        FUNCALL zclGeneral_HdlIncoming, zclGeneral_HdlInSpecificCommands
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
// 1185   ZStatus_t stat = ZSuccess;
// 1186 
// 1187 #if defined ( INTER_PAN )
// 1188   if ( StubAPS_InterPan( pInMsg->msg->srcAddr.panId, pInMsg->msg->srcAddr.endPoint ) )
// 1189     return ( stat ); // Cluster not supported thru Inter-PAN
// 1190 #endif
// 1191   if ( zcl_ClusterCmd( pInMsg->hdr.fc.type ) )
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        ANL     A,#0x3
        XRL     A,#0x1
        JNZ     ??zclGeneral_HdlIncoming_0
// 1192   {
// 1193     // Is this a manufacturer specific command?
// 1194     if ( pInMsg->hdr.fc.manuSpecific == 0 )
        MOV     A,R0
        ANL     A,#0x4
        JNZ     ??zclGeneral_HdlIncoming_0
// 1195     {
// 1196       stat = zclGeneral_HdlInSpecificCommands( pInMsg );
        ; Setup parameters for call to function zclGeneral_HdlInSpecificCommands
        LCALL   ??zclGeneral_HdlInSpecificCommands?relay
        SJMP    ??zclGeneral_HdlIncoming_1
// 1197     }
// 1198     else
// 1199     {
// 1200       // We don't support any manufacturer specific command.
// 1201       stat = ZFailure;
??zclGeneral_HdlIncoming_0:
        MOV     R1,#0x1
// 1202     }
// 1203   }
// 1204   else
// 1205   {
// 1206     // Handle all the normal (Read, Write...) commands -- should never get here
// 1207     stat = ZFailure;
// 1208   }
// 1209   return ( stat );
??zclGeneral_HdlIncoming_1:
        POP     DPH
        CFI DPH0 SameValue
        CFI CFA_SP SP+-4
        POP     DPL
        CFI DPL0 SameValue
        CFI CFA_SP SP+-3
        LJMP    ?BRET
        CFI EndBlock cfiBlock12
// 1210 }
// 1211 
// 1212 /*********************************************************************
// 1213  * @fn      zclGeneral_HdlInSpecificCommands
// 1214  *
// 1215  * @brief   Callback from ZCL to process incoming Commands specific
// 1216  *          to this cluster library
// 1217 
// 1218  * @param   pInMsg - pointer to the incoming message
// 1219  *
// 1220  * @return  ZStatus_t
// 1221  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1222 static ZStatus_t zclGeneral_HdlInSpecificCommands( zclIncoming_t *pInMsg )
zclGeneral_HdlInSpecificCommands:
        CFI Block cfiBlock13 Using cfiCommon0
        CFI Function zclGeneral_HdlInSpecificCommands
// 1223 {
        FUNCALL zclGeneral_HdlInSpecificCommands, zclGeneral_ProcessInIdentity
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 0
// 1224   ZStatus_t stat;
// 1225   zclGeneral_AppCallbacks_t *pCBs;
// 1226 
// 1227   // make sure endpoint exists
// 1228   pCBs = zclGeneral_FindCallbacks( pInMsg->msg->endPoint );
        MOV     DPL,R2
        LCALL   ?Subroutine5 & 0xFFFF
??CrossCallReturnLabel_10:
        LCALL   ?Subroutine6 & 0xFFFF
??CrossCallReturnLabel_12:
        MOV     R4,A
        MOV     DPTR,#zclGenCBs
??zclGeneral_HdlInSpecificCommands_0:
        LCALL   ?Subroutine7 & 0xFFFF
??CrossCallReturnLabel_14:
        JNZ     ??zclGeneral_HdlInSpecificCommands_1
        MOV     A,R1
??zclGeneral_HdlInSpecificCommands_1:
        JZ      ??zclGeneral_HdlInSpecificCommands_2
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,R4
        MOV     DPL,R0
        MOV     DPH,R1
        JNZ     ??zclGeneral_HdlInSpecificCommands_0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
// 1229   if ( pCBs == NULL )
        MOV     A,R4
        JNZ     ??zclGeneral_HdlInSpecificCommands_3
        MOV     A,R5
??zclGeneral_HdlInSpecificCommands_3:
        JZ      ??zclGeneral_HdlInSpecificCommands_2
// 1230     return ( ZFailure );
// 1231 
// 1232   switch ( pInMsg->msg->clusterId )
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 0,A
        INC     DPTR
        MOVX    A,@DPTR
        JNZ     ??zclGeneral_HdlInSpecificCommands_4
        MOV     A,?V0 + 0
        LCALL   ?UC_SWITCH_SPARSE
`?<Jumptable for zclGeneral_HdlInSpecificComman_0`:
        DATA
        DB        0
        DB        3
        DB        0
        DW        ??zclGeneral_HdlInSpecificCommands_5
        DB        3
        DW        ??zclGeneral_HdlInSpecificCommands_6
        DB        6
        DW        ??zclGeneral_HdlInSpecificCommands_7
        DW        ??zclGeneral_HdlInSpecificCommands_4
        CODE
// 1233   {
// 1234 #ifdef ZCL_BASIC
// 1235     case ZCL_CLUSTER_ID_GEN_BASIC:
// 1236       stat = zclGeneral_ProcessInBasic( pInMsg, pCBs );
??zclGeneral_HdlInSpecificCommands_5:
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        ANL     A,#0x8
        JNZ     ??zclGeneral_HdlInSpecificCommands_8
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        JNZ     ??zclGeneral_HdlInSpecificCommands_4
        MOV     DPL,R4
        MOV     DPH,R5
        LCALL   ?Subroutine2 & 0xFFFF
??CrossCallReturnLabel_4:
        JNZ     ??zclGeneral_HdlInSpecificCommands_9
        MOV     A,DPH
??zclGeneral_HdlInSpecificCommands_9:
        JZ      ??zclGeneral_HdlInSpecificCommands_8
        ; Setup parameters for indirect call
        SJMP    ??zclGeneral_HdlInSpecificCommands_10
??zclGeneral_HdlInSpecificCommands_2:
        SJMP    ??zclGeneral_HdlInSpecificCommands_4
// 1237       break;
// 1238 #endif // ZCL_BASIC
// 1239 
// 1240 #ifdef ZCL_IDENTIFY
// 1241     case ZCL_CLUSTER_ID_GEN_IDENTIFY:
// 1242       stat = zclGeneral_ProcessInIdentity( pInMsg, pCBs );
??zclGeneral_HdlInSpecificCommands_6:
        ; Setup parameters for call to function zclGeneral_ProcessInIdentity
        LCALL   ??zclGeneral_ProcessInIdentity?relay
        SJMP    ??zclGeneral_HdlInSpecificCommands_11
// 1243       break;
// 1244 #endif // ZCL_IDENTIFY
// 1245 
// 1246 #ifdef ZCL_GROUPS
// 1247     case ZCL_CLUSTER_ID_GEN_GROUPS:
// 1248       if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
// 1249         stat = zclGeneral_ProcessInGroupsServer( pInMsg );
// 1250       else
// 1251         stat = zclGeneral_ProcessInGroupsClient( pInMsg, pCBs );
// 1252       break;
// 1253 #endif // ZCL_GROUPS
// 1254 
// 1255 #ifdef ZCL_SCENES
// 1256     case ZCL_CLUSTER_ID_GEN_SCENES:
// 1257       if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
// 1258         stat = zclGeneral_ProcessInScenesServer( pInMsg, pCBs );
// 1259       else
// 1260         stat = zclGeneral_ProcessInScenesClient( pInMsg, pCBs );
// 1261       break;
// 1262 #endif // ZCL_SCENES
// 1263 
// 1264 #ifdef ZCL_ON_OFF
// 1265     case ZCL_CLUSTER_ID_GEN_ON_OFF:
// 1266       stat = zclGeneral_ProcessInOnOff( pInMsg, pCBs );
??zclGeneral_HdlInSpecificCommands_7:
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        ANL     A,#0x8
        JNZ     ??zclGeneral_HdlInSpecificCommands_8
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        CLR     C
        SUBB    A,#0x3
        JNC     ??zclGeneral_HdlInSpecificCommands_4
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        LCALL   ?Subroutine2 & 0xFFFF
??CrossCallReturnLabel_5:
        JNZ     ??zclGeneral_HdlInSpecificCommands_12
        MOV     A,DPH
??zclGeneral_HdlInSpecificCommands_12:
        JZ      ??zclGeneral_HdlInSpecificCommands_8
        ; Setup parameters for indirect call
        MOV     A,R2
        MOV     R1,A
??zclGeneral_HdlInSpecificCommands_10:
        LCALL   ?CALL_IND
??zclGeneral_HdlInSpecificCommands_8:
        MOV     R1,#0x0
        SJMP    ??zclGeneral_HdlInSpecificCommands_11
// 1267       break;
// 1268 #endif // ZCL_ON_OFF
// 1269 
// 1270 #ifdef ZCL_LEVEL_CTRL
// 1271     case ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL:
// 1272       stat = zclGeneral_ProcessInLevelControl( pInMsg, pCBs );
// 1273       break;
// 1274 #endif // ZCL_LEVEL_CTRL
// 1275 
// 1276 #ifdef ZCL_ALARMS
// 1277     case ZCL_CLUSTER_ID_GEN_ALARMS:
// 1278       if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
// 1279         stat = zclGeneral_ProcessInAlarmsServer( pInMsg, pCBs );
// 1280       else
// 1281         stat = zclGeneral_ProcessInAlarmsClient( pInMsg, pCBs );
// 1282       break;
// 1283 #endif // ZCL_ALARMS
// 1284 
// 1285 #ifdef ZCL_LOCATION
// 1286     case ZCL_CLUSTER_ID_GEN_LOCATION:
// 1287       if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
// 1288         stat = zclGeneral_ProcessInLocationServer( pInMsg, pCBs );
// 1289       else
// 1290         stat = zclGeneral_ProcessInLocationClient( pInMsg, pCBs );
// 1291       break;
// 1292 #endif // ZCL_LOCATION
// 1293 
// 1294     case ZCL_CLUSTER_ID_GEN_POWER_CFG:
// 1295     case ZCL_CLUSTER_ID_GEN_DEVICE_TEMP_CONFIG:
// 1296     case ZCL_CLUSTER_ID_GEN_ON_OFF_SWITCH_CONFIG:
// 1297     case ZCL_CLUSTER_ID_GEN_TIME:
// 1298     default:
// 1299       stat = ZFailure;
??zclGeneral_HdlInSpecificCommands_4:
        MOV     R1,#0x1
// 1300       break;
// 1301   }
// 1302 
// 1303   return ( stat );
??zclGeneral_HdlInSpecificCommands_11:
        LJMP    ??Subroutine11_0 & 0xFFFF
        CFI EndBlock cfiBlock13
// 1304 }

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine2:
        CFI Block cfiCond14 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_4
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        CFI Block cfiCond15 Using cfiCommon0
        CFI (cfiCond15) NoFunction
        CFI (cfiCond15) Conditional ??CrossCallReturnLabel_5
        CFI (cfiCond15) R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond15) VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond15) V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond15) V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond15) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond15) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond15) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond15) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond15) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond15) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond15) CFA_SP SP+0
        CFI (cfiCond15) CFA_XSP16 add(XSP16, 10)
        CFI Block cfiPicker16 Using cfiCommon1
        CFI (cfiPicker16) NoFunction
        CFI (cfiPicker16) Picker
        LCALL   ?Subroutine8 & 0xFFFF
??CrossCallReturnLabel_18:
        MOV     A,DPL
        RET
        CFI EndBlock cfiCond14
        CFI EndBlock cfiCond15
        CFI EndBlock cfiPicker16
// 1305 
// 1306 #ifdef ZCL_BASIC
// 1307 /*********************************************************************
// 1308  * @fn      zclGeneral_ProcessInBasic
// 1309  *
// 1310  * @brief   Process in the received Basic Command.
// 1311  *
// 1312  * @param   pInMsg - pointer to the incoming message
// 1313  *
// 1314  * @return  ZStatus_t
// 1315  */
// 1316 static ZStatus_t zclGeneral_ProcessInBasic( zclIncoming_t *pInMsg,
// 1317                                             zclGeneral_AppCallbacks_t *pCBs )
// 1318 {
// 1319   if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
// 1320   {
// 1321     if ( pInMsg->hdr.commandID > COMMAND_BASIC_RESET_FACT_DEFAULT )
// 1322       return ( ZFailure );   // Error ignore the command
// 1323 
// 1324     if ( pCBs->pfnBasicReset )
// 1325       pCBs->pfnBasicReset();
// 1326   }
// 1327   // no Client command
// 1328 
// 1329   return ( ZSuccess );
// 1330 }
// 1331 #endif // ZCL_BASIC
// 1332 
// 1333 #ifdef ZCL_IDENTIFY
// 1334 /*********************************************************************
// 1335  * @fn      zclGeneral_ProcessInIdentity
// 1336  *
// 1337  * @brief   Process in the received Identity Command.
// 1338  *
// 1339  * @param   pInMsg - pointer to the incoming message
// 1340  *
// 1341  * @return  ZStatus_t
// 1342  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1343 static ZStatus_t zclGeneral_ProcessInIdentity( zclIncoming_t *pInMsg,
zclGeneral_ProcessInIdentity:
        CFI Block cfiBlock17 Using cfiCommon0
        CFI Function zclGeneral_ProcessInIdentity
// 1344                                                zclGeneral_AppCallbacks_t *pCBs )
// 1345 {
        FUNCALL zclGeneral_ProcessInIdentity, zclFindAttrRec
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclGeneral_ProcessInIdentity, zclReadAttrData
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 26, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 26, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclGeneral_ProcessInIdentity, zclGeneral_SendIdentifyQueryResponse
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xc
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 12)
        ; Saved register size: 12
        ; Auto size: 14
        MOV     A,#-0xe
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 26)
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
// 1346   if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPL,?V0 + 0
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        ANL     A,#0x8
        JZ      $+5
        LJMP    ??zclGeneral_ProcessInIdentity_0 & 0xFFFF
// 1347   {
// 1348     if ( pInMsg->hdr.commandID > COMMAND_IDENTIFY_QUERY )
        MOV     A,R2
        CLR     C
        SUBB    A,#0x2
        JC      ??zclGeneral_ProcessInIdentity_1
// 1349       return ( ZFailure );   // Error ignore the command
??zclGeneral_ProcessInIdentity_2:
        MOV     R1,#0x1
        LJMP    ??zclGeneral_ProcessInIdentity_3 & 0xFFFF
// 1350 
// 1351     if ( pInMsg->hdr.commandID == COMMAND_IDENTIFY )
??zclGeneral_ProcessInIdentity_1:
        MOV     A,R2
        JNZ     ??zclGeneral_ProcessInIdentity_4
// 1352     {
// 1353       if ( pCBs->pfnIdentify )
        MOV     DPL,R4
        MOV     DPH,R5
        LCALL   ?Subroutine4 & 0xFFFF
// 1354       {
// 1355         zclIdentify_t cmd;
// 1356 
// 1357         cmd.srcAddr = &(pInMsg->msg->srcAddr);
// 1358         cmd.identifyTime = BUILD_UINT16( pInMsg->pData[0], pInMsg->pData[1] );
// 1359 
// 1360         pCBs->pfnIdentify( &cmd );
// 1361       }
// 1362     }
??CrossCallReturnLabel_8:
        JNZ     ??zclGeneral_ProcessInIdentity_5
        MOV     A,R5
??zclGeneral_ProcessInIdentity_5:
        LJMP    ??zclGeneral_ProcessInIdentity_6 & 0xFFFF
// 1363     else
// 1364     {
// 1365       zclAttrRec_t attrRec;
// 1366       uint16 identifyTime = 0;
??zclGeneral_ProcessInIdentity_4:
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        CLR     A
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    @DPTR,A
// 1367 
// 1368       // Retrieve Identify Time
// 1369       if ( zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, ATTRID_IDENTIFY_TIME, &attrRec ) )
        MOV     DPL,?V0 + 0
        LCALL   ?Subroutine5 & 0xFFFF
??CrossCallReturnLabel_11:
        ; Setup parameters for call to function zclFindAttrRec
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOV     ?V0 + 2,DPL
        MOV     ?V0 + 3,DPH
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 28)
        MOV     R4,#0x0
        MOV     R5,#0x0
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        LCALL   ?Subroutine3 & 0xFFFF
??CrossCallReturnLabel_6:
        LCALL   ??zclFindAttrRec?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 26)
        MOV     A,R1
        JZ      ??zclGeneral_ProcessInIdentity_7
// 1370         zclReadAttrData( (uint8 *)&identifyTime, &attrRec );
        ; Setup parameters for call to function zclReadAttrData
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??zclReadAttrData?relay
// 1371 
// 1372       // Is device identifying itself?
// 1373       if ( identifyTime > 0 )
??zclGeneral_ProcessInIdentity_7:
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        JNZ     ??zclGeneral_ProcessInIdentity_8
        INC     DPTR
        MOVX    A,@DPTR
??zclGeneral_ProcessInIdentity_8:
        JZ      ??zclGeneral_ProcessInIdentity_9
// 1374       {
// 1375         zclGeneral_SendIdentifyQueryResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 1376                                               identifyTime, true, pInMsg->hdr.transSeqNum );
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    A,@DPTR
        MOV     R6,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R7,A
        ; Setup parameters for call to function zclGeneral_SendIdentifyQueryResponse
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 0,A
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_ONE
        CFI CFA_XSP16 add(XSP16, 27)
        MOV     ?V0 + 0,#0x1
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_ONE
        CFI CFA_XSP16 add(XSP16, 28)
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     A,R6
        ADD     A,#0x6
        MOV     R2,A
        MOV     A,R7
        ADDC    A,#0x0
        LCALL   ?Subroutine3 & 0xFFFF
// 1377       }
??CrossCallReturnLabel_7:
        LCALL   ??zclGeneral_SendIdentifyQueryResponse?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 26)
// 1378 
// 1379       return ( ZCL_STATUS_CMD_HAS_RSP );
??zclGeneral_ProcessInIdentity_9:
        MOV     R1,#-0x1
        SJMP    ??zclGeneral_ProcessInIdentity_3
// 1380     }
// 1381   }
// 1382   else // Client Command
// 1383   {
// 1384     if ( pInMsg->hdr.commandID > COMMAND_IDENTIFY_QUERY_RSP )
??zclGeneral_ProcessInIdentity_0:
        MOV     A,R2
        JZ      $+5
        LJMP    ??zclGeneral_ProcessInIdentity_2 & 0xFFFF
// 1385       return ( ZFailure );   // Error ignore the command
// 1386 
// 1387     if ( pCBs->pfnIdentifyQueryRsp )
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        INC     DPTR
        LCALL   ?Subroutine4 & 0xFFFF
??CrossCallReturnLabel_9:
        JNZ     ??zclGeneral_ProcessInIdentity_6
        MOV     A,R5
??zclGeneral_ProcessInIdentity_6:
        JZ      ??zclGeneral_ProcessInIdentity_10
// 1388     {
// 1389       zclIdentifyQueryRsp_t rsp;
// 1390 
// 1391       rsp.srcAddr = &(pInMsg->msg->srcAddr);
        MOV     DPL,?V0 + 0
        MOV     DPH,R3
        MOVX    A,@DPTR
        ADD     A,#0x6
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1392       rsp.timeout = BUILD_UINT16( pInMsg->pData[0], pInMsg->pData[1] );
        MOV     DPL,?V0 + 0
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        LCALL   ?Subroutine8 & 0xFFFF
??CrossCallReturnLabel_17:
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R2
        MOV     R0,A
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1393 
// 1394       pCBs->pfnIdentifyQueryRsp( &rsp );
        ; Setup parameters for indirect call
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R2,DPL
        MOV     R3,DPH
        MOV     DPL,R4
        MOV     DPH,R5
        LCALL   ?CALL_IND
// 1395     }
// 1396   }
// 1397 
// 1398   return ( ZSuccess );
??zclGeneral_ProcessInIdentity_10:
        MOV     R1,#0x0
??zclGeneral_ProcessInIdentity_3:
        MOV     A,#0xe
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 12)
        LJMP    ?Subroutine9 & 0xFFFF
        CFI EndBlock cfiBlock17
// 1399 }

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine8:
        CFI Block cfiCond18 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_18, ??CrossCallReturnLabel_4
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        CFI Block cfiCond19 Using cfiCommon0
        CFI (cfiCond19) NoFunction
        CFI (cfiCond19) Conditional ??CrossCallReturnLabel_18, ??CrossCallReturnLabel_5
        CFI (cfiCond19) R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond19) VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond19) V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond19) V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond19) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond19) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond19) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond19) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond19) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond19) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond19) CFA_SP SP+0
        CFI (cfiCond19) CFA_XSP16 add(XSP16, 10)
        CFI Block cfiCond20 Using cfiCommon0
        CFI (cfiCond20) NoFunction
        CFI (cfiCond20) Conditional ??CrossCallReturnLabel_17
        CFI (cfiCond20) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond20) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond20) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond20) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond20) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond20) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond20) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond20) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond20) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond20) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond20) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond20) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond20) CFA_SP SP+0
        CFI (cfiCond20) CFA_XSP16 add(XSP16, 26)
        CFI Block cfiPicker21 Using cfiCommon1
        CFI (cfiPicker21) NoFunction
        CFI (cfiPicker21) Picker
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        RET
        CFI EndBlock cfiCond18
        CFI EndBlock cfiCond19
        CFI EndBlock cfiCond20
        CFI EndBlock cfiPicker21

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine5:
        CFI Block cfiCond22 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_10
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        CFI Block cfiCond23 Using cfiCommon0
        CFI (cfiCond23) NoFunction
        CFI (cfiCond23) Conditional ??CrossCallReturnLabel_11
        CFI (cfiCond23) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond23) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond23) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond23) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond23) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond23) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond23) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond23) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond23) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond23) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond23) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond23) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond23) CFA_SP SP+0
        CFI (cfiCond23) CFA_XSP16 add(XSP16, 26)
        CFI Block cfiPicker24 Using cfiCommon1
        CFI (cfiPicker24) NoFunction
        CFI (cfiPicker24) Picker
        MOV     DPH,R3
        LCALL   ?Subroutine7 & 0xFFFF
??CrossCallReturnLabel_16:
        MOV     R6,A
        MOV     A,R1
        MOV     R7,A
        RET
        CFI EndBlock cfiCond22
        CFI EndBlock cfiCond23
        CFI EndBlock cfiPicker24

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine7:
        CFI Block cfiCond25 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_14
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        CFI Block cfiCond26 Using cfiCommon0
        CFI (cfiCond26) NoFunction
        CFI (cfiCond26) Conditional ??CrossCallReturnLabel_16, ??CrossCallReturnLabel_10
        CFI (cfiCond26) R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond26) VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond26) V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond26) V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond26) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond26) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond26) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond26) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond26) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond26) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond26) CFA_SP SP+0
        CFI (cfiCond26) CFA_XSP16 add(XSP16, 10)
        CFI Block cfiCond27 Using cfiCommon0
        CFI (cfiCond27) NoFunction
        CFI (cfiCond27) Conditional ??CrossCallReturnLabel_16, ??CrossCallReturnLabel_11
        CFI (cfiCond27) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond27) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond27) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond27) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond27) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond27) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond27) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond27) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond27) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond27) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond27) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond27) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond27) CFA_SP SP+0
        CFI (cfiCond27) CFA_XSP16 add(XSP16, 26)
        CFI Block cfiCond28 Using cfiCommon0
        CFI (cfiCond28) NoFunction
        CFI (cfiCond28) Conditional ??CrossCallReturnLabel_15, ??CrossCallReturnLabel_8
        CFI (cfiCond28) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond28) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond28) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond28) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond28) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond28) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond28) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond28) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond28) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond28) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond28) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond28) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond28) CFA_SP SP+0
        CFI (cfiCond28) CFA_XSP16 add(XSP16, 26)
        CFI Block cfiCond29 Using cfiCommon0
        CFI (cfiCond29) NoFunction
        CFI (cfiCond29) Conditional ??CrossCallReturnLabel_15, ??CrossCallReturnLabel_9
        CFI (cfiCond29) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond29) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond29) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond29) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond29) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond29) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond29) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond29) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond29) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond29) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond29) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond29) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond29) CFA_SP SP+0
        CFI (cfiCond29) CFA_XSP16 add(XSP16, 26)
        CFI Block cfiPicker30 Using cfiCommon1
        CFI (cfiPicker30) NoFunction
        CFI (cfiPicker30) Picker
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        RET
        CFI EndBlock cfiCond25
        CFI EndBlock cfiCond26
        CFI EndBlock cfiCond27
        CFI EndBlock cfiCond28
        CFI EndBlock cfiCond29
        CFI EndBlock cfiPicker30

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine4:
        CFI Block cfiCond31 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_8
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 26)
        CFI Block cfiCond32 Using cfiCommon0
        CFI (cfiCond32) NoFunction
        CFI (cfiCond32) Conditional ??CrossCallReturnLabel_9
        CFI (cfiCond32) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond32) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond32) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond32) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond32) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond32) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond32) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond32) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond32) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond32) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond32) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond32) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond32) CFA_SP SP+0
        CFI (cfiCond32) CFA_XSP16 add(XSP16, 26)
        CFI Block cfiPicker33 Using cfiCommon1
        CFI (cfiPicker33) NoFunction
        CFI (cfiPicker33) Picker
        INC     DPTR
        INC     DPTR
        LCALL   ?Subroutine7 & 0xFFFF
??CrossCallReturnLabel_15:
        MOV     R4,A
        MOV     A,R1
        MOV     R5,A
        MOV     A,R4
        RET
        CFI EndBlock cfiCond31
        CFI EndBlock cfiCond32
        CFI EndBlock cfiPicker33

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine3:
        CFI Block cfiCond34 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_6
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 28)
        CFI Block cfiCond35 Using cfiCommon0
        CFI (cfiCond35) NoFunction
        CFI (cfiCond35) Conditional ??CrossCallReturnLabel_7
        CFI (cfiCond35) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond35) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond35) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond35) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond35) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond35) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond35) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond35) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond35) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond35) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond35) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond35) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond35) CFA_SP SP+0
        CFI (cfiCond35) CFA_XSP16 add(XSP16, 28)
        CFI Block cfiPicker36 Using cfiCommon1
        CFI (cfiPicker36) NoFunction
        CFI (cfiPicker36) Picker
        MOV     R3,A
        LCALL   ?Subroutine6 & 0xFFFF
??CrossCallReturnLabel_13:
        MOV     R1,A
        RET
        CFI EndBlock cfiCond34
        CFI EndBlock cfiCond35
        CFI EndBlock cfiPicker36

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine6:
        CFI Block cfiCond37 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_12
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        CFI Block cfiCond38 Using cfiCommon0
        CFI (cfiCond38) NoFunction
        CFI (cfiCond38) Conditional ??CrossCallReturnLabel_13, ??CrossCallReturnLabel_6
        CFI (cfiCond38) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond38) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond38) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond38) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond38) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond38) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond38) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond38) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond38) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond38) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond38) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond38) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond38) CFA_SP SP+0
        CFI (cfiCond38) CFA_XSP16 add(XSP16, 28)
        CFI Block cfiCond39 Using cfiCommon0
        CFI (cfiCond39) NoFunction
        CFI (cfiCond39) Conditional ??CrossCallReturnLabel_13, ??CrossCallReturnLabel_7
        CFI (cfiCond39) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond39) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond39) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond39) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond39) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond39) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond39) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond39) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond39) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond39) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond39) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond39) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond39) CFA_SP SP+0
        CFI (cfiCond39) CFA_XSP16 add(XSP16, 28)
        CFI Block cfiPicker40 Using cfiCommon1
        CFI (cfiPicker40) NoFunction
        CFI (cfiPicker40) Picker
        MOV     A,R6
        ADD     A,#0x14
        MOV     DPL,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        RET
        CFI EndBlock cfiCond37
        CFI EndBlock cfiCond38
        CFI EndBlock cfiCond39
        CFI EndBlock cfiPicker40

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclGeneral_RegisterCmdCallbacks?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    zclGeneral_RegisterCmdCallbacks

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclGeneral_SendIdentify?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    zclGeneral_SendIdentify

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclGeneral_SendIdentifyQueryResponse?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    zclGeneral_SendIdentifyQueryResponse

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclGeneral_HdlIncoming?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    zclGeneral_HdlIncoming

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclGeneral_HdlInSpecificCommands?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    zclGeneral_HdlInSpecificCommands

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclGeneral_ProcessInIdentity?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    zclGeneral_ProcessInIdentity

        END
// 1400 #endif // ZCL_IDENTIFY
// 1401 
// 1402 #ifdef ZCL_GROUPS
// 1403 
// 1404 /*********************************************************************
// 1405  * @fn      zclGeneral_AddGroup
// 1406  *
// 1407  * @brief   Add a Group.
// 1408  *
// 1409  * @param   endPoint - application endpoint
// 1410  * @param   group - group to be added
// 1411  * @param   pData - pointer to the group info
// 1412  *
// 1413  * @return  ZStatus_t
// 1414  */
// 1415 static ZStatus_t zclGeneral_AddGroup( uint8 endPoint, aps_Group_t *group, uint8 *pData )
// 1416 {
// 1417   zclAttrRec_t attrRec;
// 1418   uint8 nameLen;
// 1419   uint8 nameSupport = FALSE;
// 1420 
// 1421   pData += 2;   // Move past group ID
// 1422   nameLen = *pData++;
// 1423 
// 1424   // Retrieve Name Support attribute
// 1425   if ( zclFindAttrRec( endPoint, ZCL_CLUSTER_ID_GEN_GROUPS, ATTRID_GROUP_NAME_SUPPORT, &attrRec ) )
// 1426      zclReadAttrData( &nameSupport, &attrRec );
// 1427 
// 1428   if ( nameSupport )
// 1429   {
// 1430     if ( nameLen > (APS_GROUP_NAME_LEN-1) )
// 1431        nameLen = (APS_GROUP_NAME_LEN-1);
// 1432     group->name[0] = nameLen;
// 1433     osal_memcpy( &(group->name[1]), pData, nameLen );
// 1434   }
// 1435 
// 1436   return ( aps_AddGroup( endPoint, group ) );
// 1437 }
// 1438 
// 1439 /*********************************************************************
// 1440  * @fn      zclGeneral_ProcessInGroupsServer
// 1441  *
// 1442  * @brief   Process in the received Groups Command.
// 1443  *
// 1444  * @param   pInMsg - pointer to the incoming message
// 1445  *
// 1446  * @return  ZStatus_t
// 1447  */
// 1448 static ZStatus_t zclGeneral_ProcessInGroupsServer( zclIncoming_t *pInMsg )
// 1449 {
// 1450   zclAttrRec_t attrRec;
// 1451   aps_Group_t group;
// 1452   aps_Group_t *pGroup;
// 1453   uint8 *pData;
// 1454   uint8 status;
// 1455   uint8 grpCnt;
// 1456   uint8 grpRspCnt = 0;
// 1457   uint16 *grpList;
// 1458   uint16 identifyTime = 0;
// 1459   uint8 i;
// 1460   ZStatus_t stat = ZSuccess;
// 1461 
// 1462   osal_memset( (uint8*)&group, 0, sizeof( aps_Group_t ) );
// 1463 
// 1464   pData = pInMsg->pData;
// 1465   group.ID = BUILD_UINT16( pData[0], pData[1] );
// 1466   switch ( pInMsg->hdr.commandID )
// 1467   {
// 1468     case COMMAND_GROUP_ADD:
// 1469       status = zclGeneral_AddGroup( pInMsg->msg->endPoint, &group, pData );
// 1470       if ( status != ZSuccess )
// 1471       {
// 1472         if ( status == ZApsDuplicateEntry )
// 1473           status = ZCL_STATUS_DUPLICATE_EXISTS;
// 1474         else
// 1475           status = ZCL_STATUS_INSUFFICIENT_SPACE;
// 1476       }
// 1477 
// 1478       zclGeneral_SendGroupAddResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 1479                                        status, group.ID, true, pInMsg->hdr.transSeqNum );
// 1480       stat = ZCL_STATUS_CMD_HAS_RSP;
// 1481       break;
// 1482 
// 1483     case COMMAND_GROUP_VIEW:
// 1484       pGroup = aps_FindGroup( pInMsg->msg->endPoint, group.ID );
// 1485       if ( pGroup )
// 1486       {
// 1487         status = ZCL_STATUS_SUCCESS;
// 1488       }
// 1489       else
// 1490       {
// 1491         // Group not found
// 1492         status = ZCL_STATUS_NOT_FOUND;
// 1493         pGroup = &group;
// 1494       }
// 1495       zclGeneral_SendGroupViewResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 1496                                         status, pGroup, true, pInMsg->hdr.transSeqNum );
// 1497       stat = ZCL_STATUS_CMD_HAS_RSP;
// 1498       break;
// 1499 
// 1500     case COMMAND_GROUP_GET_MEMBERSHIP:
// 1501       grpCnt = *pData++;
// 1502         
// 1503       // Allocate space for the group list
// 1504       grpList = osal_mem_alloc( sizeof( uint16 ) * APS_MAX_GROUPS );
// 1505       if ( grpList != NULL )
// 1506       {
// 1507         if ( grpCnt == 0 )
// 1508         {
// 1509           // Find out all the groups of which the endpoint is a member.
// 1510           grpRspCnt = aps_FindAllGroupsForEndpoint( pInMsg->msg->endPoint, grpList );
// 1511         }
// 1512         else
// 1513         {
// 1514           // Find out the groups (in the list) of which the endpoint is a member.
// 1515           for ( i = 0; i < grpCnt; i++ )
// 1516           {
// 1517             group.ID = BUILD_UINT16( pData[0], pData[1] );
// 1518             pData += 2;
// 1519 
// 1520             if ( aps_FindGroup( pInMsg->msg->endPoint, group.ID ) )
// 1521               grpList[grpRspCnt++] = group.ID;
// 1522           }
// 1523         }
// 1524       
// 1525         if ( grpCnt == 0 ||  grpRspCnt != 0 )
// 1526         {
// 1527           zclGeneral_SendGroupGetMembershipResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr, 
// 1528                                                      aps_GroupsRemaingCapacity(), grpRspCnt, 
// 1529                                                      grpList, true, pInMsg->hdr.transSeqNum );
// 1530         }
// 1531 
// 1532         osal_mem_free( grpList );
// 1533       }
// 1534       else
// 1535       {
// 1536         // Couldn't allocate space for the group list -- send a Default Response command back.
// 1537         zclDefaultRspCmd_t defaultRspCmd;
// 1538         
// 1539         defaultRspCmd.commandID = pInMsg->hdr.commandID;
// 1540         defaultRspCmd.statusCode = ZCL_STATUS_INSUFFICIENT_SPACE;
// 1541         zcl_SendDefaultRspCmd( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
// 1542                                pInMsg->msg->clusterId, &defaultRspCmd,
// 1543                                ZCL_FRAME_SERVER_CLIENT_DIR, true, 0, pInMsg->hdr.transSeqNum );
// 1544       }
// 1545 
// 1546       stat = ZCL_STATUS_CMD_HAS_RSP;
// 1547       break;
// 1548 
// 1549     case COMMAND_GROUP_REMOVE:
// 1550       if ( aps_RemoveGroup( pInMsg->msg->endPoint, group.ID ) )
// 1551         status = ZCL_STATUS_SUCCESS;
// 1552       else
// 1553         status = ZCL_STATUS_NOT_FOUND;
// 1554       zclGeneral_SendGroupRemoveResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 1555                                           status, group.ID, true, pInMsg->hdr.transSeqNum );
// 1556       stat = ZCL_STATUS_CMD_HAS_RSP;
// 1557       break;
// 1558 
// 1559     case COMMAND_GROUP_REMOVE_ALL:
// 1560       aps_RemoveAllGroup( pInMsg->msg->endPoint );
// 1561       break;
// 1562 
// 1563     case COMMAND_GROUP_ADD_IF_IDENTIFYING:
// 1564       // Retrieve Identify Time
// 1565       if ( zclFindAttrRec( pInMsg->msg->endPoint, ZCL_CLUSTER_ID_GEN_IDENTIFY, ATTRID_IDENTIFY_TIME, &attrRec ) )
// 1566         zclReadAttrData( (uint8 *)&identifyTime, &attrRec );
// 1567 
// 1568       // Is device identifying itself?
// 1569       if ( identifyTime > 0 )
// 1570         zclGeneral_AddGroup( pInMsg->msg->endPoint, &group, pData );
// 1571       break;
// 1572 
// 1573     default:
// 1574       stat = ZFailure;
// 1575       break;
// 1576   }
// 1577 
// 1578   return ( stat );
// 1579 }
// 1580 
// 1581 /*********************************************************************
// 1582  * @fn      zclGeneral_ProcessInGroupsClient
// 1583  *
// 1584  * @brief   Process in the received Groups Command.
// 1585  *
// 1586  * @param   pInMsg - pointer to the incoming message
// 1587  *
// 1588  * @return  ZStatus_t
// 1589  */
// 1590 static ZStatus_t zclGeneral_ProcessInGroupsClient( zclIncoming_t *pInMsg,
// 1591                                                    zclGeneral_AppCallbacks_t *pCBs )
// 1592 {
// 1593   aps_Group_t group;
// 1594   uint8 *pData = pInMsg->pData;
// 1595   uint16 *grpList;
// 1596   uint8 grpCnt;
// 1597   uint8 nameLen;
// 1598   zclGroupRsp_t rsp;
// 1599   uint8 i;
// 1600   ZStatus_t stat = ZSuccess;
// 1601 
// 1602   osal_memset( (uint8*)&group, 0, sizeof( aps_Group_t ) );
// 1603   osal_memset( (uint8*)&rsp, 0, sizeof( zclGroupRsp_t ) );
// 1604 
// 1605   switch ( pInMsg->hdr.commandID )
// 1606   {
// 1607     case COMMAND_GROUP_ADD_RSP:
// 1608     case COMMAND_GROUP_VIEW_RSP:
// 1609     case COMMAND_GROUP_REMOVE_RSP:
// 1610       rsp.status = *pData++;
// 1611       group.ID = BUILD_UINT16( pData[0], pData[1] );
// 1612 
// 1613       if ( rsp.status == ZCL_STATUS_SUCCESS && pInMsg->hdr.commandID == COMMAND_GROUP_VIEW_RSP )
// 1614       {
// 1615         pData += 2;   // Move past ID
// 1616         nameLen = *pData++;
// 1617         if ( nameLen > (APS_GROUP_NAME_LEN-1) )
// 1618           nameLen = (APS_GROUP_NAME_LEN-1);
// 1619         group.name[0] = nameLen;
// 1620         osal_memcpy( &(group.name[1]), pData, nameLen );
// 1621         rsp.grpName = group.name;
// 1622       }
// 1623 
// 1624       if ( pCBs->pfnGroupRsp )
// 1625       {
// 1626         rsp.srcAddr = &(pInMsg->msg->srcAddr);
// 1627         rsp.cmdID = pInMsg->hdr.commandID;
// 1628         rsp.grpCnt = 1;
// 1629         rsp.grpList = &group.ID;
// 1630         rsp.capacity = 0;
// 1631 
// 1632         pCBs->pfnGroupRsp( &rsp );
// 1633       }
// 1634       break;
// 1635 
// 1636     case COMMAND_GROUP_GET_MEMBERSHIP_RSP:
// 1637       rsp.capacity = *pData++;
// 1638       grpCnt = *pData++;
// 1639 
// 1640       if ( grpCnt > 0 )
// 1641       {
// 1642         // Allocate space for the group list
// 1643         grpList = osal_mem_alloc( sizeof( uint16 ) * grpCnt );
// 1644         if ( grpList != NULL )
// 1645         {
// 1646           rsp.grpCnt = grpCnt;
// 1647           for ( i = 0; i < grpCnt; i++ )
// 1648           {
// 1649             grpList[i] = BUILD_UINT16( pData[0], pData[1] );
// 1650             pData += 2;
// 1651           }
// 1652         }
// 1653       }
// 1654 
// 1655       if ( pCBs->pfnGroupRsp )
// 1656       {
// 1657         rsp.srcAddr = &(pInMsg->msg->srcAddr);
// 1658         rsp.cmdID = pInMsg->hdr.commandID;
// 1659         rsp.grpList = grpList;
// 1660 
// 1661         pCBs->pfnGroupRsp( &rsp );
// 1662       }
// 1663       
// 1664       if ( grpList != NULL )
// 1665         osal_mem_free( grpList );
// 1666       break;
// 1667 
// 1668     default:
// 1669       stat = ZFailure;
// 1670       break;
// 1671   }
// 1672 
// 1673   return ( stat );
// 1674 }
// 1675 #endif // ZCL_GROUPS
// 1676 
// 1677 #ifdef ZCL_SCENES
// 1678 /*********************************************************************
// 1679  * @fn      zclGeneral_AddScene
// 1680  *
// 1681  * @brief   Add a scene for an endpoint
// 1682  *
// 1683  * @param   endpoint -
// 1684  * @param   scene - new scene item
// 1685  *
// 1686  * @return  ZStatus_t
// 1687  */
// 1688 ZStatus_t zclGeneral_AddScene( uint8 endpoint, zclGeneral_Scene_t *scene )
// 1689 {
// 1690   zclGenSceneItem_t *pNewItem;
// 1691   zclGenSceneItem_t *pLoop;
// 1692 
// 1693   // Fill in the new profile list
// 1694   pNewItem = osal_mem_alloc( sizeof( zclGenSceneItem_t ) );
// 1695   if ( pNewItem == NULL )
// 1696     return ( ZMemError );
// 1697 
// 1698   // Fill in the plugin record.
// 1699   pNewItem->next = (zclGenSceneItem_t *)NULL;
// 1700   pNewItem->endpoint = endpoint;
// 1701   osal_memcpy( (uint8*)&(pNewItem->scene), (uint8*)scene, sizeof ( zclGeneral_Scene_t ));
// 1702 
// 1703   // Find spot in list
// 1704   if (  zclGenSceneTable == NULL )
// 1705   {
// 1706     zclGenSceneTable = pNewItem;
// 1707   }
// 1708   else
// 1709   {
// 1710     // Look for end of list
// 1711     pLoop = zclGenSceneTable;
// 1712     while ( pLoop->next != NULL )
// 1713       pLoop = pLoop->next;
// 1714 
// 1715     // Put new item at end of list
// 1716     pLoop->next = pNewItem;
// 1717   }
// 1718 
// 1719   // Update NV
// 1720   zclGeneral_ScenesWriteNV();
// 1721 
// 1722   return ( ZSuccess );
// 1723 }
// 1724 
// 1725 /*********************************************************************
// 1726  * @fn      zclGeneral_FindScene
// 1727  *
// 1728  * @brief   Find a scene with endpoint and sceneID
// 1729  *
// 1730  * @param   endpoint -
// 1731  * @param   groupID - what group the scene belongs to
// 1732  * @param   sceneID - ID to look for scene
// 1733  *
// 1734  * @return  a pointer to the scene information, NULL if not found
// 1735  */
// 1736 zclGeneral_Scene_t *zclGeneral_FindScene( uint8 endpoint, uint16 groupID, uint8 sceneID )
// 1737 {
// 1738   zclGenSceneItem_t *pLoop;
// 1739 
// 1740   // Look for end of list
// 1741   pLoop = zclGenSceneTable;
// 1742   while ( pLoop )
// 1743   {
// 1744     if ( (pLoop->endpoint == endpoint || endpoint == 0xFF)
// 1745         && pLoop->scene.groupID == groupID && pLoop->scene.ID == sceneID )
// 1746     {
// 1747       return ( &(pLoop->scene) );
// 1748     }
// 1749     pLoop = pLoop->next;
// 1750   }
// 1751 
// 1752   return ( (zclGeneral_Scene_t *)NULL );
// 1753 }
// 1754 
// 1755 /*********************************************************************
// 1756  * @fn      aps_FindAllScensForGroup
// 1757  *
// 1758  * @brief   Find all the scenes with groupID
// 1759  *
// 1760  * @param   endpoint - endpoint to look for
// 1761  * @param   sceneList - List to hold scene IDs (should hold APS_MAX_SCENES entries)
// 1762  *
// 1763  * @return  number of scenes copied to sceneList
// 1764  */
// 1765 uint8 zclGeneral_FindAllScenesForGroup( uint8 endpoint, uint16 groupID, uint8 *sceneList )
// 1766 {
// 1767   zclGenSceneItem_t *pLoop;
// 1768   uint8 cnt = 0;
// 1769 
// 1770   // Look for end of list
// 1771   pLoop = zclGenSceneTable;
// 1772   while ( pLoop )
// 1773   {
// 1774     if ( pLoop->endpoint == endpoint && pLoop->scene.groupID == groupID )
// 1775       sceneList[cnt++] = pLoop->scene.ID;
// 1776     pLoop = pLoop->next;
// 1777   }
// 1778   return ( cnt );
// 1779 }
// 1780 
// 1781 /*********************************************************************
// 1782  * @fn      zclGeneral_RemoveScene
// 1783  *
// 1784  * @brief   Remove a scene with endpoint and sceneID
// 1785  *
// 1786  * @param   endpoint -
// 1787  * @param   groupID - what group the scene belongs to
// 1788  * @param   sceneID - ID to look for scene
// 1789  *
// 1790  * @return  TRUE if removed, FALSE if not found
// 1791  */
// 1792 uint8 zclGeneral_RemoveScene( uint8 endpoint, uint16 groupID, uint8 sceneID )
// 1793 {
// 1794   zclGenSceneItem_t *pLoop;
// 1795   zclGenSceneItem_t *pPrev;
// 1796 
// 1797   // Look for end of list
// 1798   pLoop = zclGenSceneTable;
// 1799   pPrev = NULL;
// 1800   while ( pLoop )
// 1801   {
// 1802     if ( pLoop->endpoint == endpoint
// 1803         && pLoop->scene.groupID == groupID && pLoop->scene.ID == sceneID )
// 1804     {
// 1805       if ( pPrev == NULL )
// 1806         zclGenSceneTable = pLoop->next;
// 1807       else
// 1808         pPrev->next = pLoop->next;
// 1809 
// 1810       // Free the memory
// 1811       osal_mem_free( pLoop );
// 1812 
// 1813       // Update NV
// 1814       zclGeneral_ScenesWriteNV();
// 1815 
// 1816       return ( TRUE );
// 1817     }
// 1818     pPrev = pLoop;
// 1819     pLoop = pLoop->next;
// 1820   }
// 1821 
// 1822   return ( FALSE );
// 1823 }
// 1824 
// 1825 /*********************************************************************
// 1826  * @fn      zclGeneral_RemoveAllScenes
// 1827  *
// 1828  * @brief   Remove all scenes with endpoint and group Id
// 1829  *
// 1830  * @param   endpoint -
// 1831  * @param   groupID - ID to look for group
// 1832  *
// 1833  * @return  none
// 1834  */
// 1835 void zclGeneral_RemoveAllScenes( uint8 endpoint, uint16 groupID )
// 1836 {
// 1837   zclGenSceneItem_t *pLoop;
// 1838   zclGenSceneItem_t *pPrev;
// 1839   zclGenSceneItem_t *pNext;
// 1840 
// 1841   // Look for end of list
// 1842   pLoop = zclGenSceneTable;
// 1843   pPrev = NULL;
// 1844   while ( pLoop )
// 1845   {
// 1846     if ( pLoop->endpoint == endpoint && pLoop->scene.groupID == groupID )
// 1847     {
// 1848       if ( pPrev == NULL )
// 1849         zclGenSceneTable = pLoop->next;
// 1850       else
// 1851         pPrev->next = pLoop->next;
// 1852       pNext = pLoop->next;
// 1853 
// 1854       // Free the memory
// 1855       osal_mem_free( pLoop );
// 1856       pLoop = pNext;
// 1857     }
// 1858     else
// 1859     {
// 1860       pPrev = pLoop;
// 1861       pLoop = pLoop->next;
// 1862     }
// 1863   }
// 1864 
// 1865   // Update NV
// 1866   zclGeneral_ScenesWriteNV();
// 1867 }
// 1868 
// 1869 /*********************************************************************
// 1870  * @fn      zclGeneral_CountScenes
// 1871  *
// 1872  * @brief   Count the number of scenes for an endpoint
// 1873  *
// 1874  * @param   endpoint -
// 1875  *
// 1876  * @return  number of scenes assigned to an endpoint
// 1877  */
// 1878 uint8 zclGeneral_CountScenes( uint8 endpoint )
// 1879 {
// 1880   zclGenSceneItem_t *pLoop;
// 1881   uint8 cnt = 0;
// 1882 
// 1883   // Look for end of list
// 1884   pLoop = zclGenSceneTable;
// 1885   while ( pLoop )
// 1886   {
// 1887     if ( pLoop->endpoint == endpoint  )
// 1888       cnt++;
// 1889     pLoop = pLoop->next;
// 1890   }
// 1891   return ( cnt );
// 1892 }
// 1893 
// 1894 /*********************************************************************
// 1895  * @fn      zclGeneral_CountAllScenes
// 1896  *
// 1897  * @brief   Count the total number of scenes
// 1898  *
// 1899  * @param   none
// 1900  *
// 1901  * @return  number of scenes
// 1902  */
// 1903 uint8 zclGeneral_CountAllScenes( void )
// 1904 {
// 1905   zclGenSceneItem_t *pLoop;
// 1906   uint8 cnt = 0;
// 1907 
// 1908   // Look for end of list
// 1909   pLoop = zclGenSceneTable;
// 1910   while ( pLoop )
// 1911   {
// 1912     cnt++;
// 1913     pLoop = pLoop->next;
// 1914   }
// 1915   return ( cnt );
// 1916 }
// 1917 
// 1918 /*********************************************************************
// 1919  * @fn      zclGeneral_ProcessInScenesServer
// 1920  *
// 1921  * @brief   Process in the received Scenes Command.
// 1922  *
// 1923  * @param   pInMsg - pointer to the incoming message
// 1924  *
// 1925  * @return  ZStatus_t
// 1926  */
// 1927 static ZStatus_t zclGeneral_ProcessInScenesServer( zclIncoming_t *pInMsg,
// 1928                                                    zclGeneral_AppCallbacks_t *pCBs )
// 1929 {
// 1930   zclAttrRec_t attrRec;
// 1931   zclGeneral_Scene_t scene;
// 1932   zclGeneral_Scene_t *pScene;
// 1933   uint8 *pData = pInMsg->pData;
// 1934   uint8 nameLen;
// 1935   uint8 status;
// 1936   uint8 sceneCnt = 0;
// 1937   uint8 *sceneList = NULL;
// 1938   uint8 sendRsp = FALSE;
// 1939   uint8 nameSupport = FALSE;
// 1940   ZStatus_t stat = ZSuccess;
// 1941 
// 1942   osal_memset( (uint8*)&scene, 0, sizeof( zclGeneral_Scene_t ) );
// 1943 
// 1944   scene.groupID = BUILD_UINT16( pData[0], pData[1] );
// 1945   pData += 2;   // Move past group ID
// 1946   scene.ID = *pData++;
// 1947 
// 1948   switch ( pInMsg->hdr.commandID )
// 1949   {
// 1950     case COMMAND_SCENE_ADD:
// 1951       // Parse the rest of the incoming message
// 1952       scene.transTime = BUILD_UINT16( pData[0], pData[1] );
// 1953       pData += 2;
// 1954       nameLen= *pData++; // Name length
// 1955 
// 1956       // Retrieve Name Support attribute
// 1957       if ( zclFindAttrRec( pInMsg->msg->endPoint, ZCL_CLUSTER_ID_GEN_SCENES, ATTRID_SCENES_NAME_SUPPORT, &attrRec ) )
// 1958         zclReadAttrData( &nameSupport, &attrRec );
// 1959 
// 1960       if ( nameSupport )
// 1961       {
// 1962         if ( nameLen > (ZCL_GEN_SCENE_NAME_LEN-1) )
// 1963           nameLen = (ZCL_GEN_SCENE_NAME_LEN-1);
// 1964         scene.name[0] = nameLen;
// 1965         osal_memcpy( &(scene.name[1]), pData, nameLen );
// 1966       }
// 1967 
// 1968       pData += nameLen; // move pass name
// 1969 
// 1970       scene.extLen = pInMsg->pDataLen - ( (uint16)( pData - pInMsg->pData ) );
// 1971       if ( scene.extLen > 0 )
// 1972       {
// 1973         // Copy the extention field(s)
// 1974         if ( scene.extLen > ZCL_GEN_SCENE_EXT_LEN )
// 1975           scene.extLen = ZCL_GEN_SCENE_EXT_LEN;
// 1976         osal_memcpy( scene.extField, pData, scene.extLen );
// 1977       }
// 1978 
// 1979       if ( scene.groupID == 0x0000 ||
// 1980            aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
// 1981       {
// 1982         // Either the Scene doesn't belong to a Group (Group ID = 0x0000) or it
// 1983         // does and the corresponding Group exits
// 1984         pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
// 1985         if ( pScene || ( zclGeneral_CountAllScenes() < ZCL_GEN_MAX_SCENES ) )
// 1986         {
// 1987           status = ZCL_STATUS_SUCCESS;
// 1988           if ( pScene != NULL )
// 1989           {
// 1990             // The Scene already exists so update it
// 1991             pScene->transTime = scene.transTime;
// 1992             osal_memcpy( pScene->name, scene.name, ZCL_GEN_SCENE_NAME_LEN );
// 1993 
// 1994             // Use the new extention field(s)
// 1995             osal_memcpy( pScene->extField, scene.extField, scene.extLen );
// 1996             pScene->extLen = scene.extLen;
// 1997 
// 1998             // Update NV
// 1999             zclGeneral_ScenesWriteNV();
// 2000           }
// 2001           else
// 2002           {
// 2003             // The Scene doesn't exist so add it
// 2004             zclGeneral_AddScene( pInMsg->msg->endPoint, &scene );
// 2005           }
// 2006         }
// 2007         else
// 2008           status = ZCL_STATUS_INSUFFICIENT_SPACE; // The Scene Table is full
// 2009       }
// 2010       else
// 2011         status = ZCL_STATUS_INVALID_FIELD; // The Group is not in the Group Table
// 2012 
// 2013       zclGeneral_SendSceneAddResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 2014                                        status, scene.groupID, scene.ID,
// 2015                                        true, pInMsg->hdr.transSeqNum );
// 2016       stat = ZCL_STATUS_CMD_HAS_RSP;
// 2017       break;
// 2018 
// 2019     case COMMAND_SCENE_VIEW:
// 2020       pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
// 2021       if ( pScene != NULL )
// 2022       {
// 2023         status = ZCL_STATUS_SUCCESS;
// 2024       }
// 2025       else
// 2026       {
// 2027         // Scene not found
// 2028         if ( scene.groupID != 0x0000 &&
// 2029              aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) == NULL )
// 2030         {
// 2031           status = ZCL_STATUS_INVALID_FIELD; // The Group is not in the Group Table
// 2032         }
// 2033         else
// 2034           status = ZCL_STATUS_NOT_FOUND;
// 2035         pScene = &scene;
// 2036       }
// 2037       zclGeneral_SendSceneViewResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 2038                                         status, pScene, true, pInMsg->hdr.transSeqNum );
// 2039       stat = ZCL_STATUS_CMD_HAS_RSP;
// 2040       break;
// 2041 
// 2042     case COMMAND_SCENE_REMOVE:
// 2043       if ( zclGeneral_RemoveScene( pInMsg->msg->endPoint, scene.groupID, scene.ID ) )
// 2044       {
// 2045         status = ZCL_STATUS_SUCCESS;
// 2046       }
// 2047       else
// 2048       {
// 2049         // Scene not found
// 2050         if ( aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) == NULL )
// 2051         {
// 2052           // The Group is not in the Group Table
// 2053           status = ZCL_STATUS_INVALID_FIELD;
// 2054         }
// 2055         else
// 2056           status = ZCL_STATUS_NOT_FOUND;
// 2057       }
// 2058 
// 2059       if ( UNICAST_MSG( pInMsg->msg ) )
// 2060       {
// 2061         // Addressed to this device (not to a group) - send a response back
// 2062         zclGeneral_SendSceneRemoveResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 2063                                             status, scene.groupID,
// 2064                                             scene.ID, true, pInMsg->hdr.transSeqNum );
// 2065       }
// 2066       stat = ZCL_STATUS_CMD_HAS_RSP;
// 2067       break;
// 2068 
// 2069     case COMMAND_SCENE_REMOVE_ALL:
// 2070       if ( scene.groupID == 0x0000 ||
// 2071            aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
// 2072       {
// 2073         zclGeneral_RemoveAllScenes( pInMsg->msg->endPoint, scene.groupID );
// 2074         status = ZCL_STATUS_SUCCESS;
// 2075       }
// 2076       else
// 2077         status = ZCL_STATUS_INVALID_FIELD;
// 2078 
// 2079       if ( UNICAST_MSG( pInMsg->msg ) )
// 2080       {
// 2081         // Addressed to this device (not to a group) - send a response back
// 2082         zclGeneral_SendSceneRemoveAllResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 2083                                                status, scene.groupID, true, pInMsg->hdr.transSeqNum );
// 2084       }
// 2085       stat = ZCL_STATUS_CMD_HAS_RSP;
// 2086       break;
// 2087 
// 2088     case COMMAND_SCENE_STORE:
// 2089       if ( scene.groupID == 0x0000 ||
// 2090            aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
// 2091       {
// 2092         // Either the Scene doesn't belong to a Group (Group ID = 0x0000) or it
// 2093         // does and the corresponding Group exits
// 2094         pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
// 2095         if ( pScene || ( zclGeneral_CountAllScenes() < ZCL_GEN_MAX_SCENES ) )
// 2096         {
// 2097           uint8 sceneChanged = FALSE;
// 2098 
// 2099           status = ZCL_STATUS_SUCCESS;
// 2100           if ( pScene == NULL )
// 2101           {
// 2102             // Haven't been added yet
// 2103             pScene = &scene;
// 2104           }
// 2105 
// 2106           if ( pCBs->pfnSceneStoreReq )
// 2107           {
// 2108             zclSceneReq_t req;
// 2109 
// 2110             req.srcAddr = &(pInMsg->msg->srcAddr);
// 2111             req.scene = pScene;
// 2112 
// 2113             // Get the latest Scene info
// 2114             if ( pCBs->pfnSceneStoreReq( &req ) )
// 2115               sceneChanged = TRUE;
// 2116           }
// 2117 
// 2118           if ( pScene == &scene )
// 2119           {
// 2120             // The Scene doesn't exist so add it
// 2121             zclGeneral_AddScene( pInMsg->msg->endPoint, &scene );
// 2122           }
// 2123           else if ( sceneChanged )
// 2124           {
// 2125             // The Scene already exists so update only NV
// 2126             zclGeneral_ScenesWriteNV();
// 2127           }
// 2128         }
// 2129         else
// 2130           status = ZCL_STATUS_INSUFFICIENT_SPACE; // The Scene Table is full
// 2131       }
// 2132       else
// 2133         status = ZCL_STATUS_INVALID_FIELD; // The Group is not in the Group Table
// 2134 
// 2135       if ( UNICAST_MSG( pInMsg->msg ) )
// 2136       {
// 2137         // Addressed to this device (not to a group) - send a response back
// 2138         zclGeneral_SendSceneStoreResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 2139                                            status, scene.groupID, scene.ID,
// 2140                                            true, pInMsg->hdr.transSeqNum );
// 2141       }
// 2142       stat = ZCL_STATUS_CMD_HAS_RSP;
// 2143       break;
// 2144 
// 2145     case COMMAND_SCENE_RECALL:
// 2146       pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
// 2147       if ( pScene && pCBs->pfnSceneRecallReq )
// 2148       {
// 2149         zclSceneReq_t req;
// 2150 
// 2151         req.srcAddr = &(pInMsg->msg->srcAddr);
// 2152         req.scene = pScene;
// 2153 
// 2154         pCBs->pfnSceneRecallReq( &req );
// 2155       }
// 2156       // No response
// 2157       break;
// 2158 
// 2159     case COMMAND_SCENE_GET_MEMBERSHIP:
// 2160       // Find all the Scenes corresponding to the Group ID
// 2161       if ( scene.groupID == 0x0000 ||
// 2162            aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
// 2163       {
// 2164         // Allocate space for the scene list
// 2165         sceneList = osal_mem_alloc( ZCL_GEN_MAX_SCENES );
// 2166         if ( sceneList != NULL )
// 2167         {
// 2168           sceneCnt = zclGeneral_FindAllScenesForGroup( pInMsg->msg->endPoint, 
// 2169                                                        scene.groupID, sceneList ); 
// 2170           status = ZCL_STATUS_SUCCESS;
// 2171           if ( UNICAST_MSG( pInMsg->msg ) )
// 2172           {
// 2173             // Addressed only to this device - send a response back
// 2174             sendRsp = TRUE;
// 2175           }
// 2176           else
// 2177           {
// 2178             // Addressed to the Group - ONLY send a response if an entry within the 
// 2179             // Scene Table corresponds to the Group ID
// 2180             if ( sceneCnt != 0 )
// 2181               sendRsp = TRUE;
// 2182           }
// 2183         }
// 2184         else
// 2185         {
// 2186           // Couldn't allocate space for the scene list!
// 2187           status = ZCL_STATUS_INSUFFICIENT_SPACE;
// 2188           sendRsp = TRUE;
// 2189         }
// 2190       }
// 2191       else
// 2192       {
// 2193         // The Group is not in the Group Table - send a response back
// 2194         status = ZCL_STATUS_INVALID_FIELD;
// 2195         sendRsp = TRUE;
// 2196       }
// 2197 
// 2198       if ( sendRsp )
// 2199       {
// 2200         zclGeneral_SendSceneGetMembershipResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 2201                                     status, zclGeneral_ScenesRemaingCapacity(), sceneCnt, sceneList,
// 2202                                     scene.groupID, true, pInMsg->hdr.transSeqNum );
// 2203       }
// 2204       
// 2205       if ( sceneList != NULL )
// 2206         osal_mem_free( sceneList );
// 2207       
// 2208       stat = ZCL_STATUS_CMD_HAS_RSP;
// 2209       break;
// 2210 
// 2211     default:
// 2212       stat = ZFailure;
// 2213     break;
// 2214   }
// 2215 
// 2216   return ( stat );
// 2217 }
// 2218 
// 2219 /*********************************************************************
// 2220  * @fn      zclGeneral_ProcessInScenesClient
// 2221  *
// 2222  * @brief   Process in the received Scenes Command.
// 2223  *
// 2224  * @param   pInMsg - pointer to the incoming message
// 2225  *
// 2226  * @return  ZStatus_t
// 2227  */
// 2228 static ZStatus_t zclGeneral_ProcessInScenesClient( zclIncoming_t *pInMsg,
// 2229                                                    zclGeneral_AppCallbacks_t *pCBs )
// 2230 {
// 2231   zclGeneral_Scene_t scene;
// 2232   uint8 *pData = pInMsg->pData;
// 2233   uint8 nameLen;
// 2234   uint8 *sceneList = NULL;
// 2235   zclSceneRsp_t rsp;
// 2236   uint8 i;
// 2237   ZStatus_t stat = ZSuccess;
// 2238 
// 2239   osal_memset( (uint8*)&scene, 0, sizeof( zclGeneral_Scene_t ) );
// 2240   osal_memset( (uint8*)&rsp, 0, sizeof( zclSceneRsp_t ) );
// 2241 
// 2242   // Get the status field first
// 2243   rsp.status = *pData++;
// 2244 
// 2245   if ( pInMsg->hdr.commandID == COMMAND_SCENE_GET_MEMBERSHIP_RSP )
// 2246     rsp.capacity = *pData++;
// 2247 
// 2248   scene.groupID = BUILD_UINT16( pData[0], pData[1] );
// 2249   pData += 2;   // Move past group ID
// 2250 
// 2251   switch ( pInMsg->hdr.commandID )
// 2252   {
// 2253     case COMMAND_SCENE_VIEW_RSP:
// 2254       // Parse the rest of the incoming message
// 2255       scene.ID = *pData++; // Not applicable to Remove All Response command
// 2256       scene.transTime = BUILD_UINT16( pData[0], pData[1] );
// 2257       pData += 2;
// 2258       nameLen = *pData++; // Name length
// 2259       if ( nameLen > (ZCL_GEN_SCENE_NAME_LEN-1) )
// 2260         nameLen = (ZCL_GEN_SCENE_NAME_LEN-1);
// 2261       scene.name[0] = nameLen;
// 2262       osal_memcpy( &(scene.name[1]), pData, nameLen );
// 2263       pData += nameLen; // move pass name
// 2264 
// 2265       //*** Do something with the extension field(s)
// 2266 
// 2267       // Fall through to callback - break is left off intentionally
// 2268 
// 2269     case COMMAND_SCENE_ADD_RSP:
// 2270     case COMMAND_SCENE_REMOVE_RSP:
// 2271     case COMMAND_SCENE_REMOVE_ALL_RSP:
// 2272     case COMMAND_SCENE_STORE_RSP:
// 2273       if ( pCBs->pfnSceneRsp )
// 2274       {
// 2275         rsp.srcAddr = &(pInMsg->msg->srcAddr);
// 2276         rsp.cmdID = pInMsg->hdr.commandID;
// 2277         rsp.scene = &scene;
// 2278 
// 2279         pCBs->pfnSceneRsp( &rsp );
// 2280       }
// 2281       break;
// 2282 
// 2283     case COMMAND_SCENE_GET_MEMBERSHIP_RSP:
// 2284       if ( rsp.status == ZCL_STATUS_SUCCESS )
// 2285       {
// 2286         uint8 sceneCnt = *pData++;
// 2287         
// 2288         if ( sceneCnt > 0 )
// 2289         {
// 2290           // Allocate space for the scene list
// 2291           sceneList = osal_mem_alloc( sceneCnt );
// 2292           if ( sceneList != NULL )
// 2293           {
// 2294             rsp.sceneCnt = sceneCnt;
// 2295             for ( i = 0; i < sceneCnt; i++ )
// 2296               sceneList[i] = *pData++;
// 2297           }
// 2298         }
// 2299       }
// 2300 
// 2301       if ( pCBs->pfnSceneRsp )
// 2302       {
// 2303         rsp.srcAddr = &(pInMsg->msg->srcAddr);
// 2304         rsp.cmdID = pInMsg->hdr.commandID;
// 2305         rsp.sceneList = sceneList;
// 2306         rsp.scene = &scene;
// 2307 
// 2308         pCBs->pfnSceneRsp( &rsp);
// 2309       }
// 2310       
// 2311       if ( sceneList != NULL )
// 2312         osal_mem_free( sceneList );
// 2313       break;
// 2314 
// 2315     default:
// 2316       stat = ZFailure;
// 2317       break;
// 2318   }
// 2319 
// 2320   return ( stat );
// 2321 }
// 2322 #endif // ZCL_SCENES
// 2323 
// 2324 #ifdef ZCL_ON_OFF
// 2325 /*********************************************************************
// 2326  * @fn      zclGeneral_ProcessInCmdOnOff
// 2327  *
// 2328  * @brief   Process in the received On/Off Command.
// 2329  *
// 2330  * @param   pInMsg - pointer to the incoming message
// 2331  *
// 2332  * @return  ZStatus_t
// 2333  */
// 2334 static ZStatus_t zclGeneral_ProcessInOnOff( zclIncoming_t *pInMsg,
// 2335                                             zclGeneral_AppCallbacks_t *pCBs )
// 2336 {
// 2337   if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
// 2338   {
// 2339     if ( pInMsg->hdr.commandID > COMMAND_TOGGLE )
// 2340       return ( ZFailure );   // Error ignore the command
// 2341 
// 2342     if ( pCBs->pfnOnOff )
// 2343       pCBs->pfnOnOff( pInMsg->hdr.commandID );
// 2344   }
// 2345   // no Client command
// 2346 
// 2347   return ( ZSuccess );
// 2348 }
// 2349 #endif // ZCL_ON_OFF
// 2350 
// 2351 #ifdef ZCL_LEVEL_CTRL
// 2352 /*********************************************************************
// 2353  * @fn      zclGeneral_ProcessInLevelControl
// 2354  *
// 2355  * @brief   Process in the received Level Control Command.
// 2356  *
// 2357  * @param   pInMsg - pointer to the incoming message
// 2358  *
// 2359  * @return  ZStatus_t
// 2360  */
// 2361 static ZStatus_t zclGeneral_ProcessInLevelControl( zclIncoming_t *pInMsg,
// 2362                                                    zclGeneral_AppCallbacks_t *pCBs )
// 2363 {
// 2364   uint8 withOnOff = FALSE;
// 2365   ZStatus_t stat = ZSuccess;
// 2366 
// 2367   if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
// 2368   {
// 2369     switch ( pInMsg->hdr.commandID )
// 2370     {
// 2371       case COMMAND_LEVEL_MOVE_TO_LEVEL_WITH_ON_OFF:
// 2372         withOnOff = TRUE;
// 2373         // fall through
// 2374       case COMMAND_LEVEL_MOVE_TO_LEVEL:
// 2375         if ( pCBs->pfnLevelControlMoveToLevel )
// 2376         {
// 2377           zclLCMoveToLevel_t cmd;
// 2378 
// 2379           cmd.level = pInMsg->pData[0];
// 2380           cmd.transitionTime = BUILD_UINT16( pInMsg->pData[1], pInMsg->pData[2] );
// 2381           cmd.withOnOff = withOnOff;
// 2382 
// 2383           pCBs->pfnLevelControlMoveToLevel( &cmd );
// 2384         }
// 2385         break;
// 2386 
// 2387       case COMMAND_LEVEL_MOVE_WITH_ON_OFF:
// 2388         withOnOff = TRUE;
// 2389         // fall through
// 2390       case COMMAND_LEVEL_MOVE:
// 2391         if ( pCBs->pfnLevelControlMove )
// 2392         {
// 2393           zclLCMove_t cmd;
// 2394 
// 2395           cmd.moveMode = pInMsg->pData[0];
// 2396           cmd.rate = pInMsg->pData[1];
// 2397           cmd.withOnOff = withOnOff;
// 2398 
// 2399           pCBs->pfnLevelControlMove( &cmd );
// 2400         }
// 2401         break;
// 2402 
// 2403       case COMMAND_LEVEL_STEP_WITH_ON_OFF:
// 2404         withOnOff = TRUE;
// 2405         // fall through
// 2406       case COMMAND_LEVEL_STEP:
// 2407         if ( pCBs->pfnLevelControlStep )
// 2408         {
// 2409           zclLCStep_t cmd;
// 2410 
// 2411           cmd.stepMode = pInMsg->pData[0];
// 2412           cmd.amount =  pInMsg->pData[1];
// 2413           cmd.transitionTime = BUILD_UINT16( pInMsg->pData[2], pInMsg->pData[3] );
// 2414           cmd.withOnOff = withOnOff;
// 2415 
// 2416           pCBs->pfnLevelControlStep( &cmd );
// 2417         }
// 2418         break;
// 2419 
// 2420       case COMMAND_LEVEL_STOP:
// 2421       case COMMAND_LEVEL_STOP_WITH_ON_OFF:
// 2422         // Both Stop commands are identical
// 2423         if ( pCBs->pfnLevelControlStop )
// 2424         {
// 2425           pCBs->pfnLevelControlStop();
// 2426         }
// 2427         break;
// 2428 
// 2429       default:
// 2430         stat = ZFailure;
// 2431         break;
// 2432     }
// 2433   }
// 2434   // no Client command
// 2435 
// 2436   return ( stat );
// 2437 }
// 2438 #endif // ZCL_LEVEL_CTRL
// 2439 
// 2440 #ifdef ZCL_ALARMS
// 2441 /*********************************************************************
// 2442  * @fn      zclGeneral_AddAlarm
// 2443  *
// 2444  * @brief   Add an alarm for a cluster
// 2445  *
// 2446  * @param   endpoint -
// 2447  * @param   alarm - new alarm item
// 2448  *
// 2449  * @return  ZStatus_t
// 2450  */
// 2451 ZStatus_t zclGeneral_AddAlarm( uint8 endpoint, zclGeneral_Alarm_t *alarm )
// 2452 {
// 2453   zclGenAlarmItem_t *pNewItem;
// 2454   zclGenAlarmItem_t *pLoop;
// 2455 
// 2456   // Fill in the new profile list
// 2457   pNewItem = osal_mem_alloc( sizeof( zclGenAlarmItem_t ) );
// 2458   if ( pNewItem == NULL )
// 2459     return ( ZMemError );
// 2460 
// 2461   // Fill in the plugin record.
// 2462   pNewItem->next = (zclGenAlarmItem_t *)NULL;
// 2463   pNewItem->endpoint =  endpoint;
// 2464   osal_memcpy( (uint8*)(&pNewItem->alarm), (uint8*)alarm, sizeof ( zclGeneral_Alarm_t ) );
// 2465 
// 2466   // Find spot in list
// 2467   if (  zclGenAlarmTable == NULL )
// 2468   {
// 2469     zclGenAlarmTable = pNewItem;
// 2470   }
// 2471   else
// 2472   {
// 2473     // Look for end of list
// 2474     pLoop = zclGenAlarmTable;
// 2475     while ( pLoop->next != NULL )
// 2476       pLoop = pLoop->next;
// 2477 
// 2478     // Put new item at end of list
// 2479     pLoop->next = pNewItem;
// 2480   }
// 2481 
// 2482   return ( ZSuccess );
// 2483 }
// 2484 
// 2485 /*********************************************************************
// 2486  * @fn      zclGeneral_FindAlarm
// 2487  *
// 2488  * @brief   Find an alarm with alarmCode and clusterID
// 2489  *
// 2490  * @param   endpoint -
// 2491  * @param   groupID - what group the scene belongs to
// 2492  * @param   sceneID - ID to look for scene
// 2493  *
// 2494  * @return  a pointer to the alarm information, NULL if not found
// 2495  */
// 2496 zclGeneral_Alarm_t *zclGeneral_FindAlarm( uint8 endpoint, uint8 alarmCode, uint16 clusterID )
// 2497 {
// 2498   zclGenAlarmItem_t *pLoop;
// 2499 
// 2500   // Look for the alarm
// 2501   pLoop = zclGenAlarmTable;
// 2502   while ( pLoop )
// 2503   {
// 2504     if ( pLoop->endpoint == endpoint &&
// 2505          pLoop->alarm.code == alarmCode && pLoop->alarm.clusterID == clusterID )
// 2506     {
// 2507       return ( &(pLoop->alarm) );
// 2508     }
// 2509     pLoop = pLoop->next;
// 2510   }
// 2511 
// 2512   return ( (zclGeneral_Alarm_t *)NULL );
// 2513 }
// 2514 
// 2515 /*********************************************************************
// 2516  * @fn      zclGeneral_FindEarliestAlarm
// 2517  *
// 2518  * @brief   Find an alarm with the earliest timestamp
// 2519  *
// 2520  * @param   endpoint -
// 2521  *
// 2522  * @return  a pointer to the alarm information, NULL if not found
// 2523  */
// 2524 zclGeneral_Alarm_t *zclGeneral_FindEarliestAlarm( uint8 endpoint )
// 2525 {
// 2526   zclGenAlarmItem_t *pLoop;
// 2527   zclGenAlarmItem_t earliestAlarm;
// 2528   zclGenAlarmItem_t *pEarliestAlarm = &earliestAlarm;
// 2529 
// 2530   pEarliestAlarm->alarm.timeStamp = 0xFFFFFFFF;
// 2531 
// 2532   // Look for alarm with earliest time
// 2533   pLoop = zclGenAlarmTable;
// 2534   while ( pLoop )
// 2535   {
// 2536     if ( pLoop->endpoint == endpoint &&
// 2537          pLoop->alarm.timeStamp < pEarliestAlarm->alarm.timeStamp )
// 2538     {
// 2539       pEarliestAlarm = pLoop;
// 2540     }
// 2541     pLoop = pLoop->next;
// 2542   }
// 2543 
// 2544   if ( pEarliestAlarm->alarm.timeStamp != 0xFFFFFFFF )
// 2545     return ( &(pEarliestAlarm->alarm) );
// 2546 
// 2547   // No alarm
// 2548   return ( (zclGeneral_Alarm_t *)NULL );
// 2549 }
// 2550 
// 2551 /*********************************************************************
// 2552  * @fn      zclGeneral_ResetAlarm
// 2553  *
// 2554  * @brief   Remove a scene with endpoint and sceneID
// 2555  *
// 2556  * @param   endpoint -
// 2557  * @param   alarmCode -
// 2558  * @param   clusterID -
// 2559  *
// 2560  * @return  TRUE if removed, FALSE if not found
// 2561  */
// 2562 void zclGeneral_ResetAlarm( uint8 endpoint, uint8 alarmCode, uint16 clusterID )
// 2563 {
// 2564   zclGenAlarmItem_t *pLoop;
// 2565   zclGenAlarmItem_t *pPrev;
// 2566 
// 2567   // Look for end of list
// 2568   pLoop = zclGenAlarmTable;
// 2569   pPrev = NULL;
// 2570   while ( pLoop )
// 2571   {
// 2572     if ( pLoop->endpoint == endpoint &&
// 2573          pLoop->alarm.code == alarmCode && pLoop->alarm.clusterID == clusterID )
// 2574     {
// 2575       if ( pPrev == NULL )
// 2576         zclGenAlarmTable = pLoop->next;
// 2577       else
// 2578         pPrev->next = pLoop->next;
// 2579 
// 2580       // Free the memory
// 2581       osal_mem_free( pLoop );
// 2582 
// 2583       // Notify the Application so that if the alarm condition still active then
// 2584       // a new notification will be generated, and a new alarm record will be
// 2585       // added to the alarm log
// 2586       // zclGeneral_NotifyReset( alarmCode, clusterID ); // callback function?
// 2587       return;
// 2588     }
// 2589     pPrev = pLoop;
// 2590     pLoop = pLoop->next;
// 2591   }
// 2592 }
// 2593 
// 2594 /*********************************************************************
// 2595  * @fn      zclGeneral_ResetAllAlarms
// 2596  *
// 2597  * @brief   Remove all alarms with endpoint
// 2598  *
// 2599  * @param   endpoint -
// 2600  * @param   notifyApp -
// 2601  *
// 2602  * @return  none
// 2603  */
// 2604 void zclGeneral_ResetAllAlarms( uint8 endpoint, uint8 notifyApp )
// 2605 {
// 2606   zclGenAlarmItem_t *pLoop;
// 2607   zclGenAlarmItem_t *pPrev;
// 2608   zclGenAlarmItem_t *pNext;
// 2609 
// 2610   // Look for end of list
// 2611   pLoop = zclGenAlarmTable;
// 2612   pPrev = NULL;
// 2613   while ( pLoop )
// 2614   {
// 2615     if (  pLoop->endpoint == endpoint )
// 2616     {
// 2617       if ( pPrev == NULL )
// 2618         zclGenAlarmTable = pLoop->next;
// 2619       else
// 2620         pPrev->next = pLoop->next;
// 2621 
// 2622       pNext = pLoop->next;
// 2623 
// 2624       // Free the memory
// 2625       osal_mem_free( pLoop );
// 2626 
// 2627       pLoop = pNext;
// 2628     }
// 2629     else
// 2630     {
// 2631       pPrev = pLoop;
// 2632       pLoop = pLoop->next;
// 2633     }
// 2634   }
// 2635 
// 2636   if ( notifyApp )
// 2637   {
// 2638     // Notify the Application so that if any alarm conditions still active then
// 2639     // a new notification will be generated, and a new alarm record will be
// 2640     // added to the alarm log
// 2641     // zclGeneral_NotifyResetAll(); // callback function?
// 2642   }
// 2643 }
// 2644 
// 2645 /*********************************************************************
// 2646  * @fn      zclGeneral_ProcessInAlarmsServer
// 2647  *
// 2648  * @brief   Process in the received Alarms Command.
// 2649  *
// 2650  * @param   pInMsg - pointer to the incoming message
// 2651  *
// 2652  * @return  ZStatus_t
// 2653  */
// 2654 static ZStatus_t zclGeneral_ProcessInAlarmsServer( zclIncoming_t *pInMsg,
// 2655                                                    zclGeneral_AppCallbacks_t *pCBs )
// 2656 {
// 2657   zclGeneral_Alarm_t *pAlarm;
// 2658   uint8 *pData = pInMsg->pData;
// 2659   ZStatus_t stat = ZSuccess;
// 2660 
// 2661   switch ( pInMsg->hdr.commandID )
// 2662   {
// 2663     case COMMAND_ALARMS_RESET:
// 2664       zclGeneral_ResetAlarm( pInMsg->msg->endPoint, pData[0],
// 2665                              BUILD_UINT16( pData[1], pData[2] ) );
// 2666       break;
// 2667 
// 2668     case COMMAND_ALARMS_RESET_ALL:
// 2669       zclGeneral_ResetAllAlarms( pInMsg->msg->endPoint, TRUE );
// 2670       break;
// 2671 
// 2672     case COMMAND_ALARMS_GET:
// 2673       pAlarm = zclGeneral_FindEarliestAlarm( pInMsg->msg->endPoint );
// 2674       if ( pAlarm )
// 2675       {
// 2676         // Send a response back
// 2677         zclGeneral_SendAlarmGetRespnose( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 2678                                          ZCL_STATUS_SUCCESS, pAlarm->code,
// 2679                                          pAlarm->clusterID, pAlarm->timeStamp,
// 2680                                          true, pInMsg->hdr.transSeqNum );
// 2681         // Remove the entry from the Alarm table
// 2682         zclGeneral_ResetAlarm( pInMsg->msg->endPoint, pAlarm->code, pAlarm->clusterID );
// 2683       }
// 2684       else
// 2685       {
// 2686         // Send a response back
// 2687         zclGeneral_SendAlarmGetRespnose( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 2688                                          ZCL_STATUS_NOT_FOUND, 0, 0, 0,
// 2689                                          true, pInMsg->hdr.transSeqNum );
// 2690       }
// 2691       stat = ZCL_STATUS_CMD_HAS_RSP;
// 2692       break;
// 2693 
// 2694     case COMMAND_ALARMS_RESET_LOG:
// 2695       zclGeneral_ResetAllAlarms( pInMsg->msg->endPoint, FALSE );
// 2696       break;
// 2697 
// 2698     default:
// 2699       stat = ZFailure;
// 2700       break;
// 2701   }
// 2702 
// 2703   return ( stat );
// 2704 }
// 2705 
// 2706 /*********************************************************************
// 2707  * @fn      zclGeneral_ProcessInAlarmsClient
// 2708  *
// 2709  * @brief   Process in the received Alarms Command.
// 2710  *
// 2711  * @param   pInMsg - pointer to the incoming message
// 2712  *
// 2713  * @return  ZStatus_t
// 2714  */
// 2715 static ZStatus_t zclGeneral_ProcessInAlarmsClient( zclIncoming_t *pInMsg,
// 2716                                                    zclGeneral_AppCallbacks_t *pCBs )
// 2717 {
// 2718   uint8 *pData = pInMsg->pData;
// 2719   zclAlarm_t alarm;
// 2720   ZStatus_t stat = ZSuccess;
// 2721 
// 2722   osal_memset( (uint8*)&alarm, 0, sizeof( zclAlarm_t ) );
// 2723 
// 2724   switch ( pInMsg->hdr.commandID )
// 2725   {
// 2726     case COMMAND_ALARMS_ALARM:
// 2727       if ( pCBs->pfnAlarm )
// 2728       {
// 2729         alarm.srcAddr = &(pInMsg->msg->srcAddr);
// 2730         alarm.cmdID = pInMsg->hdr.commandID;
// 2731         alarm.status = *pData++;
// 2732         alarm.alarmCode = *pData++;
// 2733         alarm.clusterID = BUILD_UINT16( pData[0], pData[1] );
// 2734         pData += 2;
// 2735         alarm.timeStamp = osal_build_uint32( pData, 4 );
// 2736 
// 2737         pCBs->pfnAlarm( &alarm );
// 2738       }
// 2739       break;
// 2740 
// 2741     case COMMAND_ALARMS_GET_RSP:
// 2742       if ( pCBs->pfnAlarm )
// 2743       {
// 2744         alarm.srcAddr = &(pInMsg->msg->srcAddr);
// 2745         alarm.cmdID = pInMsg->hdr.commandID;
// 2746         alarm.alarmCode = *pData++;
// 2747         alarm.clusterID = BUILD_UINT16( pData[0], pData[1] );
// 2748 
// 2749         pCBs->pfnAlarm( &alarm );
// 2750       }
// 2751       break;
// 2752 
// 2753     default:
// 2754       stat = ZFailure;
// 2755       break;
// 2756   }
// 2757 
// 2758   return ( stat );
// 2759 }
// 2760 #endif // ZCL_ALARMS
// 2761 
// 2762 #ifdef ZCL_LOCATION
// 2763 /*********************************************************************
// 2764  * @fn      zclGeneral_ProcessInLocationServer
// 2765  *
// 2766  * @brief   Process in the received Location Command.
// 2767  *
// 2768  * @param   pInMsg - pointer to the incoming message
// 2769  *
// 2770  * @return  ZStatus_t
// 2771  */
// 2772 static ZStatus_t zclGeneral_ProcessInLocationServer( zclIncoming_t *pInMsg,
// 2773                                                      zclGeneral_AppCallbacks_t *pCBs )
// 2774 {
// 2775   uint8 *pData = pInMsg->pData;
// 2776   zclLocation_t cmd;
// 2777   ZStatus_t stat = ZSuccess;
// 2778 
// 2779   osal_memset( (uint8*)&cmd, 0, sizeof( zclLocation_t ) );
// 2780 
// 2781   switch ( pInMsg->hdr.commandID )
// 2782   {
// 2783     case COMMAND_LOCATION_SET_ABSOLUTE:
// 2784       cmd.un.absLoc.coordinate1 = BUILD_UINT16( pData[0], pData[1] );
// 2785       pData += 2;
// 2786       cmd.un.absLoc.coordinate2 = BUILD_UINT16( pData[0], pData[1] );
// 2787       pData += 2;
// 2788       cmd.un.absLoc.coordinate3 = BUILD_UINT16( pData[0], pData[1] );
// 2789       pData += 2;
// 2790       cmd.un.absLoc.power = BUILD_UINT16( pData[0], pData[1] );
// 2791       pData += 2;
// 2792       cmd.un.absLoc.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
// 2793 
// 2794       if ( pCBs->pfnLocation )
// 2795       {
// 2796         cmd.srcAddr = &(pInMsg->msg->srcAddr);
// 2797         cmd.cmdID = pInMsg->hdr.commandID;
// 2798 
// 2799         // Update the absolute location info
// 2800         pCBs->pfnLocation( &cmd );
// 2801       }
// 2802       break;
// 2803 
// 2804     case COMMAND_LOCATION_SET_DEV_CFG:
// 2805       cmd.un.devCfg.power = BUILD_UINT16( pData[0], pData[1] );
// 2806       pData += 2;
// 2807       cmd.un.devCfg.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
// 2808       pData += 2;
// 2809       cmd.un.devCfg.calcPeriod = BUILD_UINT16( pData[0], pData[1] );
// 2810       pData += 2;
// 2811       cmd.un.devCfg.numMeasurements = *pData++;
// 2812       cmd.un.devCfg.reportPeriod = BUILD_UINT16( pData[0], pData[1] );
// 2813 
// 2814       if ( pCBs->pfnLocation )
// 2815       {
// 2816         cmd.srcAddr = &(pInMsg->msg->srcAddr);
// 2817         cmd.cmdID = pInMsg->hdr.commandID;
// 2818 
// 2819         // Update the device configuration info
// 2820         pCBs->pfnLocation( &cmd );
// 2821       }
// 2822       break;
// 2823 
// 2824     case COMMAND_LOCATION_GET_DEV_CFG:
// 2825       cmd.un.ieeeAddr = pData;
// 2826 
// 2827       if ( pCBs->pfnLocation )
// 2828       {
// 2829         cmd.srcAddr = &(pInMsg->msg->srcAddr);
// 2830         cmd.cmdID = pInMsg->hdr.commandID;
// 2831         cmd.seqNum = pInMsg->hdr.transSeqNum;
// 2832 
// 2833         // Retreive the Device Configuration
// 2834         pCBs->pfnLocation( &cmd );
// 2835       }
// 2836       stat = ZCL_STATUS_CMD_HAS_RSP;
// 2837       break;
// 2838 
// 2839     case COMMAND_LOCATION_GET_DATA:
// 2840       cmd.un.loc.bitmap.locByte = *pData++;
// 2841       cmd.un.loc.numResponses = *pData++;
// 2842 
// 2843       if ( cmd.un.loc.brdcastResponse == 0 ) // command is sent as a unicast
// 2844         osal_cpyExtAddr( cmd.un.loc.targetAddr, pData );
// 2845 
// 2846       if ( pCBs->pfnLocation )
// 2847       {
// 2848         cmd.srcAddr = &(pInMsg->msg->srcAddr);
// 2849         cmd.cmdID = pInMsg->hdr.commandID;
// 2850         cmd.seqNum = pInMsg->hdr.transSeqNum;
// 2851 
// 2852         // Retreive the Location Data
// 2853         pCBs->pfnLocation( &cmd );
// 2854       }
// 2855       stat = ZCL_STATUS_CMD_HAS_RSP;
// 2856       break;
// 2857 
// 2858     default:
// 2859       stat = ZFailure;
// 2860       break;
// 2861   }
// 2862 
// 2863   return ( stat );
// 2864 }
// 2865 
// 2866 /*********************************************************************
// 2867  * @fn      zclGeneral_ProcessInLocationDataRsp
// 2868  *
// 2869  * @brief   Process in the received Location Command.
// 2870  *
// 2871  * @param   pInMsg - pointer to the incoming message
// 2872  *
// 2873  * @return  ZStatus_t
// 2874  */
// 2875 static void zclGeneral_ProcessInLocationDataRsp( zclIncoming_t *pInMsg,
// 2876                                                  zclGeneral_AppCallbacks_t *pCBs )
// 2877 {
// 2878   uint8 *pData = pInMsg->pData;
// 2879   zclLocationRsp_t rsp;
// 2880 
// 2881   osal_memset( (uint8*)&rsp, 0, sizeof( zclLocationRsp_t ) );
// 2882 
// 2883   if ( pCBs->pfnLocationRsp )
// 2884   {
// 2885     if ( pInMsg->hdr.commandID == COMMAND_LOCATION_DATA_RSP )
// 2886       rsp.un.loc.status = *pData++;
// 2887 
// 2888     if ( pInMsg->hdr.commandID != COMMAND_LOCATION_DATA_RSP ||
// 2889          rsp.un.loc.status == ZCL_STATUS_SUCCESS )
// 2890     {
// 2891       rsp.un.loc.data.type = *pData++;
// 2892       rsp.un.loc.data.absLoc.coordinate1 = BUILD_UINT16( pData[0], pData[1] );
// 2893       pData += 2;
// 2894       rsp.un.loc.data.absLoc.coordinate2 = BUILD_UINT16( pData[0], pData[1] );
// 2895       pData += 2;
// 2896 
// 2897       if ( locationType2D( rsp.un.loc.data.type ) == 0 )
// 2898       {
// 2899         rsp.un.loc.data.absLoc.coordinate3 = BUILD_UINT16( pData[0], pData[1] );
// 2900         pData += 2;
// 2901       }
// 2902 
// 2903       if ( pInMsg->hdr.commandID != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
// 2904       {
// 2905         rsp.un.loc.data.absLoc.power = BUILD_UINT16( pData[0], pData[1] );
// 2906         pData += 2;
// 2907         rsp.un.loc.data.absLoc.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
// 2908         pData += 2;
// 2909       }
// 2910 
// 2911       if ( locationTypeAbsolute( rsp.un.loc.data.type ) == 0 )
// 2912       {
// 2913         if ( pInMsg->hdr.commandID != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
// 2914           rsp.un.loc.data.calcLoc.locationMethod = *pData++;
// 2915 
// 2916         rsp.un.loc.data.calcLoc.qualityMeasure = *pData++;
// 2917         rsp.un.loc.data.calcLoc.locationAge = BUILD_UINT16( pData[0], pData[1] );
// 2918       }
// 2919     }
// 2920 
// 2921     rsp.srcAddr = &(pInMsg->msg->srcAddr);
// 2922     rsp.cmdID = pInMsg->hdr.commandID;
// 2923 
// 2924     // Notify the Application
// 2925     pCBs->pfnLocationRsp( &rsp );
// 2926   }
// 2927 }
// 2928 
// 2929 /*********************************************************************
// 2930  * @fn      zclGeneral_ProcessInLocationClient
// 2931  *
// 2932  * @brief   Process in the received Location Command.
// 2933  *
// 2934  * @param   pInMsg - pointer to the incoming message
// 2935  *
// 2936  * @return  ZStatus_t
// 2937  */
// 2938 static ZStatus_t zclGeneral_ProcessInLocationClient( zclIncoming_t *pInMsg,
// 2939                                                      zclGeneral_AppCallbacks_t *pCBs )
// 2940 {
// 2941   uint8 *pData = pInMsg->pData;
// 2942   zclLocationRsp_t rsp;
// 2943   ZStatus_t stat = ZSuccess;
// 2944 
// 2945   osal_memset( (uint8*)&rsp, 0, sizeof( zclLocationRsp_t ) );
// 2946 
// 2947   switch ( pInMsg->hdr.commandID )
// 2948   {
// 2949     case COMMAND_LOCATION_DEV_CFG_RSP:
// 2950       if ( pCBs->pfnLocationRsp )
// 2951       {
// 2952         rsp.un.devCfg.status = *pData++;
// 2953         if ( rsp.un.devCfg.status == ZCL_STATUS_SUCCESS )
// 2954         {
// 2955           rsp.un.devCfg.data.power = BUILD_UINT16( pData[0], pData[1] );
// 2956           pData += 2;
// 2957           rsp.un.devCfg.data.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
// 2958           pData += 2;
// 2959           rsp.un.devCfg.data.calcPeriod = BUILD_UINT16( pData[0], pData[1] );
// 2960           pData += 2;
// 2961           rsp.un.devCfg.data.numMeasurements = *pData++;
// 2962           rsp.un.devCfg.data.reportPeriod = BUILD_UINT16( pData[0], pData[1] );
// 2963 
// 2964           rsp.srcAddr = &(pInMsg->msg->srcAddr);
// 2965           rsp.cmdID = pInMsg->hdr.commandID;
// 2966 
// 2967           // Notify the Application
// 2968           pCBs->pfnLocationRsp( &rsp );
// 2969         }
// 2970       }
// 2971       break;
// 2972 
// 2973     case COMMAND_LOCATION_DATA_RSP:
// 2974     case COMMAND_LOCATION_DATA_NOTIF:
// 2975     case COMMAND_LOCATION_COMPACT_DATA_NOTIF:
// 2976       zclGeneral_ProcessInLocationDataRsp( pInMsg, pCBs );
// 2977       break;
// 2978 
// 2979     case COMMAND_LOCATION_RSSI_PING:
// 2980       if ( pCBs->pfnLocationRsp )
// 2981       {
// 2982         rsp.un.locationType = *pData;
// 2983 
// 2984         rsp.srcAddr = &(pInMsg->msg->srcAddr);
// 2985         rsp.cmdID = pInMsg->hdr.commandID;
// 2986 
// 2987         // Notify the Application
// 2988         pCBs->pfnLocationRsp( &rsp );
// 2989       }
// 2990       break;
// 2991 
// 2992     default:
// 2993       stat = ZFailure;
// 2994       break;
// 2995   }
// 2996 
// 2997   return ( stat );
// 2998 }
// 2999 #endif // ZCL_LOCATION
// 3000 
// 3001 #ifdef ZCL_SCENES
// 3002 /*********************************************************************
// 3003  * @fn      zclGeneral_ScenesInitNV
// 3004  *
// 3005  * @brief   Initialize the NV Scene Table Items
// 3006  *
// 3007  * @param   none
// 3008  *
// 3009  * @return  number of scenes
// 3010  */
// 3011 static uint8 zclGeneral_ScenesInitNV( void )
// 3012 {
// 3013   uint8  status;
// 3014   uint16 size;
// 3015 
// 3016   size = (uint16)((sizeof ( nvGenScenesHdr_t ))
// 3017                   + ( sizeof( zclGenSceneNVItem_t ) * ZCL_GEN_MAX_SCENES ));
// 3018 
// 3019   status = osal_nv_item_init( ZCD_NV_SCENE_TABLE, size, NULL );
// 3020 
// 3021   if ( status != ZSUCCESS )
// 3022   {
// 3023     zclGeneral_ScenesSetDefaultNV();
// 3024   }
// 3025 
// 3026   return status;
// 3027 }
// 3028 
// 3029 /*********************************************************************
// 3030  * @fn          zclGeneral_ScenesSetDefaultNV
// 3031  *
// 3032  * @brief       Write the defaults to NV
// 3033  *
// 3034  * @param       none
// 3035  *
// 3036  * @return      none
// 3037  */
// 3038 static void zclGeneral_ScenesSetDefaultNV( void )
// 3039 {
// 3040   nvGenScenesHdr_t hdr;
// 3041 
// 3042   // Initialize the header
// 3043   hdr.numRecs = 0;
// 3044 
// 3045   // Save off the header
// 3046   osal_nv_write( ZCD_NV_SCENE_TABLE, 0, sizeof( nvGenScenesHdr_t ), &hdr );
// 3047 }
// 3048 
// 3049 /*********************************************************************
// 3050  * @fn          zclGeneral_ScenesWriteNV
// 3051  *
// 3052  * @brief       Save the Scene Table in NV
// 3053  *
// 3054  * @param       none
// 3055  *
// 3056  * @return      none
// 3057  */
// 3058 static void zclGeneral_ScenesWriteNV( void )
// 3059 {
// 3060   nvGenScenesHdr_t hdr;
// 3061   zclGenSceneItem_t *pLoop;
// 3062   zclGenSceneNVItem_t item;
// 3063 
// 3064   hdr.numRecs = 0;
// 3065 
// 3066   // Look for end of list
// 3067   pLoop = zclGenSceneTable;
// 3068   while ( pLoop )
// 3069   {
// 3070     // Build the record
// 3071     item.endpoint = pLoop->endpoint;
// 3072     osal_memcpy( &(item.scene), &(pLoop->scene), sizeof ( zclGeneral_Scene_t ) );
// 3073 
// 3074     // Save the record to NV
// 3075     osal_nv_write( ZCD_NV_SCENE_TABLE,
// 3076             (uint16)((sizeof( nvGenScenesHdr_t )) + (hdr.numRecs * sizeof ( zclGenSceneNVItem_t ))),
// 3077                     sizeof ( zclGenSceneNVItem_t ), &item );
// 3078 
// 3079     hdr.numRecs++;
// 3080 
// 3081     pLoop = pLoop->next;
// 3082   }
// 3083 
// 3084   // Save off the header
// 3085   osal_nv_write( ZCD_NV_SCENE_TABLE, 0, sizeof( nvGenScenesHdr_t ), &hdr );
// 3086 }
// 3087 
// 3088 /*********************************************************************
// 3089  * @fn          zclGeneral_ScenesRestoreFromNV
// 3090  *
// 3091  * @brief       Restore the Scene table from NV
// 3092  *
// 3093  * @param       none
// 3094  *
// 3095  * @return      Number of entries restored
// 3096  */
// 3097 static uint16 zclGeneral_ScenesRestoreFromNV( void )
// 3098 {
// 3099   uint16 x;
// 3100   nvGenScenesHdr_t hdr;
// 3101 
// 3102   zclGenSceneNVItem_t item;
// 3103   uint16 numAdded = 0;
// 3104 
// 3105   if ( osal_nv_read( ZCD_NV_SCENE_TABLE, 0, sizeof(nvGenScenesHdr_t), &hdr ) == ZSuccess )
// 3106   {
// 3107     // Read in the device list
// 3108     for ( x = 0; x < hdr.numRecs; x++ )
// 3109     {
// 3110       if ( osal_nv_read( ZCD_NV_SCENE_TABLE,
// 3111                 (uint16)(sizeof(nvGenScenesHdr_t) + (x * sizeof ( zclGenSceneNVItem_t ))),
// 3112                                   sizeof ( zclGenSceneNVItem_t ), &item ) == ZSUCCESS )
// 3113       {
// 3114         // Add the scene
// 3115         if ( zclGeneral_AddScene( item.endpoint, &(item.scene) ) == ZSuccess )
// 3116         {
// 3117           numAdded++;
// 3118         }
// 3119       }
// 3120     }
// 3121   }
// 3122 
// 3123   return ( numAdded );
// 3124 }
// 3125 #endif // ZCL_SCENES
// 3126 
// 3127 /***************************************************************************
// 3128 ****************************************************************************/
// 
// 1 013 bytes in segment BANKED_CODE
//    36 bytes in segment BANK_RELAYS
//     3 bytes in segment XDATA_Z
// 
// 1 049 bytes of CODE  memory
//     3 bytes of XDATA memory
//
//Errors: none
//Warnings: none
