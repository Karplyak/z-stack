###############################################################################
#                                                                             #
# IAR C/C++ Compiler V7.51A/W32 for 8051                30/Nov/2010  10:23:17 #
# Copyright 2004-2009 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  D:\R.D Dept\程式開發\TI CC2530 example\ZIGBEE      #
#                          Z-Stack\CC2530_ZStack-2.3.0-1.4.0\Sensor Network   #
#                          Example\Components\mt\MT_UART.c                    #
#    Command line       =  -f "D:\R.D Dept\程式開發\TI CC2530 example\ZIGBEE  #
#                          Z-Stack\CC2530_ZStack-2.3.0-1.4.0\Sensor Network   #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\Tools\CC2530DB\f8wEndev.c #
#                          fg" (-DCPU32MHZ -DROOT=__near_func -DBLINK_LEDS)   #
#                          -f "D:\R.D Dept\程式開發\TI CC2530 example\ZIGBEE  #
#                          Z-Stack\CC2530_ZStack-2.3.0-1.4.0\Sensor Network   #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig. #
#                          cfg" (-DSECURE=0 -DZG_SECURE_DYNAMIC=0             #
#                          -DREFLECTOR -DDEFAULT_CHANLIST=0x00000800          #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116 "-DCONST=const __code"    #
#                          -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=TRUE      #
#                          -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100            #
#                          -DRESPONSE_POLL_RATE=100 -DREJOIN_POLL_RATE=440)   #
#                          -f "D:\R.D Dept\程式開發\TI CC2530 example\ZIGBEE  #
#                          Z-Stack\CC2530_ZStack-2.3.0-1.4.0\Sensor Network   #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\Tools\CC2530DB\f8wZCL.cfg #
#                          " (-DZCL_READ -DZCL_WRITE -DZCL_BASIC              #
#                          -DZCL_IDENTIFY -DZCL_ON_OFF -DZCL_KEY_ESTABLISH    #
#                          -DZCL_LOAD_CONTROL -DZCL_SIMPLE_METERING           #
#                          -DZCL_PRICING) -DZCL_MESSAGE "D:\R.D               #
#                          Dept\程式開發\TI CC2530 example\ZIGBEE             #
#                          Z-Stack\CC2530_ZStack-2.3.0-1.4.0\Sensor Network   #
#                          Example\Components\mt\MT_UART.c" -D NWK_AUTO_POLL  #
#                          -D ZTOOL_P1 -D MT_TASK -D MT_APP_FUNC -D           #
#                          MT_SYS_FUNC -D MT_ZDO_FUNC -D LCD_SUPPORTED=DEBUG  #
#                          -D xPOWER_SAVING -D End_Device -D M220 -D xPA2591  #
#                          -lC "D:\R.D Dept\程式開發\TI CC2530                #
#                          example\ZIGBEE Z-Stack\CC2530_ZStack-2.3.0-1.4.0\S #
#                          ensor Network Example\Projects\zstack\Sensor       #
#                          Network Application\ZIGBEE Endpoint &              #
#                          Device\CC2530DB\EndDeviceKB_M220\List\" -lA        #
#                          "D:\R.D Dept\程式開發\TI CC2530 example\ZIGBEE     #
#                          Z-Stack\CC2530_ZStack-2.3.0-1.4.0\Sensor Network   #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\EndDeviceKB_M220\List\"            #
#                          --diag_suppress Pe001,Pa010 -o "D:\R.D             #
#                          Dept\程式開發\TI CC2530 example\ZIGBEE             #
#                          Z-Stack\CC2530_ZStack-2.3.0-1.4.0\Sensor Network   #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\EndDeviceKB_M220\Obj\" -e          #
#                          --require_prototypes --debug --core=plain          #
#                          --dptr=16,1 --data_model=large                     #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data_rom                  #
#                          --nr_virtual_regs 16 -I "D:\R.D Dept\程式開發\TI   #
#                          CC2530 example\ZIGBEE Z-Stack\CC2530_ZStack-2.3.0- #
#                          1.4.0\Sensor Network Example\Projects\zstack\Senso #
#                          r Network Application\ZIGBEE Endpoint &            #
#                          Device\CC2530DB\" -I "D:\R.D Dept\程式開發\TI      #
#                          CC2530 example\ZIGBEE Z-Stack\CC2530_ZStack-2.3.0- #
#                          1.4.0\Sensor Network Example\Projects\zstack\Senso #
#                          r Network Application\ZIGBEE Endpoint &            #
#                          Device\CC2530DB\..\SOURCE\" -I "D:\R.D             #
#                          Dept\程式開發\TI CC2530 example\ZIGBEE             #
#                          Z-Stack\CC2530_ZStack-2.3.0-1.4.0\Sensor Network   #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\SOURCE\" -I "D:\R.D          #
#                          Dept\程式開發\TI CC2530 example\ZIGBEE             #
#                          Z-Stack\CC2530_ZStack-2.3.0-1.4.0\Sensor Network   #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\ZMAIN\TI2530DB\" -I       #
#                          "D:\R.D Dept\程式開發\TI CC2530 example\ZIGBEE     #
#                          Z-Stack\CC2530_ZStack-2.3.0-1.4.0\Sensor Network   #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\MT\" -I  #
#                          "D:\R.D Dept\程式開發\TI CC2530 example\ZIGBEE     #
#                          Z-Stack\CC2530_ZStack-2.3.0-1.4.0\Sensor Network   #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\INCL #
#                          UDE\" -I "D:\R.D Dept\程式開發\TI CC2530           #
#                          example\ZIGBEE Z-Stack\CC2530_ZStack-2.3.0-1.4.0\S #
#                          ensor Network Example\Projects\zstack\Sensor       #
#                          Network Application\ZIGBEE Endpoint &              #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\MODU #
#                          LE\" -I "D:\R.D Dept\程式開發\TI CC2530            #
#                          example\ZIGBEE Z-Stack\CC2530_ZStack-2.3.0-1.4.0\S #
#                          ensor Network Example\Projects\zstack\Sensor       #
#                          Network Application\ZIGBEE Endpoint &              #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\TARG #
#                          ET\CC2530KB\" -I "D:\R.D Dept\程式開發\TI CC2530   #
#                          example\ZIGBEE Z-Stack\CC2530_ZStack-2.3.0-1.4.0\S #
#                          ensor Network Example\Projects\zstack\Sensor       #
#                          Network Application\ZIGBEE Endpoint &              #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\OSAL\MCU #
#                          \CCSOC\" -I "D:\R.D Dept\程式開發\TI CC2530        #
#                          example\ZIGBEE Z-Stack\CC2530_ZStack-2.3.0-1.4.0\S #
#                          ensor Network Example\Projects\zstack\Sensor       #
#                          Network Application\ZIGBEE Endpoint &              #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\OSAL\INC #
#                          LUDE\" -I "D:\R.D Dept\程式開發\TI CC2530          #
#                          example\ZIGBEE Z-Stack\CC2530_ZStack-2.3.0-1.4.0\S #
#                          ensor Network Example\Projects\zstack\Sensor       #
#                          Network Application\ZIGBEE Endpoint &              #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\AF #
#                          \" -I "D:\R.D Dept\程式開發\TI CC2530              #
#                          example\ZIGBEE Z-Stack\CC2530_ZStack-2.3.0-1.4.0\S #
#                          ensor Network Example\Projects\zstack\Sensor       #
#                          Network Application\ZIGBEE Endpoint &              #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\NW #
#                          K\" -I "D:\R.D Dept\程式開發\TI CC2530             #
#                          example\ZIGBEE Z-Stack\CC2530_ZStack-2.3.0-1.4.0\S #
#                          ensor Network Example\Projects\zstack\Sensor       #
#                          Network Application\ZIGBEE Endpoint &              #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SE #
#                          C\" -I "D:\R.D Dept\程式開發\TI CC2530             #
#                          example\ZIGBEE Z-Stack\CC2530_ZStack-2.3.0-1.4.0\S #
#                          ensor Network Example\Projects\zstack\Sensor       #
#                          Network Application\ZIGBEE Endpoint &              #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SA #
#                          PI\" -I "D:\R.D Dept\程式開發\TI CC2530            #
#                          example\ZIGBEE Z-Stack\CC2530_ZStack-2.3.0-1.4.0\S #
#                          ensor Network Example\Projects\zstack\Sensor       #
#                          Network Application\ZIGBEE Endpoint &              #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SY #
#                          S\" -I "D:\R.D Dept\程式開發\TI CC2530             #
#                          example\ZIGBEE Z-Stack\CC2530_ZStack-2.3.0-1.4.0\S #
#                          ensor Network Example\Projects\zstack\Sensor       #
#                          Network Application\ZIGBEE Endpoint &              #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\ZC #
#                          L\" -I "D:\R.D Dept\程式開發\TI CC2530             #
#                          example\ZIGBEE Z-Stack\CC2530_ZStack-2.3.0-1.4.0\S #
#                          ensor Network Example\Projects\zstack\Sensor       #
#                          Network Application\ZIGBEE Endpoint &              #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\ZD #
#                          O\" -I "D:\R.D Dept\程式開發\TI CC2530             #
#                          example\ZIGBEE Z-Stack\CC2530_ZStack-2.3.0-1.4.0\S #
#                          ensor Network Example\Projects\zstack\Sensor       #
#                          Network Application\ZIGBEE Endpoint &              #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\ZMAC\F8W #
#                          \" -I "D:\R.D Dept\程式開發\TI CC2530              #
#                          example\ZIGBEE Z-Stack\CC2530_ZStack-2.3.0-1.4.0\S #
#                          ensor Network Example\Projects\zstack\Sensor       #
#                          Network Application\ZIGBEE Endpoint &              #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\ZMAC\"   #
#                          -I "D:\R.D Dept\程式開發\TI CC2530 example\ZIGBEE  #
#                          Z-Stack\CC2530_ZStack-2.3.0-1.4.0\Sensor Network   #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\SERVICES #
#                          \SADDR\" -I "D:\R.D Dept\程式開發\TI CC2530        #
#                          example\ZIGBEE Z-Stack\CC2530_ZStack-2.3.0-1.4.0\S #
#                          ensor Network Example\Projects\zstack\Sensor       #
#                          Network Application\ZIGBEE Endpoint &              #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\SERVICES #
#                          \SDATA\" -I "D:\R.D Dept\程式開發\TI CC2530        #
#                          example\ZIGBEE Z-Stack\CC2530_ZStack-2.3.0-1.4.0\S #
#                          ensor Network Example\Projects\zstack\Sensor       #
#                          Network Application\ZIGBEE Endpoint &              #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\INCL #
#                          UDE\" -I "D:\R.D Dept\程式開發\TI CC2530           #
#                          example\ZIGBEE Z-Stack\CC2530_ZStack-2.3.0-1.4.0\S #
#                          ensor Network Example\Projects\zstack\Sensor       #
#                          Network Application\ZIGBEE Endpoint &              #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\HIGH #
#                          _LEVEL\" -I "D:\R.D Dept\程式開發\TI CC2530        #
#                          example\ZIGBEE Z-Stack\CC2530_ZStack-2.3.0-1.4.0\S #
#                          ensor Network Example\Projects\zstack\Sensor       #
#                          Network Application\ZIGBEE Endpoint &              #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\LOW_ #
#                          LEVEL\srf04\" -I "D:\R.D Dept\程式開發\TI CC2530   #
#                          example\ZIGBEE Z-Stack\CC2530_ZStack-2.3.0-1.4.0\S #
#                          ensor Network Example\Projects\zstack\Sensor       #
#                          Network Application\ZIGBEE Endpoint &              #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\LOW_ #
#                          LEVEL\srf04\SINGLE_CHIP\" -I "C:\IAR               #
#                          Systems\Embedded Workbench for MCS-51              #
#                          V7.51\8051\INC\" -I "C:\IAR Systems\Embedded       #
#                          Workbench for MCS-51 V7.51\8051\INC\CLIB\" -Ohz    #
#    List file          =  D:\R.D Dept\程式開發\TI CC2530 example\ZIGBEE      #
#                          Z-Stack\CC2530_ZStack-2.3.0-1.4.0\Sensor Network   #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\EndDeviceKB_M220\List\MT_UART.lst  #
#    Object file        =  D:\R.D Dept\程式開發\TI CC2530 example\ZIGBEE      #
#                          Z-Stack\CC2530_ZStack-2.3.0-1.4.0\Sensor Network   #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\EndDeviceKB_M220\Obj\MT_UART.r51   #
#                                                                             #
#                                                                             #
###############################################################################

D:\R.D Dept\程式開發\TI CC2530 example\ZIGBEE Z-Stack\CC2530_ZStack-2.3.0-1.4.0\Sensor Network Example\Components\mt\MT_UART.c
      1          /***************************************************************************************************
      2            Filename:       MT_UART.c
      3            Revised:        $Date: 2009-03-12 16:25:22 -0700 (Thu, 12 Mar 2009) $
      4            Revision:       $Revision: 19404 $
      5          
      6            Description:  This module handles anything dealing with the serial port.
      7          
      8            Copyright 2007 Texas Instruments Incorporated. All rights reserved.
      9          
     10            Should you have any questions regarding your right to use this Software,
     11            contact Texas Instruments Incorporated at www.TI.com.
     12          
     13          ***************************************************************************************************/
     14          
     15          /***************************************************************************************************
     16           * INCLUDES
     17           ***************************************************************************************************/
     18          #include "ZComDef.h"
     19          
     20          /* HAL */
     21          #include "hal_uart.h"
     22          
     23          /* MT */
     24          #include "MT.h"
     25          #include "MT_UART.h"
     26          
     27          /* OSAL */
     28          #include "OSAL.h"
     29          #include "OSAL_Memory.h"
     30          
     31          /* APP */
     32          #if defined (Coor_receiver) || defined (Router_receiver)
     33            #include "zcl_zigbee receiver.h"
     34          #endif
     35          #ifdef End_Device
     36            #include "zcl_zigbee device.h"
     37          #endif
     38          
     39          /***************************************************************************************************
     40           * MACROS
     41           ***************************************************************************************************/
     42          /***************************************************************************************************
     43           * CONSTANTS
     44           ***************************************************************************************************/
     45          /* State values for ZTool protocal */
     46          #define SOP_STATE      0x00
     47          #define CMD_STATE1     0x01
     48          #define CMD_STATE2     0x02
     49          #define LEN_STATE      0x03
     50          #define DATA_STATE     0x04
     51          #define FCS_STATE      0x05
     52          
     53          /***************************************************************************************************
     54           *                                         GLOBAL VARIABLES
     55           ***************************************************************************************************/

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     56          byte App_TaskID; // Used to indentify the application ID for osal task
   \                     App_TaskID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
     57          
     58          /* ZTool protocal parameters */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     59          uint8 state;
   \                     state:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     60          uint8  CMD_Token[2];
   \                     CMD_Token:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     61          uint8  LEN_Token;
   \                     LEN_Token:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     62          uint8  FSC_Token;
   \                     FSC_Token:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     63          mtOSALSerialData_t  *pMsg;
   \                     pMsg:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     64          uint8  tempDataLen;
   \                     tempDataLen:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
     65          
     66          #if defined (ZAPP_P1) || defined (ZAPP_P2)
     67          uint16  MT_UartMaxZAppBufLen;
     68          bool    MT_UartZAppRxStatus;
     69          #endif
     70          
     71          /***************************************************************************************************
     72           *                                          LOCAL FUNCTIONS
     73           ***************************************************************************************************/
     74          
     75          /***************************************************************************************************
     76           * @fn      MT_UartInit
     77           * @brief   Initialize MT with UART support
     78          ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     79          void MT_UartInit ( void )
   \                     MT_UartInit:
     80          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 29
   \   000004   74E3         MOV     A,#-0x1d
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
     81            halUARTCfg_t uartConfig;
     82          
     83            App_TaskID = 0; // Initialize APP ID
   \   000009   E4           CLR     A
   \   00000A   90....       MOV     DPTR,#App_TaskID
   \   00000D   F0           MOVX    @DPTR,A
     84          
     85            /* UART Configuration */
     86            uartConfig.configured           = TRUE;
   \   00000E   7401         MOV     A,#0x1
   \   000010   85..82       MOV     DPL,?XSP + 0
   \   000013   85..83       MOV     DPH,?XSP + 1
   \   000016   F0           MOVX    @DPTR,A
     87            uartConfig.baudRate             = MT_UART_DEFAULT_BAUDRATE;
   \   000017   12....       LCALL   ?XSTACK_DISP0_8
   \   00001A   7404         MOV     A,#0x4
   \   00001C   F0           MOVX    @DPTR,A
     88            uartConfig.flowControl          = FALSE; // FlowControl define RTS, CTS ; TRUE -> Enable, FALSE -> Disable
   \   00001D   7402         MOV     A,#0x2
   \   00001F   12....       LCALL   ?XSTACK_DISP0_8
   \   000022   E4           CLR     A
   \   000023   F0           MOVX    @DPTR,A
     89            uartConfig.flowControlThreshold = MT_UART_DEFAULT_THRESHOLD;
   \   000024   7403         MOV     A,#0x3
   \   000026   12....       LCALL   ?XSTACK_DISP0_8
   \   000029   7440         MOV     A,#0x40
   \   00002B   F0           MOVX    @DPTR,A
   \   00002C   A3           INC     DPTR
   \   00002D   E4           CLR     A
   \   00002E   F0           MOVX    @DPTR,A
     90            uartConfig.rx.maxBufSize        = MT_UART_DEFAULT_MAX_RX_BUFF;
   \   00002F   740A         MOV     A,#0xa
   \   000031   12....       LCALL   ?XSTACK_DISP0_8
   \   000034   7480         MOV     A,#-0x80
   \   000036   F0           MOVX    @DPTR,A
   \   000037   A3           INC     DPTR
   \   000038   E4           CLR     A
   \   000039   F0           MOVX    @DPTR,A
     91            uartConfig.tx.maxBufSize        = MT_UART_DEFAULT_MAX_TX_BUFF;
   \   00003A   7412         MOV     A,#0x12
   \   00003C   12....       LCALL   ?XSTACK_DISP0_8
   \   00003F   7480         MOV     A,#-0x80
   \   000041   F0           MOVX    @DPTR,A
   \   000042   A3           INC     DPTR
   \   000043   E4           CLR     A
   \   000044   F0           MOVX    @DPTR,A
     92            uartConfig.idleTimeout          = MT_UART_DEFAULT_IDLE_TIMEOUT;
   \   000045   7405         MOV     A,#0x5
   \   000047   12....       LCALL   ?XSTACK_DISP0_8
   \   00004A   7406         MOV     A,#0x6
   \   00004C   F0           MOVX    @DPTR,A
     93            uartConfig.intEnable            = TRUE;
   \   00004D   7416         MOV     A,#0x16
   \   00004F   12....       LCALL   ?XSTACK_DISP0_8
   \   000052   7401         MOV     A,#0x1
   \   000054   F0           MOVX    @DPTR,A
     94          #if defined (ZTOOL_P1) || defined (ZTOOL_P2)
     95            uartConfig.callBackFunc         = MT_UartProcessZToolData;
   \   000055   741B         MOV     A,#0x1b
   \   000057   12....       LCALL   ?XSTACK_DISP0_8
   \   00005A   74..         MOV     A,#(??MT_UartProcessZToolData?relay & 0xff)
   \   00005C   F0           MOVX    @DPTR,A
   \   00005D   A3           INC     DPTR
   \   00005E   74..         MOV     A,#((??MT_UartProcessZToolData?relay >> 8) & 0xff)
   \   000060   F0           MOVX    @DPTR,A
     96            #if defined (Coor_receiver) || defined (Router_receiver)
     97              uartConfig.callBackFunc         = zclUARTMsg_CallBack; // The Coordinator receive UART command callback
     98            #endif
     99            #if defined (End_Device)
    100              uartConfig.callBackFunc         = zclRS485_CallBack; // The Coordinator receive UART/RS485 command callback
   \   000061   741B         MOV     A,#0x1b
   \   000063   12....       LCALL   ?XSTACK_DISP0_8
   \   000066   74..         MOV     A,#(??zclRS485_CallBack?relay & 0xff)
   \   000068   F0           MOVX    @DPTR,A
   \   000069   A3           INC     DPTR
   \   00006A   74..         MOV     A,#((??zclRS485_CallBack?relay >> 8) & 0xff)
   \   00006C   F0           MOVX    @DPTR,A
    101            #endif
    102          #elif defined (ZAPP_P1) || defined (ZAPP_P2)
    103            uartConfig.callBackFunc         = MT_UartProcessZAppData;
    104          #else
    105            uartConfig.callBackFunc         = NULL;
    106          #endif
    107          
    108            /* Start UART */
    109          #if defined (MT_UART_DEFAULT_PORT)
    110            HalUARTOpen (MT_UART_DEFAULT_PORT, &uartConfig);
   \   00006D                ; Setup parameters for call to function HalUARTOpen
   \   00006D   85..82       MOV     DPL,?XSP + 0
   \   000070   85..83       MOV     DPH,?XSP + 1
   \   000073   AA82         MOV     R2,DPL
   \   000075   AB83         MOV     R3,DPH
   \   000077   7900         MOV     R1,#0x0
   \   000079   12....       LCALL   ??HalUARTOpen?relay
    111          #else
    112            /* Silence IAR compiler warning */
    113            (void)uartConfig;
    114          #endif
    115          
    116            /* Initialize for ZApp */
    117          #if defined (ZAPP_P1) || defined (ZAPP_P2)
    118            /* Default max bytes that ZAPP can take */
    119            MT_UartMaxZAppBufLen  = 1;
    120            MT_UartZAppRxStatus   = MT_UART_ZAPP_RX_READY;
    121          #endif
    122          }
   \   00007C   741D         MOV     A,#0x1d
   \   00007E   12....       LCALL   ?DEALLOC_XSTACK8
   \   000081                REQUIRE ?Subroutine6
   \   000081                ; // Fall through to label ?Subroutine6

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET
    123          
    124          /***************************************************************************************************
    125           * @fn      MT_SerialRegisterTaskID
    126           * @brief   This function registers the taskID of the application so it knows
    127           *          where to send the messages whent they come in.
    128           * @param   void
    129           * @return  void
    130           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    131          void MT_UartRegisterTaskID( byte taskID )
   \                     MT_UartRegisterTaskID:
    132          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    133            App_TaskID = taskID;
   \   000004   E9           MOV     A,R1
   \   000005   90....       MOV     DPTR,#App_TaskID
   \   000008   F0           MOVX    @DPTR,A
    134          }
   \   000009   80..         SJMP    ?Subroutine6
    135          
    136          /***************************************************************************************************
    137           * @fn      SPIMgr_CalcFCS
    138           * @brief   Calculate the FCS of a message buffer by XOR'ing each byte.
    139           *          Remember to NOT include SOP and FCS fields, so start at the CMD field.
    140           * @param   byte *msg_ptr - message pointer
    141           *          byte len - length (in bytes) of message
    142           * @return  result byte
    143           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    144          byte MT_UartCalcFCS( uint8 *msg_ptr, uint8 len )
   \                     MT_UartCalcFCS:
    145          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FC           MOV     R4,A
    146            byte x;
    147            byte xorResult;
    148          
    149            xorResult = 0;
   \   000007   7900         MOV     R1,#0x0
    150          
    151            for ( x = 0; x < len; x++, msg_ptr++ )
   \   000009   7D00         MOV     R5,#0x0
   \   00000B   800E         SJMP    ??MT_UartCalcFCS_0
    152              xorResult = xorResult ^ *msg_ptr;
   \                     ??MT_UartCalcFCS_1:
   \   00000D   8A82         MOV     DPL,R2
   \   00000F   8B83         MOV     DPH,R3
   \   000011   E0           MOVX    A,@DPTR
   \   000012   C9           XCH     A,R1
   \   000013   69           XRL     A,R1
   \   000014   F9           MOV     R1,A
   \   000015   0D           INC     R5
   \   000016   A3           INC     DPTR
   \   000017   AA82         MOV     R2,DPL
   \   000019   AB83         MOV     R3,DPH
   \                     ??MT_UartCalcFCS_0:
   \   00001B   ED           MOV     A,R5
   \   00001C   C3           CLR     C
   \   00001D   9C           SUBB    A,R4
   \   00001E   40ED         JC      ??MT_UartCalcFCS_1
    153          
    154            return ( xorResult );
   \   000020   7F01         MOV     R7,#0x1
   \   000022   02....       LJMP    ?BANKED_LEAVE_XDATA
    155          }
    156          
    157          /***************************************************************************************************
    158           * @fn      MT_UartProcessZToolData
    159           * @brief   | SOP | Data Length  |   CMD   |   Data   |  FCS  |
    160           *          |  1  |     1        |    2    |  0-Len   |   1   |
    161           *          Parses the data and determine either is SPI or just simply serial data
    162           *          then send the data to correct place (MT or APP)
    163           * @param   port     - UART port
    164           *          event    - Event that causes the callback
    165           * @return  None
    166           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    167          void MT_UartProcessZToolData ( uint8 port, uint8 event )
   \                     MT_UartProcessZToolData:
    168          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
    169            uint8  ch;
    170            uint8  bytesInRxBuffer;
    171             
    172            (void)event;  // Intentionally unreferenced parameter
   \   00000C   8033         SJMP    ??MT_UartProcessZToolData_0
    173          
    174            while (Hal_UART_RxBufLen(port))
    175            {
    176              HalUARTRead (port, &ch, 1);
    177              
    178              switch (state)
    179              {
    180                case SOP_STATE:
    181                  if (ch == MT_UART_SOF)
    182                    state = LEN_STATE;
    183                  break;
    184          
    185                case LEN_STATE:
    186                  LEN_Token = ch;
    187                  tempDataLen = 0;
    188          
    189                  /* Allocate memory for the data */
    190                  pMsg = (mtOSALSerialData_t *)osal_msg_allocate( sizeof ( mtOSALSerialData_t ) + MT_RPC_FRAME_HDR_SZ + LEN_Token );
    191          
    192                  if (pMsg)
    193                  {
    194                    /* Fill up what we can */
    195                    pMsg->hdr.event = CMD_SERIAL_MSG;
   \                     ??MT_UartProcessZToolData_1:
   \   00000E   90....       MOV     DPTR,#pMsg
   \   000011   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   000014   7401         MOV     A,#0x1
   \   000016   F0           MOVX    @DPTR,A
    196                    pMsg->msg = (uint8*)(pMsg+1);
   \   000017   90....       MOV     DPTR,#pMsg
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   2404         ADD     A,#0x4
   \   00001D   F8           MOV     R0,A
   \   00001E   A3           INC     DPTR
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   3400         ADDC    A,#0x0
   \   000022   F9           MOV     R1,A
   \   000023   12....       LCALL   ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_7:
   \   000026   E8           MOV     A,R0
   \   000027   F0           MOVX    @DPTR,A
   \   000028   A3           INC     DPTR
   \   000029   E9           MOV     A,R1
   \   00002A   12....       LCALL   ?Subroutine4 & 0xFFFF
    197                    pMsg->msg[MT_RPC_POS_LEN] = LEN_Token;
   \                     ??CrossCallReturnLabel_9:
   \   00002D   C0E0         PUSH    A
   \   00002F   90....       MOV     DPTR,#pMsg
   \   000032   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_2:
   \   000035   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   000038   D0E0         POP     A
   \   00003A   F0           MOVX    @DPTR,A
    198                    state = CMD_STATE1;
   \   00003B   7401         MOV     A,#0x1
   \                     ??MT_UartProcessZToolData_2:
   \   00003D   90....       MOV     DPTR,#state
   \   000040   F0           MOVX    @DPTR,A
    199                  }
   \                     ??MT_UartProcessZToolData_0:
   \   000041                ; Setup parameters for call to function Hal_UART_RxBufLen
   \   000041   EE           MOV     A,R6
   \   000042   F9           MOV     R1,A
   \   000043   12....       LCALL   ??Hal_UART_RxBufLen?relay
   \   000046   EA           MOV     A,R2
   \   000047   7001         JNZ     ??MT_UartProcessZToolData_3
   \   000049   EB           MOV     A,R3
   \                     ??MT_UartProcessZToolData_3:
   \   00004A   7003         JNZ     $+5
   \   00004C   02....       LJMP    ??MT_UartProcessZToolData_4 & 0xFFFF
   \   00004F                ; Setup parameters for call to function HalUARTRead
   \   00004F   7C01         MOV     R4,#0x1
   \   000051   7D00         MOV     R5,#0x0
   \   000053   85..82       MOV     DPL,?XSP + 0
   \   000056   85..83       MOV     DPH,?XSP + 1
   \   000059   AA82         MOV     R2,DPL
   \   00005B   AB83         MOV     R3,DPH
   \   00005D   EE           MOV     A,R6
   \   00005E   F9           MOV     R1,A
   \   00005F   12....       LCALL   ??HalUARTRead?relay
   \   000062   90....       MOV     DPTR,#pMsg
   \   000065   E0           MOVX    A,@DPTR
   \   000066   2402         ADD     A,#0x2
   \   000068   F8           MOV     R0,A
   \   000069   A3           INC     DPTR
   \   00006A   E0           MOVX    A,@DPTR
   \   00006B   3400         ADDC    A,#0x0
   \   00006D   F9           MOV     R1,A
   \   00006E   E8           MOV     A,R0
   \   00006F   FA           MOV     R2,A
   \   000070   E9           MOV     A,R1
   \   000071   FB           MOV     R3,A
   \   000072   90....       MOV     DPTR,#state
   \   000075   E0           MOVX    A,@DPTR
   \   000076   12....       LCALL   ?UC_SWITCH_DENSE
   \                     `?<Jumptable for MT_UartProcessZToolData>_0`:
   \   000079   00           DB        0
   \   00007A   05           DB        5
   \   00007B   ....         DW        ??MT_UartProcessZToolData_0
   \   00007D   ....         DW        ??MT_UartProcessZToolData_5
   \   00007F   ....         DW        ??MT_UartProcessZToolData_6
   \   000081   ....         DW        ??MT_UartProcessZToolData_7
   \   000083   ....         DW        ??MT_UartProcessZToolData_8
   \   000085   ....         DW        ??MT_UartProcessZToolData_9
   \   000087   ....         DW        ??MT_UartProcessZToolData_10
   \                     ??MT_UartProcessZToolData_5:
   \   000089   85..82       MOV     DPL,?XSP + 0
   \   00008C   85..83       MOV     DPH,?XSP + 1
   \   00008F   E0           MOVX    A,@DPTR
   \   000090   64FE         XRL     A,#0xfe
   \   000092   70AD         JNZ     ??MT_UartProcessZToolData_0
   \   000094   7403         MOV     A,#0x3
   \   000096   80A5         SJMP    ??MT_UartProcessZToolData_2
   \                     ??MT_UartProcessZToolData_8:
   \   000098   85..82       MOV     DPL,?XSP + 0
   \   00009B   85..83       MOV     DPH,?XSP + 1
   \   00009E   E0           MOVX    A,@DPTR
   \   00009F   90....       MOV     DPTR,#LEN_Token
   \   0000A2   F0           MOVX    @DPTR,A
   \   0000A3   E4           CLR     A
   \   0000A4   90....       MOV     DPTR,#tempDataLen
   \   0000A7   12....       LCALL   ?Subroutine4 & 0xFFFF
   \                     ??CrossCallReturnLabel_10:
   \   0000AA   F8           MOV     R0,A
   \   0000AB   7407         MOV     A,#0x7
   \   0000AD   28           ADD     A,R0
   \   0000AE   FA           MOV     R2,A
   \   0000AF   E4           CLR     A
   \   0000B0   3400         ADDC    A,#0x0
   \   0000B2   FB           MOV     R3,A
   \   0000B3   12....       LCALL   ??osal_msg_allocate?relay
   \   0000B6   90....       MOV     DPTR,#pMsg
   \   0000B9   EA           MOV     A,R2
   \   0000BA   F0           MOVX    @DPTR,A
   \   0000BB   A3           INC     DPTR
   \   0000BC   EB           MOV     A,R3
   \   0000BD   F0           MOVX    @DPTR,A
   \   0000BE   90....       MOV     DPTR,#pMsg
   \   0000C1   E0           MOVX    A,@DPTR
   \   0000C2   7002         JNZ     ??MT_UartProcessZToolData_11
   \   0000C4   A3           INC     DPTR
   \   0000C5   E0           MOVX    A,@DPTR
   \                     ??MT_UartProcessZToolData_11:
   \   0000C6   6003         JZ      $+5
   \   0000C8   02....       LJMP    ??MT_UartProcessZToolData_1 & 0xFFFF
    200                  else
    201                  {
    202                    state = SOP_STATE;
   \   0000CB   E4           CLR     A
   \   0000CC   90....       MOV     DPTR,#state
   \   0000CF   F0           MOVX    @DPTR,A
    203                    return;
   \                     ??MT_UartProcessZToolData_4:
   \   0000D0   7401         MOV     A,#0x1
   \   0000D2   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000D5   7F02         MOV     R7,#0x2
   \   0000D7   02....       LJMP    ?BANKED_LEAVE_XDATA
    204                  }
    205                  break;
    206          
    207                case CMD_STATE1:
    208                  pMsg->msg[MT_RPC_POS_CMD0] = ch;
   \                     ??MT_UartProcessZToolData_6:
   \   0000DA   85..82       MOV     DPL,?XSP + 0
   \   0000DD   85..83       MOV     DPH,?XSP + 1
   \   0000E0   E0           MOVX    A,@DPTR
   \   0000E1   C0E0         PUSH    A
   \   0000E3   8A82         MOV     DPL,R2
   \   0000E5   8B83         MOV     DPH,R3
   \   0000E7   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_6:
   \   0000EA   A3           INC     DPTR
   \   0000EB   D0E0         POP     A
   \   0000ED   F0           MOVX    @DPTR,A
    209                  state = CMD_STATE2;
   \   0000EE   7402         MOV     A,#0x2
   \   0000F0   02....       LJMP    ??MT_UartProcessZToolData_2 & 0xFFFF
    210                  break;
    211          
    212                case CMD_STATE2:
    213                  pMsg->msg[MT_RPC_POS_CMD1] = ch;
   \                     ??MT_UartProcessZToolData_7:
   \   0000F3   85..82       MOV     DPL,?XSP + 0
   \   0000F6   85..83       MOV     DPH,?XSP + 1
   \   0000F9   E0           MOVX    A,@DPTR
   \   0000FA   C0E0         PUSH    A
   \   0000FC   8A82         MOV     DPL,R2
   \   0000FE   8B83         MOV     DPH,R3
   \   000100   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   000103   D0E0         POP     A
   \   000105   12....       LCALL   ?Subroutine4 & 0xFFFF
    214                  if (LEN_Token) // If there is no data, skip to FCS state
   \                     ??CrossCallReturnLabel_11:
   \   000108   607D         JZ      ??MT_UartProcessZToolData_12
    215                  {
    216                    state = DATA_STATE;
   \   00010A   7404         MOV     A,#0x4
   \   00010C   02....       LJMP    ??MT_UartProcessZToolData_2 & 0xFFFF
    217                  }
    218                  else
    219                  {
    220                    state = FCS_STATE;
    221                  }
    222                  break;
    223          
    224                case DATA_STATE:
    225                  pMsg->msg[MT_RPC_FRAME_HDR_SZ + tempDataLen++] = ch; // Fill in the buffer the first byte of the data
   \                     ??MT_UartProcessZToolData_9:
   \   00010F   85..82       MOV     DPL,?XSP + 0
   \   000112   85..83       MOV     DPH,?XSP + 1
   \   000115   E0           MOVX    A,@DPTR
   \   000116   C0E0         PUSH    A
   \   000118   90....       MOV     DPTR,#tempDataLen
   \   00011B   E0           MOVX    A,@DPTR
   \   00011C   F8           MOV     R0,A
   \   00011D   8A82         MOV     DPL,R2
   \   00011F   8B83         MOV     DPH,R3
   \   000121   12....       LCALL   ?Subroutine0 & 0xFFFF
   \                     ??CrossCallReturnLabel_0:
   \   000124   D0E0         POP     A
   \   000126   F0           MOVX    @DPTR,A
   \   000127   90....       MOV     DPTR,#tempDataLen
   \   00012A   E0           MOVX    A,@DPTR
   \   00012B   04           INC     A
   \   00012C   F0           MOVX    @DPTR,A
    226                 
    227                  bytesInRxBuffer = Hal_UART_RxBufLen(port); // Check number of bytes left in the Rx buffer
   \   00012D                ; Setup parameters for call to function Hal_UART_RxBufLen
   \   00012D   EE           MOV     A,R6
   \   00012E   F9           MOV     R1,A
   \   00012F   12....       LCALL   ??Hal_UART_RxBufLen?relay
   \   000132   EA           MOV     A,R2
   \   000133   FF           MOV     R7,A
    228          
    229                  /* If the remain of the data is there, read them all, otherwise, just read enough */
    230                  if (bytesInRxBuffer <= LEN_Token - tempDataLen)
   \   000134   90....       MOV     DPTR,#tempDataLen
   \   000137   E0           MOVX    A,@DPTR
   \   000138   F8           MOV     R0,A
   \   000139   12....       LCALL   ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_8:
   \   00013C   12....       LCALL   ?Subroutine0 & 0xFFFF
   \                     ??CrossCallReturnLabel_1:
   \   00013F   AA82         MOV     R2,DPL
   \   000141   AB83         MOV     R3,DPH
   \   000143   90....       MOV     DPTR,#LEN_Token
   \   000146   E0           MOVX    A,@DPTR
   \   000147   C3           CLR     C
   \   000148   98           SUBB    A,R0
   \   000149   FC           MOV     R4,A
   \   00014A   E4           CLR     A
   \   00014B   9400         SUBB    A,#0x0
   \   00014D   FD           MOV     R5,A
   \   00014E   8F..         MOV     ?V0 + 0,R7
   \   000150   C3           CLR     C
   \   000151   EC           MOV     A,R4
   \   000152   95..         SUBB    A,?V0 + 0
   \   000154   ED           MOV     A,R5
   \   000155   9400         SUBB    A,#0x0
   \   000157   A2D2         MOV     C,0xD0 /* PSW */.2
   \   000159   65D0         XRL     A,PSW
   \   00015B   33           RLC     A
   \   00015C   4010         JC      ??MT_UartProcessZToolData_13
    231                  {
    232                    HalUARTRead (port, &pMsg->msg[MT_RPC_FRAME_HDR_SZ + tempDataLen], bytesInRxBuffer);
   \   00015E                ; Setup parameters for call to function HalUARTRead
   \   00015E   AC..         MOV     R4,?V0 + 0
   \   000160   7D00         MOV     R5,#0x0
   \   000162   EE           MOV     A,R6
   \   000163   F9           MOV     R1,A
   \   000164   12....       LCALL   ??HalUARTRead?relay
    233                    tempDataLen += bytesInRxBuffer;
   \   000167   90....       MOV     DPTR,#tempDataLen
   \   00016A   E0           MOVX    A,@DPTR
   \   00016B   2F           ADD     A,R7
   \   00016C   800C         SJMP    ??MT_UartProcessZToolData_14
    234                  }
    235                  else
    236                  {
    237                    HalUARTRead (port, &pMsg->msg[MT_RPC_FRAME_HDR_SZ + tempDataLen], LEN_Token - tempDataLen);
   \                     ??MT_UartProcessZToolData_13:
   \   00016E                ; Setup parameters for call to function HalUARTRead
   \   00016E   EE           MOV     A,R6
   \   00016F   F9           MOV     R1,A
   \   000170   12....       LCALL   ??HalUARTRead?relay
    238                    tempDataLen += (LEN_Token - tempDataLen);
   \   000173   90....       MOV     DPTR,#LEN_Token
   \   000176   E0           MOVX    A,@DPTR
   \   000177   90....       MOV     DPTR,#tempDataLen
   \                     ??MT_UartProcessZToolData_14:
   \   00017A   F0           MOVX    @DPTR,A
    239                  }
    240          
    241                  /* If number of bytes read is equal to data length, time to move on to FCS */
    242                  if ( tempDataLen == LEN_Token )
   \   00017B   E0           MOVX    A,@DPTR
   \   00017C   FA           MOV     R2,A
   \   00017D   90....       MOV     DPTR,#LEN_Token
   \   000180   E0           MOVX    A,@DPTR
   \   000181   6A           XRL     A,R2
   \   000182   6003         JZ      $+5
   \   000184   02....       LJMP    ??MT_UartProcessZToolData_0 & 0xFFFF
   \                     ??MT_UartProcessZToolData_12:
   \   000187   7405         MOV     A,#0x5
   \   000189   02....       LJMP    ??MT_UartProcessZToolData_2 & 0xFFFF
    243                      state = FCS_STATE;
    244          
    245                  break;
    246          
    247                case FCS_STATE:
    248          
    249                  FSC_Token = ch;
   \                     ??MT_UartProcessZToolData_10:
   \   00018C   85..82       MOV     DPL,?XSP + 0
   \   00018F   85..83       MOV     DPH,?XSP + 1
   \   000192   E0           MOVX    A,@DPTR
   \   000193   90....       MOV     DPTR,#FSC_Token
   \   000196   12....       LCALL   ?Subroutine4 & 0xFFFF
    250                  if ((MT_UartCalcFCS ((uint8*)&pMsg->msg[0], MT_RPC_FRAME_HDR_SZ + LEN_Token) == FSC_Token)) // Make sure it's correct
   \                     ??CrossCallReturnLabel_12:
   \   000199   2403         ADD     A,#0x3
   \   00019B   F9           MOV     R1,A
   \   00019C   8A82         MOV     DPL,R2
   \   00019E   8B83         MOV     DPH,R3
   \   0001A0   E0           MOVX    A,@DPTR
   \   0001A1   FA           MOV     R2,A
   \   0001A2   A3           INC     DPTR
   \   0001A3   E0           MOVX    A,@DPTR
   \   0001A4   FB           MOV     R3,A
   \   0001A5   12....       LCALL   ??MT_UartCalcFCS?relay
   \   0001A8   E9           MOV     A,R1
   \   0001A9   FA           MOV     R2,A
   \   0001AA   90....       MOV     DPTR,#FSC_Token
   \   0001AD   E0           MOVX    A,@DPTR
   \   0001AE   6A           XRL     A,R2
   \   0001AF   90....       MOV     DPTR,#pMsg
   \   0001B2   700F         JNZ     ??MT_UartProcessZToolData_15
    251                  {
    252                    osal_msg_send( App_TaskID, (byte *)pMsg );
   \   0001B4                ; Setup parameters for call to function osal_msg_send
   \   0001B4   E0           MOVX    A,@DPTR
   \   0001B5   FA           MOV     R2,A
   \   0001B6   A3           INC     DPTR
   \   0001B7   E0           MOVX    A,@DPTR
   \   0001B8   FB           MOV     R3,A
   \   0001B9   90....       MOV     DPTR,#App_TaskID
   \   0001BC   E0           MOVX    A,@DPTR
   \   0001BD   F9           MOV     R1,A
   \   0001BE   12....       LCALL   ??osal_msg_send?relay
   \   0001C1   8008         SJMP    ??MT_UartProcessZToolData_16
    253                  }
    254                  else
    255                  {
    256                    osal_msg_deallocate ( (uint8 *)pMsg ); // deallocate the msg
   \                     ??MT_UartProcessZToolData_15:
   \   0001C3                ; Setup parameters for call to function osal_msg_deallocate
   \   0001C3   E0           MOVX    A,@DPTR
   \   0001C4   FA           MOV     R2,A
   \   0001C5   A3           INC     DPTR
   \   0001C6   E0           MOVX    A,@DPTR
   \   0001C7   FB           MOV     R3,A
   \   0001C8   12....       LCALL   ??osal_msg_deallocate?relay
    257                  }
    258                  state = SOP_STATE; // Reset the state, send or discard the buffers at this point
   \                     ??MT_UartProcessZToolData_16:
   \   0001CB   E4           CLR     A
   \   0001CC   02....       LJMP    ??MT_UartProcessZToolData_2 & 0xFFFF
    259                  break;
    260          
    261                default:
    262                 break;
    263              }
    264            }
    265          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function osal_msg_allocate
   \   000001                ; Setup parameters for call to function MT_UartCalcFCS
   \   000001   90....       MOV     DPTR,#LEN_Token
   \   000004   E0           MOVX    A,@DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   90....       MOV     DPTR,#pMsg
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FA           MOV     R2,A
   \   000005   A3           INC     DPTR
   \   000006   E0           MOVX    A,@DPTR
   \   000007   F583         MOV     DPH,A
   \   000009   8A82         MOV     DPL,R2
   \   00000B   A3           INC     DPTR
   \   00000C   A3           INC     DPTR
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_14:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F583         MOV     DPH,A
   \   000006   8882         MOV     DPL,R0
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_13:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   28           ADD     A,R0
   \   000002   FA           MOV     R2,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   3400         ADDC    A,#0x0
   \   000007   8A82         MOV     DPL,R2
   \   000009   F583         MOV     DPH,A
   \   00000B   A3           INC     DPTR
   \   00000C   A3           INC     DPTR
   \   00000D   A3           INC     DPTR
   \   00000E   22           RET

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??MT_UartInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_UartInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??MT_UartRegisterTaskID?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_UartRegisterTaskID

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??MT_UartCalcFCS?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_UartCalcFCS

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??MT_UartProcessZToolData?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_UartProcessZToolData
    266          
    267          #if defined (ZAPP_P1) || defined (ZAPP_P2)
    268          /***************************************************************************************************
    269           * @fn      MT_UartProcessZAppData
    270           * @brief   | SOP | CMD  |   Data Length   | FSC  |
    271           *          |  1  |  2   |       1         |  1   |
    272           *
    273           *          Parses the data and determine either is SPI or just simply serial data
    274           *          then send the data to correct place (MT or APP)
    275           * @param   port    - UART port
    276           *          event   - Event that causes the callback
    277           * @return  None
    278           ***************************************************************************************************/
    279          void MT_UartProcessZAppData ( uint8 port, uint8 event )
    280          {
    281          
    282            osal_event_hdr_t  *msg_ptr;
    283            uint16 length = 0;
    284            uint16 rxBufLen  = Hal_UART_RxBufLen(MT_UART_DEFAULT_PORT);
    285          
    286            /* If maxZAppBufferLength is 0 or larger than current length
    287               the entire length of the current buffer is returned. */
    288            if ((MT_UartMaxZAppBufLen != 0) && (MT_UartMaxZAppBufLen <= rxBufLen))
    289            {
    290              length = MT_UartMaxZAppBufLen;
    291            }
    292            else
    293            {
    294              length = rxBufLen;
    295            }
    296          
    297            /* Verify events */
    298            if (event == HAL_UART_TX_FULL)
    299            {
    300              // Do something when TX if full
    301              return;
    302            }
    303          
    304            if (event & ( HAL_UART_RX_FULL | HAL_UART_RX_ABOUT_FULL | HAL_UART_RX_TIMEOUT))
    305            {
    306              if ( App_TaskID )
    307              {
    308                /*
    309                   If Application is ready to receive and there is something
    310                   in the Rx buffer then send it up
    311                */
    312                if ((MT_UartZAppRxStatus == MT_UART_ZAPP_RX_READY ) && (length != 0))
    313                {
    314                  /* Disable App flow control until it processes the current data */
    315                   MT_UartAppFlowControl (MT_UART_ZAPP_RX_NOT_READY);
    316          
    317                  /* 2 more bytes are added, 1 for CMD type, other for length */
    318                  msg_ptr = (osal_event_hdr_t *)osal_msg_allocate( length + sizeof(osal_event_hdr_t) );
    319                  if ( msg_ptr )
    320                  {
    321                    msg_ptr->event = SPI_INCOMING_ZAPP_DATA;
    322                    msg_ptr->status = length;
    323          
    324                    /* Read the data of Rx buffer */
    325                    HalUARTRead( MT_UART_DEFAULT_PORT, (uint8 *)(msg_ptr + 1), length );
    326          
    327                    /* Send the raw data to application...or where ever */
    328                    osal_msg_send( App_TaskID, (uint8 *)msg_ptr );
    329                  }
    330                }
    331              }
    332            }
    333          }
    334          
    335          /***************************************************************************************************
    336           * @fn      SPIMgr_ZAppBufferLengthRegister
    337           * @brief
    338           * @param   maxLen - Max Length that the application wants at a time
    339           * @return  None
    340           ***************************************************************************************************/
    341          void MT_UartZAppBufferLengthRegister ( uint16 maxLen )
    342          {
    343            /* If the maxLen is larger than the RX buff, something is not right */
    344            if (maxLen <= MT_UART_DEFAULT_MAX_RX_BUFF)
    345              MT_UartMaxZAppBufLen = maxLen;
    346            else
    347              MT_UartMaxZAppBufLen = 1; /* default is 1 byte */
    348          }
    349          
    350          /***************************************************************************************************
    351           * @fn      SPIMgr_AppFlowControl
    352           * @brief
    353           * @param   status - ready to send or not
    354           * @return  None
    355           ***************************************************************************************************/
    356          void MT_UartAppFlowControl ( bool status )
    357          {
    358            /* Make sure only update if needed */
    359            if (status != MT_UartZAppRxStatus )
    360            {
    361              MT_UartZAppRxStatus = status;
    362            }
    363          
    364            /* App is ready to read again, ProcessZAppData have to be triggered too */
    365            if (status == MT_UART_ZAPP_RX_READY)
    366            {
    367              MT_UartProcessZAppData (MT_UART_DEFAULT_PORT, HAL_UART_RX_TIMEOUT );
    368            }
    369          }
    370          #endif //ZAPP
    371          
    372          /***************************************************************************************************
    373          ***************************************************************************************************/

   Maximum stack usage in bytes:

     Function                 ISTACK PSTACK XSTACK
     --------                 ------ ------ ------
     MT_UartCalcFCS               0      0     20
     MT_UartInit                  3      0     29
       -> HalUARTOpen             4      0     58
     MT_UartProcessZToolData      1      0     11
       -> Hal_UART_RxBufLen       0      0     22
       -> HalUARTRead             0      0     22
       -> osal_msg_allocate       0      0     22
       -> Hal_UART_RxBufLen       0      0     22
       -> HalUARTRead             0      0     22
       -> HalUARTRead             0      0     22
       -> MT_UartCalcFCS          0      0     22
       -> osal_msg_send           0      0     22
       -> osal_msg_deallocate     0      0     22
     MT_UartRegisterTaskID        2      0      0


   Segment part sizes:

     Function/Label                  Bytes
     --------------                  -----
     App_TaskID                         1
     state                              1
     CMD_Token                          2
     LEN_Token                          1
     FSC_Token                          1
     pMsg                               2
     tempDataLen                        1
     MT_UartInit                      129
     ?Subroutine6                       7
     MT_UartRegisterTaskID             11
     MT_UartCalcFCS                    37
     MT_UartProcessZToolData          463
     ?Subroutine4                       6
     ?Subroutine3                      14
     ?Subroutine2                       4
     ?Subroutine5                       9
     ?Subroutine1                       6
     ?Subroutine0                      15
     ??MT_UartInit?relay                6
     ??MT_UartRegisterTaskID?relay      6
     ??MT_UartCalcFCS?relay             6
     ??MT_UartProcessZToolData?relay    6

 
 701 bytes in segment BANKED_CODE
  24 bytes in segment BANK_RELAYS
   9 bytes in segment XDATA_Z
 
 725 bytes of CODE  memory
   9 bytes of XDATA memory

Errors: none
Warnings: none
